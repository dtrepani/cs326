'From Squeak5.0 of 20 July 2015 [latest update: #15110] on 20 July 2015 at 4:14:07 pm'!ReleaseBuilder prepareNewRelease!----QUIT----{20 July 2015 . 4:14:16 pm} Squeak5.0-15110.image priorSource: 0!----STARTUP----{23 July 2015 . 4:29:16 am} as /home/pi/Downloads/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15110.image!----QUIT/NOSAVE----{23 July 2015 . 4:29:25 am} Squeak5.0-15110.image priorSource: 123!----STARTUP----{23 July 2015 . 4:35:21 am} as /home/pi/Downloads/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15110.image!----QUIT/NOSAVE----{23 July 2015 . 4:35:54 am} Squeak5.0-15110.image priorSource: 123!----STARTUP----{23 July 2015 . 10:39:38 pm} as /home/cmm/Chris/dev/Squeak/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15110.image!----QUIT/NOSAVE----{23 July 2015 . 10:39:42 pm} Squeak5.0-15110.image priorSource: 123!----STARTUP----{24 July 2015 . 10:37:42 am} as /home/cmm/Chris/dev/Squeak/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15110.image!SystemOrganization addCategory: #UserObjects!----QUIT----{24 July 2015 . 10:39:02 am} Squeak5.0-15110.image priorSource: 123!----STARTUP----{24 July 2015 . 10:39:16 am} as /home/cmm/Chris/dev/Squeak/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15110.image!FileList initialize!----QUIT----{24 July 2015 . 10:39:36 am} Squeak5.0-15110.image priorSource: 1160!----STARTUP----{24 July 2015 . 10:39:44 am} as /home/cmm/Chris/dev/Squeak/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15110.image!MCFileBasedRepository flushAllCaches.!----QUIT----{24 July 2015 . 10:39:56 am} Squeak5.0-15110.image priorSource: 1430!----STARTUP----{24 July 2015 . 10:46:41 am} as /home/cmm/Chris/dev/Squeak/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15110.image!----QUIT----{24 July 2015 . 10:48 am} Squeak5.0-15110.image priorSource: 1719!----STARTUP----{24 July 2015 . 1:16:20 pm} as /home/cmm/Chris/dev/Squeak/Squeak5.0-15110.image!----QUIT/NOSAVE----{24 July 2015 . 3:04:34 pm} Squeak5.0-15110.image priorSource: 1968!----STARTUP----{28 July 2015 . 2:21:53 pm} as /home/cmm/Chris/dev/Squeak/Squeak5.0-15110.image!----QUIT/NOSAVE----{28 July 2015 . 2:21:59 pm} Squeak5.0-15110.image priorSource: 1968!----STARTUP----{2 August 2015 . 10:17:39 pm} as /home/cmm/Chris/dev/Squeak/Squeak5.0-15110.image!----QUIT/NOSAVE----{3 August 2015 . 1:31:21 am} Squeak5.0-15110.image priorSource: 1968!----STARTUP----{5 August 2015 . 4:08:17 pm} as /home/cmm/Chris/dev/Squeak/Squeak5.0-15110.image!	Display extent!----STARTUP----{6 August 2015 . 10:23:48 am} as /home/cmm/Chris/dev/Squeak/Squeak5.0-15110.image!!CompiledMethod methodsFor: '*Kernel-tool support' stamp: 'cmm 8/5/2015 19:59' prior: 31510441!hasBreakpoint	^ self class environment		at: #BreakpointManager		ifPresent: [:bpm | bpm methodHasBreakpoint: self]		ifAbsent: [false]! !"Kernel"!!CompiledMethod methodsFor: '*Kernel-tool support' stamp: 'cmm 8/5/2015 19:59' prior: 33557358!hasBreakpoint	^ self class environment		at: #BreakpointManager		ifPresent: [:bpm | bpm methodHasBreakpoint: self]		ifAbsent: [false]! !!ReleaseBuilder class methodsFor: 'scripts' stamp: 'cmm 7/24/2015 09:54' prior: 52285267!prepareNewBuild: anMCRepository 	"ReleaseBuilderTrunk prepareNewBuild"	"Prepare everything that should be done for a new image build"	MCMcmUpdater updateMissingPackages: true.	MCMcmUpdater enableUpdatesForAllPackages.	TTCFont registerAll.	FileList initialize.	RealEstateAgent standardSize: 600 @ 400.	SystemVersion newVersion: self versionString.	SMLoaderPlus setDefaultFilters: (OrderedCollection with: #filterSafelyAvailable)."	Preferences outOfTheBox."  "<-- uncomment after #defaultValueTableForCurrentRelease is fixed up."	self		 setDisplayExtent: 800 @ 600 ;		 switchToNewRepository: anMCRepository ;		 setPreferences ;  "<-- remove this after defaultValueTableForCurrentRelease is fixed up."		 checkForDirtyPackages ;		 configureDesktop.	Smalltalk cleanUp: true.	MCFileBasedRepository flushAllCaches.	MCHttpRepository clearCredentials.	Utilities setAuthorInitials: String empty.	Environment allInstancesDo: [ : env | env purgeUndeclared ].	Undeclared removeUnreferencedKeys.	Smalltalk garbageCollect.	[ self loadWellKnownPackages "<-- 4.5 is not ready for unloaded / reloaded packages" ].	Compiler recompileAll.	self		setProjectBackground: Color darkGray ;		openWelcomeWorkspaces! !!ReleaseBuilder class methodsFor: 'scripts' stamp: 'cmm 1/26/2014 22:12' prior: 52287084!prepareNewRelease	"This method is run at time of release to transfer the top trunk versions into my releaseRepository, and produce a release image."	self		transferCurrentPackagesAsUser: Utilities authorInitials		password: (UIManager default requestPassword: 'Enter password for ' , self projectUrl).	self prepareNewBuild: self releaseRepository! !!ReleaseBuilder class methodsFor: 'scripts' stamp: 'cmm 8/5/2015 19:41' prior: 52288115!prepareNextVersionAlpha	"Prepare the first alpha image for next release."	SystemVersion		newVersion: ((UIManager default request: 'Please specify the name of the\new version of Squeak.' withCRs initialAnswer: SystemVersion current version)				ifEmpty: [^ self inform: 'Aborted.']).	MCFileBasedRepository flushAllCaches.	MCHttpRepository clearCredentials.	Utilities setAuthorInitials: String empty.	self switchToNewRepository: self buildRepository! !!ReleaseBuilder class methodsFor: 'preferences' stamp: 'cmm 7/24/2015 10:27' prior: 52305451!setPreferences	"Preferences class defaultValueTableForCurrentRelease"	self setProjectBackground: Color darkGray.	"General User interaction"	Preferences		enable: #generalizedYellowButtonMenu ;		disable: #mouseOverForKeyboardFocus ;		enable: #swapMouseButtons.	Morph indicateKeyboardFocus: true.	SearchBar useScratchPad: false.			"Text input."	TextEditor		 autoEnclose: true ;		 autoIndent: true ;		 destructiveBackWord: false ;		 blinkingCursor: true ;		 dumbbellCursor: false.	Preferences		 insertionPointColor: Color red.	PluggableTextMorph simpleFrameAdornments: false.		"Windows"	Preferences installUniformWindowColors.	SystemWindow reuseWindows: false.	Model windowActiveOnFirstClick: false. "Not good for 800x600"	Preferences		disable: #showSplitterHandles;		enable: #fastDragWindowForMorphic.		CornerGripMorph drawCornerResizeHandles: false.	ProportionalSplitterMorph		 smartHorizontalSplitters: false ;		 smartVerticalSplitters: false.	"Scroll bars."	Preferences		enable: #scrollBarsNarrow;		enable: #scrollBarsOnRight;		disable: #alwaysHideHScrollbar;		disable: #alwaysShowHScrollbar;		disable: #alwaysShowVScrollbar.	ScrollBar		scrollBarsWithoutArrowButtons: true;		scrollBarsWithoutMenuButton: true.	ScrollPane		useRetractableScrollBars: false.	"Rounded corners."	Morph preferredCornerRadius: 6.	Preferences disable: #roundedWindowCorners.	PluggableButtonMorph roundedButtonCorners: false.	FillInTheBlankMorph roundedDialogCorners: false.	MenuMorph roundedMenuCorners: false.	ScrollBar roundedScrollBarLook: false.		"Gradients."	Preferences disable: #gradientScrollBars.	SystemWindow gradientWindow: false.	MenuMorph gradientMenu: false.	PluggableButtonMorph gradientButton: false.	"Shadows"	Preferences enable: #menuAppearance3d.	MenuMorph		menuBorderWidth: 1;		menuBorderColor: Color lightGray;		menuLineColor: Color lightGray.	Morph useSoftDropShadow: true..		"Lists and Trees"	PluggableListMorph		filterableLists: true;		clearFilterAutomatically: false;		highlightHoveredRow: true;		menuRequestUpdatesSelection: true.	PluggableTreeMorph		filterByLabelsOnly: false;		maximumSearchDepth: 1.	LazyListMorph		listSelectionTextColor: Color black;		listSelectionColor: (Color r: 0.72 g: 0.72 b: 0.9).		"Standard Tools"	BalloonMorph setBalloonColorTo:		(TranslucentColor r: 0.92 g: 0.92 b: 0.706 alpha: 0.75).	Workspace shouldStyle: false.	Browser		listClassesHierarchically: true;		showClassIcons: true;		showMessageIcons: true;		sortMessageCategoriesAlphabetically: true.	Preferences enable: #annotationPanes;		 enable: #optionalButtons;		 enable: #diffsWithPrettyPrint;		 enable: #traceMessages;		 enable: #alternativeBrowseIt;		 enable: #menuWithIcons;		 enable: #visualExplorer.	SystemNavigation thoroughSenders: true.		"Halo"	Preferences		enable: #showBoundsInHalo ;		disable: #alternateHandlesLook.	"System"	NetNameResolver enableIPv6: false.	Scanner		allowUnderscoreAsAssignment: true;		prefAllowUnderscoreSelectors: true.	"that's all, folks"! !"ReleaseBuilder"!"Kernel"!----SNAPSHOT----{6 August 2015 . 10:24:41 am} Squeak5.0-15113.image priorSource: 1968!----STARTUP----{6 August 2015 . 10:46:02 am} as /home/cmm/Chris/dev/Squeak/Squeak5.0-15113.image!"Morphic"!SystemOrganization removeSystemCategory: 'Morphic-UserObjects'!SystemOrganization removeSystemCategory: 'EToy-UserObjects'!SystemOrganization removeSystemCategory: 'Morphic-Imported'!ReleaseBuilder prepareNewRelease!----QUIT----{6 August 2015 . 10:50:45 am} Squeak5.0-15113.image priorSource: 8807!----STARTUP----{9 August 2015 . 10:50:30 am} as /Users/craig/Downloads/squeak release/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15113.image!----QUIT/NOSAVE----{9 August 2015 . 10:50:39 am} Squeak5.0-15113.image priorSource: 9231!----STARTUP----{9 August 2015 . 10:51:22 am} as /Users/craig/Downloads/squeak release/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15113.image!----QUIT/NOSAVE----{9 August 2015 . 10:51:47 am} Squeak5.0-15113.image priorSource: 9231!----STARTUP----{13 January 2016 . 6:45:30 am} as /Users/wiljo/Desktop/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15113.image!SystemOrganization addCategory: #ConfigurationOfFileTree!Object subclass: #ConfigurationOfFileTree	instanceVariableNames: 'project'	classVariableNames: 'LastVersionLoad'	poolDictionaries: ''	category: 'ConfigurationOfFileTree'!!ConfigurationOfFileTree class methodsFor: 'development support' stamp: 'dkh 4/5/2012 16:22:00'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfFileTree class methodsFor: 'private' stamp: 'dkh 07/12/2013 12:08'!baseConfigurationClassIfAbsent: aBlock  ^ Smalltalk    at: #'MetacelloBaseConfiguration'    ifAbsent: [       self ensureMetacelloBaseConfiguration.      Smalltalk at: #'MetacelloBaseConfiguration' ifAbsent: aBlock ]! !!ConfigurationOfFileTree class methodsFor: 'private' stamp: '07/12/2013 07:09'!ensureMetacello  (self baseConfigurationClassIfAbsent: [  ]) ensureMetacello! !!ConfigurationOfFileTree class methodsFor: 'private' stamp: '07/11/2013 16:46'!ensureMetacelloBaseConfiguration  Smalltalk    at: #'MetacelloBaseConfiguration'    ifAbsent: [       #('http://smalltalkhub.com/mc/dkh/metacello/main' 'http://seaside.gemtalksystems.com/ss/metacello')        do: [ :url |           | repository version |          repository := MCHttpRepository location: url user: '' password: ''.          repository            versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.19.mcz'            do: [ :reader |               version := reader version.              version load.              version workingCopy repositoryGroup addRepository: repository.              ^ self ] ].      self        error:          'Error bootstrapping Metacello: likely network error. Please try again' ]! !!ConfigurationOfFileTree class methodsFor: 'metacello tool support' stamp: 'dkh 4/5/2012 16:22:00'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfFileTree class methodsFor: 'loading' stamp: 'dkh 4/5/2012 16:22:00'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfFileTree class methodsFor: 'loading' stamp: 'dkh 4/5/2012 16:22:00'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfFileTree class methodsFor: 'loading' stamp: 'dkh 4/5/2012 16:22:00'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfFileTree class methodsFor: 'accessing' stamp: 'dkh 4/5/2012 16:22:00'!project	^self new project! !!ConfigurationOfFileTree class methodsFor: 'development support' stamp: 'dkh 4/5/2012 16:22:00'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfFileTree methodsFor: 'baselines' stamp: 'dkh 9/15/2012 20:27'!baseline100: spec    <version: '1.0-baseline'>    spec        for: #'common'        do: [             spec blessing: #'baseline'.            spec repository: 'http://ss3.gemstone.com/ss/FileTree'.            spec package: 'MonticelloFileTree-Core'.            spec group: 'default' with: #('MonticelloFileTree-Core') ].    spec        for: #'pharo1.1.x'        do: [             spec                package: 'MonticelloFileTree-Core' with: [ spec file: 'MonticelloFileTree-Core.pharo11' ];                package: 'MonticelloFileTree-FileDirectory-Utilities'                    with: [                             spec                                file: 'MonticelloFileTree-FileDirectory-Utilities.pharo11';                                requires: 'MonticelloFileTree-Core' ].            spec group: 'default' with: #('MonticelloFileTree-FileDirectory-Utilities') ].    spec        for: #'pharo1.2.x'        do: [             spec                package: 'MonticelloFileTree-Core' with: [ spec file: 'MonticelloFileTree-Core.pharo11' ];                package: 'MonticelloFileTree-FileDirectory-Utilities'                    with: [                             spec                                file: 'MonticelloFileTree-FileDirectory-Utilities.pharo11';                                requires: 'MonticelloFileTree-Core' ].            spec group: 'default' with: #('MonticelloFileTree-FileDirectory-Utilities') ].    spec        for: #'pharo1.3.x'        do: [             spec                package: 'MonticelloFileTree-Core' with: [ spec file: 'MonticelloFileTree-Core.pharo13' ];                package: 'MonticelloFileTree-FileDirectory-Utilities'                    with: [                             spec                                file: 'MonticelloFileTree-FileDirectory-Utilities.pharo13';                                requires: 'MonticelloFileTree-Core' ].            spec group: 'default' with: #('MonticelloFileTree-FileDirectory-Utilities') ].    spec        for: #'pharo1.4.x'        do: [             spec                package: 'MonticelloFileTree-Core' with: [ spec file: 'MonticelloFileTree-Core.pharo14' ];                package: 'MonticelloFileTree-FileDirectory-Utilities'                    with: [                             spec                                file: 'MonticelloFileTree-FileDirectory-Utilities.pharo14';                                requires: 'MonticelloFileTree-Core' ].            spec group: 'default' with: #('MonticelloFileTree-FileDirectory-Utilities') ].    spec        for: #'pharo2.x'        do: [             spec                package: 'MonticelloFileTree-Core' with: [ spec file: 'MonticelloFileTree-Core.pharo20' ];                package: 'MonticelloFileTree-FileSystem-Utilities'                    with: [                             spec                                file: 'MonticelloFileTree-FileSystem-Utilities.pharo20';                                requires: 'MonticelloFileTree-Core' ].            spec group: 'default' with: #('MonticelloFileTree-FileSystem-Utilities') ].    spec        for: #'squeak'        do: [             spec                package: 'MonticelloFileTree-Core' with: [ spec file: 'MonticelloFileTree-Core.squeak43' ];                package: 'MonticelloFileTree-FileDirectory-Utilities'                    with: [                             spec                                file: 'MonticelloFileTree-FileDirectory-Utilities.squeak43';                                requires: 'MonticelloFileTree-Core' ].            spec group: 'default' with: #('MonticelloFileTree-FileDirectory-Utilities') ].    spec        for: #'gemstone'        do: [             spec                project: 'GsCore'                    with: [                             spec                                className: 'ConfigurationOfGsCore';                                repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];                project: 'Monticello'                    with: [                             spec                                className: 'ConfigurationOfGsMonticello';                                repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ].            spec                package: 'MonticelloFileTree-Core'                    with: [                             spec                                file: 'MonticelloFileTree-Core.gemstone24';                                requires: #('GsCore' 'Monticello') ];                package: 'MonticelloFileTree-FileDirectory-Utilities'                    with: [                             spec                                file: 'MonticelloFileTree-FileDirectory-Utilities.gemstone24';                                requires: 'MonticelloFileTree-Core' ].            spec group: 'default' with: #('MonticelloFileTree-FileDirectory-Utilities') ]! !!ConfigurationOfFileTree methodsFor: 'baselines' stamp: 'dkh 06/15/2013 20:22'!baseline102: spec  <version: '1.0.2-baseline'>  spec    for: #'common'    do: [       spec blessing: #'baseline'.      spec repository: 'http://ss3.gemstone.com/ss/FileTree'.      spec package: 'MonticelloFileTree-Core'.      spec group: 'default' with: #('MonticelloFileTree-Core') ].  spec    for: #'pharo1.1.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: [ spec file: 'MonticelloFileTree-Core.pharo11' ];        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: [               spec                file: 'MonticelloFileTree-FileDirectory-Utilities.pharo11';                requires: 'MonticelloFileTree-Core' ].      spec        group: 'default'        with: #('MonticelloFileTree-FileDirectory-Utilities') ].  spec    for: #'pharo1.2.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: [ spec file: 'MonticelloFileTree-Core.pharo11' ];        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: [               spec                file: 'MonticelloFileTree-FileDirectory-Utilities.pharo11';                requires: 'MonticelloFileTree-Core' ].      spec        group: 'default'        with: #('MonticelloFileTree-FileDirectory-Utilities') ].  spec    for: #'pharo1.3.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: [ spec file: 'MonticelloFileTree-Core.pharo13' ];        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: [               spec                file: 'MonticelloFileTree-FileDirectory-Utilities.pharo13';                requires: 'MonticelloFileTree-Core' ].      spec        group: 'default'        with: #('MonticelloFileTree-FileDirectory-Utilities') ].  spec    for: #'pharo1.4.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: [ spec file: 'MonticelloFileTree-Core.pharo14' ];        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: [               spec                file: 'MonticelloFileTree-FileDirectory-Utilities.pharo14';                requires: 'MonticelloFileTree-Core' ].      spec        group: 'default'        with: #('MonticelloFileTree-FileDirectory-Utilities') ].  spec    for: #'pharo2.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: [ spec file: 'MonticelloFileTree-Core.pharo20' ];        package: 'MonticelloFileTree-FileSystem-Utilities'          with: [               spec                file: 'MonticelloFileTree-FileSystem-Utilities.pharo20';                requires: 'MonticelloFileTree-Core' ];        package: 'MonticelloFileTree-Git'          with: [               spec                file: 'MonticelloFileTree-Git.pharo20';                requires: #('MonticelloFileTree-Core') ];        yourself.      spec group: 'default' with: #('MonticelloFileTree-FileSystem-Utilities') ].  spec    for: #'pharo3.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: [ spec file: 'MonticelloFileTree-Core.pharo30' ];        package: 'MonticelloFileTree-FileSystem-Utilities'          with: [               spec                file: 'MonticelloFileTree-FileSystem-Utilities.pharo30';                requires: 'MonticelloFileTree-Core' ];        package: 'MonticelloFileTree-Git'          with: [               spec                file: 'MonticelloFileTree-Git.pharo20';                requires: #('MonticelloFileTree-Core') ];        yourself.      spec group: 'default' with: #('MonticelloFileTree-FileSystem-Utilities') ].  spec    for: #'squeak'    do: [       spec        package: 'MonticelloFileTree-Core'          with: [ spec file: 'MonticelloFileTree-Core.squeak43' ];        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: [               spec                file: 'MonticelloFileTree-FileDirectory-Utilities.squeak43';                requires: 'MonticelloFileTree-Core' ].      spec        group: 'default'        with: #('MonticelloFileTree-FileDirectory-Utilities') ].  spec    for: #'gemstone'    do: [       spec        project: 'GsCore'          with: [               spec                className: 'ConfigurationOfGsCore';                repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];        project: 'Monticello'          with: [               spec                className: 'ConfigurationOfGsMonticello';                repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ].      spec        package: 'MonticelloFileTree-Core'          with: [               spec                file: 'MonticelloFileTree-Core.gemstone24';                requires: #('GsCore' 'Monticello') ];        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: [               spec                file: 'MonticelloFileTree-FileDirectory-Utilities.gemstone24';                requires: 'MonticelloFileTree-Core' ].      spec        group: 'default'        with: #('MonticelloFileTree-FileDirectory-Utilities') ]! !!ConfigurationOfFileTree methodsFor: 'baselines' stamp: 'dkh 09/16/2014 11:51'!baseline103: spec  <version: '1.0.3-baseline'>  spec    for: #'common'    do: [       spec blessing: #'baseline'.      spec repository: 'http://ss3.gemtalksystems.com/ss/FileTree'.      spec package: 'MonticelloFileTree-Core'.      spec group: 'default' with: #('MonticelloFileTree-Core') ].  spec    for: #'pharo1.1.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: [ spec file: 'MonticelloFileTree-Core.pharo11' ];        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: [               spec                file: 'MonticelloFileTree-FileDirectory-Utilities.pharo11';                requires: 'MonticelloFileTree-Core' ].      spec        group: 'default'        with: #('MonticelloFileTree-FileDirectory-Utilities') ].  spec    for: #'pharo1.2.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: [ spec file: 'MonticelloFileTree-Core.pharo11' ];        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: [               spec                file: 'MonticelloFileTree-FileDirectory-Utilities.pharo11';                requires: 'MonticelloFileTree-Core' ].      spec        group: 'default'        with: #('MonticelloFileTree-FileDirectory-Utilities') ].  spec    for: #'pharo1.3.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: [ spec file: 'MonticelloFileTree-Core.pharo13' ];        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: [               spec                file: 'MonticelloFileTree-FileDirectory-Utilities.pharo13';                requires: 'MonticelloFileTree-Core' ].      spec        group: 'default'        with: #('MonticelloFileTree-FileDirectory-Utilities') ].  spec    for: #'pharo1.4.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: [ spec file: 'MonticelloFileTree-Core.pharo14' ];        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: [               spec                file: 'MonticelloFileTree-FileDirectory-Utilities.pharo14';                requires: 'MonticelloFileTree-Core' ].      spec        group: 'default'        with: #('MonticelloFileTree-FileDirectory-Utilities') ].  spec    for: #'pharo2.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: [ spec file: 'MonticelloFileTree-Core.pharo20' ];        package: 'MonticelloFileTree-FileSystem-Utilities'          with: [               spec                file: 'MonticelloFileTree-FileSystem-Utilities.pharo20';                requires: 'MonticelloFileTree-Core' ];        package: 'MonticelloFileTree-Git'          with: [               spec                file: 'MonticelloFileTree-Git.pharo20';                requires: #('MonticelloFileTree-Core') ];        yourself.      spec group: 'default' with: #('MonticelloFileTree-FileSystem-Utilities') ].  spec    for: #'pharo3.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: [ spec file: 'MonticelloFileTree-Core.pharo30' ];        package: 'MonticelloFileTree-FileSystem-Utilities'          with: [               spec                file: 'MonticelloFileTree-FileSystem-Utilities.pharo30';                requires: 'MonticelloFileTree-Core' ];        package: 'MonticelloFileTree-Git'          with: [               spec                file: 'MonticelloFileTree-Git.pharo20';                requires: #('MonticelloFileTree-Core') ];        yourself.      spec group: 'default' with: #('MonticelloFileTree-FileSystem-Utilities') ].  spec    for: #'squeak'    do: [       spec        package: 'MonticelloFileTree-Core'          with: [ spec file: 'MonticelloFileTree-Core.squeak43' ];        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: [               spec                file: 'MonticelloFileTree-FileDirectory-Utilities.squeak43';                requires: 'MonticelloFileTree-Core' ].      spec        group: 'default'        with: #('MonticelloFileTree-FileDirectory-Utilities') ].  spec    for: #'gemstone'    do: [       spec        project: 'GsCore'          with: [               spec                className: 'ConfigurationOfGsCore';                repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];        project: 'Monticello'          with: [               spec                className: 'ConfigurationOfGsMonticello';                repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ].      spec        package: 'MonticelloFileTree-Core'          with: [               spec                file: 'MonticelloFileTree-Core.gemstone24';                requires: #('GsCore' 'Monticello') ];        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: [               spec                file: 'MonticelloFileTree-FileDirectory-Utilities.gemstone24';                requires: 'MonticelloFileTree-Core' ].      spec        group: 'default'        with: #('MonticelloFileTree-FileDirectory-Utilities') ]! !!ConfigurationOfFileTree methodsFor: 'accessing' stamp: 'dkh 4/5/2012 16:22:00'!customProjectAttributes    "Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttrributes "    ^ #()! !!ConfigurationOfFileTree methodsFor: 'accessing' stamp: 'dkh 4/5/2012 16:22:00'!project    ^ project        ifNil: [             "Bootstrap Metacello if it is not already loaded"            self class ensureMetacello.            project := MetacelloMCProject new projectAttributes: self customProjectAttributes.	"Create the Metacello project"            (Smalltalk at: #'MetacelloVersionConstructor') on: self project: project.	"Construct the project"            project loadType: #'linear'.	"change to #atomic if desired"            project ]! !!ConfigurationOfFileTree methodsFor: 'symbolic versions' stamp: 'dkh 10/29/2014 12:49'!stable: spec	<symbolicVersion: #'stable'>	spec for: #'common' version: '1.0.6.2'.! !!ConfigurationOfFileTree methodsFor: 'versions' stamp: 'dkh 9/15/2012 20:27'!version100: spec    <version: '1.0' imports: #('1.0-baseline')>    spec        for: #'common'        do: [             spec blessing: #'release'.            spec description: 'FileTree 1.0'.            spec author: 'dkh'.            spec timestamp: '9/15/2012 14:10' ].    spec        for: #'pharo1.1.x'        do: [             spec                package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo11-dkh.92';                package: 'MonticelloFileTree-FileDirectory-Utilities'                    with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14'  ].    spec        for: #'pharo1.2.x'        do: [             spec                package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo11-dkh.92';                package: 'MonticelloFileTree-FileDirectory-Utilities'                    with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14'  ].    spec        for: #'pharo1.3.x'        do: [             spec                package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo13-dkh.90';                package: 'MonticelloFileTree-FileDirectory-Utilities'                    with: 'MonticelloFileTree-FileDirectory-Utilities.pharo13-dkh.12' ].    spec        for: #'pharo1.4.x'        do: [             spec                package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo14-dkh.90';                package: 'MonticelloFileTree-FileDirectory-Utilities'                    with: 'MonticelloFileTree-FileDirectory-Utilities.pharo14-dkh.12' ].    spec        for: #'pharo2.x'        do: [             spec                package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo20-dkh.91';                package: 'MonticelloFileTree-FileSystem-Utilities'                    with: 'MonticelloFileTree-FileSystem-Utilities.pharo20-dkh.17' ].    spec        for: #'squeak'        do: [             spec                package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.squeak43-dkh.90';                package: 'MonticelloFileTree-FileDirectory-Utilities'                    with: 'MonticelloFileTree-FileDirectory-Utilities.squeak43-dkh.12' ].    spec        for: #'gemstone'        do: [             spec                project: 'GsCore' with: '0.246';                project: 'Monticello' with: '0.243'.            spec                package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.gemstone24-dkh.92';                package: 'MonticelloFileTree-FileDirectory-Utilities'                    with: 'MonticelloFileTree-FileDirectory-Utilities.gemstone24-dkh.14' ]! !!ConfigurationOfFileTree methodsFor: 'versions' stamp: 'dkh 03/12/2013 16:30'!version101: spec    <version: '1.0.1' imports: #('1.0-baseline')>    spec        for: #'common'        do: [             spec blessing: #'release'.            spec description: 'port to GemStone 3.1.x- write out gemstone class options in class definitions correctly- fix problems in filename generation in presence of specials1.0.1 (dkh.35):- port to GemStone 3.21.0.1 (dkh.36):- fix Issue #69:  https://github.com/dalehenrich/filetree/issues/69- commit: d861c5d76ecc762d6cb4f11f6ec6c1ba45d6bdc0'.            spec author: 'dkh'.            spec timestamp: '3/12/2013 16:30' ].    spec        for: #'pharo1.1.x'        do: [             spec                package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo11-dkh.95';                package: 'MonticelloFileTree-FileDirectory-Utilities'                    with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14'  ].    spec        for: #'pharo1.2.x'        do: [             spec                package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo11-dkh.95';                package: 'MonticelloFileTree-FileDirectory-Utilities'                    with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14'  ].    spec        for: #'pharo1.3.x'        do: [             spec                package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo13-dkh.93';                package: 'MonticelloFileTree-FileDirectory-Utilities'                    with: 'MonticelloFileTree-FileDirectory-Utilities.pharo13-dkh.12' ].    spec        for: #'pharo1.4.x'        do: [             spec                package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo14-dkh.93';                package: 'MonticelloFileTree-FileDirectory-Utilities'                    with: 'MonticelloFileTree-FileDirectory-Utilities.pharo14-dkh.12' ].    spec        for: #'pharo2.x'        do: [             spec                package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo20-dkh.91';                package: 'MonticelloFileTree-FileSystem-Utilities'                    with: 'MonticelloFileTree-FileSystem-Utilities.pharo20-dkh.17' ].    spec        for: #'squeak'        do: [             spec                package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.squeak43-dkh.92';                package: 'MonticelloFileTree-FileDirectory-Utilities'                    with: 'MonticelloFileTree-FileDirectory-Utilities.squeak43-dkh.12' ].    spec        for: #'gemstone'        do: [             spec                project: 'GsCore' with: '0.246';                project: 'Monticello' with: '0.243'.            spec                package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.gemstone24-dkh.99';                package: 'MonticelloFileTree-FileDirectory-Utilities'                    with: 'MonticelloFileTree-FileDirectory-Utilities.gemstone24-dkh.14' ].	spec for: #'gs3.1.0.x' do: [		spec                package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.gemstone24-dkh.99' ].	spec for: #'gs3.2.0.x' do: [		spec                package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.gemstone24-dkh.99' ].! !!ConfigurationOfFileTree methodsFor: 'versions' stamp: 'dkh 06/16/2013 19:43'!version102: spec  <version: '1.0.2' imports: #('1.0.2-baseline')>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec description: '- non UTF-8 data in monticello.meta/version file  https://github.com/dalehenrich/filetree/issues/72- Missing FileTreeUrl in Pharo  https://github.com/dalehenrich/filetree/issues/74- Gemstone 24 dev - Issue #72 fixes  https://github.com/dalehenrich/filetree/issues/75- In Pharo-2.0, MCVersionInfoWriter>>writeVersionInfo: pre-emptorily converts version message to latin-1  https://github.com/dalehenrich/filetree/issues/76- Add Pharo2.0 support  https://github.com/dalehenrich/filetree/issues/81- commit: 0d1f1dfc82919978db39e3021078b4b5acf551da'.      spec author: 'dkh'.      spec timestamp: '6/16/2013 19:24' ].  spec    for: #'pharo1.1.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo11-dkh.95';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14' ].  spec    for: #'pharo1.2.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo11-dkh.95';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14' ].  spec    for: #'pharo1.3.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo13-dkh.93';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo13-dkh.12' ].  spec    for: #'pharo1.4.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo14-dkh.93';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo14-dkh.12' ].  spec    for: #'pharo2.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo20-dkh.109';        package: 'MonticelloFileTree-FileSystem-Utilities'          with: 'MonticelloFileTree-FileSystem-Utilities.pharo20-dkh.17';        package: 'MonticelloFileTree-Git'          with: 'MonticelloFileTree-Git.pharo20-dkh.24' ].  spec    for: #'pharo3.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo30-dkh.103';        package: 'MonticelloFileTree-FileSystem-Utilities'          with: 'MonticelloFileTree-FileSystem-Utilities.pharo30-dkh.24' ].  spec    for: #'squeak'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.squeak43-dkh.92';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.squeak43-dkh.12' ].  spec    for: #'gemstone'    do: [       spec        project: 'GsCore' with: '0.246';        project: 'Monticello' with: '0.243'.      spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.gemstone24-dkh.108';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.gemstone24-dkh.14' ]! !!ConfigurationOfFileTree methodsFor: 'versions' stamp: 'dkh 07/07/2013 15:57'!version1031: spec  <version: '1.0.3.1' imports: #('1.0.3-baseline')>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec        description:          '- fix Issue #64 : FileTree should not override MCVersionInfo>>date and time  https://github.com/dalehenrich/filetree/issues/64- partial fix for Issue #87: Ston chages  https://github.com/dalehenrich/filetree/pull/87'.      spec author: 'dkh'.      spec timestamp: '7/7/2013 08:57' ].  spec    for: #'pharo1.1.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo11-dkh.95';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14' ].  spec    for: #'pharo1.2.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo11-dkh.95';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14' ].  spec    for: #'pharo1.3.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo13-dkh.93';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo13-dkh.12' ].  spec    for: #'pharo1.4.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo14-dkh.93';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo14-dkh.12' ].  spec    for: #'pharo2.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo20-dkh.127';        package: 'MonticelloFileTree-FileSystem-Utilities'          with: 'MonticelloFileTree-FileSystem-Utilities.pharo20-dkh.17';        package: 'MonticelloFileTree-Git'          with: 'MonticelloFileTree-Git.pharo20-dkh.39' ].  spec    for: #'pharo3.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo30-dkh.103';        package: 'MonticelloFileTree-FileSystem-Utilities'          with: 'MonticelloFileTree-FileSystem-Utilities.pharo30-dkh.24' ].  spec    for: #'squeak'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.squeak43-dkh.96';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.squeak43-dkh.12' ].  spec    for: #'gemstone'    do: [       spec        project: 'GsCore' with: '0.246';        project: 'Monticello' with: '0.243'.      spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.gemstone24-dkh.108';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.gemstone24-dkh.14' ]! !!ConfigurationOfFileTree methodsFor: 'versions' stamp: 'dkh 07/07/2013 15:21'!version103: spec  <version: '1.0.3' imports: #('1.0.3-baseline')>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec        description:          '- fix Issue #86 : update config to use seaside.gemtalksystems.com and ss3.gemtalksystems.com  https://github.com/dalehenrich/filetree/issues/86'.      spec author: 'dkh'.      spec timestamp: '6/28/2013 16:24' ].  spec    for: #'pharo1.1.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo11-dkh.95';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14' ].  spec    for: #'pharo1.2.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo11-dkh.95';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14' ].  spec    for: #'pharo1.3.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo13-dkh.93';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo13-dkh.12' ].  spec    for: #'pharo1.4.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo14-dkh.93';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo14-dkh.12' ].  spec    for: #'pharo2.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo20-dkh.109';        package: 'MonticelloFileTree-FileSystem-Utilities'          with: 'MonticelloFileTree-FileSystem-Utilities.pharo20-dkh.17';        package: 'MonticelloFileTree-Git'          with: 'MonticelloFileTree-Git.pharo20-dkh.24' ].  spec    for: #'pharo3.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo30-dkh.103';        package: 'MonticelloFileTree-FileSystem-Utilities'          with: 'MonticelloFileTree-FileSystem-Utilities.pharo30-dkh.24' ].  spec    for: #'squeak'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.squeak43-dkh.92';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.squeak43-dkh.12' ].  spec    for: #'gemstone'    do: [       spec        project: 'GsCore' with: '0.246';        project: 'Monticello' with: '0.243'.      spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.gemstone24-dkh.108';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.gemstone24-dkh.14' ]! !!ConfigurationOfFileTree methodsFor: 'versions' stamp: 'dkh 07/22/2013 23:35'!version1041: spec  <version: '1.0.4.1' imports: #('1.0.3-baseline')>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec description: '- checkpoint working on PHaro3.0 port'.      spec author: 'dkh'.      spec timestamp: '7/22/2013 23:03' ].  spec    for: #'pharo1.1.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo11-dkh.101';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14' ].  spec    for: #'pharo1.2.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo11-dkh.101';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14' ].  spec    for: #'pharo1.3.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo13-dkh.99';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo13-dkh.12' ].  spec    for: #'pharo1.4.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo14-dkh.99';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo14-dkh.12' ].  spec    for: #'pharo2.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo20-dkh.134';        package: 'MonticelloFileTree-FileSystem-Utilities'          with: 'MonticelloFileTree-FileSystem-Utilities.pharo20-dkh.17';        package: 'MonticelloFileTree-Git'          with: 'MonticelloFileTree-Git.pharo20-dkh.42' ].  spec    for: #'pharo3.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo30-dkh.143';        package: 'MonticelloFileTree-FileSystem-Utilities'          with: 'MonticelloFileTree-FileSystem-Utilities.pharo30-dkh.27' ].  spec    for: #'squeak'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.squeak43-dkh.132';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.squeak43-dkh.12' ].  spec    for: #'gemstone'    do: [       spec        project: 'GsCore' with: '0.246';        project: 'Monticello' with: '0.243'.      spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.gemstone24-dkh.147';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.gemstone24-dkh.14' ]! !!ConfigurationOfFileTree methodsFor: 'versions' stamp: 'EstebanLorenzano 8/8/2013 13:25'!version1042: spec  <version: '1.0.4.2' imports: #('1.0.3-baseline')>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec description: '- trait support for pharo 2.0'.      spec author: 'EstebanLorenzano'.      spec timestamp: '9/08/2013 13:23' ].  spec    for: #'pharo1.1.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo11-dkh.101';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14' ].  spec    for: #'pharo1.2.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo11-dkh.101';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14' ].  spec    for: #'pharo1.3.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo13-dkh.99';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo13-dkh.12' ].  spec    for: #'pharo1.4.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo14-dkh.99';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo14-dkh.12' ].  spec    for: #'pharo2.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo20-EstebanLorenzano.137';        package: 'MonticelloFileTree-FileSystem-Utilities'          with: 'MonticelloFileTree-FileSystem-Utilities.pharo20-EstebanLorenzano.19';        package: 'MonticelloFileTree-Git'          with: 'MonticelloFileTree-Git.pharo20-dkh.42' ].  spec    for: #'pharo3.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo30-dkh.143';        package: 'MonticelloFileTree-FileSystem-Utilities'          with: 'MonticelloFileTree-FileSystem-Utilities.pharo30-dkh.27' ].  spec    for: #'squeak'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.squeak43-dkh.132';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.squeak43-dkh.12' ].  spec    for: #'gemstone'    do: [       spec        project: 'GsCore' with: '0.246';        project: 'Monticello' with: '0.243'.      spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.gemstone24-dkh.147';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.gemstone24-dkh.14' ]! !!ConfigurationOfFileTree methodsFor: 'versions' stamp: 'dkh 07/10/2013 14:05'!version104: spec  <version: '1.0.4' imports: #('1.0.3-baseline')>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec description: '- fix Issue #66: Pharo install instructions incorrect  https://github.com/dalehenrich/filetree/issues/66- fix Issue #82: Sqeak4.5 builds failing....  https://github.com/dalehenrich/filetree/issues/82- fix Issue #83: Don''t override Monticello methods  https://github.com/dalehenrich/filetree/issues/83- fix Issue #86: update config to use seaside.gemtalksystems.com and ss3.gemtalksystems.com  https://github.com/dalehenrich/filetree/issues/86- fix Issue #87: Ston changes  https://github.com/dalehenrich/filetree/issues/87- fix Issue #88: Gitfiletree  https://github.com/dalehenrich/filetree/issues/88- fix Issue #90: provide option to create `.ston` property files  https://github.com/dalehenrich/filetree/issues/90- fix Issue #91: Git repository tests failing with Issue #90 bugfix  https://github.com/dalehenrich/filetree/issues/91'.      spec author: 'dkh'.      spec timestamp: '7/10/2013 11:30' ].  spec    for: #'pharo1.1.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo11-dkh.101';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14' ].  spec    for: #'pharo1.2.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo11-dkh.101';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14' ].  spec    for: #'pharo1.3.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo13-dkh.99';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo13-dkh.12' ].  spec    for: #'pharo1.4.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo14-dkh.99';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo14-dkh.12' ].  spec    for: #'pharo2.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo20-dkh.134';        package: 'MonticelloFileTree-FileSystem-Utilities'          with: 'MonticelloFileTree-FileSystem-Utilities.pharo20-dkh.17';        package: 'MonticelloFileTree-Git'          with: 'MonticelloFileTree-Git.pharo20-dkh.42' ].  spec    for: #'pharo3.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo30-dkh.103';        package: 'MonticelloFileTree-FileSystem-Utilities'          with: 'MonticelloFileTree-FileSystem-Utilities.pharo30-dkh.24' ].  spec    for: #'squeak'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.squeak43-dkh.132';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.squeak43-dkh.12' ].  spec    for: #'gemstone'    do: [       spec        project: 'GsCore' with: '0.246';        project: 'Monticello' with: '0.243'.      spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.gemstone24-dkh.129';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.gemstone24-dkh.14' ]! !!ConfigurationOfFileTree methodsFor: 'versions' stamp: 'dkh 08/11/2013 08:19'!version105: spec  <version: '1.0.5' imports: #('1.0.3-baseline')>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec description: '-fix Issue #11: Traits and Script support- fix Issue #92: Mac case insensitivity `must` be addressed- fix Issue #97: Load packages from repos with no monticello meta data - fix Issue #101: Refactor MCFileTreeStCypressWriter>>writeDefinitions: to ease Issue #11 integrationfor details: https://github.com/dalehenrich/filetree/issues?direction=desc&milestone=9&page=1&sort=updated&state=closed '.      spec author: 'dkh'.      spec timestamp: '8/11/2013 07:28' ].  spec    for: #'pharo1.1.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo11-dkh.154';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14' ].  spec    for: #'pharo1.2.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo11-dkh.154';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14' ].  spec    for: #'pharo1.3.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo13-dkh.154';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo13-dkh.12' ].  spec    for: #'pharo1.4.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo14-dkh.154';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.pharo14-dkh.12' ].  spec    for: #'pharo2.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo20-dkh.160';        package: 'MonticelloFileTree-FileSystem-Utilities'          with:            'MonticelloFileTree-FileSystem-Utilities.pharo20-EstebanLorenzano.19';        package: 'MonticelloFileTree-Git'          with: 'MonticelloFileTree-Git.pharo20-dkh.61' ].  spec    for: #'pharo3.x'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.pharo30-dkh.154';        package: 'MonticelloFileTree-FileSystem-Utilities'          with: 'MonticelloFileTree-FileSystem-Utilities.pharo30-dkh.27' ].  spec    for: #'squeak'    do: [       spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.squeak43-dkh.161';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.squeak43-dkh.12' ].  spec    for: #'gemstone'    do: [       spec        project: 'GsCore' with: '0.246';        project: 'Monticello' with: '0.243'.      spec        package: 'MonticelloFileTree-Core'          with: 'MonticelloFileTree-Core.gemstone24-dkh.154';        package: 'MonticelloFileTree-FileDirectory-Utilities'          with: 'MonticelloFileTree-FileDirectory-Utilities.gemstone24-dkh.14' ]! !!ConfigurationOfFileTree methodsFor: 'versions' stamp: 'dkh 09/12/2013 06:28'!version1061: spec	<version: '1.0.6.1' imports: #('1.0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- fix issue #108:  https://github.com/dalehenrich/filetree/pull/108Milestone:  https://github.com/dalehenrich/filetree/issues?direction=desc&milestone=12&page=1&state=closed'.		spec author: 'dkh'.		spec timestamp: '9/12/2013 15:23'. ].	spec for: #'pharo1.1.x' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo11-dkh.157';			package: 'MonticelloFileTree-FileDirectory-Utilities' with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14'. ].	spec for: #'pharo1.2.x' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo11-dkh.157';			package: 'MonticelloFileTree-FileDirectory-Utilities' with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14'. ].	spec for: #'pharo1.3.x' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo13-dkh.165';			package: 'MonticelloFileTree-FileDirectory-Utilities' with: 'MonticelloFileTree-FileDirectory-Utilities.pharo13-dkh.12'. ].	spec for: #'pharo1.4.x' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo14-dkh.166';			package: 'MonticelloFileTree-FileDirectory-Utilities' with: 'MonticelloFileTree-FileDirectory-Utilities.pharo14-dkh.12'. ].	spec for: #'pharo2.x' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo20-dkh.163';			package: 'MonticelloFileTree-FileSystem-Utilities' with: 'MonticelloFileTree-FileSystem-Utilities.pharo20-EstebanLorenzano.19';			package: 'MonticelloFileTree-Git' with: 'MonticelloFileTree-Git.pharo20-dkh.63'. ].	spec for: #'pharo3.x' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo30-dkh.159';			package: 'MonticelloFileTree-FileSystem-Utilities' with: 'MonticelloFileTree-FileSystem-Utilities.pharo30-dkh.27'. ].	spec for: #'squeak' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.squeak43-dkh.165';			package: 'MonticelloFileTree-FileDirectory-Utilities' with: 'MonticelloFileTree-FileDirectory-Utilities.squeak43-dkh.12'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.246';			project: 'Monticello' with: '0.243'.		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.gemstone24-dkh.164';			package: 'MonticelloFileTree-FileDirectory-Utilities' with: 'MonticelloFileTree-FileDirectory-Utilities.gemstone24-dkh.14'. ].! !!ConfigurationOfFileTree methodsFor: 'versions' stamp: 'dkh 10/29/2014 12:49'!version1062: spec	<version: '1.0.6.2' imports: #('1.0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- bugfix for Issue #132: possible Squeak problem with FileTree caching  https://github.com/dalehenrich/filetree/issues/132'.		spec author: 'dkh'.		spec timestamp: '10/29/2014 12:48'. ].	spec for: #'pharo1.1.x' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo11-dkh.157';			package: 'MonticelloFileTree-FileDirectory-Utilities' with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14'. ].	spec for: #'pharo1.2.x' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo11-dkh.157';			package: 'MonticelloFileTree-FileDirectory-Utilities' with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14'. ].	spec for: #'pharo1.3.x' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo13-dkh.165';			package: 'MonticelloFileTree-FileDirectory-Utilities' with: 'MonticelloFileTree-FileDirectory-Utilities.pharo13-dkh.12'. ].	spec for: #'pharo1.4.x' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo14-dkh.166';			package: 'MonticelloFileTree-FileDirectory-Utilities' with: 'MonticelloFileTree-FileDirectory-Utilities.pharo14-dkh.12'. ].	spec for: #'pharo2.x' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo20-dkh.163';			package: 'MonticelloFileTree-FileSystem-Utilities' with: 'MonticelloFileTree-FileSystem-Utilities.pharo20-EstebanLorenzano.19';			package: 'MonticelloFileTree-Git' with: 'MonticelloFileTree-Git.pharo20-dkh.63'. ].	spec for: #'pharo3.x' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo30-dkh.159';			package: 'MonticelloFileTree-FileSystem-Utilities' with: 'MonticelloFileTree-FileSystem-Utilities.pharo30-dkh.27'. ].	spec for: #'squeak' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.squeak43-dkh.169';			package: 'MonticelloFileTree-FileDirectory-Utilities' with: 'MonticelloFileTree-FileDirectory-Utilities.squeak43-dkh.12'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.246';			project: 'Monticello' with: '0.243'.		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.gemstone24-dkh.164';			package: 'MonticelloFileTree-FileDirectory-Utilities' with: 'MonticelloFileTree-FileDirectory-Utilities.gemstone24-dkh.14'. ].! !!ConfigurationOfFileTree methodsFor: 'versions' stamp: 'dkh 09/08/2013 07:17'!version106: spec	<version: '1.0.6' imports: #('1.0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: 'https://github.com/dalehenrich/filetree/issues?direction=desc&milestone=10&page=1&state=closed'.		spec author: 'dkh'.		spec timestamp: '9/8/2013 06:22'. ].	spec for: #'pharo1.1.x' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo11-dkh.157';			package: 'MonticelloFileTree-FileDirectory-Utilities' with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14'. ].	spec for: #'pharo1.2.x' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo11-dkh.157';			package: 'MonticelloFileTree-FileDirectory-Utilities' with: 'MonticelloFileTree-FileDirectory-Utilities.pharo11-dkh.14'. ].	spec for: #'pharo1.3.x' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo13-dkh.165';			package: 'MonticelloFileTree-FileDirectory-Utilities' with: 'MonticelloFileTree-FileDirectory-Utilities.pharo13-dkh.12'. ].	spec for: #'pharo1.4.x' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo14-dkh.166';			package: 'MonticelloFileTree-FileDirectory-Utilities' with: 'MonticelloFileTree-FileDirectory-Utilities.pharo14-dkh.12'. ].	spec for: #'pharo2.x' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo20-dkh.163';			package: 'MonticelloFileTree-FileSystem-Utilities' with: 'MonticelloFileTree-FileSystem-Utilities.pharo20-EstebanLorenzano.19';			package: 'MonticelloFileTree-Git' with: 'MonticelloFileTree-Git.pharo20-dkh.63'. ].	spec for: #'pharo3.x' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.pharo30-dkh.157';			package: 'MonticelloFileTree-FileSystem-Utilities' with: 'MonticelloFileTree-FileSystem-Utilities.pharo30-dkh.27'. ].	spec for: #'squeak' do: [		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.squeak43-dkh.165';			package: 'MonticelloFileTree-FileDirectory-Utilities' with: 'MonticelloFileTree-FileDirectory-Utilities.squeak43-dkh.12'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.246';			project: 'Monticello' with: '0.243'.		spec 			package: 'MonticelloFileTree-Core' with: 'MonticelloFileTree-Core.gemstone24-dkh.164';			package: 'MonticelloFileTree-FileDirectory-Utilities' with: 'MonticelloFileTree-FileDirectory-Utilities.gemstone24-dkh.14'. ].! !"ConfigurationOfFileTree"!SystemOrganization addCategory: #'Metacello-Base'!Object subclass: #MetacelloBaseConfiguration	instanceVariableNames: 'project'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Base'!!MetacelloBaseConfiguration commentStamp: '<historical>' prior: 0!THIS IS AN EXPERIMENTAL CLASS. Use MetacelloConfigTemplate for creating configurations.Subclass me to create a new configuration, then edit and evaluate the following expression to create the initial baseline version:	"create baseline method"        MetacelloToolBox                 createBaseline: '1.0-baseline'                for: 'MyProject'                repository: 'http://www.example.com/MyProjectRepository'                requiredProjects: #('Gofer')                packages: #('MyProject-Core' 'MyProject-Tests')                dependencies:                        {('MyProject-Core' -> #('Gofer')).                         ('MyProject-Tests' -> #('MyProject-Core'))}                groups:                        {('default' -> #('Core')).                        ('Core' -> #('MyProject-Core')).                        ('Tests' -> #('MyProject-Tests'))}.	   "create initial development method from the baseline"         MetacelloToolBox               createDevelopment: '1.0'               for: 'MyProject'                importFromBaseline: '1.0-baseline'                description: 'initial version'.!!MetacelloBaseConfiguration class methodsFor: 'development support' stamp: 'DaleHenrichs 12/17/2010 10:20'!DevelopmentProcess"DEVELOPMENT Process	- load current version:	  	(self project version: #stable) load: 'ALL'.	- open new version for development:		self createNewDevelopmentVersion	- do development and periodically save mcz files and configuration until ready for release		self saveModifiedPackagesAndConfiguration: '- fixed a bug'	- update the the development version to match mcz file versions		self updateToLatestPackageVersions: '- fixed a bug'	- save configuration		self saveConfiguration: '- checkpoint configuration'RELEASE Process	- mark development version as release:		self releaseDevelopmentVersion: '- release'"	<apiDocumentation>! !!MetacelloBaseConfiguration class methodsFor: 'private' stamp: 'DaleHenrichs 11/2/2010 14:03'!bootstrapPackage: aString from: aPath 	| repository version |	repository := MCHttpRepository				location: aPath				user: ''				password: ''.	repository		versionReaderForFileNamed: aString , '.mcz'		do: [:reader | 			version := reader version.			version load.			version workingCopy repositoryGroup addRepository: repository]! !!MetacelloBaseConfiguration class methodsFor: 'development support' stamp: 'DaleHenrichs 1/14/2011 11:51'!compareVersions	"Compare the #stable version to #development version"	"self compareVersions"	<apiDocumentation>	self ensureMetacello.	((Smalltalk at: #MetacelloToolBox) compareVersionsIn: self) inspect! !!MetacelloBaseConfiguration class methodsFor: 'development support' stamp: 'DaleHenrichs 1/11/2011 15:00'!createNewBaselineVersion	"Create a new baseline version based upon the #stable version's baseline.	 A new baseline should be created if new packages have been added or package dependencies have changed."	"self createNewDevelopmentVersion"	<apiDocumentation>	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) createNewBaselineVersionIn: self description: ''! !!MetacelloBaseConfiguration class methodsFor: 'development support' stamp: 'DaleHenrichs 1/11/2011 15:00'!createNewDevelopmentVersion	"Create a new development version using the #stable version as model."	"self createNewDevelopmentVersion"	<apiDocumentation>	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) createNewDevelopmentVersionIn: self description: ''! !!MetacelloBaseConfiguration class methodsFor: 'private' stamp: 'DaleHenrichs 11/2/2010 14:03'!ensureMetacello	"Bootstrap Gofer (if necessary), load latest mcz file for ConfigurationOfMetacello (using old 	 Gofer API), then load the latest version of Metacello itself."	Smalltalk at: #MetacelloProject ifAbsent: [ | error |		"list of repositories to try, in case primary repository is not accessible"		(Array 			with: 'http://www.squeaksource.com/MetacelloRepository' 			with: 'http://seaside.gemstone.com/ss/metacello') do: [:repositoryUrl |				([					Smalltalk at: #Gofer ifAbsent: [					"Current version of Gofer from which to bootstrap - as of 1.0-beta.21"						self bootstrapPackage: 'Gofer-Core-lr.115' from: repositoryUrl ].					Smalltalk at: #Gofer ifPresent: [:goferClass | | gofer |						gofer := goferClass new							url: repositoryUrl;							yourself.						[ gofer addPackage: 'ConfigurationOfMetacello' ] on: Warning do: [:ex | ex resume ].						gofer load ]]							on: Error							do: [ :ex |								error := ex.								Transcript 									cr; 									show: 'failed ensureMetacello: ';									show: ex description printString;									show: '...retrying'.								"try again"								ex return: nil ]) ~~ nil					ifTrue: [						"load 'default' group of Metacello"						(Smalltalk at: #ConfigurationOfMetacello) perform: #load.						^self ]].		"shouldn't get here unless the load failed ... throw an error"		self error: 'retry with alternate repository failed: ', error description printString ]! !!MetacelloBaseConfiguration class methodsFor: 'metacello tool support' stamp: 'DaleHenrichs 11/2/2010 14:03'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!MetacelloBaseConfiguration class methodsFor: 'loading' stamp: 'DaleHenrichs 11/29/2010 14:55'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!MetacelloBaseConfiguration class methodsFor: 'loading' stamp: 'DaleHenrichs 11/29/2010 14:57'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!MetacelloBaseConfiguration class methodsFor: 'loading' stamp: 'DaleHenrichs 11/29/2010 14:54'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!MetacelloBaseConfiguration class methodsFor: 'accessing' stamp: 'DaleHenrichs 11/2/2010 14:03'!project	^self new project! !!MetacelloBaseConfiguration class methodsFor: 'development support' stamp: 'DaleHenrichs 1/11/2011 15:06'!releaseDevelopmentVersion: commitMessage	"Release #development version: set version blessing to #release, update the #development and #stable symbolic version methods and save the configuration."	"self releaseDevelopmentVersion: '- release version 1.0.2'"	<apiDocumentation>	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) releaseDevelopmentVersionIn: self description: commitMessage! !!MetacelloBaseConfiguration class methodsFor: 'development support' stamp: 'DaleHenrichs 1/11/2011 15:07'!saveConfiguration: commitMessage	"Save mcz file that contains the configuration to it's repository."	"self saveConfiguration: '- fixed bug'"	<apiDocumentation>	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) saveConfigurationPackageFor: self name asString description: commitMessage! !!MetacelloBaseConfiguration class methodsFor: 'development support' stamp: 'DaleHenrichs 1/11/2011 15:10'!saveModifiedPackagesAndConfiguration: commitMessage	"Save modified mcz files, update the #development version and then save the configuration."	"self saveModifiedPackagesAndConfiguration: '- fixed bug'"	<apiDocumentation>	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) saveModifiedPackagesAndConfigurationIn: self description: commitMessage! !!MetacelloBaseConfiguration class methodsFor: 'unloading Metacello' stamp: 'DaleHenrichs 11/29/2010 15:00'!unloadMetacello	"Unload the classes that implement Metacello. Metacello is not needed once a project has been loaded, so it can safely be unloaded."	"self unloadMetacello"	<apiDocumentation>	| gofer |	gofer := (Smalltalk at: #Gofer) new.	MCWorkingCopy allManagers do: [:wc |		((wc packageName beginsWith: 'Metacello') or: [ wc packageName beginsWith: 'OB-Metacello' ])			ifTrue: [ gofer package: wc packageName ]].	gofer unload.! !!MetacelloBaseConfiguration class methodsFor: 'development support' stamp: 'DaleHenrichs 1/11/2011 15:11'!updateToLatestPackageVersions: descriptionString	"Update the #development version to match currently loaded mcz files."	"self updateToLatestPackageVersions: '- fixed a bug'"	<apiDocumentation>	self ensureMetacello.	((Smalltalk at: #MetacelloToolBox) updateToLatestPackageVersionsIn: self description: descriptionString) isEmpty		ifTrue: [ self inform: 'All specs up to date' ]! !!MetacelloBaseConfiguration class methodsFor: 'development support' stamp: 'DaleHenrichs 12/6/2010 11:13'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!MetacelloBaseConfiguration methodsFor: 'defaults' stamp: 'DaleHenrichs 11/8/2010 10:42'!bleedingEdge 	"override if different behavior desired.	 Use:		self versionDoesNotExistError: #bleedingEdge	 if #bleedingEdge version is disallowed."	<defaultSymbolicVersion: #bleedingEdge>		^self defaultBleedingEdgeVersion! !!MetacelloBaseConfiguration methodsFor: 'defaults' stamp: 'DaleHenrichs 1/7/2011 16:24'!defaultBleedingEdgeVersion	| bleedingEdgeVersion |	bleedingEdgeVersion := (self project map values select: [ :version | version blessing == #baseline ])		detectMax: [ :version | version ].	bleedingEdgeVersion ifNil: [ ^#'notDefined' ].	^ bleedingEdgeVersion versionString! !!MetacelloBaseConfiguration methodsFor: 'accessing' stamp: 'DaleHenrichs 11/2/2010 14:03'!project	^ project ifNil: [ | constructor |		"Bootstrap Metacello if it is not already loaded"		self class ensureMetacello.		"Construct Metacello project"		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.		project := constructor project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!MetacelloBaseConfiguration methodsFor: 'accessing' stamp: 'DaleHenrichs 11/2/2010 14:27'!project: aProject	project ifNil: [ self class ensureMetacello ].	project := aProject! !!MetacelloBaseConfiguration methodsFor: 'private' stamp: 'DaleHenrichs 11/4/2010 14:22'!versionDoesNotExistError: versionStringOrSymbol	((Smalltalk at: #MetacelloSymbolicVersionDoesNotExistError) project: self project versionString: versionStringOrSymbol) signal! !"Metacello-Base"!SystemOrganization addCategory: #'Gofer-Core'!Error subclass: #GoferRepositoryError	instanceVariableNames: 'repository'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!Object subclass: #Gofer	instanceVariableNames: 'references repositories errorBlock packageCacheRepository resolvedReferencesCache'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!!Gofer commentStamp: 'lr 12/14/2009 09:20' prior: 0!: Gofer, a person who runs errands. Origin 1960s: from go for, i.e. go and fetch.: ''The New Oxford American Dictionary''!! SynopsisGofer is a small tool on top of Monticello that loads, updates, merges, diffs, reverts, commits, recompiles and unloads groups of Monticello packages. Contrary to existing tools Gofer makes sure that these operations are performed as clean as possible:- Gofer treats packages from one or more repository in one operation.- Gofer works with fixed versions or tries to find the "latest" version using a given name prefix.- Gofer automatically assigns repositories to all packages, so that the other tools are ready to be used on individual packages.- Gofer makes sure that there is only one repository instance registered for a single physical location.- Gofer works with Monticello dependencies and uniformly treats them like the primary package.- Gofer prefers to work with faster repositories if there is a choice.- Gofer cleans up after Monticello, no empty class categories and no empty method protocols are to be expected.!! InstallationGofer is included with the latest Pharo and GemStone distributions. To update to the latest version you can use Gofer itself:== Gofer gofer updateIn case you are missing Gofer in your image, grab it from *http://source.lukas-renggli.ch/gofer.html*.!! DescriptionGofer is very simple by design, the basic useage scenario is always the same and consists of three steps:# You specify a Monticello repository URL. You can do this using the methods ==url:==, ==url:username:password:== (HTTP, FTP), or ==directory:== if you need full control, or using convenience methods like ==squeaksource:==, ==wiresong:==, or ==gemsource:== for well known repositories. Additionally the following settings are available:#- Gofer implicitly declares the local package cache as a repository. To disable the local package cache use the method ==disablePackageCache==, to re-enable use ==enablePackageCache==.#- Gofer throws Gofer throws errors if a repository is not reachable. To silently ignore repository erros use the message ==disableRepositoryErrors==, to re-enable use ==enableRepositoryErrors==.# You specify one or more Monticello packages you want to work with, by adding them to the Gofer instance. Use ==version:== to add a specific version, or use ==package:== to add the "latest" version in the given repository. Furthermore there is ==package:constraint:== that allows to further constraint the version to be loaded in a block passed in as the second argument.# You specify one or more actions to be performed on the specified packages:| ==load==	| Load the specified packages.| ==update==	| Update the specified packages.| ==merge==	| Merge the specified packages into their working copies.| ==localChanges==	| Display the changes between the base version and the working copy.| ==remoteChanges==	| Display the changes between the working copy and the remote changes.| ==cleanup==	| Cleans the specified packages.| ==commit==	| Commit the modified specified packages.| ==commit:==	| Commit the modified specified packages with the given commit message.| ==revert==	| Revert the specified packages to the currently loaded version.| ==recompile==	| Recompile the specified packages.| ==unload==	| Unload the specified packages.| ==fetch==     | Download versions from remote repositories into the local cache.| ==push==      | Upload local versions from local cache into remote repositories.!! ExampleTo use Gofer to load exact versions of the Kom Server, the 'latest' code of Seaside 2.8 and the 'latest' code of the Scriptaculous package that is committed by the author with the initials 'lr' one could write:== Gofer new==     squeaksource: 'KomHttpServer';==     version: 'DynamicBindings-gc.7';==     version: 'KomServices-gc.19';==     version: 'KomHttpServer-gc.32';==     squeaksource: 'Seaside';==     package: 'Seaside2.8a';==     package: 'Scriptaculous' constraint: [ :version | version author = 'lr' ];==     load!Object subclass: #GoferOperation	instanceVariableNames: 'gofer model'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferOperation subclass: #GoferLoad	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferOperation subclass: #GoferSynchronize	instanceVariableNames: 'cacheReferences'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferSynchronize subclass: #GoferFetch	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferSynchronize subclass: #GoferPush	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferOperation subclass: #GoferWorking	instanceVariableNames: 'workingCopies'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferWorking subclass: #GoferChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferChanges subclass: #GoferLocalChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferLocalChanges subclass: #GoferBrowseLocalChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferChanges subclass: #GoferRemoteChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferRemoteChanges subclass: #GoferBrowseRemoteChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferWorking subclass: #GoferCleanup	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferWorking subclass: #GoferCommit	instanceVariableNames: 'message'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferWorking subclass: #GoferRecompile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferWorking subclass: #GoferReinitialize	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferWorking subclass: #GoferUnload	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferWorking subclass: #GoferUpdate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferUpdate subclass: #GoferMerge	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferUpdate subclass: #GoferRevert	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!Object subclass: #GoferReference	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!GoferReference subclass: #GoferPackageReference	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!!GoferPackageReference commentStamp: 'lr 12/9/2009 22:47' prior: 0!A GoferPackageReference refers to the latest version of a Monticello package.!GoferPackageReference subclass: #GoferConstraintReference	instanceVariableNames: 'constraintBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!!GoferConstraintReference commentStamp: 'lr 12/9/2009 22:48' prior: 0!A GoferPackageReference refers to the latest version of a Monticello package satisfying an additional set of conditions.!GoferReference subclass: #GoferVersionReference	instanceVariableNames: 'package author branch versionNumber'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!!GoferVersionReference commentStamp: 'lr 12/9/2009 22:50' prior: 0!A GoferVersionReference refers to a specific version of a Monticello package.!GoferVersionReference subclass: #GoferResolvedReference	instanceVariableNames: 'repository'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!!GoferResolvedReference commentStamp: 'lr 12/9/2009 22:53' prior: 0!A GoferVersionReference refers to a specific version of a Monticello package in a particular repository. This class is the only one that can actually access the version, because it is the only one knowing where to find it.!!MCDictionaryRepository methodsFor: '*gofer-core-accessing' stamp: 'lr 12/11/2009 22:31'!goferPriority	^ 10! !!MCDictionaryRepository methodsFor: '*gofer-core-accessing' stamp: 'TestRunner 12/12/2009 11:12'!goferReferences	^ self allVersionInfos collect: [ :each | GoferResolvedReference name: each name repository: self ]! !!MCDictionaryRepository methodsFor: '*gofer-core-accessing' stamp: 'TestRunner 12/13/2009 14:57'!goferVersionFrom: aVersionReference	^ self dictionary detect: [ :version | version info name = aVersionReference name ]! !!GoferRepositoryError class methodsFor: 'instance creation' stamp: 'lr 12/9/2009 19:15'!signal: aString repository: aRepository	^ self new repository: aRepository; signal: aString! !!GoferRepositoryError methodsFor: 'private' stamp: 'lr 12/9/2009 22:32'!isResumable	^ true! !!GoferRepositoryError methodsFor: 'accessing' stamp: 'lr 12/9/2009 19:14'!repository	^ repository! !!GoferRepositoryError methodsFor: 'accessing' stamp: 'lr 12/9/2009 19:14'!repository: aRepository	repository := aRepository! !!MCVersionLoader methodsFor: '*gofer-core-accessing' stamp: 'lr 12/18/2009 12:43'!goferHasVersions	^ versions isEmpty not! !!MCVersionLoader methodsFor: '*gofer-core-accessing' stamp: 'lr 12/18/2009 12:43'!goferVersions	^ versions! !!MCDirectoryRepository methodsFor: '*gofer-core-accessing' stamp: 'lr 12/11/2009 22:32'!goferPriority	^ 5! !!Gofer class methodsFor: 'private' stamp: 'lr 1/5/2010 10:45'!gofer	"Create a Gofer instance of Gofer."	^ self new		renggli: 'gofer';		package: 'Gofer-Core';		package: 'Gofer-Tests';		yourself! !!Gofer class methodsFor: 'instance creation' stamp: 'lr 11/6/2009 10:50'!it	^ self new! !!Gofer class methodsFor: 'instance creation' stamp: 'lr 8/20/2009 09:54'!new	^ self basicNew initialize! !!Gofer class methodsFor: 'private' stamp: 'lr 1/12/2010 19:39'!upgrade	"Update Gofer to the latest version using itself."		| working |	[ self gofer load ]		on: Error		do: [ :err | err retry ].	self new unload		unregister: (MCWorkingCopy 			forPackage: (MCPackage named: 'Gofer')).	self gofer recompile; cleanup! !!Gofer methodsFor: 'deprecated' stamp: 'lr 12/14/2009 20:08'!addPackage: aString	self deprecated: 'Instead of #addPackage: simply use #package:'.	self package: aString! !!Gofer methodsFor: 'deprecated' stamp: 'lr 12/14/2009 20:08'!addPackage: aString constraint: aBlock	self deprecated: 'Instead of #addPackage:constraint: simply use #package:constraint:'.	self package: aString constraint: aBlock! !!Gofer methodsFor: 'deprecated' stamp: 'lr 12/14/2009 20:08'!addVersion: aString	self deprecated: 'Instead of #addVersion: simply use #version:'.	self version: aString! !!Gofer methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:17'!allResolved	"Answer all sorted references within the configured repositories."		| resolved |	resolved := OrderedCollection new.	self repositories		do: [ :repository | resolved addAll: (self allResolvedIn: repository) ].	^ resolved asSortedCollection asArray! !!Gofer methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:17'!allResolvedIn: aRepository	"Answer all sorted references within aRepository. For efficiency cache the references."	^ (resolvedReferencesCache ifNil: [ resolvedReferencesCache := Dictionary new ])		at: aRepository ifAbsentPut: [ self basicReferencesIn: aRepository ]! !!Gofer methodsFor: 'private' stamp: 'lr 12/13/2009 16:28'!basicReferencesIn: aRepository	^ [ aRepository goferReferences asSortedCollection asArray ] 		on: GoferRepositoryError		do: errorBlock! !!Gofer methodsFor: 'operations-ui' stamp: 'lr 12/14/2009 23:51'!browseLocalChanges	"Browse the changes between the base version and the working copy."		^ self execute: GoferBrowseLocalChanges! !!Gofer methodsFor: 'operations-ui' stamp: 'lr 12/14/2009 23:51'!browseRemoteChanges	"Browse the changes between the working copy and the remote changes."		^ self execute: GoferBrowseRemoteChanges! !!Gofer methodsFor: 'operations' stamp: 'lr 10/3/2009 11:31'!cleanup	"Cleans the specified packages."		^ self execute: GoferCleanup! !!Gofer methodsFor: 'operations' stamp: 'lr 11/10/2009 10:08'!commit	"Commit the modified packages."	^ self execute: GoferCommit! !!Gofer methodsFor: 'operations' stamp: 'lr 11/10/2009 10:08'!commit: aString	"Commit the modified packages with the given commit message."	^ self execute: GoferCommit do: [ :operation | operation message: aString ]! !!Gofer methodsFor: 'repositories-places' stamp: 'lr 7/10/2009 16:27'!croquet: aString	self url: 'http://hedgehog.software.umn.edu:8888/' , aString! !!Gofer methodsFor: 'repositories' stamp: 'TestRunner 1/11/2010 22:57'!directory: aDirectoryOrString	"Add a file-system repository at aDirectoryOrString."		| repository |	repository := (aDirectoryOrString isString and: [ aDirectoryOrString endsWith: '*' ])		ifTrue: [ 			(Smalltalk 				at: #MCSubDirectoryRepository				ifAbsent: [ self error: aDirectoryOrString printString , ' is an unsupported repository type' ]) new					directory: (FileDirectory on: aDirectoryOrString allButLast);					yourself ]		ifFalse: [			MCDirectoryRepository new				directory: (aDirectoryOrString isString					ifTrue: [ FileDirectory on: aDirectoryOrString ]					ifFalse: [ aDirectoryOrString ]);				yourself ].	self repository: repository! !!Gofer methodsFor: 'repositories-options' stamp: 'lr 12/13/2009 16:33'!disablePackageCache	"Disable the use of the package-cache repository."	packageCacheRepository := nil! !!Gofer methodsFor: 'repositories-options' stamp: 'lr 12/13/2009 16:32'!disableRepositoryErrors	"Silently swallow all repository errors."	errorBlock := [ :error | error resume: #() ]! !!Gofer methodsFor: 'repositories-options' stamp: 'lr 12/13/2009 16:33'!enablePackageCache	"Enable the use of the package-cache repository."	packageCacheRepository := MCCacheRepository default! !!Gofer methodsFor: 'repositories-options' stamp: 'lr 12/13/2009 16:32'!enableRepositoryErrors	"Throw an exception when repositories are not available."	errorBlock := [ :error | error pass ]! !!Gofer methodsFor: 'private' stamp: 'lr 10/2/2009 10:11'!execute: anOperationClass	^ self execute: anOperationClass do: nil! !!Gofer methodsFor: 'private' stamp: 'lr 12/13/2009 16:43'!execute: anOperationClass do: aBlock	| operation result |	operation := anOperationClass on: self copy.	aBlock isNil		ifFalse: [ aBlock value: operation ].	^ operation execute! !!Gofer methodsFor: 'operations' stamp: 'lr 12/3/2009 21:06'!fetch	"Download versions from remote repositories into the local cache."	^ self execute: GoferFetch! !!Gofer methodsFor: 'repositories-places' stamp: 'dkh 10/16/2009 10:04'!gemsource: aString	self url: 'http://seaside.gemstone.com/ss/' , aString! !!Gofer methodsFor: 'repositories-places' stamp: 'lr 7/10/2009 16:27'!impara: aString	self url: 'http://source.impara.de/' , aString! !!Gofer methodsFor: 'initialization' stamp: 'lr 12/13/2009 16:33'!initialize	self enablePackageCache; enableRepositoryErrors.	references := OrderedCollection new.	repositories := OrderedCollection new! !!Gofer methodsFor: 'operations' stamp: 'lr 11/30/2009 14:17'!load	"Load the specified packages into the image."		^ self execute: GoferLoad! !!Gofer methodsFor: 'operations' stamp: 'lr 12/14/2009 23:51'!localChanges	"Answer the changes between the base version and the working copy."		^ self execute: GoferLocalChanges! !!Gofer methodsFor: 'operations' stamp: 'lr 11/10/2009 10:06'!merge	"Merge the specified packages into their working copies."		^ self execute: GoferMerge! !!Gofer methodsFor: 'references' stamp: 'lr 12/13/2009 13:25'!package: aString	"Add the package aString to the receiver."	references addLast: (GoferPackageReference name: aString)! !!Gofer methodsFor: 'references' stamp: 'lr 12/13/2009 13:25'!package: aString constraint: aOneArgumentBlock	"Add the package aString to the receiver, constraint the resulting versions further with aOneArgumentBlock."	references addLast: (GoferConstraintReference name: aString constraint: aOneArgumentBlock)! !!Gofer methodsFor: 'copying' stamp: 'lr 12/13/2009 16:52'!postCopy	references := references copy.	repositories := repositories copy.	resolvedReferencesCache := nil! !!Gofer methodsFor: 'operations' stamp: 'lr 12/3/2009 21:06'!push	"Upload local versions from local cache into remote repositories."	^ self execute: GoferPush! !!Gofer methodsFor: 'operations' stamp: 'lr 8/20/2009 11:44'!recompile	"Recompile the specified packages."	^ self execute: GoferRecompile! !!Gofer methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:18'!references	"Answer the configured references."	^ Array withAll: references! !!Gofer methodsFor: 'operations' stamp: 'lr 12/30/2009 11:27'!reinitialize	"Calls the class side initializers on all package code."		^ self execute: GoferReinitialize! !!Gofer methodsFor: 'operations' stamp: 'lr 12/12/2009 12:49'!remoteChanges	"Display the changes between the working copy and the remote changes."		^ self execute: GoferRemoteChanges! !!Gofer methodsFor: 'repositories-places' stamp: 'lr 7/10/2009 16:25'!renggli: aString	self url: 'http://source.lukas-renggli.ch/' , aString! !!Gofer methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:18'!repositories	"Answer the configured monticello repositories."	|  result |	result := OrderedCollection withAll: repositories.	packageCacheRepository isNil		ifFalse: [ result addFirst: packageCacheRepository ].	^ result asArray! !!Gofer methodsFor: 'repositories' stamp: 'lr 1/11/2010 10:34'!repository: aRepository	"Add aRepository to the repository configuration. If there is already a repository defined in the global configuration with that URL take this one instead."		| repository |	repository := MCRepositoryGroup default repositories		detect: [ :each | each = aRepository ]		ifNone: [ aRepository ].	repositories addLast: repository! !!Gofer methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:14'!resolved	"Answer the resolved references of the receiver."	^ self references collect: [ :each | each resolveWith: self ]! !!Gofer methodsFor: 'operations' stamp: 'lr 8/20/2009 10:15'!revert	"Revert the specified packages to the currently loaded version."		^ self execute: GoferRevert! !!Gofer methodsFor: 'repositories-places' stamp: 'lr 7/10/2009 16:29'!saltypickle: aString	self url: 'http://squeak.saltypickle.com/' , aString! !!Gofer methodsFor: 'repositories-places' stamp: 'lr 7/10/2009 16:28'!squeakfoundation: aString	self url: 'http://source.squeakfoundation.org/' , aString! !!Gofer methodsFor: 'repositories-places' stamp: 'lr 7/10/2009 16:28'!squeaksource: aString	self url: 'http://www.squeaksource.com/' , aString! !!Gofer methodsFor: 'operations' stamp: 'lr 11/10/2009 10:07'!unload	"Unload the specified packages."		^ self execute: GoferUnload! !!Gofer methodsFor: 'operations' stamp: 'lr 9/18/2009 18:12'!update	"Update the specified packages."		^ self execute: GoferUpdate! !!Gofer methodsFor: 'repositories' stamp: 'lr 12/9/2009 22:17'!url: anUrlString	"Add anUrlString as a repository for the following package operations."	self url: anUrlString username: String new password: String new! !!Gofer methodsFor: 'repositories' stamp: 'lr 1/11/2010 22:41'!url: anUrlString username: aUsernameString password: aPasswordString	"Add anUrlString as a repository for the following package operations."	| repository |	repository := (anUrlString beginsWith: 'ftp://')		ifTrue: [			(Smalltalk 				at: #MCFtpRepository 				ifAbsent: [ self error: anUrlString printString , ' is an unsupported repository type' ])					host:  ((anUrlString allButFirst: 6) copyUpTo: $/)					directory: ((anUrlString allButFirst: 6) copyAfter: $/)					user: aUsernameString					password: aPasswordString ]		ifFalse: [ 			MCHttpRepository				location: anUrlString				user: aUsernameString				password: aPasswordString ].	self repository: repository! !!Gofer methodsFor: 'references' stamp: 'lr 12/13/2009 13:25'!version: aString	"Add the version aString to the receiver."	references addLast: (GoferVersionReference name: aString)! !!Gofer methodsFor: 'repositories-places' stamp: 'lr 7/10/2009 16:26'!wiresong: aString	self url: 'http://source.wiresong.ca/' , aString! !!GoferLoad methodsFor: 'private' stamp: 'lr 12/18/2009 12:56'!addResolved: aResolvedReference	| version reference |	version := aResolvedReference version.	(self versions includes: version)		ifTrue: [ ^ self ].	self versions addLast: version.	version dependencies do: [ :dependency |		self addResolved: (GoferResolvedReference			name: dependency versionInfo name			repository: aResolvedReference repository) ]! !!GoferLoad methodsFor: 'private' stamp: 'lr 9/3/2009 11:00'!defaultModel	^ MCVersionLoader new! !!GoferLoad methodsFor: 'running' stamp: 'dkh 10/12/2009 12:56'!execute	self model goferHasVersions		ifTrue: [ self model load ].	self updateRepositories.	self updateCategories! !!GoferLoad methodsFor: 'initialization' stamp: 'TestRunner 12/13/2009 14:49'!initializeOn: aGofer	super initializeOn: aGofer.	aGofer resolved		do: [ :each | self addResolved: each ]		displayingProgress: 'Loading Versions'! !!GoferLoad methodsFor: 'private' stamp: 'lr 12/18/2009 12:55'!updateCategories	"This method makes sure that the categories are ordered in load-order and as specified in the packages."	| categories |	categories := OrderedCollection new.	self versions do: [ :version |		version snapshot definitions do: [ :definition |			definition isOrganizationDefinition ifTrue: [				definition categories do: [ :category |					(categories includes: category)						ifFalse: [ categories addLast: category ] ] ] ] ].	(MCOrganizationDefinition categories: categories)		postloadOver: nil! !!GoferLoad methodsFor: 'private' stamp: 'lr 12/18/2009 12:55'!updateRepositories	"This code makes sure that all packages have a repository assigned, including the dependencies."	self versions do: [ :version |		gofer repositories do: [ :repository | 			version workingCopy repositoryGroup				addRepository: repository ] ]! !!GoferLoad methodsFor: 'accessing' stamp: 'lr 12/18/2009 12:55'!versions	^ model goferVersions! !!GoferOperation class methodsFor: 'instance creation' stamp: 'TestRunner 12/12/2009 11:09'!new	self error: 'Gofer operations can only work on Gofer instances.'! !!GoferOperation class methodsFor: 'instance creation' stamp: 'lr 8/20/2009 12:01'!on: aGofer	^ self basicNew initializeOn: aGofer! !!GoferOperation methodsFor: 'private' stamp: 'lr 8/19/2009 14:01'!defaultModel	^ nil! !!GoferOperation methodsFor: 'running' stamp: 'lr 8/17/2009 14:40'!execute	"Execute the receiving action."	self subclassResponsibility! !!GoferOperation methodsFor: 'accessing' stamp: 'lr 10/3/2009 11:38'!gofer	"Answer the Gofer instance that triggered this operation."	^ gofer! !!GoferOperation methodsFor: 'initialization' stamp: 'lr 8/19/2009 14:01'!initialize	model := self defaultModel! !!GoferOperation methodsFor: 'initialization' stamp: 'TestRunner 12/12/2009 11:09'!initializeOn: aGofer	gofer := aGofer.	self initialize! !!GoferOperation methodsFor: 'accessing' stamp: 'lr 8/20/2009 10:13'!model	"Answer the Monticello model of this operation."		^ model! !!GoferFetch methodsFor: 'private' stamp: 'lr 11/30/2009 13:46'!defaultModel	^ Set new! !!GoferFetch methodsFor: 'running' stamp: 'lr 12/13/2009 17:22'!execute	self model		do: [ :reference | self cacheRepository storeVersion: reference version ]		displayingProgress: 'Fetching Versions'! !!GoferFetch methodsFor: 'initialization' stamp: 'TestRunner 12/13/2009 19:56'!initializeOn: aGofer	super initializeOn: aGofer.	self gofer references do: [ :reference |		self gofer allResolved do: [ :resolved |			((reference matches: resolved) and: [ (cacheReferences includes: resolved) not ])				ifTrue: [ self model add: resolved ] ] ]! !!GoferPush methodsFor: 'private' stamp: 'lr 11/30/2009 13:46'!defaultModel	^ OrderedCollection new! !!GoferPush methodsFor: 'running' stamp: 'lr 12/13/2009 17:23'!execute	self model 		do: [ :assocation | assocation value storeVersion: assocation key version ]		displayingProgress: 'Pushing Versions'! !!GoferPush methodsFor: 'initialization' stamp: 'TestRunner 12/13/2009 20:08'!initializeOn: aGofer	super initializeOn: aGofer.	self gofer references do: [ :reference |		cacheReferences do: [ :resolved |			(reference matches: resolved) ifTrue: [				self gofer repositories do: [ :repository |					((self gofer allResolvedIn: repository) includes: resolved)						ifFalse: [ self model add: resolved -> repository ] ] ] ] ]! !!GoferSynchronize methodsFor: 'accessing' stamp: 'lr 12/12/2009 14:29'!cacheRepository	^ MCCacheRepository default! !!GoferSynchronize methodsFor: 'initialization' stamp: 'TestRunner 12/13/2009 19:54'!initializeOn: aGofer	super initializeOn: aGofer disablePackageCache.	MCFileBasedRepository flushAllCaches.	cacheReferences := self gofer allResolvedIn: self cacheRepository! !!GoferChanges methodsFor: 'private' stamp: 'lr 12/12/2009 12:56'!addReference: aReference	super addReference: aReference.	self model operations 		addAll: (self patchsetOf: aReference) operations! !!GoferChanges methodsFor: 'private' stamp: 'lr 8/19/2009 14:02'!defaultModel	^ MCPatch operations: OrderedCollection new! !!GoferChanges methodsFor: 'running' stamp: 'lr 12/14/2009 23:50'!execute	^ self model! !!GoferChanges methodsFor: 'queries' stamp: 'lr 12/12/2009 13:06'!patchsetOf: aReference	"Answer the source snapshot of aReference."		| source target |	source := self sourceSnapshotOf: aReference.	target := self targetSnapshotOf: aReference.	^ target patchRelativeToBase: source! !!GoferChanges methodsFor: 'queries' stamp: 'lr 12/12/2009 13:00'!sourceSnapshotOf: aReference	"Answer the source snapshot of aReference."		self subclassResponsibility! !!GoferChanges methodsFor: 'queries' stamp: 'lr 12/12/2009 12:59'!targetSnapshotOf: aReference	"Answer the source snapshot of aReference."		self subclassResponsibility! !!GoferBrowseLocalChanges methodsFor: 'running' stamp: 'lr 12/14/2009 23:50'!execute	^ super execute browse! !!GoferLocalChanges methodsFor: 'queries' stamp: 'TestRunner 12/13/2009 18:02'!sourceSnapshotOf: aReference	| ancestors reference |	ancestors := aReference workingCopy ancestry ancestors.	ancestors isEmpty ifTrue: [ ^ MCSnapshot new ].	reference := GoferVersionReference name: ancestors first name.	^ (reference resolveWith: self gofer) version snapshot! !!GoferLocalChanges methodsFor: 'queries' stamp: 'lr 12/12/2009 13:01'!targetSnapshotOf: aReference	^ aReference workingCopy package snapshot! !!GoferBrowseRemoteChanges methodsFor: 'running' stamp: 'lr 12/14/2009 23:50'!execute	^ super execute browse! !!GoferRemoteChanges methodsFor: 'queries' stamp: 'lr 12/12/2009 13:00'!sourceSnapshotOf: aReference	^ aReference workingCopy package snapshot! !!GoferRemoteChanges methodsFor: 'private' stamp: 'TestRunner 12/13/2009 19:27'!targetSnapshotOf: aReference	^ (aReference resolveWith: self gofer) version snapshot! !!GoferCleanup methodsFor: 'cleaning' stamp: 'lr 10/3/2009 11:37'!cleanup: aWorkingCopy	self cleanupCategories: aWorkingCopy.	self cleanupProtocols: aWorkingCopy! !!GoferCleanup methodsFor: 'cleaning' stamp: 'dkh 10/12/2009 12:59'!cleanupCategories: aWorkingCopy	aWorkingCopy packageInfo systemCategories do: [ :category |		(SystemOrganization goferClassesInCategory: category) isEmpty			ifTrue: [ SystemOrganization removeSystemCategory: category ] ]! !!GoferCleanup methodsFor: 'cleaning' stamp: 'lr 10/3/2009 11:37'!cleanupProtocols: aWorkingCopy	aWorkingCopy packageInfo extensionClasses do: [ :class |		(aWorkingCopy packageInfo extensionCategoriesForClass: class) do: [ :category |			(class organization listAtCategoryNamed: category) isEmpty				ifTrue: [ class organization removeCategory: category ] ] ].	aWorkingCopy packageInfo classesAndMetaClasses do: [ :class |		(aWorkingCopy packageInfo coreCategoriesForClass: class) do: [ :category |			(class organization listAtCategoryNamed: category) isEmpty				ifTrue: [ class organization removeCategory: category ] ] ]! !!GoferCleanup methodsFor: 'running' stamp: 'lr 10/3/2009 11:30'!execute	self workingCopies		do: [ :each | self cleanup: each ]! !!GoferCommit methodsFor: 'running' stamp: 'lr 12/13/2009 18:44'!execute	self workingCopies 		do: [ :each | self execute: each ]! !!GoferCommit methodsFor: 'running' stamp: 'lr 12/27/2009 17:21'!execute: aWorkingCopy	| repositories version |	repositories := self gofer repositories		reject: [ :repository | (aWorkingCopy changesRelativeToRepository: repository) isEmpty ].	repositories isEmpty		ifTrue: [ ^ self ].	version := [ aWorkingCopy newVersion ]		on: MCVersionNameAndMessageRequest		do: [ :notifcation |			self message isNil				ifTrue: [ message := notifcation outer last ].			notifcation resume: (Array with: notifcation suggestedName with: self message) ].	self gofer repositories		do: [ :repository | repository storeVersion: version ]! !!GoferCommit methodsFor: 'running' stamp: 'lr 12/13/2009 19:20'!initializeOn: aGofer	super initializeOn: aGofer disablePackageCache! !!GoferCommit methodsFor: 'accessing' stamp: 'lr 10/2/2009 10:12'!message	^ message! !!GoferCommit methodsFor: 'accessing' stamp: 'lr 10/2/2009 10:12'!message: aString	message := aString! !!GoferRecompile methodsFor: 'running' stamp: 'lr 12/13/2009 19:12'!execute	self workingCopies		do: [ :each | self execute: each ]! !!GoferRecompile methodsFor: 'running' stamp: 'lr 12/13/2009 19:12'!execute: aWorkingCopy	aWorkingCopy packageInfo methods		do: [ :each | each actualClass recompile: each methodSymbol ]! !!GoferReinitialize methodsFor: 'running' stamp: 'lr 12/30/2009 11:14'!execute	self workingCopies		do: [ :each | self execute: each ]! !!GoferReinitialize methodsFor: 'running' stamp: 'lr 12/30/2009 11:26'!execute: aWorkingCopy	aWorkingCopy packageInfo methods do: [ :each |		(each classIsMeta and: [ each selector = #initialize ])			ifTrue: [ each actualClass theNonMetaClass initialize ] ]! !!GoferUnload methodsFor: 'private' stamp: 'dkh 12/15/2009 11:35'!defaultModel	^ (Smalltalk at: #MCMultiPackageLoader ifAbsent: [ MCPackageLoader ]) new! !!GoferUnload methodsFor: 'running' stamp: 'lr 10/3/2009 11:45'!execute	self workingCopies 		do: [ :copy | self unload: copy ].	self model load.	self gofer cleanup.	self workingCopies 		do: [ :copy | self unregister: copy ]! !!GoferUnload methodsFor: 'unloading' stamp: 'lr 10/3/2009 11:46'!unload: aWorkingCopy	self unloadClasses: aWorkingCopy.	self unloadPackage: aWorkingCopy! !!GoferUnload methodsFor: 'unloading' stamp: 'lr 12/30/2009 11:27'!unloadClasses: aWorkingCopy	aWorkingCopy packageInfo methods do: [ :each |		(each classIsMeta and: [ each selector = #unload ])			ifTrue: [ each actualClass theNonMetaClass unload ] ]! !!GoferUnload methodsFor: 'unloading' stamp: 'lr 8/19/2009 14:00'!unloadPackage: aWorkingCopy	self model unloadPackage: aWorkingCopy package! !!GoferUnload methodsFor: 'unregistering' stamp: 'lr 8/19/2009 13:49'!unregister: aWorkingCopy	self unregisterWorkingCopy: aWorkingCopy.	self unregisterRepositories: aWorkingCopy.	self unregisterPackageInfo: aWorkingCopy! !!GoferUnload methodsFor: 'unregistering' stamp: 'lr 8/19/2009 13:50'!unregisterPackageInfo: aWorkingCopy	PackageOrganizer default		unregisterPackage: aWorkingCopy packageInfo! !!GoferUnload methodsFor: 'unregistering' stamp: 'lr 8/19/2009 13:50'!unregisterRepositories: aWorkingCopy	aWorkingCopy repositoryGroup repositories allButFirst do: [ :repository |		MCWorkingCopy allManagers do: [ :copy |			(copy repositoryGroup includes: repository)				ifTrue: [ ^ self ] ].		MCRepositoryGroup default			removeRepository: repository ]! !!GoferUnload methodsFor: 'unregistering' stamp: 'lr 8/20/2009 11:54'!unregisterWorkingCopy: aWorkingCopy	aWorkingCopy unregister! !!GoferMerge methodsFor: 'private' stamp: 'lr 8/19/2009 14:01'!defaultModel	^ MCVersionMerger new! !!GoferMerge methodsFor: 'running' stamp: 'lr 10/3/2009 11:39'!execute	[ [ self model merge ]		on: MCMergeResolutionRequest		do: [ :request |			request merger conflicts isEmpty				ifTrue: [ request resume: true ]				ifFalse: [ request pass ] ] ]		valueSupplyingAnswers: #(('No Changes' true)).	self gofer cleanup! !!GoferRevert methodsFor: 'running' stamp: 'lr 9/19/2009 13:15'!execute	self workingCopies		do: [ :each | each modified: false ].	super execute! !!GoferRevert methodsFor: 'private' stamp: 'TestRunner 12/13/2009 18:09'!referenceFor: aReference	| ancestors reference |	ancestors := aReference workingCopy ancestry ancestors.	ancestors isEmpty ifTrue: [ ^ MCSnapshot new ].	^ GoferVersionReference name: ancestors first name! !!GoferUpdate methodsFor: 'private' stamp: 'TestRunner 12/13/2009 18:09'!addReference: aReference	super addReference: aReference.	self model addVersion: ((self referenceFor: aReference)		 resolveWith: self gofer) version! !!GoferUpdate methodsFor: 'private' stamp: 'lr 9/18/2009 18:13'!defaultModel	^ MCVersionLoader new! !!GoferUpdate methodsFor: 'running' stamp: 'dkh 10/12/2009 12:55'!execute	self model goferHasVersions		ifTrue: [ self model load ].	self gofer cleanup! !!GoferUpdate methodsFor: 'private' stamp: 'TestRunner 12/13/2009 18:08'!referenceFor: aReference	^ aReference! !!GoferWorking methodsFor: 'private' stamp: 'lr 12/18/2009 20:56'!addReference: aReference	| workingCopy |	workingCopy := aReference workingCopy.	(self workingCopies includes: workingCopy)		ifTrue: [ ^ self ].	self workingCopies addLast: workingCopy.	workingCopy requiredPackages do: [ :package |		self addReference: (GoferPackageReference			name: package name) ]! !!GoferWorking methodsFor: 'initialization' stamp: 'lr 8/19/2009 13:14'!initialize	super initialize.	workingCopies := OrderedCollection new! !!GoferWorking methodsFor: 'initialization' stamp: 'lr 12/13/2009 19:16'!initializeOn: aGofer	super initializeOn: aGofer.	aGofer references 		do: [ :each | self addReference: each ]! !!GoferWorking methodsFor: 'accessing' stamp: 'lr 9/24/2009 16:55'!workingCopies	"Answer the working copies to be operated on."	^ workingCopies! !!GoferConstraintReference class methodsFor: 'instance creation' stamp: 'lr 12/9/2009 22:44'!name: aString constraint: aBlock	^ self basicNew initializeName: aString constraint: aBlock! !!GoferConstraintReference methodsFor: 'initialization' stamp: 'TestRunner 12/12/2009 00:18'!initializeName: aString constraint: aBlock	self initializeName: aString.	constraintBlock := aBlock! !!GoferConstraintReference methodsFor: 'private' stamp: 'lr 12/11/2009 22:14'!matches: aLoadableReference	^ (super matches: aLoadableReference) and: [ constraintBlock value: aLoadableReference ]! !!GoferPackageReference methodsFor: 'private' stamp: 'lr 12/13/2009 17:10'!matches: aLoadableReference	^ self packageName = aLoadableReference packageName! !!GoferPackageReference methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:12'!packageName	^ name! !!GoferReference class methodsFor: 'instance creation' stamp: 'lr 12/9/2009 22:42'!name: aString	^ self basicNew initializeName: aString! !!GoferReference class methodsFor: 'instance creation' stamp: 'lr 12/9/2009 22:42'!new	self error: 'Use #name: to initialize the receiver.'! !!GoferReference methodsFor: 'comparing' stamp: 'lr 12/12/2009 13:33'!= aReference	^ self class = aReference class and: [ self name = aReference name ]! !!GoferReference methodsFor: 'comparing' stamp: 'lr 12/12/2009 13:33'!hash	^ self name hash! !!GoferReference methodsFor: 'initialization' stamp: 'lr 12/9/2009 22:57'!initializeName: aString	name := aString! !!GoferReference methodsFor: 'private' stamp: 'lr 12/11/2009 22:13'!matches: aLoadableReference	"Answer true if the receiver matches aLoadableReference."	self subclassResponsibility! !!GoferReference methodsFor: 'accessing' stamp: 'lr 12/11/2009 22:02'!name	"Answer the name of this reference."		^ name! !!GoferReference methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:09'!packageName	"Answer the package name."		self subclassResponsibility! !!GoferReference methodsFor: 'printing' stamp: 'lr 12/11/2009 22:02'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' name: '; print: self name! !!GoferReference methodsFor: 'querying' stamp: 'lr 12/13/2009 17:20'!resolveAllWith: aGofer	"Answer a sorted collection of all resolved references within aGofer."	^ aGofer allResolved select: [ :each | self matches: each ]! !!GoferReference methodsFor: 'querying' stamp: 'lr 12/13/2009 17:20'!resolveWith: aGofer	"Answer a single resolved reference with aGofer configuration, throw an error if the version can't be found.'"	| references |	references := self resolveAllWith: aGofer.	^ references isEmpty		ifTrue: [ self error: 'Unable to resolve ' , self name ]		ifFalse: [ references last ]! !!GoferReference methodsFor: 'querying' stamp: 'lr 12/13/2009 17:10'!workingCopy	"Answer a working copy or throw an error if not present."	^ MCWorkingCopy allManagers		detect: [ :each | self packageName = each packageName ]		ifNone: [ self error: 'Working copy for ' , self name , ' not found' ]! !!GoferResolvedReference class methodsFor: 'instance creation' stamp: 'lr 12/9/2009 22:55'!name: aString repository: aRepository	^ self basicNew initializeName: aString repository: aRepository! !!GoferResolvedReference methodsFor: 'comparing' stamp: 'lr 12/13/2009 17:22'!<= aLoadableReference	"Sort versions according to:		1. package name		2. branch name, list versions without branch last		3. version number		4. author name		5. repository priority"		self packageName = aLoadableReference packageName		ifFalse: [ ^ self packageName <= aLoadableReference packageName ].	self branch = aLoadableReference branch ifFalse: [ 		^ (self branch isEmpty or: [ aLoadableReference branch isEmpty ])			ifTrue: [ self branch size > aLoadableReference branch size ]			ifFalse: [ self branch <= aLoadableReference branch ] ].	self versionNumber = aLoadableReference versionNumber		ifFalse: [ ^ self versionNumber <= aLoadableReference versionNumber ].	self author = aLoadableReference author		ifFalse: [ ^ self author <= aLoadableReference author ].	self repository goferPriority = aLoadableReference repository goferPriority		ifFalse: [ ^ self repository goferPriority > aLoadableReference repository goferPriority ].	^ true! !!GoferResolvedReference methodsFor: 'initialization' stamp: 'lr 12/9/2009 22:55'!initializeName: aString repository: aRepository	self initializeName: aString.	repository := aRepository! !!GoferResolvedReference methodsFor: 'accessing' stamp: 'lr 12/11/2009 22:33'!repository	"Answer the repository of the receiver."		^ repository! !!GoferResolvedReference methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:22'!version	"Answer a Monticello version of the receiver."	^ self repository goferVersionFrom: self! !!GoferVersionReference methodsFor: 'accessing' stamp: 'lr 12/11/2009 22:22'!author	"Answer the author of the receiver."		^ author! !!GoferVersionReference methodsFor: 'accessing' stamp: 'lr 12/11/2009 22:23'!branch	"Answer the branch of the receiver."		^ branch! !!GoferVersionReference methodsFor: 'initialization' stamp: 'lr 12/11/2009 22:17'!initializeName: aString	super initializeName: aString.	self parseName: aString! !!GoferVersionReference methodsFor: 'private' stamp: 'lr 12/11/2009 22:14'!matches: aLoadableReference	^ self name = aLoadableReference name! !!GoferVersionReference methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:12'!packageName	"Answer the package of the receiver."	^ package! !!GoferVersionReference methodsFor: 'initialization' stamp: 'lr 12/13/2009 17:20'!parseName: aString	| basicName |	basicName := aString last isDigit		ifTrue: [ aString ]		ifFalse: [ (aString copyUpToLast: $.) copyUpTo: $( ].	package := basicName copyUpToLast: $-.	author := (basicName copyAfterLast: $-) copyUpTo: $..	versionNumber := (basicName copyAfterLast: $-) copyAfter: $..	versionNumber isEmpty 		ifTrue: [ 			branch := ''.			versionNumber := 0 ]		ifFalse: [ 			(versionNumber allSatisfy: [ :each | each isDigit ]) 				ifTrue: [					branch := ''.					versionNumber := versionNumber asInteger ]				ifFalse: [					branch := versionNumber copyUpToLast: $..					versionNumber := (versionNumber copyAfterLast: $.) asInteger ] ]! !!GoferVersionReference methodsFor: 'accessing' stamp: 'lr 12/13/2009 17:20'!versionNumber	"Answer the version of the receiver."	^ versionNumber! !!SystemOrganizer methodsFor: '*gofer-core-accessing' stamp: 'lr 12/3/2009 21:04'!goferClassesInCategory: category		^ (self listAtCategoryNamed: category) collect: [ :className | Smalltalk at: className ]! !!MCFileBasedRepository methodsFor: '*gofer-core-accessing' stamp: 'TestRunner 12/12/2009 11:12'!goferReferences	| versionNames |	versionNames := [ self allVersionNames ]		on: Error		do: [ :error | ^ GoferRepositoryError signal: error messageText repository: self ].	^ versionNames		collect: [ :each | GoferResolvedReference name: each repository: self ]! !!MCFileBasedRepository methodsFor: '*gofer-core-accessing' stamp: 'lr 12/12/2009 11:29'!goferVersionFrom: aVersionReference	^ self loadVersionFromFileNamed: aVersionReference name , '.mcz'! !!MCRepository methodsFor: '*gofer-core-accessing' stamp: 'lr 12/11/2009 22:31'!goferPriority	^ 0! !!MCRepository methodsFor: '*gofer-core-accessing' stamp: 'lr 12/9/2009 20:50'!goferReferences	^ #()! !!MCRepository methodsFor: '*gofer-core-accessing' stamp: 'lr 12/12/2009 11:29'!goferVersionFrom: aVersionReference	self error: 'Unable to load from ' , self printString! !"Gofer-Core"!SystemOrganization addCategory: #ConfigurationOfMetacello!Object subclass: #ConfigurationOfMetacello	instanceVariableNames: 'project'	classVariableNames: 'LastVersionLoad'	poolDictionaries: ''	category: 'ConfigurationOfMetacello'!!ConfigurationOfMetacello class methodsFor: 'deprecated' stamp: 'dkh 6/12/2012 09:37:55.692'!alternateEnsureMetacello	"Use this method if the primary repository 'http://seaside.gemstone.com/ss/metacello' is inaccessible.	 Secondary repository is valid for loading versions 1.0-beta.26 and later. "	self deprecated: 'current version of #ensureMetacello automatically tries to load using alternate repository'.	Smalltalk at: #MetacelloProject  ifAbsent: [  		self ensureGoferVersion: 'Gofer-Core-lr.115'.		Smalltalk at: #Gofer ifPresent: [:goferClass | | gofer version repo |			gofer := goferClass new				url: 'http://www.squeaksource.com/metacello';				version: 'Metacello-Core-DaleHenrichs.348';				version: 'Metacello-MC-DaleHenrichs.332';				yourself.			Smalltalk at: #SystemVersion ifPresent: [:cl | | versionString  |				versionString := cl current version.				(versionString beginsWith: 'Squeak3')					ifTrue: [ gofer version: 'Metacello-Platform.squeak-dkh.5']].			gofer load.			"now load minimal installation from alternate repository"			version := self project latestVersion.			repo := MCHttpRepository 				location: 'http://www.squeaksource.com/metacello' 				user: '' 				password: ''.			(version repositoryOverrides: (Array with: (repo))) load ]]! !!ConfigurationOfMetacello class methodsFor: 'metacello release process' stamp: 'dkh 6/12/2012 09:37:55.692'!backupToSqueakSource	"In order for username and password to be set correctly, you must already have the metacello repository	 set up"	| cacheRepository version |	cacheRepository := MCHttpRepository location: 'http://www.squeaksource.com/metacello' user: '' password: ''.	"need to pick up existing repository with user and password set"	cacheRepository := MCRepositoryGroup default repositories		detect: [ :each | each = cacheRepository ]		ifNone: [ cacheRepository ].	version := self project latestVersion.	version ignoreImage: true.	(version record: 'ALL') loadDirective		versionDirectivesDo: [ :versionDirective | 			| p pClass |			versionDirective spec ~~ nil				ifTrue: [ 					p := versionDirective spec project.					pClass := p configuration class.	"save packages for Gofer and Metacello only"					(pClass == (Smalltalk at: #ConfigurationOfGofer) or: [ pClass == self ])						ifTrue: [ 							| policy |							policy := ((Smalltalk at: #MetacelloLoaderPolicy) new)								cacheRepository: cacheRepository;								ignoreImage: true;								yourself.	"fetch Gofer or Metacello configuration"							p fetchProject: policy.							versionDirective								packagesDo: [ :packageDirective | 									"skip nested configurations"									(packageDirective spec name beginsWith: 'ConfigurationOf')										ifFalse: [ 											"fetch mcz file"											packageDirective spec fetchPackage: policy ] ] ] ] ]					! !!ConfigurationOfMetacello class methodsFor: 'private' stamp: 'dkh 9/14/2012 15:23'!bootstrapMetacelloFrom: repositoryUrl    "Corresponds to version 1.0-beta.31.1.5"    | minimumPackages |    self ensureGoferVersion: 'Gofer-Core-lr.115' repositoryUrl: repositoryUrl.    minimumPackages := OrderedCollection        withAll: #('Metacello-Base-DaleHenrichs.19' 'Metacello-Core-dkh.492' 'Metacello-MC-dkh.664').    self platformPackage ifNotNil: [ :pkg | minimumPackages add: pkg ].    minimumPackages do: [ :pkg | self bootstrapPackage: pkg from: repositoryUrl ]! !!ConfigurationOfMetacello class methodsFor: 'private' stamp: 'dkh 6/12/2012 09:37:55.692'!bootstrapPackage: aString from: aPath 	| repository version |	repository := (MCCacheRepository default includesVersionNamed: aString)		ifTrue: [MCCacheRepository default]		ifFalse: [MCHttpRepository				location: aPath				user: ''				password: ''].	repository		versionReaderForFileNamed: aString , '.mcz'		do: [:reader | 			version := reader version.			version load.			version workingCopy repositoryGroup addRepository: repository]! !!ConfigurationOfMetacello class methodsFor: 'metacello release process' stamp: 'dkh 6/12/2012 09:37:55.692'!copyConfigToRepos	"In order for username and password to be set correctly, you must already have the MetacelloRepository	 (on GemSource) repository set up"	| targetRepository1 targetRepository2 gofer version |	targetRepository1 := MCHttpRepository location: 'http://www.squeaksource.com/MetacelloRepository' user: '' password: ''.	targetRepository2 := MCHttpRepository location: 'http://seaside.gemstone.com/ss/MetacelloRepository' user: '' password: ''.	"need to pick up existing repository with user and password set"	targetRepository2 := MCRepositoryGroup default repositories		detect: [ :each | each = targetRepository2 ]		ifNone: [ targetRepository2 ].	gofer := (Smalltalk at: #Gofer) new		gemsource: 'metacello';		package: 'ConfigurationOfMetacello'.	version := gofer resolved first version.	(Array with: targetRepository1 with: targetRepository2) do: [:repo | repo storeVersion: version ]! !!ConfigurationOfMetacello class methodsFor: 'private' stamp: 'dkh 6/12/2012 09:37:55.692'!ensureCoreMetacello    "Bootstrap Metacello and load the minimum support"    self ensureMetacello: #('Metacello-Core')! !!ConfigurationOfMetacello class methodsFor: 'deprecated' stamp: 'dkh 06/29/2013 09:47'!ensureGoferVersion: goferVersion  "load the p=file goferVersion if Gofer isn't loaded or an earlier version of Gofer is currently loaded"  | goferVersionNumber goferRepository wc pName |  self deprecated: 'Use #ensureGoferVersion:repositoryUrl: instead ... '.  goferRepository := 'http://seaside.gemtalksystems.com/ss/metacello'.  (Smalltalk at: #'Gofer' ifAbsent: [  ]) == nil    ifTrue: [ ^ self bootstrapPackage: goferVersion from: goferRepository ].  goferVersionNumber := (goferVersion copyAfterLast: $.) asNumber.  wc := [ ((Smalltalk at: #'GoferPackageReference') name: 'Gofer') workingCopy ]    on: Error    do: [ :ex |       ex        return:          ((Smalltalk at: #'GoferPackageReference') name: 'Gofer-Core') workingCopy ].  pName := wc ancestry ancestors first name.  (pName copyAfterLast: $.) asNumber <= goferVersionNumber    ifTrue: [ self bootstrapPackage: goferVersion from: goferRepository ]! !!ConfigurationOfMetacello class methodsFor: 'private' stamp: 'dkh 6/12/2012 09:37:55.692'!ensureGoferVersion: goferVersion repositoryUrl: repositoryUrl	"load the p=file goferVersion if Gofer isn't loaded or an earlier version of Gofer is currently loaded"		 | goferVersionNumber wc pName |	(Smalltalk at: #Gofer ifAbsent: []) == nil		ifTrue: [ ^self bootstrapPackage: goferVersion from: repositoryUrl ].	goferVersionNumber := (goferVersion copyAfterLast: $.) asNumber.	wc := [ ((Smalltalk at: #GoferPackageReference) name: 'Gofer') workingCopy ]			on: Error			do: [:ex | ex return: ((Smalltalk at: #GoferPackageReference) name: 'Gofer-Core') workingCopy ].	pName := wc ancestry ancestors first name.	(pName copyAfterLast: $.) asNumber <= goferVersionNumber		ifTrue: [ self bootstrapPackage: goferVersion from: repositoryUrl ]! !!ConfigurationOfMetacello class methodsFor: 'private' stamp: 'SeanDeNigris 6/22/2012 11:38'!ensureMetacello    "Bootstrap Metacello and load the 'default' group"    self ensureMetacello: #('batch')! !!ConfigurationOfMetacello class methodsFor: 'private' stamp: 'dkh 06/29/2013 09:46'!ensureMetacello: loadList  "Bootstrap Metacello, retry using alternate repository, if primary repository is not accessible"  Smalltalk    at: #'MetacelloProject'    ifAbsent: [       | retry version error |      retry := false.      (Array        with: 'http://seaside.gemtalksystems.com/ss/metacello'        with: 'http://smalltalkhub.com/mc/dkh/metacello/main')        do: [ :repositoryUrl |           [           "bootstrap Metacello"          self bootstrapMetacelloFrom: repositoryUrl.	"load latest version of Metacello"          version := self project latestVersion.          retry            ifTrue: [               "on retry, use #repositoryOverrides:"              version                repositoryOverrides:                  (Array with: (MCHttpRepository location: repositoryUrl user: '' password: '')) ].          version load: loadList.          ^ self ]            on: Error            do: [ :ex |               error := ex.              Transcript                cr;                show: 'failed ensureMetacello: ';                show: ex description printString;                show: '...retrying'.	"try again"              retry := true.              ex return: nil ] ].	"shouldn't get here unless the load failed ... throw an error"      self        error:          'retry with alternate repository failed: ' , error description printString ]! !!ConfigurationOfMetacello class methodsFor: 'help' stamp: 'dkh 6/12/2012 09:37:55.692'!helpGettingStarted	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: 'To get started, install Metacello and see the ''Getting Started'' section in the Metacello chapter of the Help Browser:';		cr; tab; nextPutAll: 'HelpBrowser openOn: ((Smalltalk at: #MetacelloHelp) perform:  #asHelpTopic)';		cr;cr;nextPutAll: 'It is also recommended that you install the Metacello Browser,. For information see';		cr; tab; nextPutAll: 'http://metacellobrowser.dcc.uchile.cl/'.	^ (Smalltalk at: #HelpTopic) perform: #title:contents: with: 'Getting Started' with: stream contents! !!ConfigurationOfMetacello class methodsFor: 'help' stamp: 'dkh 6/12/2012 09:37:55.692'!helpInstallation	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: 'To install the core functionality of Metacello, execute the following expression:';		cr; tab; nextPutAll: 'ConfigurationOfMetacello load.';		cr;cr;nextPutAll: 'To install the tutorial (recommended), execute the following expression:';		cr; tab; nextPutAll: '(ConfigurationOfMetacello project version: #stable) load: #(''Tutorial'').'.	^ (Smalltalk at: #HelpTopic) perform: #title:contents: with: 'Installing' with: stream contents! !!ConfigurationOfMetacello class methodsFor: 'help' stamp: 'dkh 6/12/2012 09:37:55.692'!helpIntro	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: 'Metacello is a package management system for Monticello';		cr;cr;nextPutAll: 'Metacello Browser is written and maintained by:';		cr;tab;nextPutAll: 'Dale Henrichs';		cr;cr;nextPutAll: 'To submit bug reports, visit the following link:';		cr;tab;nextPutAll: 'http://code.google.com/p/metacello/issues/entry';		cr;cr;nextPutAll: 'For additional info see the Metacello project site:';		cr;tab;nextPutAll: 'http://code.google.com/p/metacello/'.	^ (Smalltalk at: #HelpTopic) perform: #title:contents: with: 'Introduction' with: stream contents! !!ConfigurationOfMetacello class methodsFor: 'help' stamp: 'dkh 6/12/2012 09:37:55.692'!helpPages	| pages |	pages := {#helpIntro. #helpInstallation. #helpGettingStarted}.	"include MetacelloHelp if installed"	Smalltalk at: #MetacelloHelp ifPresent: [ :cl | pages :=  pages , {cl} ].	^ pages! !!ConfigurationOfMetacello class methodsFor: 'metacello tool support' stamp: 'dkh 6/12/2012 09:37:55.692'!isMetacelloConfig	^true! !!ConfigurationOfMetacello class methodsFor: 'metacello tool support' stamp: 'dkh 6/12/2012 09:37:55.692'!lastMetacelloVersionLoad	"Answer the last version loaded and the list of packages loaded for that version."	LastVersionLoad == nil ifTrue: [ LastVersionLoad := nil -> 'default' ].	^LastVersionLoad! !!ConfigurationOfMetacello class methodsFor: 'loading' stamp: 'SeanDeNigris 6/27/2012 14:25'!load	"Load a minimum installation of Metacello"	"self load"	^ self project latestVersion load: 'batch'.! !!ConfigurationOfMetacello class methodsFor: 'development support' stamp: 'dkh 6/12/2012 09:37:55.692'!loadLatestPackages	"self loadLatestPackages"	"Note that Metacello 1.0-beta.28 is needed and is currently unstable and in development"	| project |	project := self project.	^(project latestVersion: #baseline) load: #( 'default' 'Metacello-Tutorial')! !!ConfigurationOfMetacello class methodsFor: 'loading' stamp: 'dkh 6/12/2012 09:37:55.692'!loadLatestVersion	"self loadLatestVersion"	self project updateProject.	^self project latestVersion load! !!ConfigurationOfMetacello class methodsFor: 'metacello tool support' stamp: 'dkh 6/12/2012 09:37:55.692'!metacelloVersion: versionString loads: anArrayOrString	"Stash the last version loaded and the list of packages loaded for that version. The list	 of packages will be used by the tools when doing 'Load Package Version'"	LastVersionLoad := versionString -> anArrayOrString! !!ConfigurationOfMetacello class methodsFor: 'deprecated' stamp: 'dkh 6/12/2012 09:37:55.692'!oldEnsureMetacello	"original implementation of ensureMetacello, just in case problems surface."	self deprecated: 'use #ensureMetacello instead'.	Smalltalk at: #MetacelloProject  ifAbsent: [  		self ensureGoferVersion: 'Gofer-Core-lr.115'.		Smalltalk at: #Gofer ifPresent: [:goferClass | | gofer |			gofer := goferClass new				url: 'http://seaside.gemstone.com/ss/metacello';				version: 'Metacello-Core-DaleHenrichs.348';				version: 'Metacello-MC-DaleHenrichs.332';				yourself.			Smalltalk at: #SystemVersion ifPresent: [:cl | | versionString |				versionString := cl current version.				(versionString beginsWith: 'Squeak3')					ifTrue: [ gofer version: 'Metacello-Platform.squeak-dkh.5']].			gofer load.			"now load minimal installation"			self load ]]! !!ConfigurationOfMetacello class methodsFor: 'private' stamp: 'SeanDeNigris 6/27/2012 23:06'!platformPackage	Smalltalk at: #SystemVersion ifPresent: [ :sysVersion | | versionString |		versionString := sysVersion current version.		(versionString beginsWith: 'Squeak') ifTrue: [ 			^ (versionString beginsWith: 'Squeak3')				ifTrue: [ 'Metacello-Platform.squeak-dkh.5' ]				ifFalse: [ 'Metacello-Platform.squeak-dkh.10' ] ].				(versionString beginsWith: 'Pharo') ifTrue: [ 			^ (versionString beginsWith: 'Pharo2')				ifTrue: [ 'Metacello-Platform.pharo20-SeanDeNigris.28' ]				ifFalse: [ 'Metacello-Platform.pharo-dkh.27' ] ] ].	^ nil.! !!ConfigurationOfMetacello class methodsFor: 'accessing' stamp: 'dkh 6/12/2012 09:37:55.692'!project	^self new project! !!ConfigurationOfMetacello class methodsFor: 'development support' stamp: 'dkh 6/12/2012 09:37:55.692'!releaseDevelopmentVersion: commitMessage	"Release #development version: set version blessing to #release, update the #development and #stable symbolic version methods and save the configuration."	"self releaseDevelopmentVersion: '- release version 1.0-beta.28.3'"	<apiDocumentation>	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) releaseDevelopmentVersionIn: self description: commitMessage! !!ConfigurationOfMetacello class methodsFor: 'metacello release process' stamp: 'dkh 6/12/2012 09:37:55.692'!releaseMetacelloVersion	"self releaseMetacelloVersion"		self 		copyConfigToRepos;		backupToSqueakSource;		yourself! !!ConfigurationOfMetacello class methodsFor: 'development support' stamp: 'dkh 6/12/2012 09:37:55.692'!saveModifiedPackagesAndConfiguration: commitMessage	"Save modified mcz files, update and then save the configuration."	"self saveModifiedPackagesAndConfiguration: '- fixed bug'"	"Note that Metacello 1.0-beta.28 is needed and is currently unstable and in development"	<apiDocumentation>	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) saveModifiedPackagesAndConfigurationIn: self description: commitMessage! !!ConfigurationOfMetacello class methodsFor: 'unloading' stamp: 'dkh 6/12/2012 09:37:55.692'!unloadMetacello	| gofer |	gofer := Gofer new.	MCWorkingCopy allManagers do: [:wc |		((wc packageName beginsWith: 'Metacello') or: [ wc packageName beginsWith: 'OB-Metacello' ])			ifTrue: [ gofer package: wc packageName ]].	gofer unload.! !!ConfigurationOfMetacello class methodsFor: 'development support' stamp: 'dkh 6/12/2012 09:37:55.692'!validate    "self validate"    self ensureMetacello.    ^ ((Smalltalk at: #'MetacelloToolBox') validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta00: spec 	<version: '1.0-beta.0-baseline'>		spec for: #common do: [		spec blessing: #baseline.		spec description: 'Default configuration ... loads latest versions of all packages'.		spec repository: 'http://seaside.gemstone.com/ss/metacello'.		spec 			package: 'Gofer' with: [				spec repository: 'http://source.lukas-renggli.ch/flair' ];			package: 'Metacello-Core' with: [				spec includes: #('Metacello-MC' 'Metacello-Platform') ];			package: 'Metacello-MC' with: [				spec requires: #('Gofer') ];			package: 'Metacello-Platform' with: [				spec requires: #('Metacello-MC') ];			package: 'Metacello-ConfigTests' with: [				spec requires: #('Metacello-MC') ];			package: 'Metacello-Reference' with: [				spec requires: #('Metacello-MC') ];			package: 'Metacello-ReferenceTests' with: [				spec requires: #('Metacello-Reference') ];			package: 'OB-Metacello' with: [				spec requires: #('Metacello-Platform') ].		spec			group: 'default' with: #('Metacello-Core' 'Metacello-Reference');			group: 'UI' with: #('Metacello-Core' 'OB-Metacello'); 			group: 'Tests' with: #('Metacello-ConfigTests' 'Metacello-ReferenceTests') ].	spec for: #gemstone do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone'].	spec for: #pharo do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo'].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak' ].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta03: spec 	<version: '1.0-beta.3-baseline' imports: #('1.0-beta.0-baseline')>		spec for: #common do: [		spec blessing: #baseline.		spec description: 'Extensions to 1.0-beta.0-baseline: - ''default'' group is just the core ... class-side loaders load ''ALL'' by default- pull in some old tests that still apply- combine Metacello-ConfigTests into Metacello-TestsMC- rename Metacello-ReferenceTests to Metacello-TestsReference- recast tutorial to new API- add Samples group (Metacello-Configuration [duh] and Seaside-Metacello-Configuration'.		spec 			package: 'Metacello-Tutorial' with: [				spec requires:  #('Metacello-Core'). ];			package: 'Metacello-TestsCore' with: [				spec requires:  #('Metacello-Core'). ];			package: 'Metacello-TestsMC' with: [				spec requires:  #('Metacello-Core'). ];			package: 'Metacello-TestsReference' with: [				spec requires: #('Metacello-Reference') ];			package: 'Metacello-TestsTutorial' with: [				spec requires:  #('Metacello-Tutorial'). ];			removePackage: 'Metacello-ConfigTests';			removePackage: 'Metacello-ReferenceTests';			"SAMPLE"			package: 'ConfigurationOfMetacello' with: [				spec repository: 'http://seaside.gemstone.com/ss/metacello' ];			"SAMPLE"			package: 'Seaside-Metacello-Configuration' with: [				spec repository: 'http://seaside.gemstone.com/ss/Seaside30' ].		spec			group: 'default' overrides: #('Metacello-Core');			group: 'Samples' with: #('ConfigurationOfMetacello' 'Seaside-Metacello-Configuration');			group: 'Tests' overrides: 				#('Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC'				  'Metacello-TestsReference'). ].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta05: spec 	<version: '1.0-beta.5-baseline' imports: #('1.0-beta.3-baseline')>		spec for: #common do: [		spec blessing: #baseline.		spec description: 'Extensions to 1.0-beta.3-baseline: - Samples group includes Seaside-Metacello-Configuration and GemTools-Configuraton (Metacello-Configuration should not be included ... it is always present)'.		spec 			package: 'GemTools-Configuraton' with: [				spec repository: 'http://seaside.gemstone.com/ss/GLASSClient' ];			removePackage: 'ConfigurationOfMetacello'.		spec			group: 'Samples' overrides: 				#('Seaside-Metacello-Configuration' 'GemTools-Configuraton' ) ].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta11: spec 	<version: '1.0-beta.11-baseline' imports: #('1.0-beta.3-baseline')>		spec for: #common do: [		spec blessing: #baseline.		spec description: 'Removing Samples completely... Confusing I think'.		spec 			removePackage: 'Seaside-Metacello-Configuration';			removePackage: 'GemTools-Configuraton';			removePackage: 'ConfigurationOfMetacello'.		spec			removeGroup: 'Samples'].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta13: spec 	<version: '1.0-beta.13-baseline' imports: #('1.0-beta.11-baseline')>		spec for: #common do: [		spec blessing: #baseline.		spec description: 'fix Metacello-MC dependency'.		spec 			package: 'OB-Metacello' with: [				spec requires: #('Metacello-Platform' 'Metacello-Core') ];			yourself].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta14: spec 	<version: '1.0-beta.14-baseline' imports: #('1.0-beta.13-baseline')>		spec for: #common do: [		spec blessing: #baseline.		spec description: 'switch gofer repositories'.		spec 			package: 'Gofer' with: [				spec repository: 'http://source.lukas-renggli.ch/gofer' ];			yourself].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta16: spec 	<version: '1.0-beta.16-baseline' imports: #('1.0-beta.14-baseline')>		spec for: #common do: [		spec blessing: #baseline.		spec description: 'switch gofer repositories again ... use copy in Metacello going forward'.		spec 			package: 'Gofer' with: [				spec repository: 'http://seaside.gemstone.com/ss/metacello' ];			yourself].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta17: spec 	<version: '1.0-beta.17-baseline' imports: #('1.0-beta.16-baseline')>		spec for: #squeakCommon do: [		spec 			package: 'Metacello-TestsPlatform' with: [				spec					requires: #('Metacello-Platform');					file: 'Metacello-TestsPlatform.squeakCommon'];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform')].		! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta18: spec 	<version: '1.0-beta.18-baseline' imports: #('1.0-beta.17-baseline')>		spec for: #gemstone do: [		spec			project: 'Monticello' with: [				spec					className: 'ConfigurationOfGsMonticello';					file: 'ConfigurationOfGsMonticello';					repository: 'http://seaside.gemstone.com/ss/monticello' ];			yourself.		spec 			package: 'Gofer' with: [				spec requires: #('Monticello')];			yourself. ].		! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta19: spec 	<version: '1.0-beta.19-baseline' imports: #('1.0-beta.18-baseline')>	spec for: #'Gofer-Core' do: [		spec			removePackage: 'Gofer';			package: 'Gofer-Core'  with: [				spec repository: 'http://www.squeaksource.com/Pharo' ];			package: 'Gofer-Tests'  with: [				spec repository: 'http://www.squeaksource.com/Pharo' ];			package: 'Metacello-MC' overrides: [				spec requires: #('Gofer-Core') ];			package: 'Metacello-TestsMC' with: [				spec requires: #('Gofer-Tests') ];			yourself ].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta21: spec 	<version: '1.0-beta.21-baseline' imports: #('1.0-beta.19-baseline')>	spec for: #'Gofer-Core' do: [		spec			removePackage: 'Gofer';			package: 'Gofer-Core'  overrides: [				spec repository: 'http://seaside.gemstone.com/ss/metacello' ];			package: 'Gofer-Tests'  overrides: [				spec 					requires: 'Gofer-Core' ;					repository: 'http://seaside.gemstone.com/ss/metacello' ];			yourself ].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta22: spec	<version: '1.0-beta.22-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://seaside.gemstone.com/ss/metacello'.		spec			project: 'Gofer Core' with: [				spec					className: 'ConfigurationOfGofer';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfGofer';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			project: 'Gofer Tests' copyFrom: 'Gofer Core' with: [				spec loads: #('Tests' ) ];			yourself.		spec 			package: 'Metacello-Core' with: [				spec includes: #('Metacello-MC' 'Metacello-Platform' ). ];			package: 'Metacello-MC' with: [				spec requires: #('Metacello-Core' 'Gofer Core' ). ];			package: 'Metacello-Platform' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Reference' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Tutorial' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsCore' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsMC' with: [				spec requires: #('Metacello-MC' 'Gofer Tests' ). ];			package: 'Metacello-TestsReference' with: [				spec requires: #('Metacello-Reference' ). ];			package: 'Metacello-TestsTutorial' with: [				spec requires: #('Metacello-Tutorial' ). ];			package: 'OB-Metacello' with: [				spec requires: #('Metacello-Platform' 'Metacello-Core' ). ];			yourself.		spec 			group: 'default' with: #('Metacello-Core' );			group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference' );			group: 'UI' with: #('OB-Metacello' );			group: 'Tests' overrides: #('Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference' );			yourself.].	spec for: #squeakCommon do: [		spec			project: 'OB' with: [				spec					className: 'ConfigurationOfOmniBrowser';					versionString: '1.1-baseline';					loads: #('Core' );					file: 'ConfigurationOfOmniBrowser';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.squeakCommon'. ];			package: 'OB-Metacello' with: [				spec requires: #('OB' ). ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself.].	spec for: #pharo do: [		spec 			project: 'ProfStef' with: [				spec					className: 'ConfigurationOfProfStef';					versionString: '1.0-baseline';					file: 'ConfigurationOfProfStef';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-ProfStef' with: [				spec requires: #('Metacello-Core' 'ProfStef' ). ];			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo';			yourself.		spec			group: 'Tutorial' with: #('Metacello-ProfStef');			yourself.].	spec for: #squeak do: [		spec			package: 'Metacello-Platform' with: 'Metacello-Platform.squeak';			yourself.].	spec for: #gemstone do: [		spec			project: 'Monticello' with: [				spec					className: 'ConfigurationOfGsMonticello';					file: 'ConfigurationOfGsMonticello';					repository: 'http://seaside.gemstone.com/ss/monticello' ];			yourself.		spec 			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone';			yourself. ].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta25: spec	<version: '1.0-beta.25-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://seaside.gemstone.com/ss/metacello'.		spec			project: 'Gofer Core' with: [				spec					className: 'ConfigurationOfGofer';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfGofer';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			project: 'Gofer Tests' copyFrom: 'Gofer Core' with: [				spec loads: #('Tests' ) ];			yourself.		spec 			package: 'Metacello-Core' with: [				spec includes: #('Metacello-MC' 'Metacello-Platform' ). ];			package: 'Metacello-MC' with: [				spec requires: #('Metacello-Core' 'Gofer Core' ). ];			package: 'Metacello-Platform' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Reference' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Tutorial' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsCore' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsMC' with: [				spec 					postLoadDoIt: #testsMC10beta25PostLoadDoIt;					requires: #('Metacello-MC' 'Gofer Tests' ). ];			package: 'Metacello-TestsReference' with: [				spec requires: #('Metacello-Reference' ). ];			package: 'Metacello-TestsTutorial' with: [				spec requires: #('Metacello-Tutorial' ). ];			package: 'OB-Metacello' with: [				spec requires: #('Metacello-Platform' 'Metacello-Core' ). ];			yourself.		spec 			group: 'default' with: #('Metacello-Core' );			group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference' );			group: 'UI' with: #('OB-Metacello' );			group: 'Tests' overrides: #('Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference' );			yourself.].	spec for: #squeakCommon do: [		spec			project: 'OB' with: [				spec					className: 'ConfigurationOfOmniBrowser';					versionString: '1.1-baseline';					loads: #('Core' );					file: 'ConfigurationOfOmniBrowser';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.squeakCommon'. ];			package: 'OB-Metacello' with: [				spec requires: #('OB' ). ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself.].	spec for: #pharo do: [		spec 			project: 'ProfStef' with: [				spec					className: 'ConfigurationOfProfStef';					versionString: '1.0-baseline';					file: 'ConfigurationOfProfStef';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-ProfStef' with: [				spec requires: #('Metacello-Core' 'ProfStef' ). ];			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo';			yourself.		spec			group: 'Tutorial' with: #('Metacello-ProfStef');			yourself.].	spec for: #squeak do: [		spec			package: 'Metacello-Platform' with: 'Metacello-Platform.squeak';			yourself.].	spec for: #gemstone do: [		spec			project: 'Monticello' with: [				spec					className: 'ConfigurationOfGsMonticello';					file: 'ConfigurationOfGsMonticello';					repository: 'http://seaside.gemstone.com/ss/monticello' ];			yourself.		spec 			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone';			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.gemstone'. ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself. ].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta27: spec	<version: '1.0-beta.27-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://seaside.gemstone.com/ss/metacello'.		spec repository: 'http://www.squeaksource.com/metacello'.		spec			project: 'Gofer Core' with: [				spec					className: 'ConfigurationOfGofer';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfGofer';					repository: 'http://www.squeaksource.com/MetacelloRepository';					repository: 'http://seaside.gemstone.com/ss/metacello'. ];			project: 'Gofer Tests' copyFrom: 'Gofer Core' with: [				spec loads: #('Tests' ) ];			yourself.		spec 			package: 'Metacello-Core' with: [				spec includes: #('Metacello-MC' 'Metacello-Platform' ). ];			package: 'Metacello-MC' with: [				spec requires: #('Metacello-Core' 'Gofer Core' ). ];			package: 'Metacello-Platform' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Reference' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Tutorial' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsCore' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsMC' with: [				spec 					postLoadDoIt: #testsMC10beta25PostLoadDoIt;					requires: #('Metacello-MC' 'Gofer Tests' ). ];			package: 'Metacello-TestsReference' with: [				spec requires: #('Metacello-Reference' ). ];			package: 'Metacello-TestsTutorial' with: [				spec requires: #('Metacello-Tutorial' ). ];			package: 'OB-Metacello' with: [				spec requires: #('Metacello-Platform' 'Metacello-Core' ). ];			yourself.		spec 			group: 'default' with: #('Metacello-Core' );			group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference' );			group: 'UI' with: #('OB-Metacello' );			group: 'Tests' overrides: #('Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference' );			yourself.].	spec for: #squeakCommon do: [		spec			project: 'Help System' with: [				spec					className: 'ConfigurationOfHelpSystem';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfHelpSystem';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			project: 'OB' with: [				spec					className: 'ConfigurationOfOmniBrowser';					versionString: '1.1-baseline';					loads: #('Core' );					file: 'ConfigurationOfOmniBrowser';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.squeakCommon'. ];			package: 'Metacello-Help' with: [				spec requires: 'Help System'. ];			package: 'OB-Metacello' with: [				spec requires: #('OB' ). ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			group: 'Tutorial' with: #('Metacello-Help' );			yourself.].	spec for: #pharo do: [		spec 			project: 'ProfStef' with: [				spec					className: 'ConfigurationOfProfStef';					versionString: '1.0-baseline';					file: 'ConfigurationOfProfStef';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-ProfStef' with: [				spec requires: #('Metacello-Core' 'ProfStef' ). ];			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo';			yourself.		spec			group: 'Tutorial' with: #('Metacello-ProfStef');			yourself.].	spec for: #squeak do: [		spec			package: 'Metacello-Platform' with: 'Metacello-Platform.squeak';			yourself.].	spec for: #gemstone do: [		spec			project: 'Monticello' with: [				spec					className: 'ConfigurationOfGsMonticello';					file: 'ConfigurationOfGsMonticello';					repository: 'http://seaside.gemstone.com/ss/monticello' ];			yourself.		spec 			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone';			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.gemstone'. ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself. ].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta2831: spec	<version: '1.0-beta.28.3.1-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://seaside.gemstone.com/ss/metacello'.		spec repository: 'http://www.squeaksource.com/metacello'.		spec			project: 'Gofer Core' with: [				spec					className: 'ConfigurationOfGofer';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfGofer';					repository: 'http://www.squeaksource.com/MetacelloRepository';					repository: 'http://seaside.gemstone.com/ss/metacello'. ];			project: 'Gofer Tests' copyFrom: 'Gofer Core' with: [				spec loads: #('Tests' ) ];			yourself.		spec 			package: 'Metacello-Base';			package: 'Metacello-ToolBox' with: [				spec requires: 'Metacello-Base'. ];			package: 'Metacello-Core' with: [				spec 					requires: 'Metacello-Base';					includes: #('Metacello-MC' 'Metacello-Platform' ). ];			package: 'Metacello-MC' with: [				spec requires: #('Metacello-Core' 'Gofer Core' ). ];			package: 'Metacello-Platform' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Reference' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Tutorial' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsCore' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsMC' with: [				spec 					postLoadDoIt: #testsMC10beta25PostLoadDoIt;					requires: #('Metacello-MC' 'Gofer Tests' ). ];			package: 'Metacello-TestsReference' with: [				spec requires: #('Metacello-Reference' ). ];			package: 'Metacello-TestsTutorial' with: [				spec requires: #('Metacello-Tutorial' 'Metacello-TestsMC' ). ];			package: 'OB-Metacello' with: [				spec requires: #('Metacello-Platform' 'Metacello-Core' 'Metacello-ToolBox'). ];			yourself.		spec 			group: 'default' with: #('Metacello-Core' 'Metacello-ToolBox' );			group: 'Base Configuration' with: #('Metacello-Base' );			group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference' );			group: 'UI' with: #('OB-Metacello' );			group: 'Tests' with: #('default' 'Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference' );			yourself.].	spec for: #squeakCommon do: [		spec			project: 'Help System' with: [				spec					className: 'ConfigurationOfHelpSystem';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfHelpSystem';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			project: 'OB' with: [				spec					className: 'ConfigurationOfOmniBrowser';					versionString: '1.1-baseline';					loads: #('Core' );					file: 'ConfigurationOfOmniBrowser';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.squeakCommon'. ];			package: 'Metacello-Help' with: [				spec requires: 'Help System'. ];			package: 'OB-Metacello' with: [				spec requires: #('OB' ). ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			group: 'Tutorial' with: #('Metacello-Help' );			yourself.].	spec for: #pharo do: [		spec 			project: 'ProfStef' with: [				spec					className: 'ConfigurationOfProfStef';					versionString: '1.0-baseline';					file: 'ConfigurationOfProfStef';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-ProfStef' with: [				spec requires: #('Metacello-Core' 'ProfStef' 'Metacello-ToolBox' ). ];			package: 'Metacello-TestsProfStef' with: [				spec requires: #('Metacello-ProfStef' ). ];			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo';			yourself.		spec			group: 'default' with: #('Metacello-Help');			group: 'Tests' with: #('Metacello-TestsProfStef' );			group: 'Tutorial' with: #('Metacello-ProfStef');			yourself.].	spec for: #'pharo1.2.x' do: [		spec 			package: 'Metacello-TestsMC' with: [				spec includes: #( 'Metacello-Issue3758' )];			package: 'Metacello-Issue3758' with: [				spec requires:#( 'Metacello-TestsMC' )];			yourself. ].	spec for: #squeak do: [		spec			package: 'Metacello-Platform' with: 'Metacello-Platform.squeak';			yourself.].	spec for: #gemstone do: [		spec			project: 'Monticello' with: [				spec					className: 'ConfigurationOfGsMonticello';					file: 'ConfigurationOfGsMonticello';					repository: 'http://seaside.gemstone.com/ss/monticello' ];			yourself.		spec 			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone';			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.gemstone'. ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself. ].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta2833: spec	<version: '1.0-beta.28.3.3-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://seaside.gemstone.com/ss/metacello'.		spec repository: 'http://www.squeaksource.com/metacello'.		spec			project: 'Gofer Core' with: [				spec					className: 'ConfigurationOfGofer';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfGofer';					repository: 'http://www.squeaksource.com/MetacelloRepository';					repository: 'http://seaside.gemstone.com/ss/metacello'. ];			project: 'Gofer Tests' copyFrom: 'Gofer Core' with: [				spec loads: #('Tests' ) ];			yourself.		spec 			package: 'Metacello-Base';			package: 'Metacello-ToolBox' with: [				spec requires: 'Metacello-Base'. ];			package: 'Metacello-Core' with: [				spec 					requires: 'Metacello-Base';					includes: #('Metacello-MC' 'Metacello-Platform' ). ];			package: 'Metacello-MC' with: [				spec requires: #('Metacello-Core' 'Gofer Core' ). ];			package: 'Metacello-Platform' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Reference' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Tutorial' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsCore' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsMC' with: [				spec 					postLoadDoIt: #testsMC10beta25PostLoadDoIt;					requires: #('Metacello-MC' 'Gofer Tests' ). ];			package: 'Metacello-TestsReference' with: [				spec requires: #('Metacello-Reference' ). ];			package: 'Metacello-TestsTutorial' with: [				spec requires: #('Metacello-Tutorial' 'Metacello-TestsMC' ). ];			package: 'OB-Metacello' with: [				spec requires: #('Metacello-Platform' 'Metacello-Core' 'Metacello-ToolBox'). ];			yourself.		spec 			group: 'default' with: #('Metacello-Core' 'Metacello-ToolBox' );			group: 'Base Configuration' with: #('Metacello-Base' );			group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference' );			group: 'UI' with: #('OB-Metacello' );			group: 'Tests' with: #('default' 'Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference' );			yourself.].	spec for: #squeakCommon do: [		spec			project: 'Help System' with: [				spec					className: 'ConfigurationOfHelpSystem';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfHelpSystem';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			project: 'OB' with: [				spec					className: 'ConfigurationOfOmniBrowser';					versionString: '1.1-baseline';					loads: #('Core' );					file: 'ConfigurationOfOmniBrowser';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.squeakCommon'. ];			package: 'Metacello-Help' with: [				spec requires: 'Help System'. ];			package: 'OB-Metacello' with: [				spec requires: #('OB' ). ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			group: 'Tutorial' with: #('Metacello-Help' );			yourself.].	spec for: #pharo do: [		spec 			project: 'ProfStef' with: [				spec					className: 'ConfigurationOfProfStef';					versionString: '1.0-baseline';					file: 'ConfigurationOfProfStef';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-ProfStef' with: [				spec requires: #('Metacello-Core' 'ProfStef' 'Metacello-ToolBox' ). ];			package: 'Metacello-TestsProfStef' with: [				spec requires: #('Metacello-ProfStef' ). ];			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo';			yourself.		spec			group: 'default' with: #('Metacello-Help');			group: 'Tests' with: #('Metacello-TestsProfStef' );			group: 'Tutorial' with: #('Metacello-ProfStef');			yourself.].	spec for: #'pharo1.2.x' do: [		spec 			package: 'Metacello-TestsMC' with: [				spec includes: #( 'Metacello-Issue3758' )];			package: 'Metacello-Issue3758' with: [				spec requires:#( 'Metacello-TestsMC' )];			yourself. ].	spec for: #'pharo1.3.x' do: [		spec 			package: 'Metacello-TestsMC' with: [				spec includes: #( 'Metacello-Issue3758' )];			package: 'Metacello-Issue3758' with: [				spec requires:#( 'Metacello-TestsMC' )];			yourself. ].	spec for: #squeak do: [		spec			package: 'Metacello-Platform' with: 'Metacello-Platform.squeak';			yourself.].	spec for: #gemstone do: [		spec			project: 'Monticello' with: [				spec					className: 'ConfigurationOfGsMonticello';					file: 'ConfigurationOfGsMonticello';					repository: 'http://seaside.gemstone.com/ss/monticello' ];			yourself.		spec 			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone';			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.gemstone'. ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself. ].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta28: spec	<version: '1.0-beta.28-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://seaside.gemstone.com/ss/metacello'.		spec repository: 'http://www.squeaksource.com/metacello'.		spec			project: 'Gofer Core' with: [				spec					className: 'ConfigurationOfGofer';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfGofer';					repository: 'http://www.squeaksource.com/MetacelloRepository';					repository: 'http://seaside.gemstone.com/ss/metacello'. ];			project: 'Gofer Tests' copyFrom: 'Gofer Core' with: [				spec loads: #('Tests' ) ];			yourself.		spec 			package: 'Metacello-Base';			package: 'Metacello-ToolBox' with: [				spec requires: 'Metacello-Base'. ];			package: 'Metacello-Core' with: [				spec 					requires: 'Metacello-Base';					includes: #('Metacello-MC' 'Metacello-Platform' ). ];			package: 'Metacello-MC' with: [				spec requires: #('Metacello-Core' 'Gofer Core' ). ];			package: 'Metacello-Platform' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Reference' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Tutorial' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsCore' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsMC' with: [				spec 					postLoadDoIt: #testsMC10beta25PostLoadDoIt;					requires: #('Metacello-MC' 'Gofer Tests' ). ];			package: 'Metacello-TestsReference' with: [				spec requires: #('Metacello-Reference' ). ];			package: 'Metacello-TestsTutorial' with: [				spec requires: #('Metacello-Tutorial' 'Metacello-TestsMC' ). ];			package: 'OB-Metacello' with: [				spec requires: #('Metacello-Platform' 'Metacello-Core' 'Metacello-ToolBox'). ];			yourself.		spec 			group: 'default' with: #('Metacello-Core' 'Metacello-ToolBox' );			group: 'Base Configuration' with: #('Metacello-Base' );			group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference' );			group: 'UI' with: #('OB-Metacello' );			group: 'Tests' with: #('Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference' );			yourself.].	spec for: #squeakCommon do: [		spec			project: 'Help System' with: [				spec					className: 'ConfigurationOfHelpSystem';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfHelpSystem';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			project: 'OB' with: [				spec					className: 'ConfigurationOfOmniBrowser';					versionString: '1.1-baseline';					loads: #('Core' );					file: 'ConfigurationOfOmniBrowser';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.squeakCommon'. ];			package: 'Metacello-Help' with: [				spec requires: 'Help System'. ];			package: 'OB-Metacello' with: [				spec requires: #('OB' ). ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			group: 'Tutorial' with: #('Metacello-Help' );			yourself.].	spec for: #pharo do: [		spec 			project: 'ProfStef' with: [				spec					className: 'ConfigurationOfProfStef';					versionString: '1.0-baseline';					file: 'ConfigurationOfProfStef';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-ProfStef' with: [				spec requires: #('Metacello-Core' 'ProfStef' 'Metacello-ToolBox' ). ];			package: 'Metacello-TestsProfStef' with: [				spec requires: #('ProfStef' ). ];			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo';			yourself.		spec			group: 'default' with: #('Metacello-Help');			group: 'Tests' with: #('Metacello-TestsProfStef' );			group: 'Tutorial' with: #('Metacello-ProfStef');			yourself.].	spec for: #squeak do: [		spec			package: 'Metacello-Platform' with: 'Metacello-Platform.squeak';			yourself.].	spec for: #gemstone do: [		spec			project: 'Monticello' with: [				spec					className: 'ConfigurationOfGsMonticello';					file: 'ConfigurationOfGsMonticello';					repository: 'http://seaside.gemstone.com/ss/monticello' ];			yourself.		spec 			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone';			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.gemstone'. ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself. ].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta28ea3: spec	<version: '1.0-beta.28-ea.3-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://seaside.gemstone.com/ss/metacello'.		spec repository: 'http://www.squeaksource.com/metacello'.		spec			project: 'Gofer Core' with: [				spec					className: 'ConfigurationOfGofer';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfGofer';					repository: 'http://www.squeaksource.com/MetacelloRepository';					repository: 'http://seaside.gemstone.com/ss/metacello'. ];			project: 'Gofer Tests' copyFrom: 'Gofer Core' with: [				spec loads: #('Tests' ) ];			yourself.		spec 			package: 'Metacello-Base';			package: 'Metacello-ToolBox' with: [				spec requires: 'Metacello-Base'. ];			package: 'Metacello-Core' with: [				spec 					requires: 'Metacello-Base';					includes: #('Metacello-MC' 'Metacello-Platform' ). ];			package: 'Metacello-MC' with: [				spec requires: #('Metacello-Core' 'Gofer Core' ). ];			package: 'Metacello-Platform' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Reference' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Tutorial' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsCore' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsMC' with: [				spec 					postLoadDoIt: #testsMC10beta25PostLoadDoIt;					requires: #('Metacello-MC' 'Gofer Tests' ). ];			package: 'Metacello-TestsReference' with: [				spec requires: #('Metacello-Reference' ). ];			package: 'Metacello-TestsTutorial' with: [				spec requires: #('Metacello-Tutorial' ). ];			package: 'OB-Metacello' with: [				spec requires: #('Metacello-Platform' 'Metacello-Core' 'Metacello-ToolBox'). ];			yourself.		spec 			group: 'default' with: #('Metacello-Core' 'Metacello-ToolBox' );			group: 'Base Configuration' with: #('Metacello-Base' );			group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference' );			group: 'UI' with: #('OB-Metacello' );			group: 'Tests' with: #('Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference' );			yourself.].	spec for: #squeakCommon do: [		spec			project: 'Help System' with: [				spec					className: 'ConfigurationOfHelpSystem';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfHelpSystem';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			project: 'OB' with: [				spec					className: 'ConfigurationOfOmniBrowser';					versionString: '1.1-baseline';					loads: #('Core' );					file: 'ConfigurationOfOmniBrowser';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.squeakCommon'. ];			package: 'Metacello-Help' with: [				spec requires: 'Help System'. ];			package: 'OB-Metacello' with: [				spec requires: #('OB' ). ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			group: 'Tutorial' with: #('Metacello-Help' );			yourself.].	spec for: #pharo do: [		spec 			project: 'ProfStef' with: [				spec					className: 'ConfigurationOfProfStef';					versionString: '1.0-baseline';					file: 'ConfigurationOfProfStef';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-ProfStef' with: [				spec requires: #('Metacello-Core' 'ProfStef' 'Metacello-ToolBox' ). ];			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo';			yourself.		spec			group: 'default' with: #('Metacello-Help');			group: 'Tutorial' with: #('Metacello-ProfStef');			yourself.].	spec for: #squeak do: [		spec			package: 'Metacello-Platform' with: 'Metacello-Platform.squeak';			yourself.].	spec for: #gemstone do: [		spec			project: 'Monticello' with: [				spec					className: 'ConfigurationOfGsMonticello';					file: 'ConfigurationOfGsMonticello';					repository: 'http://seaside.gemstone.com/ss/monticello' ];			yourself.		spec 			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone';			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.gemstone'. ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself. ].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta28ea: spec	<version: '1.0-beta.28-ea-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://seaside.gemstone.com/ss/metacello'.		spec repository: 'http://www.squeaksource.com/metacello'.		spec			project: 'Gofer Core' with: [				spec					className: 'ConfigurationOfGofer';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfGofer';					repository: 'http://www.squeaksource.com/MetacelloRepository';					repository: 'http://seaside.gemstone.com/ss/metacello'. ];			project: 'Gofer Tests' copyFrom: 'Gofer Core' with: [				spec loads: #('Tests' ) ];			yourself.		spec 			package: 'Metacello-Base';			package: 'Metacello-Core' with: [				spec 					requires: 'Metacello-Base';					includes: #('Metacello-MC' 'Metacello-Platform' ). ];			package: 'Metacello-MC' with: [				spec requires: #('Metacello-Core' 'Gofer Core' ). ];			package: 'Metacello-Platform' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Reference' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Tutorial' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsCore' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsMC' with: [				spec 					postLoadDoIt: #testsMC10beta25PostLoadDoIt;					requires: #('Metacello-MC' 'Gofer Tests' ). ];			package: 'Metacello-TestsReference' with: [				spec requires: #('Metacello-Reference' ). ];			package: 'Metacello-TestsTutorial' with: [				spec requires: #('Metacello-Tutorial' ). ];			package: 'OB-Metacello' with: [				spec requires: #('Metacello-Platform' 'Metacello-Core' ). ];			yourself.		spec 			group: 'default' with: #('Metacello-Core' );			group: 'Base Configuration' with: #('Metacello-Base' );			group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference' );			group: 'UI' with: #('OB-Metacello' );			group: 'Tests' overrides: #('Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference' );			yourself.].	spec for: #squeakCommon do: [		spec			project: 'Help System' with: [				spec					className: 'ConfigurationOfHelpSystem';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfHelpSystem';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			project: 'OB' with: [				spec					className: 'ConfigurationOfOmniBrowser';					versionString: '1.1-baseline';					loads: #('Core' );					file: 'ConfigurationOfOmniBrowser';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.squeakCommon'. ];			package: 'Metacello-Help' with: [				spec requires: 'Help System'. ];			package: 'OB-Metacello' with: [				spec requires: #('OB' ). ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			group: 'Tutorial' with: #('Metacello-Help' );			yourself.].	spec for: #pharo do: [		spec 			project: 'ProfStef' with: [				spec					className: 'ConfigurationOfProfStef';					versionString: '1.0-baseline';					file: 'ConfigurationOfProfStef';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-ProfStef' with: [				spec requires: #('Metacello-Core' 'ProfStef' ). ];			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo';			yourself.		spec			group: 'Tutorial' with: #('Metacello-ProfStef');			yourself.].	spec for: #squeak do: [		spec			package: 'Metacello-Platform' with: 'Metacello-Platform.squeak';			yourself.].	spec for: #gemstone do: [		spec			project: 'Monticello' with: [				spec					className: 'ConfigurationOfGsMonticello';					file: 'ConfigurationOfGsMonticello';					repository: 'http://seaside.gemstone.com/ss/monticello' ];			yourself.		spec 			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone';			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.gemstone'. ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself. ].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta29: spec	<version: '1.0-beta.29-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://seaside.gemstone.com/ss/metacello'.		spec repository: 'http://www.squeaksource.com/metacello'.		spec			project: 'Gofer Core' with: [				spec					className: 'ConfigurationOfGofer';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfGofer';					repository: 'http://www.squeaksource.com/MetacelloRepository';					repository: 'http://seaside.gemstone.com/ss/metacello'. ];			project: 'Gofer Tests' copyFrom: 'Gofer Core' with: [				spec loads: #('Tests' ) ];			yourself.		spec 			package: 'Metacello-Base';			package: 'Metacello-ToolBox' with: [				spec requires: 'Metacello-Base'. ];			package: 'Metacello-Core' with: [				spec 					requires: 'Metacello-Base';					includes: #('Metacello-MC' 'Metacello-Platform' ). ];			package: 'Metacello-MC' with: [				spec requires: #('Metacello-Core' 'Gofer Core' ). ];			package: 'Metacello-Platform' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Reference' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Tutorial' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsCore' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsMC' with: [				spec 					postLoadDoIt: #testsMC10beta25PostLoadDoIt;					requires: #('Metacello-MC' 'Gofer Tests' ). ];			package: 'Metacello-TestsReference' with: [				spec requires: #('Metacello-Reference' ). ];			package: 'Metacello-TestsTutorial' with: [				spec requires: #('Metacello-Tutorial' 'Metacello-TestsMC' ). ];			package: 'OB-Metacello' with: [				spec requires: #('Metacello-Platform' 'Metacello-Core' 'Metacello-ToolBox'). ];			yourself.		spec 			group: 'default' with: #('Metacello-Core' 'Metacello-ToolBox' );			group: 'Base Configuration' with: #('Metacello-Base' );			group: 'Core' with: #('default' );			group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference' );			group: 'UI' with: #('OB-Metacello' );			group: 'Tests' with: #('default' 'Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference' );			yourself.].	spec for: #squeakCommon do: [		spec			project: 'Help System' with: [				spec					className: 'ConfigurationOfHelpSystem';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfHelpSystem';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			project: 'OB' with: [				spec					className: 'ConfigurationOfOmniBrowser';					versionString: '1.1-baseline';					loads: #('Core' );					file: 'ConfigurationOfOmniBrowser';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.squeakCommon'. ];			package: 'Metacello-Help' with: [				spec requires: 'Help System'. ];			package: 'OB-Metacello' with: [				spec requires: #('OB' ). ];			yourself.		spec			group: 'default' with: #('Metacello-Help');			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself.].	spec for: #pharo do: [		spec 			project: 'ProfStef' with: [				spec					className: 'ConfigurationOfProfStef';					versionString: '1.0-baseline';					file: 'ConfigurationOfProfStef';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-ProfStef' with: [				spec requires: #('Metacello-Core' 'ProfStef' 'Metacello-ToolBox' ). ];			package: 'Metacello-TestsProfStef' with: [				spec requires: #('Metacello-ProfStef' ). ];			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo';			yourself.		spec			group: 'Tests' with: #('Metacello-TestsProfStef' );			group: 'Tutorial' with: #('Metacello-ProfStef');			yourself.].	spec for: #'pharo1.2.x' do: [		spec 			package: 'Metacello-TestsMC' with: [				spec includes: #( 'Metacello-Issue3758' )];			package: 'Metacello-Issue3758' with: [				spec requires:#( 'Metacello-TestsMC' )];			yourself. ].	spec for: #'pharo1.3.x' do: [		spec 			package: 'Metacello-TestsMC' with: [				spec includes: #( 'Metacello-Issue3758' )];			package: 'Metacello-Issue3758' with: [				spec requires:#( 'Metacello-TestsMC' )];			yourself. ].	spec for: #squeak do: [		spec			package: 'Metacello-Platform' with: 'Metacello-Platform.squeak';			yourself.].	spec for: #gemstone do: [		spec			project: 'Monticello' with: [				spec					className: 'ConfigurationOfGsMonticello';					file: 'ConfigurationOfGsMonticello';					repository: 'http://seaside.gemstone.com/ss/monticello' ];			yourself.		spec 			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone';			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.gemstone'. ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself. ].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta30: spec	<version: '1.0-beta.30-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://seaside.gemstone.com/ss/metacello'.		spec repository: 'http://www.squeaksource.com/metacello'.		spec			project: 'Gofer Core' with: [				spec					className: 'ConfigurationOfGofer';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfGofer';					repository: 'http://www.squeaksource.com/MetacelloRepository';					repository: 'http://seaside.gemstone.com/ss/metacello'. ];			project: 'Gofer Tests' copyFrom: 'Gofer Core' with: [				spec loads: #('Tests' ) ];			yourself.		spec 			package: 'Metacello-Base';			package: 'Metacello-ToolBox' with: [				spec requires: 'Metacello-Base'. ];			package: 'Metacello-Core' with: [				spec 					requires: 'Metacello-Base';					includes: #('Metacello-MC' 'Metacello-Platform' ). ];			package: 'Metacello-MC' with: [				spec requires: #('Metacello-Core' 'Gofer Core' ). ];			package: 'Metacello-Platform' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Reference' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Tutorial' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsCore' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsMC' with: [				spec 					postLoadDoIt: #testsMC10beta25PostLoadDoIt;					requires: #('Metacello-MC' 'Gofer Tests' ). ];			package: 'Metacello-TestsReference' with: [				spec requires: #('Metacello-Reference' ). ];			package: 'Metacello-TestsTutorial' with: [				spec requires: #('Metacello-Tutorial' 'Metacello-TestsMC' ). ];			package: 'OB-Metacello' with: [				spec requires: #('Metacello-Platform' 'Metacello-Core' 'Metacello-ToolBox'). ];			yourself.		spec 			group: 'default' with: #('Metacello-Core' 'Metacello-ToolBox' );			group: 'Base Configuration' with: #('Metacello-Base' );			group: 'Core' with: #('default' );			group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference' );			group: 'UI' with: #('OB-Metacello' );			group: 'Tests' with: #('default' 'Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference' );			yourself.].	spec for: #squeakCommon do: [		spec			project: 'Help System' with: [				spec					className: 'ConfigurationOfHelpSystem';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfHelpSystem';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			project: 'OB' with: [				spec					className: 'ConfigurationOfOmniBrowser';					versionString: '1.1-baseline';					loads: #('Core' );					file: 'ConfigurationOfOmniBrowser';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.squeakCommon'. ];			package: 'Metacello-Help' with: [				spec requires: 'Help System'. ];			package: 'OB-Metacello' with: [				spec requires: #('OB' ). ];			yourself.		spec			group: 'default' with: #('Metacello-Help');			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself.].	spec for: #pharo do: [		spec 			project: 'ProfStef' with: [				spec					className: 'ConfigurationOfProfStef';					versionString: '1.0-baseline';					file: 'ConfigurationOfProfStef';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-ProfStef' with: [				spec requires: #('Metacello-Core' 'ProfStef' 'Metacello-ToolBox' ). ];			package: 'Metacello-TestsProfStef' with: [				spec requires: #('Metacello-ProfStef' ). ];			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo';			yourself.		spec			group: 'Tests' with: #('Metacello-TestsProfStef' );			group: 'Tutorial' with: #('Metacello-ProfStef');			yourself.].	spec for: #'pharo1.2.x' do: [		spec 			package: 'Metacello-TestsMC' with: [				spec includes: #( 'Metacello-Issue3758' )];			package: 'Metacello-Issue3758' with: [				spec requires:#( 'Metacello-TestsMC' )];			yourself. ].	spec for: #'pharo1.3.x' do: [		spec 			package: 'Metacello-TestsMC' with: [				spec includes: #( 'Metacello-Issue3758' )];			package: 'Metacello-Issue3758' with: [				spec requires:#( 'Metacello-TestsMC' )];			yourself. ].	spec for: #squeak do: [		spec			package: 'Metacello-Platform' with: 'Metacello-Platform.squeak';			yourself.].	spec for: #gemstone do: [		spec			project: 'Monticello' with: [				spec					className: 'ConfigurationOfGsMonticello';					file: 'ConfigurationOfGsMonticello';					repository: 'http://seaside.gemstone.com/ss/monticello' ];			yourself.		spec 			package: 'Metacello-Platform' with: [				spec 					file: 'Metacello-Platform.gemstone';					requires: 'Monticello'];			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.gemstone'. ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself. ].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'SeanDeNigris 6/22/2012 11:41'!baseline10beta3113: spec	<version: '1.0-beta.31.1.3-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://seaside.gemstone.com/ss/metacello'.		spec repository: 'http://www.squeaksource.com/metacello'.		spec			project: 'Gofer Core' with: [				spec					className: 'ConfigurationOfGofer';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfGofer';					repository: 'http://www.squeaksource.com/MetacelloRepository';					repository: 'http://seaside.gemstone.com/ss/metacello'. ];			project: 'Gofer Tests' copyFrom: 'Gofer Core' with: [				spec loads: #('Tests' ) ];			yourself.		spec 			package: 'Metacello-Base';			package: 'Metacello-ToolBox' with: [				spec requires: #('Metacello-Base' 'Metacello-Core')];			package: 'Metacello-Core' with: [				spec 					requires: 'Metacello-Base';					includes: #('Metacello-MC' 'Metacello-Platform' ). ];			package: 'Metacello-MC' with: [				spec requires: #('Metacello-Core' 'Gofer Core' ). ];			package: 'Metacello-Platform' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Reference' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Tutorial' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsCore' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsMC' with: [				spec 					postLoadDoIt: #testsMC10beta25PostLoadDoIt;					requires: #('Metacello-MC' 'Gofer Tests' ). ];			package: 'Metacello-TestsReference' with: [				spec requires: #('Metacello-Reference' ). ];			package: 'Metacello-TestsTutorial' with: [				spec requires: #('Metacello-Tutorial' 'Metacello-TestsMC' ). ];			package: 'OB-Metacello' with: [				spec requires: #('Metacello-Platform' 'Metacello-Core' 'Metacello-ToolBox'). ];			yourself.		spec 			group: 'default' with: #('Metacello-Core' 'Metacello-ToolBox' );			group: 'batch' with: #('Metacello-Core' );			group: 'Base Configuration' with: #('Metacello-Base' );			group: 'Core' with: #('default' );			group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference' );			group: 'UI' with: #('OB-Metacello' );			group: 'Tests' with: #('default' 'Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference' );			yourself.].	spec for: #squeakCommon do: [		spec			project: 'Help System' with: [				spec					className: 'ConfigurationOfHelpSystem';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfHelpSystem';					repository: 'http://www.squeaksource.com/MetacelloRepository';					repository: 'http://dsal.cl/squeaksource/MetacelloRepository'. ];			project: 'OB' with: [				spec					className: 'ConfigurationOfOmniBrowser';					versionString: '1.1-baseline';					loads: #('Core' );					file: 'ConfigurationOfOmniBrowser';					repository: 'http://www.squeaksource.com/MetacelloRepository';					repository: 'http://dsal.cl/squeaksource/MetacelloRepository'. ];			yourself.		spec			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.squeakCommon'. ];			package: 'Metacello-Help' with: [				spec requires: 'Help System'. ];			package: 'OB-Metacello' with: [				spec requires: #('OB' ). ];			yourself.		spec			group: 'default' with: #('Metacello-Help');			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself.].	spec for: #pharo do: [		spec 			project: 'ProfStef' with: [				spec					className: 'ConfigurationOfProfStef';					versionString: '1.0-baseline';					file: 'ConfigurationOfProfStef';					repository: 'http://www.squeaksource.com/MetacelloRepository';					repository: 'http://dsal.cl/squeaksource/MetacelloRepository'. ];			yourself.		spec			package: 'Metacello-ProfStef' with: [				spec requires: #('Metacello-Core' 'ProfStef' 'Metacello-ToolBox' ). ];			package: 'Metacello-TestsProfStef' with: [				spec requires: #('Metacello-ProfStef' ). ];			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo';			yourself.		spec			group: 'Tests' with: #('Metacello-TestsProfStef' );			group: 'Tutorial' with: #('Metacello-ProfStef');			yourself.].	spec for: #'pharo1.2.x' do: [		spec 			package: 'Metacello-TestsMC' with: [				spec includes: #( 'Metacello-Issue3758' )];			package: 'Metacello-Issue3758' with: [				spec requires:#( 'Metacello-TestsMC' )];			yourself. ].	spec for: #'pharo1.3.x' do: [		spec 			package: 'Metacello-TestsMC' with: [				spec includes: #( 'Metacello-Issue3758' )];			package: 'Metacello-Issue3758' with: [				spec requires:#( 'Metacello-TestsMC' )];			yourself. ].	spec for: #squeak do: [		spec			package: 'Metacello-Platform' with: 'Metacello-Platform.squeak';			yourself.].	spec for: #gemstone do: [		spec			project: 'Monticello' with: [				spec					className: 'ConfigurationOfGsMonticello';					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'OB' with: [				spec					className: 'ConfigurationOfGsOB';					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			yourself.		spec 			package: 'Metacello-Platform' with: [				spec 					file: 'Metacello-Platform.gemstone';					postLoadDoIt: #gemstone10beta311PostLoadDoIt;					requires: 'Monticello'];			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.gemstone'. ];			package: 'OB-Metacello' with: [				spec requires: #('OB' ). ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself. ].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'SeanDeNigris 6/27/2012 22:15'!baseline10beta3114: spec	<version: '1.0-beta.31.1.4-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://seaside.gemstone.com/ss/metacello'.		spec repository: 'http://www.squeaksource.com/metacello'.		spec			project: 'Gofer Core' with: [				spec					className: 'ConfigurationOfGofer';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfGofer';					repository: 'http://www.squeaksource.com/MetacelloRepository';					repository: 'http://seaside.gemstone.com/ss/metacello'. ];			project: 'Gofer Tests' copyFrom: 'Gofer Core' with: [				spec loads: #('Tests' ) ];			yourself.		spec 			package: 'Metacello-Base';			package: 'Metacello-ToolBox' with: [				spec requires: #('Metacello-Base' 'Metacello-Core')];			package: 'Metacello-Core' with: [				spec 					requires: 'Metacello-Base';					includes: #('Metacello-MC' 'Metacello-Platform' ). ];			package: 'Metacello-MC' with: [				spec requires: #('Metacello-Core' 'Gofer Core' ). ];			package: 'Metacello-Platform' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Reference' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Tutorial' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsCore' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsMC' with: [				spec 					postLoadDoIt: #testsMC10beta25PostLoadDoIt;					requires: #('Metacello-MC' 'Gofer Tests' ). ];			package: 'Metacello-TestsReference' with: [				spec requires: #('Metacello-Reference' ). ];			package: 'Metacello-TestsTutorial' with: [				spec requires: #('Metacello-Tutorial' 'Metacello-TestsMC' ). ];			package: 'OB-Metacello' with: [				spec requires: #('Metacello-Platform' 'Metacello-Core' 'Metacello-ToolBox'). ];			yourself.		spec 			group: 'default' with: #('Metacello-Core' 'Metacello-ToolBox' );			group: 'batch' with: #('Metacello-Core' );			group: 'Base Configuration' with: #('Metacello-Base' );			group: 'Core' with: #('default' );			group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference' );			group: 'UI' with: #('OB-Metacello' );			group: 'Tests' with: #('default' 'Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference' );			yourself.].	spec for: #squeakCommon do: [		spec			project: 'Help System' with: [				spec					className: 'ConfigurationOfHelpSystem';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfHelpSystem';					repository: 'http://www.squeaksource.com/MetacelloRepository';					repository: 'http://dsal.cl/squeaksource/MetacelloRepository'. ];			project: 'OB' with: [				spec					className: 'ConfigurationOfOmniBrowser';					versionString: '1.1-baseline';					loads: #('Core' );					file: 'ConfigurationOfOmniBrowser';					repository: 'http://www.squeaksource.com/MetacelloRepository';					repository: 'http://dsal.cl/squeaksource/MetacelloRepository'. ];			yourself.		spec			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.squeakCommon'. ];			package: 'Metacello-Help' with: [				spec requires: 'Help System'. ];			package: 'OB-Metacello' with: [				spec requires: #('OB' ). ];			yourself.		spec			group: 'default' with: #('Metacello-Help');			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself.].	spec for: #pharo do: [		spec 			project: 'ProfStef' with: [				spec					className: 'ConfigurationOfProfStef';					versionString: '1.0-baseline';					file: 'ConfigurationOfProfStef';					repository: 'http://www.squeaksource.com/MetacelloRepository';					repository: 'http://dsal.cl/squeaksource/MetacelloRepository'. ];			yourself.		spec			package: 'Metacello-ProfStef' with: [				spec requires: #('Metacello-Core' 'ProfStef' 'Metacello-ToolBox' ). ];			package: 'Metacello-TestsProfStef' with: [				spec requires: #('Metacello-ProfStef' ). ];			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo';			yourself.		spec			group: 'Tests' with: #('Metacello-TestsProfStef' );			group: 'Tutorial' with: #('Metacello-ProfStef');			yourself.].	spec for: #'pharo1.2.x' do: [		spec 			package: 'Metacello-TestsMC' with: [				spec includes: #( 'Metacello-Issue3758' )];			package: 'Metacello-Issue3758' with: [				spec requires:#( 'Metacello-TestsMC' )];			yourself. ].	spec for: #'pharo1.3.x' do: [		spec 			package: 'Metacello-TestsMC' with: [				spec includes: #( 'Metacello-Issue3758' )];			package: 'Metacello-Issue3758' with: [				spec requires:#( 'Metacello-TestsMC' )];			yourself. ].	spec for: #'pharo2.x' do: [		spec			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo20';			yourself. ].	spec for: #squeak do: [		spec			package: 'Metacello-Platform' with: 'Metacello-Platform.squeak';			yourself.].	spec for: #gemstone do: [		spec			project: 'Monticello' with: [				spec					className: 'ConfigurationOfGsMonticello';					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'OB' with: [				spec					className: 'ConfigurationOfGsOB';					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			yourself.		spec 			package: 'Metacello-Platform' with: [				spec 					file: 'Metacello-Platform.gemstone';					postLoadDoIt: #gemstone10beta311PostLoadDoIt;					requires: 'Monticello'];			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.gemstone'. ];			package: 'OB-Metacello' with: [				spec requires: #('OB' ). ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself. ].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 06/15/2014 13:16'!baseline10beta3115: spec  <version: '1.0-beta.31.1.5-baseline'>  spec    for: #'common'    do: [       spec blessing: #'baseline'.      spec repository: 'http://seaside.gemtalksystems.com/ss/metacello'.      spec        project: 'Gofer Core'          with: [               spec                className: 'ConfigurationOfGofer';                versionString: '1.0-baseline';                loads: #('Core');                file: 'ConfigurationOfGofer';                repository: 'http://seaside.gemtalksystems.com/ss/metacello' ];        project: 'Gofer Tests'          copyFrom: 'Gofer Core'          with: [ spec loads: #('Tests') ];        yourself.      spec        package: 'Metacello-Base';        package: 'Metacello-ToolBox'          with: [ spec requires: #('Metacello-Base' 'Metacello-Core') ];        package: 'Metacello-Core'          with: [               spec                requires: 'Metacello-Base';                includes: #('Metacello-MC' 'Metacello-Platform') ];        package: 'Metacello-MC'          with: [ spec requires: #('Metacello-Core' 'Gofer Core') ];        package: 'Metacello-Platform'          with: [ spec requires: #('Metacello-MC') ];        package: 'Metacello-Reference'          with: [ spec requires: #('Metacello-MC') ];        package: 'Metacello-Tutorial'          with: [ spec requires: #('Metacello-Core') ];        package: 'Metacello-TestsCore'          with: [ spec requires: #('Metacello-Core') ];        package: 'Metacello-TestsMC'          with: [               spec                postLoadDoIt: #'testsMC10beta25PostLoadDoIt';                requires: #('Metacello-ToolBox' 'Metacello-MC' 'Gofer Tests') ];        package: 'Metacello-TestsReference'          with: [ spec requires: #('Metacello-Reference') ];        package: 'Metacello-TestsTutorial'          with: [ spec requires: #('Metacello-Tutorial' 'Metacello-TestsMC') ];        package: 'OB-Metacello'          with: [ spec requires: #('Metacello-Platform' 'Metacello-Core' 'Metacello-ToolBox') ];        yourself.      spec        group: 'default' with: #('Metacello-Core' 'Metacello-ToolBox');        group: 'batch' with: #('Metacello-Core');        group: 'Base Configuration' with: #('Metacello-Base');        group: 'Core' with: #('default');        group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference');        group: 'UI' with: #('OB-Metacello');        group: 'TravisCI'          with:            #('Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference');        group: 'Tests'          with:            #('default' 'Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference');        yourself ].  spec    for: #'squeakCommon'    do: [       spec        project: 'Help System'          with: [               spec                className: 'ConfigurationOfHelpSystem';                versionString: '1.0-baseline';                loads: #('Core');                file: 'ConfigurationOfHelpSystem';                repository: 'http://www.squeaksource.com/MetacelloRepository' ];        project: 'OB'          with: [               spec                className: 'ConfigurationOfOmniBrowser';                versionString: '1.1-baseline';                loads: #('Core');                file: 'ConfigurationOfOmniBrowser';                repository: 'http://www.squeaksource.com/MetacelloRepository' ];        yourself.      spec        package: 'Metacello-TestsPlatform'          with: [               spec                requires: #('Metacello-Platform');                file: 'Metacello-TestsPlatform.squeakCommon' ];        package: 'Metacello-Help' with: [ spec requires: 'Help System' ];        package: 'OB-Metacello' with: [ spec requires: #('OB') ];        yourself.      spec        group: 'default' with: #('Metacello-Help');        group: 'TravisCI' with: #('Metacello-TestsPlatform');        group: 'Tests' with: #('Metacello-TestsPlatform');        yourself ].  spec    for: #'pharo'    do: [       spec        project: 'ProfStef'          with: [               spec                className: 'ConfigurationOfProfStef';                versionString: '1.0-baseline';                file: 'ConfigurationOfProfStef';                repository: 'http://www.squeaksource.com/MetacelloRepository' ];        yourself.      spec        package: 'Metacello-ProfStef'          with: [ spec requires: #('Metacello-Core' 'ProfStef' 'Metacello-ToolBox') ];        package: 'Metacello-TestsProfStef'          with: [ spec requires: #('Metacello-ProfStef') ];        package: 'Metacello-Platform' with: 'Metacello-Platform.pharo';        yourself.      spec        group: 'Tests' with: #('Metacello-TestsProfStef');        group: 'Tutorial' with: #('Metacello-ProfStef');        yourself ].  spec    for: #'pharo1.0.x'    do: [       spec        package: 'Metacello-ProfStef'        with: [ spec file: 'Metacello-ProfStef.toolset' ] ].  spec    for: #'pharo1.1.x'    do: [       spec        package: 'Metacello-ProfStef'        with: [ spec file: 'Metacello-ProfStef.toolset' ] ].  spec    for: #'pharo1.2.x'    do: [       spec        package: 'Metacello-ProfStef'          with: [ spec file: 'Metacello-ProfStef.toolset' ];        package: 'Metacello-TestsMC'          with: [ spec includes: #('Metacello-Issue3758') ];        package: 'Metacello-Issue3758'          with: [ spec requires: #('Metacello-TestsMC') ];        yourself ].  spec    for: #'pharo1.3.x'    do: [       spec        package: 'Metacello-TestsMC'          with: [ spec includes: #('Metacello-Issue3758') ];        package: 'Metacello-Issue3758'          with: [ spec requires: #('Metacello-TestsMC') ];        yourself ].  spec    for: #'pharo2.x'    do: [       spec        package: 'Metacello-Platform' with: 'Metacello-Platform.pharo20';        yourself ].  spec    for: #'squeak'    do: [       spec        package: 'Metacello-Platform' with: 'Metacello-Platform.squeak';        yourself ].  spec    for: #'gemstone'    do: [       spec        project: 'Monticello'          with: [               spec                className: 'ConfigurationOfGsMonticello';                repository:                    'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];        project: 'OB'          with: [               spec                className: 'ConfigurationOfGsOB';                repository:                    'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];        yourself.      spec        package: 'Metacello-Platform'          with: [               spec                file: 'Metacello-Platform.gemstone';                postLoadDoIt: #'gemstone10beta311PostLoadDoIt';                requires: 'Monticello' ];        package: 'Metacello-TestsPlatform'          with: [               spec                requires: #('Metacello-Platform');                file: 'Metacello-TestsPlatform.gemstone' ];        package: 'OB-Metacello' with: [ spec requires: #('OB') ];        yourself.      spec        group: 'Tests' with: #('Metacello-TestsPlatform');        group: 'TravisCI' with: #('Metacello-TestsPlatform');        yourself ]! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 06/28/2013 15:50'!baseline10beta3117: spec  <version: '1.0-beta.31.1.7-baseline'>  spec    for: #'common'    do: [       spec blessing: #'baseline'.      spec repository: 'http://seaside.gemtalksystems.com/ss/metacello'.      spec repository: 'http://smalltalkhub.com/mc/dkh/metacello/main'.      spec        project: 'Gofer Core'          with: [               spec                className: 'ConfigurationOfGofer';                versionString: '1.0-baseline';                loads: #('Core');                file: 'ConfigurationOfGofer';                repository: 'http://smalltalkhub.com/mc/dkh/metacello/main';                repository: 'http://seaside.gemtalksystems.com/ss/metacello' ];        project: 'Gofer Tests'          copyFrom: 'Gofer Core'          with: [ spec loads: #('Tests') ];        yourself.      spec        package: 'Metacello-Base';        package: 'Metacello-ToolBox'          with: [ spec requires: #('Metacello-Base' 'Metacello-Core') ];        package: 'Metacello-Core'          with: [               spec                requires: 'Metacello-Base';                includes: #('Metacello-MC' 'Metacello-Platform') ];        package: 'Metacello-MC'          with: [ spec requires: #('Metacello-Core' 'Gofer Core') ];        package: 'Metacello-Platform'          with: [ spec requires: #('Metacello-MC') ];        package: 'Metacello-Reference'          with: [ spec requires: #('Metacello-MC') ];        package: 'Metacello-Tutorial'          with: [ spec requires: #('Metacello-Core') ];        package: 'Metacello-TestsCore'          with: [ spec requires: #('Metacello-Core') ];        package: 'Metacello-TestsMC'          with: [               spec                postLoadDoIt: #'testsMC10beta25PostLoadDoIt';                requires: #('Metacello-ToolBox' 'Metacello-MC' 'Gofer Tests') ];        package: 'Metacello-TestsReference'          with: [ spec requires: #('Metacello-Reference') ];        package: 'Metacello-TestsTutorial'          with: [ spec requires: #('Metacello-Tutorial' 'Metacello-TestsMC') ];        package: 'OB-Metacello'          with: [ spec requires: #('Metacello-Platform' 'Metacello-Core' 'Metacello-ToolBox') ];        yourself.      spec        group: 'default' with: #('Metacello-Core' 'Metacello-ToolBox');        group: 'batch' with: #('Metacello-Core');        group: 'Base Configuration' with: #('Metacello-Base');        group: 'Core' with: #('default');        group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference');        group: 'UI' with: #('OB-Metacello');        group: 'TravisCI'          with:            #('Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference');        group: 'Tests'          with:            #('default' 'Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference');        yourself ].  spec    for: #'squeakCommon'    do: [       spec        project: 'Help System'          with: [               spec                className: 'ConfigurationOfHelpSystem';                versionString: '1.0-baseline';                loads: #('Core');                file: 'ConfigurationOfHelpSystem';                repository: 'http://www.squeaksource.com/MetacelloRepository' ];        project: 'OB'          with: [               spec                className: 'ConfigurationOfOmniBrowser';                versionString: '1.1-baseline';                loads: #('Core');                file: 'ConfigurationOfOmniBrowser';                repository: 'http://www.squeaksource.com/MetacelloRepository' ];        yourself.      spec        package: 'Metacello-TestsPlatform'          with: [               spec                requires: #('Metacello-Platform');                file: 'Metacello-TestsPlatform.squeakCommon' ];        package: 'Metacello-Help' with: [ spec requires: 'Help System' ];        package: 'OB-Metacello' with: [ spec requires: #('OB') ];        yourself.      spec        group: 'default' with: #('Metacello-Help');        group: 'TravisCI' with: #('Metacello-TestsPlatform');        group: 'Tests' with: #('Metacello-TestsPlatform');        yourself ].  spec    for: #'pharo'    do: [       spec        project: 'ProfStef'          with: [               spec                className: 'ConfigurationOfProfStef';                versionString: '1.0-baseline';                file: 'ConfigurationOfProfStef';                repository: 'http://www.squeaksource.com/MetacelloRepository' ];        yourself.      spec        package: 'Metacello-ProfStef'          with: [ spec requires: #('Metacello-Core' 'ProfStef' 'Metacello-ToolBox') ];        package: 'Metacello-TestsProfStef'          with: [ spec requires: #('Metacello-ProfStef') ];        package: 'Metacello-Platform' with: 'Metacello-Platform.pharo';        yourself.      spec        group: 'Tests' with: #('Metacello-TestsProfStef');        group: 'Tutorial' with: #('Metacello-ProfStef');        yourself ].  spec    for: #'pharo1.0.x'    do: [       spec        package: 'Metacello-ProfStef'        with: [ spec file: 'Metacello-ProfStef.toolset' ] ].  spec    for: #'pharo1.1.x'    do: [       spec        package: 'Metacello-ProfStef'        with: [ spec file: 'Metacello-ProfStef.toolset' ] ].  spec    for: #'pharo1.2.x'    do: [       spec        package: 'Metacello-ProfStef'          with: [ spec file: 'Metacello-ProfStef.toolset' ];        package: 'Metacello-TestsMC'          with: [ spec includes: #('Metacello-Issue3758') ];        package: 'Metacello-Issue3758'          with: [ spec requires: #('Metacello-TestsMC') ];        yourself ].  spec    for: #'pharo1.3.x'    do: [       spec        package: 'Metacello-TestsMC'          with: [ spec includes: #('Metacello-Issue3758') ];        package: 'Metacello-Issue3758'          with: [ spec requires: #('Metacello-TestsMC') ];        yourself ].  spec    for: #'pharo2.x'    do: [       spec        package: 'Metacello-Platform' with: 'Metacello-Platform.pharo20';        yourself ].  spec    for: #'squeak'    do: [       spec        package: 'Metacello-Platform' with: 'Metacello-Platform.squeak';        yourself ].  spec    for: #'gemstone'    do: [       spec        project: 'Monticello'          with: [               spec                className: 'ConfigurationOfGsMonticello';                repository:                    'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];        project: 'OB'          with: [               spec                className: 'ConfigurationOfGsOB';                repository:                    'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];        yourself.      spec        package: 'Metacello-Platform'          with: [               spec                file: 'Metacello-Platform.gemstone';                postLoadDoIt: #'gemstone10beta311PostLoadDoIt';                requires: 'Monticello' ];        package: 'Metacello-TestsPlatform'          with: [               spec                requires: #('Metacello-Platform');                file: 'Metacello-TestsPlatform.gemstone' ];        package: 'OB-Metacello' with: [ spec requires: #('OB') ];        yourself.      spec        group: 'Tests' with: #('Metacello-TestsPlatform');        group: 'TravisCI' with: #('Metacello-TestsPlatform');        yourself ]! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta311: spec	<version: '1.0-beta.31.1-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://seaside.gemstone.com/ss/metacello'.		spec repository: 'http://www.squeaksource.com/metacello'.		spec			project: 'Gofer Core' with: [				spec					className: 'ConfigurationOfGofer';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfGofer';					repository: 'http://www.squeaksource.com/MetacelloRepository';					repository: 'http://seaside.gemstone.com/ss/metacello'. ];			project: 'Gofer Tests' copyFrom: 'Gofer Core' with: [				spec loads: #('Tests' ) ];			yourself.		spec 			package: 'Metacello-Base';			package: 'Metacello-ToolBox' with: [				spec requires: #('Metacello-Base' 'Metacello-Core')];			package: 'Metacello-Core' with: [				spec 					requires: 'Metacello-Base';					includes: #('Metacello-MC' 'Metacello-Platform' ). ];			package: 'Metacello-MC' with: [				spec requires: #('Metacello-Core' 'Gofer Core' ). ];			package: 'Metacello-Platform' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Reference' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Tutorial' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsCore' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsMC' with: [				spec 					postLoadDoIt: #testsMC10beta25PostLoadDoIt;					requires: #('Metacello-MC' 'Gofer Tests' ). ];			package: 'Metacello-TestsReference' with: [				spec requires: #('Metacello-Reference' ). ];			package: 'Metacello-TestsTutorial' with: [				spec requires: #('Metacello-Tutorial' 'Metacello-TestsMC' ). ];			package: 'OB-Metacello' with: [				spec requires: #('Metacello-Platform' 'Metacello-Core' 'Metacello-ToolBox'). ];			yourself.		spec 			group: 'default' with: #('Metacello-Core' 'Metacello-ToolBox' );			group: 'Base Configuration' with: #('Metacello-Base' );			group: 'Core' with: #('default' );			group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference' );			group: 'UI' with: #('OB-Metacello' );			group: 'Tests' with: #('default' 'Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference' );			yourself.].	spec for: #squeakCommon do: [		spec			project: 'Help System' with: [				spec					className: 'ConfigurationOfHelpSystem';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfHelpSystem';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			project: 'OB' with: [				spec					className: 'ConfigurationOfOmniBrowser';					versionString: '1.1-baseline';					loads: #('Core' );					file: 'ConfigurationOfOmniBrowser';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.squeakCommon'. ];			package: 'Metacello-Help' with: [				spec requires: 'Help System'. ];			package: 'OB-Metacello' with: [				spec requires: #('OB' ). ];			yourself.		spec			group: 'default' with: #('Metacello-Help');			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself.].	spec for: #pharo do: [		spec 			project: 'ProfStef' with: [				spec					className: 'ConfigurationOfProfStef';					versionString: '1.0-baseline';					file: 'ConfigurationOfProfStef';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-ProfStef' with: [				spec requires: #('Metacello-Core' 'ProfStef' 'Metacello-ToolBox' ). ];			package: 'Metacello-TestsProfStef' with: [				spec requires: #('Metacello-ProfStef' ). ];			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo';			yourself.		spec			group: 'Tests' with: #('Metacello-TestsProfStef' );			group: 'Tutorial' with: #('Metacello-ProfStef');			yourself.].	spec for: #'pharo1.2.x' do: [		spec 			package: 'Metacello-TestsMC' with: [				spec includes: #( 'Metacello-Issue3758' )];			package: 'Metacello-Issue3758' with: [				spec requires:#( 'Metacello-TestsMC' )];			yourself. ].	spec for: #'pharo1.3.x' do: [		spec 			package: 'Metacello-TestsMC' with: [				spec includes: #( 'Metacello-Issue3758' )];			package: 'Metacello-Issue3758' with: [				spec requires:#( 'Metacello-TestsMC' )];			yourself. ].	spec for: #squeak do: [		spec			package: 'Metacello-Platform' with: 'Metacello-Platform.squeak';			yourself.].	spec for: #gemstone do: [		spec			project: 'Monticello' with: [				spec					className: 'ConfigurationOfGsMonticello';					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'OB' with: [				spec					className: 'ConfigurationOfGsOB';					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			yourself.		spec 			package: 'Metacello-Platform' with: [				spec 					file: 'Metacello-Platform.gemstone';					postLoadDoIt: #gemstone10beta311PostLoadDoIt;					requires: 'Monticello'];			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.gemstone'. ];			package: 'OB-Metacello' with: [				spec requires: #('OB' ). ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself. ].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 6/12/2012 09:37:55.692'!baseline10beta31: spec	<version: '1.0-beta.31-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://seaside.gemstone.com/ss/metacello'.		spec repository: 'http://www.squeaksource.com/metacello'.		spec			project: 'Gofer Core' with: [				spec					className: 'ConfigurationOfGofer';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfGofer';					repository: 'http://www.squeaksource.com/MetacelloRepository';					repository: 'http://seaside.gemstone.com/ss/metacello'. ];			project: 'Gofer Tests' copyFrom: 'Gofer Core' with: [				spec loads: #('Tests' ) ];			yourself.		spec 			package: 'Metacello-Base';			package: 'Metacello-ToolBox' with: [				spec requires: #('Metacello-Base' 'Metacello-Core')];			package: 'Metacello-Core' with: [				spec 					requires: 'Metacello-Base';					includes: #('Metacello-MC' 'Metacello-Platform' ). ];			package: 'Metacello-MC' with: [				spec requires: #('Metacello-Core' 'Gofer Core' ). ];			package: 'Metacello-Platform' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Reference' with: [				spec requires: #('Metacello-MC' ). ];			package: 'Metacello-Tutorial' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsCore' with: [				spec requires: #('Metacello-Core' ). ];			package: 'Metacello-TestsMC' with: [				spec 					postLoadDoIt: #testsMC10beta25PostLoadDoIt;					requires: #('Metacello-MC' 'Gofer Tests' ). ];			package: 'Metacello-TestsReference' with: [				spec requires: #('Metacello-Reference' ). ];			package: 'Metacello-TestsTutorial' with: [				spec requires: #('Metacello-Tutorial' 'Metacello-TestsMC' ). ];			package: 'OB-Metacello' with: [				spec requires: #('Metacello-Platform' 'Metacello-Core' 'Metacello-ToolBox'). ];			yourself.		spec 			group: 'default' with: #('Metacello-Core' 'Metacello-ToolBox' );			group: 'Base Configuration' with: #('Metacello-Base' );			group: 'Core' with: #('default' );			group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference' );			group: 'UI' with: #('OB-Metacello' );			group: 'Tests' with: #('default' 'Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference' );			yourself.].	spec for: #squeakCommon do: [		spec			project: 'Help System' with: [				spec					className: 'ConfigurationOfHelpSystem';					versionString: '1.0-baseline';					loads: #('Core' );					file: 'ConfigurationOfHelpSystem';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			project: 'OB' with: [				spec					className: 'ConfigurationOfOmniBrowser';					versionString: '1.1-baseline';					loads: #('Core' );					file: 'ConfigurationOfOmniBrowser';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.squeakCommon'. ];			package: 'Metacello-Help' with: [				spec requires: 'Help System'. ];			package: 'OB-Metacello' with: [				spec requires: #('OB' ). ];			yourself.		spec			group: 'default' with: #('Metacello-Help');			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself.].	spec for: #pharo do: [		spec 			project: 'ProfStef' with: [				spec					className: 'ConfigurationOfProfStef';					versionString: '1.0-baseline';					file: 'ConfigurationOfProfStef';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Metacello-ProfStef' with: [				spec requires: #('Metacello-Core' 'ProfStef' 'Metacello-ToolBox' ). ];			package: 'Metacello-TestsProfStef' with: [				spec requires: #('Metacello-ProfStef' ). ];			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo';			yourself.		spec			group: 'Tests' with: #('Metacello-TestsProfStef' );			group: 'Tutorial' with: #('Metacello-ProfStef');			yourself.].	spec for: #'pharo1.2.x' do: [		spec 			package: 'Metacello-TestsMC' with: [				spec includes: #( 'Metacello-Issue3758' )];			package: 'Metacello-Issue3758' with: [				spec requires:#( 'Metacello-TestsMC' )];			yourself. ].	spec for: #'pharo1.3.x' do: [		spec 			package: 'Metacello-TestsMC' with: [				spec includes: #( 'Metacello-Issue3758' )];			package: 'Metacello-Issue3758' with: [				spec requires:#( 'Metacello-TestsMC' )];			yourself. ].	spec for: #squeak do: [		spec			package: 'Metacello-Platform' with: 'Metacello-Platform.squeak';			yourself.].	spec for: #gemstone do: [		spec			project: 'Monticello' with: [				spec					className: 'ConfigurationOfGsMonticello';					file: 'ConfigurationOfGsMonticello';					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			yourself.		spec 			package: 'Metacello-Platform' with: [				spec 					file: 'Metacello-Platform.gemstone';					requires: 'Monticello'];			package: 'Metacello-TestsPlatform' with: [				spec 					requires: #('Metacello-Platform' );					file: 'Metacello-TestsPlatform.gemstone'. ];			yourself.		spec			group: 'Tests' with: #('Metacello-TestsPlatform' );			yourself. ].! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'topa 1/28/2015 00:39'!baseline10beta321: spec  <version: '1.0-beta.32.1-baseline'>  spec    for: #'common'    do: [       spec blessing: #'baseline'.      spec repository: 'http://seaside.gemtalksystems.com/ss/metacello'.      spec repository: 'http://smalltalkhub.com/mc/dkh/metacello/main'.      spec        project: 'FileTree'          with: [               spec                className: 'ConfigurationOfFileTree';                versionString: '1.0-baseline';                repository: 'http://ss3.gemtalksystems.com/ss/FileTree' ];        project: 'Gofer'          with: [               spec                className: 'ConfigurationOfGofer';                versionString: '1.0-baseline';                loads: #('Core');                repository: 'http://seaside.gemtalksystems.com/ss/metacello' ];        project: 'Gofer Tests'          copyFrom: 'Gofer'          with: [ spec loads: #('Tests') ];        yourself.      spec        package: 'Metacello-Base';        package: 'Metacello-ToolBox'          with: [ spec requires: #('Metacello-Base' 'Metacello-Core') ];        package: 'Metacello-Core'          with: [               spec                requires: 'Metacello-Base';                includes: #('Metacello-MC' 'Metacello-Platform') ];        package: 'Metacello-FileTree'          with: [ spec requires: #('Metacello-MC' 'FileTree') ];        package: 'Metacello-GitHub'          with: [ spec requires: #('Metacello-MC' 'Metacello-FileTree') ];        package: 'Metacello-MC'          with: [ spec requires: #('Metacello-Core' 'Gofer') ];        package: 'Metacello-Platform'          with: [ spec requires: #('Metacello-MC') ];        package: 'Metacello-Reference'          with: [ spec requires: #('Metacello-MC') ];        package: 'Metacello-Tutorial'          with: [ spec requires: #('Metacello-Core') ];        package: 'Metacello-TestsCore'          with: [ spec requires: #('Metacello-Core') ];        package: 'Metacello-TestsMCResources'          with: [               spec                postLoadDoIt: #'testResourcePostLoadDoIt';                includes: #('Metacello-TestsCommonMC');                requires: #('Metacello-Core') ];        package: 'Metacello-TestsMCCore'          with: [               spec                requires:                  #('Metacello-Core' 'Metacello-TestsCore' 'Metacello-ToolBox' 'Metacello-TestsMCResources') ];        package: 'Metacello-TestsMC'          with: [               spec                requires:                  #('Metacello-MC' 'Gofer Tests' 'Metacello-ToolBox' 'Metacello-GitHub' 'Metacello-TestsMCResources') ];        package: 'Metacello-TestsMCA'          with: [ spec requires: #('Metacello-TestsMC') ];        package: 'Metacello-TestsMCB'          with: [ spec requires: #('Metacello-TestsMC') ];        package: 'Metacello-TestsCommonMC'          with: [               spec                file: 'Metacello-TestsCommonMC.common';                requires: 'Metacello-TestsMCResources' ];        package: 'Metacello-TestsReference'          with: [ spec requires: #('Metacello-Reference') ];        package: 'Metacello-TestsTutorial'          with: [ spec requires: #('Metacello-Tutorial' 'Metacello-TestsMCResources') ];        yourself.      spec        group: 'default' with: #('batch' 'Metacello-ToolBox');        group: 'batch' with: #('Metacello-Core' 'Metacello-GitHub');        group: 'Base Configuration' with: #('Metacello-Base');        group: 'Core' with: #('default');        group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference');        group: 'UI' with: #('default');        group: 'TravisCI_1'          with:            #('Metacello-TestsCore' 'Metacello-TestsReference' 'Metacello-TestsMCCore');        group: 'TravisCI_2' with: #('Metacello-TestsMCA');        group: 'TravisCI_3'          with: #('Metacello-TestsMCB' 'Metacello-TestsTutorial');        group: 'TravisCI' with: #('TravisCI_1' 'TravisCI_2' 'TravisCI_3');        group: 'Tests'          with:            #('Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMCA' 'Metacello-TestsMCB' 'Metacello-TestsReference' 'Metacello-TestsMCCore');        yourself ].  spec    for: #'squeakCommon'    do: [       spec        project: 'HelpSystem'          with: [               spec                className: 'ConfigurationOfHelpSystem';                versionString: '1.0-baseline';                loads: #('Core');                repository: 'http://www.squeaksource.com/MetacelloRepository' ];        yourself.      spec        package: 'Metacello-TestsPlatform'          with: [               spec                requires: #('Metacello-Platform');                file: 'Metacello-TestsPlatform.squeakCommon' ];        package: 'Metacello-Help' with: [ spec requires: 'HelpSystem' ];        yourself.      spec        group: 'Tests' with: #('Metacello-TestsPlatform');        group: 'TravisCI_1' with: #('Metacello-TestsPlatform');        yourself ].  spec    for: #'pharo'    do: [       spec        project: 'OSProcess'          with: [               spec                className: 'ConfigurationOfOSProcess';                versionString: #'stable';                repository: 'http://www.squeaksource.com/MetacelloRepository';                repository: 'http://seaside.gemtalksystems.com/ss/metacello' ];        project: 'ProfStef'          with: [               spec                className: 'ConfigurationOfProfStef';                versionString: #'stable';                repository:                    'http://smalltalkhub.com/mc/PharoExtras/ProfStef/main' ];        yourself.      spec        package: 'Metacello-ProfStef'          with: [ spec requires: #('Metacello-Core' 'ProfStef' 'Metacello-ToolBox') ];        package: 'Metacello-TestsProfStef'          with: [ spec requires: #('Metacello-ProfStef') ];        package: 'Metacello-PharoCommonPlatform'          with: [ spec requires: #('Metacello-MC') ];        package: 'Metacello-Platform'          with: [ spec requires: #('Metacello-PharoCommonPlatform') ];        yourself.      spec        group: 'Tests' with: #('Metacello-TestsProfStef');        group: 'Tutorial' with: #('Metacello-ProfStef');        yourself ].  spec    for: #'pharo1.x'    do: [       spec        package: 'Metacello-Platform'        with: [ spec 				file: 'Metacello-Platform.pharo';				 requires: #('OSProcess') ] ].  spec    for: #'pharo2.x'    do: [       spec        project: 'OSProcess'          with: [ spec repository: 'http://ss3.gemtalksystems.com/ss/MetaRepoForPharo20' ];        yourself.      spec        package: 'Metacello-Platform'          with: [ spec				file: 'Metacello-Platform.pharo20';				requires: #('OSProcess') ];        package: 'Metacello-TestsCommonMC'          with: [ spec file: 'Metacello-TestsCommonMC.pharo20' ];        yourself ].  spec    for: #'pharo3.x'    do: [       spec removeProject: 'OSProcess'.      spec        package: 'Metacello-Platform'          with: [ spec				file: 'Metacello-Platform.pharo30' ];        package: 'Metacello-TestsCommonMC'          with: [ spec file: 'Metacello-TestsCommonMC.pharo20' ];        yourself ].  spec    for: #'squeak'    do: [      spec        project: 'WebClient'          with: [               spec                className: 'ConfigurationOfWebClient';                versionString: #stable;                loads: #('Core');                repository: 'http://www.squeaksource.com/MetacelloRepository';                repository: 'http://ss3.gemtalksystems.com/ss/WebClient' ].      spec        package: 'SqueakSSL-Core' 	    with: [spec repository: 'http://www.squeaksource.com/SqueakSSL'];        package: 'Metacello-Platform'          with: [               spec                file: 'Metacello-Platform.squeak';                requires: #('WebClient' 'SqueakSSL-Core') ];        yourself ].  spec    for: #'gemstone'    do: [       spec        project: 'GsCore'          with: [               spec                className: 'ConfigurationOfGsCore';                versionString: '0.247';                repository:                    'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];        project: 'GsMonticello'          with: [               spec                className: 'ConfigurationOfGsMonticello';                versionString: '0.242';                repository:                    'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];        yourself.      spec        package: 'Metacello-GitHub' with: [ spec requires: #('GsCore') ];        package: 'Metacello-Platform'          with: [               spec                file: 'Metacello-Platform.gemstone';                postLoadDoIt: #'gemstone10beta311PostLoadDoIt';                requires: 'GsMonticello' ];        package: 'Metacello-TestsPlatform'          with: [               spec                requires: #('Metacello-Platform');                file: 'Metacello-TestsPlatform.gemstone' ];        yourself.      spec        group: 'Tests' with: #('Metacello-TestsPlatform');        group: 'TravisCI_1' with: #('Metacello-TestsPlatform');        yourself ]! !!ConfigurationOfMetacello methodsFor: 'baselines' stamp: 'dkh 06/15/2014 13:17'!baseline10beta32: spec  <version: '1.0-beta.32-baseline'>  spec    for: #'common'    do: [       spec blessing: #'baseline'.      spec repository: 'http://seaside.gemtalksystems.com/ss/metacello'.      spec repository: 'http://www.squeaksource.com/metacello'.      spec        project: 'FileTree'          with: [               spec                className: 'ConfigurationOfFileTree';                versionString: '1.0-baseline';                repository: 'http://ss3.gemtalksystems.com/ss/FileTree' ];        project: 'Gofer'          with: [               spec                className: 'ConfigurationOfGofer';                versionString: '1.0-baseline';                loads: #('Core');                repository: 'http://seaside.gemtalksystems.com/ss/metacello' ];        project: 'Gofer Tests'          copyFrom: 'Gofer'          with: [ spec loads: #('Tests') ];        yourself.      spec        package: 'Metacello-Base';        package: 'Metacello-ToolBox'          with: [ spec requires: #('Metacello-Base' 'Metacello-Core') ];        package: 'Metacello-Core'          with: [               spec                requires: 'Metacello-Base';                includes: #('Metacello-MC' 'Metacello-Platform') ];        package: 'Metacello-FileTree'          with: [ spec requires: #('Metacello-MC' 'FileTree') ];        package: 'Metacello-GitHub'          with: [ spec requires: #('Metacello-MC' 'Metacello-FileTree') ];        package: 'Metacello-MC'          with: [ spec requires: #('Metacello-Core' 'Gofer') ];        package: 'Metacello-Platform'          with: [ spec requires: #('Metacello-MC') ];        package: 'Metacello-Reference'          with: [ spec requires: #('Metacello-MC') ];        package: 'Metacello-Tutorial'          with: [ spec requires: #('Metacello-Core') ];        package: 'Metacello-TestsCore'          with: [ spec requires: #('Metacello-Core') ];        package: 'Metacello-TestsMC'          with: [               spec                postLoadDoIt: #'testsMC10beta25PostLoadDoIt';                requires:                    #('Metacello-MC' 'Metacello-TestsCore' 'Gofer Tests' 'Metacello-ToolBox') ];        package: 'Metacello-TestsReference'          with: [ spec requires: #('Metacello-Reference') ];        package: 'Metacello-TestsTutorial'          with: [ spec requires: #('Metacello-Tutorial' 'Metacello-TestsMC') ];        package: 'OB-Metacello'          with: [ spec requires: #('Metacello-Platform' 'Metacello-Core' 'Metacello-ToolBox') ];        yourself.      spec        group: 'default'          with: #('Metacello-Core' 'Metacello-ToolBox' 'Metacello-GitHub');        group: 'batch' with: #('Metacello-Core' 'Metacello-GitHub');        group: 'Base Configuration' with: #('Metacello-Base');        group: 'Core' with: #('default');        group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference');        group: 'UI' with: #('OB-Metacello');        group: 'TravisCI'          with:            #('Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference');        group: 'Tests'          with:            #('default' 'Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMC' 'Metacello-TestsReference');        yourself ].  spec    for: #'squeakCommon'    do: [       spec        project: 'HelpSystem'          with: [               spec                className: 'ConfigurationOfHelpSystem';                versionString: #'1.0-baseline';                loads: #('Core');                repository: 'http://www.squeaksource.com/MetacelloRepository' ];        project: 'OmniBrowser'          with: [               spec                className: 'ConfigurationOfOmniBrowser';                versionString: #'stable';                loads: #('Core');                repository: 'http://www.squeaksource.com/MetacelloRepository' ];        project: 'OSProcess'          with: [               spec                className: 'ConfigurationOfOSProcess';                versionString: #'stable';                repository: 'http://www.squeaksource.com/MetacelloRepository' ];        yourself.      spec        package: 'Metacello-TestsPlatform'          with: [               spec                requires: #('Metacello-Platform');                file: 'Metacello-TestsPlatform.squeakCommon' ];        package: 'Metacello-Help' with: [ spec requires: 'HelpSystem' ];        package: 'OB-Metacello' with: [ spec requires: #('OmniBrowser') ];        yourself.      spec        group: 'Tests' with: #('Metacello-TestsPlatform');        group: 'TravisCI' with: #('Metacello-TestsPlatform');        yourself ].  spec    for: #'pharo'    do: [       spec        project: 'ProfStef'          with: [               spec                className: 'ConfigurationOfProfStef';                versionString: #'stable';                repository: 'http://www.squeaksource.com/MetacelloRepository' ];        yourself.      spec        package: 'Metacello-ProfStef'          with: [ spec requires: #('Metacello-Core' 'ProfStef' 'Metacello-ToolBox') ];        package: 'Metacello-TestsProfStef'          with: [ spec requires: #('Metacello-ProfStef') ];        package: 'Metacello-Platform'          with: [               spec                file: 'Metacello-Platform.pharo';                requires: #('OSProcess') ];        yourself.      spec        group: 'Tests' with: #('Metacello-TestsProfStef');        group: 'Tutorial' with: #('Metacello-ProfStef');        yourself ].  spec    for: #'pharo2.x'    do: [       spec removeProject: 'OmniBrowser'.      spec        package: 'Metacello-Platform'        with: [ spec file: 'Metacello-Platform.pharo20' ] ].  spec    for: #'squeak'    do: [       spec yourself.      spec        package: 'Metacello-Platform'          with: [               spec                file: 'Metacello-Platform.squeak';                requires: #('OSProcess') ];        yourself ].  spec    for: #'gemstone'    do: [       spec        project: 'GsCore'          with: [               spec                className: 'ConfigurationOfGsCore';                versionString: '0.247';                repository:                    'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];        project: 'GsMonticello'          with: [               spec                className: 'ConfigurationOfGsMonticello';                versionString: '0.242';                repository:                    'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];        project: 'OmniBrowser'          with: [               spec                className: 'ConfigurationOfGsOB';                versionString: #'stable';                repository:                    'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];        yourself.      spec        package: 'Metacello-GitHub' with: [ spec requires: #('GsCore') ];        package: 'Metacello-MC'          with: [ spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt' ];        package: 'Metacello-Platform'          with: [               spec                file: 'Metacello-Platform.gemstone';                postLoadDoIt: #'gemstone10beta311PostLoadDoIt';                requires: 'GsMonticello' ];        package: 'Metacello-TestsPlatform'          with: [               spec                requires: #('Metacello-Platform');                file: 'Metacello-TestsPlatform.gemstone' ];        package: 'OB-Metacello' with: [ spec requires: #('OmniBrowser') ];        yourself.      spec        group: 'Tests' with: #('Metacello-TestsPlatform');        group: 'TravisCI' with: #('Metacello-TestsPlatform');        yourself ]! !!ConfigurationOfMetacello methodsFor: 'symbolic versions' stamp: 'dkh 9/14/2012 16:31'!bleedingEdge: spec    <symbolicVersion: #'bleedingEdge'>    spec for: #'common' version: '1.0-beta.31.1.5-baseline'! !!ConfigurationOfMetacello methodsFor: 'accessing' stamp: 'dkh 6/12/2012 09:37:55.692'!customProjectAttributes    "Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttrributes "    | attributes |    attributes := #(#'Gofer-Core').    Smalltalk        at: #'SystemVersion'        ifPresent: [ :cl |             (cl current version beginsWith: 'Pharo')                ifTrue: [                     (cl current perform: #'highestUpdate') <= 10504                        ifTrue: [ attributes := #(#'Gofer') ] ] ].    ^ attributes! !!ConfigurationOfMetacello methodsFor: 'symbolic versions' stamp: 'dkh 9/10/2012 11:55'!development: spec    <symbolicVersion: #'development'>    spec for: #'common' version: #'notDefined'! !!ConfigurationOfMetacello methodsFor: 'doits' stamp: 'dkh 6/12/2012 09:37:55.692'!gemstone10beta24PreLoadDoIt	"MetacelloGoferLoad>>addVersion: references an IV that no longer exists after version 292 of Metacello-MC"		| wc ancestry versionNumber |	wc := [((Smalltalk at: #GoferPackageReference) name: 'Metacello-MC') workingCopy] 			on: Error 			do: [:ex | ^self ].	(ancestry := wc ancestry ancestors) isEmpty ifTrue: [ ^self ].	versionNumber := (ancestry first name copyAfterLast: $.) asNumber.	versionNumber > 292 ifTrue: [ ^self ].	(Smalltalk at: #MetacelloGoferLoad)		compileMethod: self gemstone10beta24PreLoadMethodString		category: 'accessing'! !!ConfigurationOfMetacello methodsFor: 'doits' stamp: 'dkh 6/12/2012 09:37:55.692'!gemstone10beta24PreLoadMethodString	^'addVersion: aVersion	model addVersion: version'! !!ConfigurationOfMetacello methodsFor: 'doits' stamp: 'dkh 6/12/2012 09:37:55.692'!gemstone10beta311PostLoadDoIt	(Smalltalk at: #MetacelloGemStonePlatform) initialize! !!ConfigurationOfMetacello methodsFor: 'doits' stamp: 'dkh 6/15/2012 16:54'!metacelloPrimeRegistry    (Smalltalk at: #'MetacelloProjectRegistration') perform: #'primeRegistryFromImage'! !!ConfigurationOfMetacello methodsFor: 'doits' stamp: 'dkh 12/18/2013 14:59'!metacelloPrimeRegistryFor10beta32  [ self metacelloPrimeRegistry ]    on: Error    do: [ :ex |       Transcript        cr;        show:            'Error during #metacelloPrimeRegistry:' , ex description printString                , 'You should rerun the command after the load completes' ]! !!ConfigurationOfMetacello methodsFor: 'doits' stamp: 'dkh 05/07/2013 13:32'!postLoadSqueakRestoreGlobalUnderscoreSelectors  (Smalltalk at: #'Scanner')    perform: #'prefAllowUnderscoreSelectors:'    with:      (Smalltalk at: #'MetacelloSqueakOriginalUnderscoreSelectorsPreferenceValue').  Smalltalk    removeKey: #'MetacelloSqueakOriginalUnderscoreSelectorsPreferenceValue'! !!ConfigurationOfMetacello methodsFor: 'doits' stamp: 'dkh 05/07/2013 16:49'!preLoadSqueakEnsureGlobalUnderscoreSelectors  Smalltalk    at: #'MetacelloSqueakOriginalUnderscoreSelectorsPreferenceValue'    put: ((Smalltalk at: #'Scanner') perform: #'prefAllowUnderscoreSelectors').  (Smalltalk at: #'Scanner')    perform: #'prefAllowUnderscoreSelectors:'    with: true.  ($_ perform: #'tokenish')    ifFalse: [       Character        perform: #'compile:classified:'        with:          'tokenish        "Answer whether the receiver is a valid token-character--letter, digit, or        colon."        ^self == $_ or: [self == $: or: [self isLetter or: [self isDigit]]]'        with: 'testing'.      String initialize ]! !!ConfigurationOfMetacello methodsFor: 'symbolic versions' stamp: 'dkh 05/05/2013 16:02'!previewBootstrap: spec  "version to use when bootstrapping the Metacello Preview"  <symbolicVersion: #'previewBootstrap'>  spec for: #'common' version: '1.0-beta.32.1'! !!ConfigurationOfMetacello methodsFor: 'accessing' stamp: 'dkh 9/16/2012 10:43'!project    ^ project        ifNil: [             "Bootstrap Metacello if it is not already loaded"            self class ensureMetacello.            project := (Smalltalk at: #'MetacelloMCProject') new projectAttributes: self customProjectAttributes.	"Create the Metacello project"            (Smalltalk at: #'MetacelloVersionConstructor') on: self project: project.	"Construct the project"            project loadType: #'linear'.	"change to #atomic if desired"            project ]! !!ConfigurationOfMetacello methodsFor: 'symbolic versions' stamp: 'dkh 7/23/2013 09:48'!stable: spec  <symbolicVersion: #'stable'>  spec for: #'common' version: '1.0-beta.31.1.8'! !!ConfigurationOfMetacello methodsFor: 'doits' stamp: 'dkh 07/17/2013 09:20'!testResourcePostLoadDoIt  "reset test resources"  #(#'MetacelloAlternateResource' #'MetacelloAtomicConfigurationResource' #'MetacelloAtomicMonticelloResource' #'MetacelloConfigurationResource' #'MetacelloMonticelloResource' #'MetacelloScriptingResource' #'MetacelloIssue108Resource')    do: [ :className | Smalltalk at: className ifPresent: [ :cls | cls reset ] ]! !!ConfigurationOfMetacello methodsFor: 'doits' stamp: 'dkh 07/17/2013 09:20'!testsMC10beta25PostLoadDoIt  "reset test resources"  self testResourcePostLoadDoIt! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta0: spec	<version: '1.0-beta.0' imports: #('1.0-beta.0-baseline')>	spec for: #common do: [		spec blessing: #beta.		spec description: 'Beta release introducing the shiny new API'.		spec author: 'dkh'.		spec timestamp: '10/9/2009 14:13'.		spec 			package: 'Gofer' with: 'Gofer-lr.64';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.266';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.194';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.11';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.24';			package: 'Metacello-ConfigTests' with: 'Metacello-ConfigTests-dkh.6';			package: 'Metacello-ReferenceTests' with: 'Metacello-ReferenceTests-dkh.1'.].	spec for: #gemstone do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.4'.].	spec for: #pharo do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.7'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.1'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta10: spec	<excludedValidationIssues: #('1.0-beta.10' #(noVersionSpecified))>	<version: '1.0-beta.10' imports: #('1.0-beta.5-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- GemStone-specific mods- improve error message for missing import- fix a couple of bugs in spawn new version- if versionString is not specified in project reference, use #latestVersion of the project- ''Update Package Method'' command updates the versionString for project reference to #currentVersion of the project- ''Spawn New Version'' command spawns entry for proejct reference using #currentVersion of the project- latest version of configuration package is loaded if the project reference refers to a version whose blessing is #development- refactor #saveProject- add #transact: to platform to support GemStone optional transactions- define querying protocol (public access)- use literal arrays instead of array constructors _everywhere_- clean up printing- refine querying API- extend tutorial to cover querying API'.		spec author: 'dkh'.		spec timestamp: '10/25/2009 11:34'.		spec 			package: 'Gofer' with: 'Gofer-lr.70';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.285';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.222';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.18';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.17';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.29';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.4';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.1';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.11';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.4'.].	spec for: #gemstone do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.7'.].	spec for: #pharo do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.7'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.3'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta11: spec	<version: '1.0-beta.11' imports: #('1.0-beta.11-baseline' )>	spec for: #'common' do: [		spec blessing: #'beta'.		spec description: '- pick up latest Gofer package- fix a project version loading bug- printing fix- fix an update packages bug- adjust working version package name calculation- fix current version package name calculation (http://code.google.com/p/metacello/issues/detail?id=4)- doits bugfix- fix a project reference project package bug- add ''Load Latest Packages'' OB command- remove Samples group- save packages fix- must be able to load packages that use directory repositories- GemStone/GLASS support'.		spec author: 'dkh'.		spec timestamp: '10/31/09 11:03:31'.		spec 			package: 'Gofer' with: 'Gofer-lr.76';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.294';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.239';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.18';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.17';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.32';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.4';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.1';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.11';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.4'.].	spec for: #'gemstone' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.7'.].	spec for: #'pharo' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.7'.].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.3'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta12: spec	<version: '1.0-beta.12' imports: #('1.0-beta.11-baseline' )>	spec for: #'common' do: [		spec blessing: #'beta'.		spec description: '-convert to using ConfigurationOfMetacello convention- fix updateRepositories bug (update repository for loaded packages only)- #repositoryFor:from: ... more GLASS support- record last version loaded and list of packages loaded for each configuration (optional)- use last list of packages loaded last when loading packages using tools- improve promptForVersion algorithm to show current version and reduce version list to logical choices- fix version number bug when version is empty. add tests'.		spec author: 'dkh'.		spec timestamp: '11/03/09 11:07:27'.		spec 			package: 'Gofer' with: 'Gofer-lr.76';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.295';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.245';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.18';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.17';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.37';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.4';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.2';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.11';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.4'.].	spec for: #'gemstone' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.7'.].	spec for: #'pharo' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.7'.].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.3'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta13: spec	<version: '1.0-beta.13' imports: #('1.0-beta.13-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- fix a bug in current version algorithm- improve current version algorithm- pick up latest Gofer'.		spec author: 'dkh'.		spec timestamp: '11/5/2009 15:46'.		spec 			package: 'Gofer' with: 'Gofer-lr.77';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.300';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.249';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.18';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.17';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.37';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.4';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.2';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.11';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.4'.].	spec for: #gemstone do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.7'.].	spec for: #pharo do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.7'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.3'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta14: spec	<version: '1.0-beta.14' imports: #('1.0-beta.14-baseline' )>	spec for: #'common' do: [		spec blessing: #'beta'.		spec description: '- improve handling of #development project references. Loader is responsible for ensuring that #development projects have latest package loaded.- use latest Gofer- skip automatic loading of packages when working copy #needsSaving- better loop termination logic for packageSpecsInLoadOrder- fix logic for loading latest version of a project when versionString is not set (use latest, then last version)- collect repositories from just the packages (ignoring projects) ... affects load latest logic- fix #promptForVersion: ... include #development versions in listing- GemStone attributes, now may include: #gemstone #''gs2.x'' #''gs2.3.x'' #''gs2.4.x'' and #''gs3.x'' for finer grainded resolution of Stone version- fix a package loading logic bug found by Doru (loading latest)'.		spec author: 'dkh'.		spec timestamp: '11/16/2009 15:02'.		spec 			package: 'Gofer' with: 'Gofer-lr.83';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.302';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.256';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.18';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.17';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.38';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.4';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.2';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.11';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.4'.].	spec for: #'gemstone' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.9'.].	spec for: #'pharo' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.7'.].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.3'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta15: spec	<version: '1.0-beta.15' imports: #('1.0-beta.14-baseline' )>	spec for: #common do: [		spec blessing: #development.		spec description: '- fix ''Spawn New Version'' command- tweak packageSpec shortcut printing - fine tune use of #overrides:'.		spec author: 'dkh'.		spec timestamp: '11/21/2009 11:49'.		spec 			package: 'Gofer' with: 'Gofer-lr.83';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.302';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.258';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.18';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.17';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.37';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.4';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.2';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.11';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.4'.].	spec for: #gemstone do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.9'.].	spec for: #pharo do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.7'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.3'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta16: spec	<version: '1.0-beta.16' imports: #('1.0-beta.16-baseline' )>	spec for: #'common' do: [		spec blessing: #'beta'.		spec description: '- put Gofer package in Metacello repository'.		spec author: 'dkh'.		spec timestamp: '12/01/09 16:22:42'.		spec 			package: 'Gofer' with: 'Gofer-lr.83';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.302';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.259';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.18';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.17';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.37';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.4';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.2';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.11';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.4'.].	spec for: #'gemstone' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.9'.].	spec for: #'pharo' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.7'.].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.3'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta17: spec	<version: '1.0-beta.17' imports: #('1.0-beta.17-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- fix a branch name problem for working copies- fine tune the ''Update Package Methods'' algorithm- fix Issue 3: http://code.google.com/p/metacello/issues/detail?id=3 ''Save Packages'' save new- fix Issue 12: http://code.google.com/p/metacello/issues/detail?id=12 Wait cursor during load- fix Issue 14: http://code.google.com/p/metacello/issues/detail?id=14 Ftp repository for Pharo & Squeak- fix Issue 19: http://code.google.com/p/metacello/issues/detail?id=19 Bug in Spawn New Version'.		spec author: 'dkh'.		spec timestamp: '12/9/2009 11:13'.		spec 			package: 'Gofer' with: 'Gofer-lr.83';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.306';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.268';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.19';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.17';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.38';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.5';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.2';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.12';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.4'.].	spec for: #gemstone do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.9'.].	spec for: #squeakCommon do: [		spec package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2'.].	spec for: #pharo do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.9'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.3'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta18: spec	<version: '1.0-beta.18' imports: #('1.0-beta.18-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- implement MetacelloVersion>>isPossibleBaseline- fix currentVersion when no packages or projects are in play- fix a Spawn New Version bug- allow for a nil #versionString spec in projects- fix Issue 14: http://code.google.com/p/metacello/issues/detail?id=14 Ftp repository for Squeak only- fix Issue 18: http://code.google.com/p/metacello/issues/detail?id=18 #linear default loadType- fix Issue 21: http://code.google.com/p/metacello/issues/detail?id=21 optional blessing for Spawn New Version- fix Issue 22: http://code.google.com/p/metacello/issues/detail?id=22 Better filter for Branch blessing and lastVersion- fix Issue 23: http://code.google.com/p/metacello/issues/detail?id=23 Use Gofer batch commit for Save Packages- fix Issue 26: http://code.google.com/p/metacello/issues/detail?id=26 New version of Gofer breaks Metacello- port to latest version of Gofer (Gofer-lr.109)'.		spec author: 'dkh'.		spec timestamp: '12/29/2009 16:17'.		spec 			package: 'Gofer' with: 'Gofer-lr.109';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.311';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.281';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.20';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.17';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.40';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.6';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.3';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.15';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.4'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.235'.		spec 			package: 'Gofer' with: 'Gofer-dkh.105';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.279';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.10'.].	spec for: #squeakCommon do: [		spec package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2'.].	spec for: #pharo do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.9'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.4'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta191: spec	<excludedValidationIssues: #('1.0-beta.19.1' #(noVersionSpecified))>	<version: '1.0-beta.19.1' imports: #('1.0-beta.19-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- fix Issue 39: http://code.google.com/p/metacello/issues/detail?id=39 "WB at end of ConfigurationOfPharo load"'.		spec author: 'dkh'.		spec timestamp: '1/8/2010 14:45'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-dkh.319';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.292';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.26';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.17';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.40';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.11';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.3';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.26';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.5'.].	spec for: #'Gofer-Core' do: [		spec package: 'Gofer-Core' with: 'Gofer-Core-AdrianLienhard.114'.].	spec for: #Gofer do: [		spec package: 'Gofer' with: 'Gofer-lr.109'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.11'.].	spec for: #squeakCommon do: [		spec package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2'.].	spec for: #pharo do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.11'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.4'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta19: spec	<excludedValidationIssues: #('1.0-beta.19' #(noVersionSpecified))>	<version: '1.0-beta.19' imports: #('1.0-beta.19-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- "Pure" Refactoring of MetacelloVersionConstructor>>on: (Danie Roux)- fix Issue 7: http://code.google.com/p/metacello/issues/detail?id=7 "#repositoryOverrides: should be in MetacelloMCVersion"- fix Issue 13: http://code.google.com/p/metacello/issues/detail?id=13 "more than one repository per package"- fix Issue 16: http://code.google.com/p/metacello/issues/detail?id=16 "version level predoit/postdoit"- fix Issue 20: http://code.google.com/p/metacello/issues/detail?id=20 "validation in #postLoadDoIt:/#preLoadDoit:"- fix Issue 28: http://code.google.com/p/metacello/issues/detail?id=28 "supplyingAnswers: attribute for packages"- fix Issue 30: http://code.google.com/p/metacello/issues/detail?id=30 "Imported version names"- fix Issue 33: http://code.google.com/p/metacello/issues/detail?id=33 "ensureMetacello should do full bootstrap"- fix Issue 38: http://code.google.com/p/metacello/issues/detail?id=38 "Metacello load fails on Squeak"- port Gofer-lr.109 to GemStone- stop caching packages in Pharo ... can cause trouble if repository off-line- fix problems with GemStone Metacello when runnng without OB- make error handler for #do:displaying: a little more specific - fix a problem when a second version of a package is being requested during atomic load. Must override with newer package.- run with pre and post 10504 Pharo images'.		spec author: 'dkh'.		spec timestamp: '1/8/2010 11:12'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-dkh.319';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.292';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.26';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.17';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.40';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.11';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.3';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.26';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.5'.].	spec for: #'Gofer-Core' do: [		spec package: 'Gofer-Core' with: 'Gofer-Core-AdrianLienhard.114'.].	spec for: #Gofer do: [		spec package: 'Gofer' with: 'Gofer-lr.109'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.11'.].	spec for: #squeakCommon do: [		spec package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2'.].	spec for: #pharo do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.10'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.4'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta1: spec	<version: '1.0-beta.1' imports: #('1.0-beta.0-baseline')>	spec for: #common do: [		spec blessing: #beta.		spec description: 'Bugfixes:- change base version name for spawn method- make sure author and timestamp included by spawn - fix file duplication for spawn method'.		spec author: 'dkh'.		spec timestamp: '10/10/2009 14:58'.		spec 			package: 'Gofer' with: 'Gofer-lr.64';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.268';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.196';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.12';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.25';			package: 'Metacello-ConfigTests' with: 'Metacello-ConfigTests-dkh.7';			package: 'Metacello-ReferenceTests' with: 'Metacello-ReferenceTests-dkh.1'.].	spec for: #gemstone do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.4'.].	spec for: #pharo do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.7'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.1'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta20: spec	<excludedValidationIssues: #('1.0-beta.20' #(noVersionSpecified))>	<version: '1.0-beta.20' imports: #('1.0-beta.19-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- tests for nested #for:do: statements- fix Issue 40: http://code.google.com/p/metacello/issues/detail?id=40 "Tight package/repository coordination lost"- take full advantage of Gofer repository caching- more tests to ensure expected loading behavior- typos fixed in Tutorial (Torsten)'.		spec author: 'DaleHenrichs'.		spec timestamp: '1/14/2010 09:45'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-dkh.319';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.296';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.26';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-tbn.19';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.40';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.11';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.3';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.29';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.5'.].	spec for: #'Gofer-Core' do: [		spec package: 'Gofer-Core' with: 'Gofer-Core-AdrianLienhard.114'.].	spec for: #Gofer do: [		spec package: 'Gofer' with: 'Gofer-lr.109'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.11'.].	spec for: #squeakCommon do: [		spec package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2'.].	spec for: #pharo do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.11'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.4'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta21: spec	<version: '1.0-beta.21' imports: #('1.0-beta.21-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- fix new tests so that they run on GemStone and don''t collide with existing packages- fix Issue 41: http://code.google.com/p/metacello/issues/detail?id=41 "Trouble with nested ProgressInitiationException in certain circumstances"- fix Issue 42: http://code.google.com/p/metacello/issues/detail?id=42 "ConfigurationOfSeaside* should use supplyingAnswers:"- fix Issue 43: http://code.google.com/p/metacello/issues/detail?id=43 "Eliminate use of #versionInfoFor:from:do: "- Metacello now uses Gofer for all of its interactions with Monticello (a few pockets of workingCopy still exist:)- pick up latest Gofer-Core-lr.115 and Gofer-Tests- some more version caching for speed- better workingCopy resolution for MetacelloCachingGoferResolvedReference- adjust tests - no longer inheriting pragmas ... too expensive- introduce valueSupplyingMetacelloAnswers: to work around Pharo Issue 1824 http://code.google.com/p/pharo/issues/detail?id=1824'.		spec author: 'DaleHenrichs'.		spec timestamp: '1/16/2010 12:47'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.321';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.302';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.26';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-tbn.19';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.40';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.11';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.3';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.34';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.5'.].	spec for: #'Gofer-Core' do: [		spec 			package: 'Gofer-Core' with: 'Gofer-Core-lr.115';			package: 'Gofer-Tests' with: 'Gofer-Tests-lr.113'.].	spec for: #Gofer do: [		spec package: 'Gofer' with: 'Gofer-lr.113'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.12'.].	spec for: #squeakCommon do: [		spec package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2'.].	spec for: #pharo do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.12'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.4'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta22: spec	<version: '1.0-beta.22' imports: #('1.0-beta.22-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- fix Issue 36: http://code.google.com/p/metacello/issues/detail?id=36 "Use ConfigurationOfOB for Metacello"- fix Issue 49: http://code.google.com/p/metacello/issues/detail?id=49 "occassional load of older versions of projects"- fix Issue 52: http://code.google.com/p/metacello/issues/detail?id=52 "preload/postload for groups and projects"- MetacelloMCVersion>>resolveToLoadableSpecs: added to supplement query API- support for Metaceller- fix a bug in MetacelloMCProjectSpec>>resolveToAllPackagesIn:visited: when the project spec doesn''t have a versionString specified- ProfStef tutorial (MetacelloCreateConfigurationTutorial)- latest Gofer (Gofer-Core-lr.116 and Gofer-Tests-lr.115)'.		spec author: 'DaleHenrichs'.		spec timestamp: '1/25/2010 14:19'.		spec 			project: 'Gofer Core' with: '1.0';			project: 'Gofer Tests' with: '1.0'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.328';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.312';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.28';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-tbn.19';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.40';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.13';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.3';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.43';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.5'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.13'.].	spec for: #squeakCommon do: [		spec project: 'OB' with: '1.1'.		spec package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2'.].	spec for: #pharo do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.12'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.4'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta23: spec	<version: '1.0-beta.23' imports: #('1.0-beta.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'beta'.		spec description: '- port to Squeak3.9.1-final-7075, Squeak3.10.2-7179-basic, Squeak3.10.2-Trunk-091128 and Squeak3.11-8931-alpha- add #unloadMetacello to MetacelloConfigTemplate- fix Issue25 : http://code.google.com/p/metacello/issues/detail?id=25 "currentVersion cache is too sticky ..."- full frontal assault on findCurrentVersion and currentVersion algorithms ... corner implementation with a brigage of tests- fix a bug in GoferResolvedReference>>compare:using: related to branch comparison found during frontal assault!!- version #versionStatus provides additional info for using currentVersion- deleted a bunch of methods (redundant,  confusing, not interesting and no longer used):  - MetacelloVersion>>isCurrentCovering:  - MetacelloProject>>currentVersionComparison:to:covering:  - MetacelloProject>>currentVersionCovering:  - MetacelloProject>>findCurrentVersion  - MetacelloMCVersionSpec>>isCurrentCovering:  - MetacelloMCVersionSpec>>isPartiallyCurrentAgainst:  - MetacelloMCProjectSpec>>isCurrent  - MetacelloProjectReferenceSpec>>compareVersionForLoad:using:  - MetacelloAbstractPackageSpec>>compareVersionForLoad:using:  - MetacelloMCVersionSpec>>isPartiallyCurrentFor:  - MetacelloProjectReferenceSpec>>isPartiallyCurrentUsing:  - MetacelloMCProjectSpec>>comparePartialVersion:using:  - MetacelloProject>>partialVersionComparison:to:covering:  - MetacelloMCProject>>projectPackage  - MetacelloMCVersionSpec>>currentVersionComparison:covering:  - MetacelloMCVersion>>currentVersionComparison:covering:  - MetacelloVersion>>currentVersionComparison:covering:  - MetacelloProjectReferenceSpec>>isPartiallyCurrentUsing:  - MetacelloMCProjectSpec>>compareVersionForLoad:using:  - MetacelloMCVersionSpec>>isCurrent  - MetacelloPackageSpec>>compareVersion:using:  - MetacelloPackageSpec>>isCurrentUsing:  - MetacelloMCProjectSpec>>compareVersion:using:  - MetacelloMCProjectSpec>>isCurrentUsing:  - MetacelloAbstractPackageSpec>>isCurrentUsing:  - MetacelloGroupSpec>>isCurrentUsing:  - MetacelloProjectReferenceSpec>>isCurrentUsing:  - MetacelloProject>>currentVersionComparison:to:  - MetacelloVersion>>isCurrent  - MetacelloVersionSpec>>isCurrent'.		spec author: 'DaleHenrichs'.		spec timestamp: '02/10/10 09:56:41'.		spec 			project: 'Gofer Core' with: '1.0';			project: 'Gofer Tests' with: '1.0'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.348';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.332';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.28';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-tbn.19';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.40';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.13';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.8';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.66';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.5'.].	spec for: #'gemstone' do: [		spec project: 'Monticello' with: '0.236'.		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.14'.].	spec for: #'squeakCommon' do: [		spec project: 'OB' with: '1.1'.		spec package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2'.].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.13'.].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta2401: spec	<version: '1.0-beta.24.0.1' imports: #('1.0-beta.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'patched'.		spec description: 'picked up from patched 1.0-beta.24 from allen for GLASS 1.0-beta.7.1 on GemStone 3.0'.		spec author: 'DaleHenrichs'.		spec timestamp: '7/16/2010 12:56'.		spec 			project: 'Gofer Core' with: '1.0.1';			project: 'Gofer Tests' with: '1.0.1'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-ao.350';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.334';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.28';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-tbn.19';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.40';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.13';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.8';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.66';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.5'.].	spec for: #'gemstone' do: [		spec project: 'Monticello' with: '0.236'.		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.15'.].	spec for: #'squeakCommon' do: [		spec project: 'OB' with: '1.1'.		spec package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2'.].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.13'.].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta241: spec	<version: '1.0-beta.24.1' imports: #('1.0-beta.22-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- fix Issue 66: http://code.google.com/p/metacello/issues/detail?id=66 "loading latest broken by new code in 1.0-beta.24"'.		spec author: 'DaleHenrichs'.		spec timestamp: '3/17/2010 11:26'.		spec 			project: 'Gofer Core' with: '1.0.1';			project: 'Gofer Tests' with: '1.0.1'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-Dalehenrichs.349';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.Issue66.335';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.28';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-tbn.19';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.40';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.13';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.8';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.66';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.5'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #gemstone10beta24PreLoadDoIt. ];			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.15'.].	spec for: #squeakCommon do: [		spec project: 'OB' with: '1.1'.		spec package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2'.].	spec for: #pharo do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.13'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta24: spec	<version: '1.0-beta.24' imports: #('1.0-beta.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'beta'.		spec description: '- fix a bug in MetacelloMCProjectSpec>>compareCurrentVersion:targetVersionStatus:using: related when calculating current version against a non-standard loader- tweak the loader API a bit for GemStone (performance improvements)- tweak transcript info for atomic load- start using Gofer 1.0.1- adjust conditions that lead to a load conflict error'.		spec author: 'DaleHenrichs'.		spec timestamp: '02/12/10 14:44:01'.		spec 			project: 'Gofer Core' with: '1.0.1';			project: 'Gofer Tests' with: '1.0.1'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-Dalehenrichs.349';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.335';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.28';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-tbn.19';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.40';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.13';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.8';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.66';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.5'.].	spec for: #'gemstone' do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #gemstone10beta24PreLoadDoIt ];			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.15'.].	spec for: #'squeakCommon' do: [		spec project: 'OB' with: '1.1'.		spec package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2'.].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.13'.].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta251: spec	<version: '1.0-beta.25.1' imports: #('1.0-beta.25-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- fix Issue 67: http://code.google.com/p/metacello/issues/detail?id=67 "blessing not generated by MetacelloVersionConstructor>>spawnPackageMethodIn: category: named: sourceVersion: targetVersion: blessing:"'.		spec author: 'DaleHenrichs'.		spec timestamp: '3/23/2010 19:16'.		spec 			project: 'Gofer Core' with: '1.0.2';			project: 'Gofer Tests' with: '1.0.2'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.360';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.386';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.29';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.20';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.55';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.14';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.8';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.90';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.7'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #gemstone10beta24PreLoadDoIt. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.16'.].	spec for: #squeakCommon do: [		spec project: 'OB' with: '1.1.1'.		spec package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2'.].	spec for: #pharo do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.16'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta25: spec	<version: '1.0-beta.25' imports: #('1.0-beta.25-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- pick up Gofer 1.0.2- fix Issue 10: http://code.google.com/p/metacello/issues/detail?id=10 "''save packages'' should recurse through projects"- fix Issue 24: http://code.google.com/p/metacello/issues/detail?id=24 "Gofer #fetch support"- fix Issue 31: http://code.google.com/p/metacello/issues/detail?id=31 "Handle boundary between #atomic and #linear loads ..."- fix Issue 32: http://code.google.com/p/metacello/issues/detail?id=32 "Connect repositories as MCServerDirectory rather than MCDirectory"- fix Issue 48: http://code.google.com/p/metacello/issues/detail?id=48 "Should have #loadReport message for loader..."- fix Issue 56: http://code.google.com/p/metacello/issues/detail?id=56 "save configurtion that uses Gofer>>commit:"- fix Issue 57: http://code.google.com/p/metacello/issues/detail?id=57 "specificy method category for version category in Metacello version constructor"- fix Issue 58: http://code.google.com/p/metacello/issues/detail?id=58 "make #file: optional in project reference specification"- fix Issue 59: http://code.google.com/p/metacello/issues/detail?id=59 "repository overrides should be used for MetacelloPackageSpec>>load"- fix Issue 60: http://code.google.com/p/metacello/issues/detail?id=60 "bypass progress bars...."- fix Issue 64: http://code.google.com/p/metacello/issues/detail?id=64 "update package methods has extra file entry"- fix Issue 66: http://code.google.com/p/metacello/issues/detail?id=66 "loading latest broken by new code in 1.0-beta.24" [MERGE]- #fetch and #fetch: added to MetacelloMcVersion. #fetch and #fetch: correspond to #load and #load: but only download the mcz files to a cacheRepository (controlled by version #loadPolicy)- #fetchProject, #fetchProject:, #updateProject: added to support direct fetch of a project (ala #updateProject)- implement version #record/#record:- implement version #silently: for Issue 60- implement non-interactive commit support using gofer: MetacelloMCProject>>goferCommitProject:, MetacelloPackageSpec>>goferCommitPackage:'.		spec author: 'DaleHenrichs'.		spec timestamp: '3/23/2010 15:24'.		spec 			project: 'Gofer Core' with: '1.0.2';			project: 'Gofer Tests' with: '1.0.2'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.358';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.386';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.29';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.20';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.55';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.14';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.8';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.90';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.7'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #gemstone10beta24PreLoadDoIt. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.16'.].	spec for: #squeakCommon do: [		spec project: 'OB' with: '1.1.1'.		spec package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2'.].	spec for: #pharo do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.16'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta261: spec	<version: '1.0-beta.26.1' imports: #('1.0-beta.25-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- fix and test coverage for bug involving a postload doit with linear load nested inside an atomic load- when loading a project reference, do not load mcz files that are older than the currently loaded mcz files (implicit version request). Older files will be loaded if directly referenced from the project being loaded (explicit version request).- add RETRY logic to handle HTTP droppage'.		spec author: 'DaleHenrichs'.		spec timestamp: '5/12/2010 12:19'.		spec 			project: 'Gofer Core' with: '1.0.2';			project: 'Gofer Tests' with: '1.0.2'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.361';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.404';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.29';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.20';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.55';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.14';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.8';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.98';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.7'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #gemstone10beta24PreLoadDoIt. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.16'.].	spec for: #squeakCommon do: [		spec project: 'OB' with: '1.1.1'.		spec package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2'.].	spec for: #pharo do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.16'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta262: spec	<version: '1.0-beta.26.2' imports: #('1.0-beta.25-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- Pharo1.1 compat for OB-Metacello- fix Issue 77: http://code.google.com/p/metacello/issues/detail?id=77 "later version of Project reference not loaded after old version already loaded"- add MetacelloFetchingMCSpecLoader>>printOn: that prints out loadDirective, thus restoring correct #printOn: behavior for MetacelloNullRecordingMCSpecLoader since tutorial depends upon it..'.		spec author: 'DaleHenrichs'.		spec timestamp: '5/21/2010 16:26 '.		spec 			project: 'Gofer Core' with: '1.0.2';			project: 'Gofer Tests' with: '1.0.2'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.361';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.407';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.29';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.20';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.56';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.14';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.8';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.99';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.7'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #gemstone10beta24PreLoadDoIt. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.16'.].	spec for: #squeakCommon do: [		spec project: 'OB' with: '1.1.1'.		spec package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2'.].	spec for: #pharo do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.16'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta263: spec	<version: '1.0-beta.26.3' imports: #('1.0-beta.25-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- fix Issue 81: http://code.google.com/p/metacello/issues/detail?id=81 "wrong mcz file can be loaded when mcz file has Monticello dependencies"- fix Issue 82: http://code.google.com/p/metacello/issues/detail?id=82 "Metacello and (Windows) file repositories"'.		spec author: 'DaleHenrichs'.		spec timestamp: '6/11/2010 11:26'.		spec 			project: 'Gofer Core' with: '1.0.2';			project: 'Gofer Tests' with: '1.0.2'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-tbn.362';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.409';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.30';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.20';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.56';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.15';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.8';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.102';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.7'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #gemstone10beta24PreLoadDoIt. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.16'.].	spec for: #squeakCommon do: [		spec project: 'OB' with: '1.1.1'.		spec package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2'.].	spec for: #pharo do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.16'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta26: spec	<version: '1.0-beta.26' imports: #('1.0-beta.25-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- put comment in MetacelloMCProject>>#updateProject to warn about refreshing instance.- helper messages: #cacheRepository: and #ignoreImage: added to MetacelloMCVersion- refactor directive hierarchy for post/pre Load directives add #postLoadDo: and #preLoadDo: to round out API- clean up null recording loader with respect to fetch and post/pre load doits- directives weren''t being created correctly for post/pre load doits on packages .... now they are- ConfigurationOfMetacello class>>alternateEnsureMetacello to be used if GemSource repository is inaccessible- assorted tests- #fetchPackage: added to MetacelloPackageSpec taking a MetacelloLoaderPolicy like #fetchProject: for MetacelloMCProjectSpec'.		spec author: 'DaleHenrichs'.		spec timestamp: '4/12/2010 14:27'.		spec 			project: 'Gofer Core' with: '1.0.2';			project: 'Gofer Tests' with: '1.0.2'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.361';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.393';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.29';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.20';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.55';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.14';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.8';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.92';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.7'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #gemstone10beta24PreLoadDoIt. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.16'.].	spec for: #squeakCommon do: [		spec project: 'OB' with: '1.1.1'.		spec package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2'.].	spec for: #pharo do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.16'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta271: spec	<version: '1.0-beta.27.1' imports: #('1.0-beta.27-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- fix for Issue 86 (http://code.google.com/p/metacello/issues/detail?id=86) "project references that are supersets of a loaded project reference appear to be partially loaded"'.		spec author: 'DaleHenrichs'.		spec timestamp: '6/24/2010 20:06'.		spec 			project: 'Gofer Core' with: '1.0.2.1';			project: 'Gofer Tests' with: '1.0.2.1'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.363';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.417';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.20';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.56';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.16';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.8';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.106';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.7'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #gemstone10beta24PreLoadDoIt. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.16'.].	spec for: #squeakCommon do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-tbn.3'.].	spec for: #pharo do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.16'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta272: spec	<version: '1.0-beta.27.2' imports: #('1.0-beta.27-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- OBCmdMetacello >> isActive used #and:and which is deprecated in Pharo 1.1rc4'.		spec author: 'DaleHenrichs'.		spec timestamp: '7/5/2010 09:31'.		spec 			project: 'Gofer Core' with: '1.0.2.1';			project: 'Gofer Tests' with: '1.0.2.1'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.363';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.417';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.20';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.57';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.16';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.8';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.106';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.7'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #gemstone10beta24PreLoadDoIt. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.16'.].	spec for: #squeakCommon do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-tbn.3'.].	spec for: #pharo do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.16'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta273: spec	<version: '1.0-beta.27.3' imports: #('1.0-beta.27-baseline' )>	spec for: #common do: [		spec blessing: #release.		spec description: '- fix for Issue 90: http://code.google.com/p/metacello/issues/detail?id=90 "includes: aglgorithm not aggressive enough"- fix for Issue 92: http://code.google.com/p/metacello/issues/detail?id=92 "Trait does not understand #isMetacelloConfig"'.		spec author: 'DaleHenrichs'.		spec timestamp: '7/29/2010 15:56'.		spec 			project: 'Gofer Core' with: '1.0.2.1';			project: 'Gofer Tests' with: '1.0.2.1'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.364';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.417';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.20';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.58';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.16';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.8';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.107';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.7'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #gemstone10beta24PreLoadDoIt. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.16'.].	spec for: #squeakCommon do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-tbn.3'.].	spec for: #pharo do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.16'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta274: spec	<version: '1.0-beta.27.4' imports: #('1.0-beta.27-baseline' )>	spec for: #common do: [		spec blessing: #release.		spec description: 'fix bugs when trying to stash packages and configurations into a repository.- fix Issue 79: http://code.google.com/p/metacello/issues/detail?id=79 "OB-Metacello should use MetacelloMCProjectSpec>>loadVersion: style default packages instead of lastMetacelloVersionLoad"- best fix for Issue 92: http://code.google.com/p/metacello/issues/detail?id=92 "Trait does not understand #isMetacelloConfig"- fix Issue 93: http://code.google.com/p/metacello/issues/detail?id=93 "poor error message when failing to resolve a package in a repository"- fix Issue 94: http://code.google.com/p/metacello/issues/detail?id=94 "lastVersion vs latestVersion"- fix Issue 95: http://code.google.com/p/metacello/issues/detail?id=95 "Infinite project reference loop"'.		spec author: 'DaleHenrichs'.		spec timestamp: '8/31/2010 15:07'.		spec 			project: 'Gofer Core' with: '1.0.2.1';			project: 'Gofer Tests' with: '1.0.2.1'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.366';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.428';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.21';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.60';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.16';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.8';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.114';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.9'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #gemstone10beta24PreLoadDoIt. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.16'.].	spec for: #squeakCommon do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-tbn.3'.].	spec for: #pharo do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.16'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta275: spec	<version: '1.0-beta.27.5' imports: #('1.0-beta.27-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- fixes needed for new bootstrapping scheme in GemStone3.0- stop using deprecated in Pharo1.2 methods (sortBy:)'.		spec author: 'DaleHenrichs'.		spec timestamp: '11/11/2010 11:29'.		spec 			project: 'Gofer Core' with: '1.0.2.1';			project: 'Gofer Tests' with: '1.0.2.1'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.390';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.445';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.21';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.60';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.16';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.13';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.114';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.9'.].	spec for: #'gemstone' do: [		spec project: 'Monticello' with: '0.239'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt'. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.16'.].	spec for: #'squeakCommon' do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-tbn.3'.].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.16'.].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta276: spec	<version: '1.0-beta.27.6' imports: #('1.0-beta.27-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- fix a bug that prevented gofer from resolving packages in http://www.squeaksource.com/Swazoo'.		spec author: 'DaleHenrichs'.		spec timestamp: '12/13/2010 16:45'.		spec 			project: 'Gofer Core' with: '1.0.2.2';			project: 'Gofer Tests' with: '1.0.2.2'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.390';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.445';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.21';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.60';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.16';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.13';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.114';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.9'.].	spec for: #'gemstone' do: [		spec project: 'Monticello' with: '0.239'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt'. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.16'.].	spec for: #'squeakCommon' do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-tbn.3'.].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.16'.].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta27: spec	<version: '1.0-beta.27' imports: #('1.0-beta.27-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- include Metacello-Help from Torsten- test case confirming that group name can be used "anywhere that project/package name can be used"- fix Issue 85: http://code.google.com/p/metacello/issues/detail?id=85 "Metacello should load from alternate repository"- pick up OB 1.1.4 for Pharo 1.1 compat- redundant repository for Gofer too'.		spec author: 'DaleHenrichs'.		spec timestamp: '6/15/2010 11:02'.		spec 			project: 'Gofer Core' with: '1.0.2.1';			project: 'Gofer Tests' with: '1.0.2.1'.		spec 			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.363';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.415';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.20';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.56';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.16';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.8';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.103';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.7'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #gemstone10beta24PreLoadDoIt. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.16'.].	spec for: #squeakCommon do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-tbn.3'.].	spec for: #pharo do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.16'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta281: spec	<version: '1.0-beta.28.1' imports: #('1.0-beta.28-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- fix MetacelloProject>>stableVersion and MetacelloProject>>lastVersion'.		spec author: 'DaleHenrichs'.		spec timestamp: '1/21/2011 09:33'.		spec 			project: 'Gofer Core' with: '1.0.2.2';			project: 'Gofer Tests' with: '1.0.2.2'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.457';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.505';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.24';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.80';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.17';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.139';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.29';			package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-DaleHenrichs.87'. ].	spec for: #'gemstone' do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt'. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.19'. ].	spec for: #'squeakCommon' do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-DaleHenrichs.9'. ].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: '1.5'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.10';			package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.24'. ].	spec for: #'pharo1.2.x' do: [		spec 			project: 'OB' with: '1.2.3';			project: 'ProfStef' with: '1.6'. ].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.10'. ].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta282: spec	<version: '1.0-beta.28.2' imports: #('1.0-beta.28-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- add #''pharo1.3.x'' attribute- get rid of #sortBy: ... deprecated in Pharo1.2 '.		spec author: 'DaleHenrichs'.		spec timestamp: '1/23/2011 10:46'.		spec 			project: 'Gofer Core' with: '1.0.2.2';			project: 'Gofer Tests' with: '1.0.2.2'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.458';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.505';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.24';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.80';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.17';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.139';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.29';			package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-DaleHenrichs.87'. ].	spec for: #'gemstone' do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt'. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.19'. ].	spec for: #'squeakCommon' do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-DaleHenrichs.9'. ].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: '1.5'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.10';			package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.25'. ].	spec for: #'pharo1.2.x' do: [		spec 			project: 'OB' with: '1.2.3';			project: 'ProfStef' with: '1.6'. ].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.10'. ].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta28311: spec	<version: '1.0-beta.28.3.1.1' imports: #('1.0-beta.28.3.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: '1.0-beta.28.3.1.1 (dkh.603):- cherry pick the clean up repository code from Metacello-TestsMC-dkh.146- tests green in Squeak4.2alpha update #10892  376 run, 375 passes, 1 expected failures, 0 failures, 0 errors, 0 unexpected passes1.0-beta.28.3.1.1 (dkh.604):- clean up a few more repositories ...'.		spec author: 'dkh'.		spec timestamp: '4/18/2011 18:40'.		spec 			project: 'Gofer Core' with: '1.0.5';			project: 'Gofer Tests' with: '1.0.5'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.460';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.507';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.24';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.81';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.17';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.148';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.30';			package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-DaleHenrichs.88'. ].	spec for: #'gemstone' do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt'. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.20'. ].	spec for: #'squeakCommon' do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-DaleHenrichs.9'. ].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: '1.5'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.10';			package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.25'. ].	spec for: #'pharo1.2.x' do: [		spec 			project: 'OB' with: '1.2.3';			project: 'ProfStef' with: '1.6'.		spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.1'. ].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.10'. ].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta2831: spec	<version: '1.0-beta.28.3.1' imports: #('1.0-beta.28.3.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- fix Issue 3758: Metacello has 12 failing tests in 1.2  http://code.google.com/p/pharo/issues/detail?id=3758- well ... add expectedFails for the tests are failing due to the fix for Pharo Issue 3660'.		spec author: 'dkh'.		spec timestamp: '2/25/2011 19:42'.		spec 			project: 'Gofer Core' with: '1.0.2.2';			project: 'Gofer Tests' with: '1.0.2.2'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.460';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.507';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.24';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.81';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.17';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.140';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.29';			package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-DaleHenrichs.88'. ].	spec for: #'gemstone' do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt'. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.20'. ].	spec for: #'squeakCommon' do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-DaleHenrichs.9'. ].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: '1.5'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.10';			package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.25'. ].	spec for: #'pharo1.2.x' do: [		spec 			project: 'OB' with: '1.2.3';			project: 'ProfStef' with: '1.6'.		spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.1'. ].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.10'. ].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta2832: spec	<version: '1.0-beta.28.3.2' imports: #('1.0-beta.28.3.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: '- fix a problem with a "naked" project: call in a version method ... run into this error during automated generation- fix Issue 123: broken development scenario  http://code.google.com/p/metacello/issues/detail?id=123- fix Issue 120:lessons methods disapppeared in Metacello-Tutorial-DaleHenrichs.24  http://code.google.com/p/metacello/issues/detail?id=120- proposed fix for Issue 122: misleading error message regarding stable versions  http://code.google.com/p/metacello/issues/detail?id=122- parrallel current version calculations...(actually found real-life case where parallel is better)- minor toolbox tweak ... commitMethod should be okay with no methodSpec ... just noop- fix Issue 118: dirty package after merge skews currentVersion calculation  http://code.google.com/p/metacello/issues/detail?id=118- MetacelloCurrentVersionTest>>testIssue118 added to validate the fix'.		spec author: 'dkh'.		spec timestamp: '3/20/2011 19:52'.		spec 			project: 'Gofer Core' with: '1.0.2.2';			project: 'Gofer Tests' with: '1.0.2.2'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.463';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.510';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.25';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.81';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.17';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.143';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.29';			package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-dkh.95'. ].	spec for: #'gemstone' do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt'. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.20'. ].	spec for: #'squeakCommon' do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-DaleHenrichs.9'. ].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: '1.5'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.10';			package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.25'. ].	spec for: #'pharo1.2.x' do: [		spec 			project: 'OB' with: '1.2.3';			project: 'ProfStef' with: '1.6'.		spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.1'. ].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.10'. ].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta2833: spec	<version: '1.0-beta.28.3.3' imports: #('1.0-beta.28.3.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- fix Issue 4049: Failing Tests 1.3 Full: MetaCello  http://code.google.com/p/pharo/issues/detail?id=4049'.		spec author: 'dkh'.		spec timestamp: '4/27/2011 02:50'.		spec 			project: 'Gofer Core' with: '1.0.2.2';			project: 'Gofer Tests' with: '1.0.2.2'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.460';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.507';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.24';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.81';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.17';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.140';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.29';			package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-DaleHenrichs.88'. ].	spec for: #'gemstone' do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt'. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.20'. ].	spec for: #'squeakCommon' do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-DaleHenrichs.9'. ].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: '1.5'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.10';			package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.25'. ].	spec for: #'pharo1.2.x' do: [		spec 			project: 'OB' with: '1.2.3';			project: 'ProfStef' with: '1.6'.		spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.1'. ].	spec for: #'pharo1.3.x' do: [		spec 			project: 'OB' with: '1.3';			project: 'ProfStef' with: '1.7'.		spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.1'. ].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.10'. ].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta283: spec	<version: '1.0-beta.28.3' imports: #('1.0-beta.28-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- fix errors in MetacelloVersionValidator class>>populateReasonCodeDescriptions and MetacelloMCVersionValidator class>>populateReasonCodeDescriptions- #sort: needs to be used instead of #sorted: for GemStone3.0 compatability- after sorting reconvert Arrays to OrderedCollections- when saving packages and configuration, dump diffs to Transcript- fix a spot where refresh of package is needed while calculating current version (when in #development)- add #maglev attribute for conditional maglev code [GemStone]'.		spec author: 'DaleHenrichs'.		spec timestamp: '02/02/2011 17:07:53'.		spec 			project: 'Gofer Core' with: '1.0.2.2';			project: 'Gofer Tests' with: '1.0.2.2'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.460';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.507';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.24';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.81';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.17';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.140';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.29';			package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-DaleHenrichs.88'. ].	spec for: #'gemstone' do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt'. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.20'. ].	spec for: #'squeakCommon' do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-DaleHenrichs.9'. ].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: '1.5'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.10';			package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.25'. ].	spec for: #'pharo1.2.x' do: [		spec 			project: 'OB' with: '1.2.3';			project: 'ProfStef' with: '1.6'. ].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.10'. ].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta284: spec	<version: '1.0-beta.28.4' imports: #('1.0-beta.28-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: '- open 1.0-beta.28.4 for development- improve MetacelloToolBox class>>stripVersionStringForSelector: algorithm- fix Issue 108:	Need to update Metacello (tests and Gofer config) to integrate changes from Pharo Issue 3660  http://code.google.com/p/metacello/issues/detail?id=108- add MetacelloToolBox class>>stableVersion:for:platformAttribute: for MetacelloBrowser- warn about newer versions when saving modified packages- check for possibly newer versions when saving configuration- testing (so there''s a halt in here too)- warning is better than a halt ... any daypick up patch for Pharo  Issue 3763: assert failure during Decompiler>>popIntoTemporaryVariable:  http://code.google.com/p/pharo/issues/detail?id=3763- integrate the parallel currentVersion calculation ... no ill affectcts yet- another sent but not implemented cleanup for GemStone- fix a problem with a "naked" project: call in a version method ... run into this error during automated generation- proposed fix for Issue 122: misleading error message regarding stable versions  http://code.google.com/p/metacello/issues/detail?id=122- parrallel current version calculations...(actually found real-life case where parallel is better)'.		spec author: 'DaleHenrichs'.		spec timestamp: '3/18/2011 15:47'.		spec 			project: 'Gofer Core' with: '1.0.2.2';			project: 'Gofer Tests' with: '1.0.2.2'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.463';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.509';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.24';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.81';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.17';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.142';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.30';			package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-dkh.94'. ].	spec for: #'gemstone' do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt'. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.20'. ].	spec for: #'squeakCommon' do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-DaleHenrichs.9'. ].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: '1.5'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.10';			package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.25'. ].	spec for: #'pharo1.2.x' do: [		spec 			project: 'OB' with: '1.2.3';			project: 'ProfStef' with: '1.6'. ].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.10'. ].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta285: spec	<version: '1.0-beta.28.5' imports: #('1.0-beta.28.3.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'copy from 1.0-beta.28.3.1.1 ... 1.0-beta.28.5 is a better name:)1.0-beta.28.3.1.1 (dkh.603):- cherry pick the clean up repository code from Metacello-TestsMC-dkh.146- tests green in Squeak4.2alpha update #10892  376 run, 375 passes, 1 expected failures, 0 failures, 0 errors, 0 unexpected passes1.0-beta.28.3.1.1 (dkh.604):- clean up a few more repositories ...'.		spec author: 'dkh'.		spec timestamp: '4/18/2011 18:40'.		spec 			project: 'Gofer Core' with: '1.0.5';			project: 'Gofer Tests' with: '1.0.5'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.461';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.507';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.24';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.81';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.17';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.148';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.30';			package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-DaleHenrichs.88'. ].	spec for: #'gemstone' do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt'. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.20'. ].	spec for: #'squeakCommon' do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-DaleHenrichs.9'. ].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: '1.5'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.10';			package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.25'. ].	spec for: #'pharo1.2.x' do: [		spec 			project: 'OB' with: '1.2.3';			project: 'ProfStef' with: '1.6'.		spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.1'. ].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.10'. ].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta28: spec	<version: '1.0-beta.28' imports: #('1.0-beta.28-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- pick up #versionKey from work done with Simon during ESUG 2010- add MetacelloPlatform>>primeStackCacheWith:doing: from work done with Simon during ESUG 2010- deprecate MetacelloPlatform>>primeStackCacheFor:doing:defaultDictionary:- add primeStackCache tests- dynamic caching for 5x speedup of #currentVersion- standard Pharo version attributes: #''pharo1.x'', #''pharo1.0.x'', #''pharo1.1.x'', #''pharo1.2.x''- throw an error when a version is not found- collapse running zeroes in a version number in absence of a numeric element- introduce MetacelloBaseConfiguration added so that Configurations can have a superclass (not yet ready for use)- introduce symbolic versions.   - #development, #stable, and #bleedingEdge are standard versions.  - a default is defined for #bleedingEdge- fix Issue 100: http://code.google.com/p/metacello/issues/detail?id=100 "last block wins when there are duplicate attribute blocks"- added two new commands for OB-Metacello: ''Validate Configuration'' and ''ValidateConfiguration Version''- MetacelloToolBox added- transferred tutorial lessons to ProfStef- convert OB-Metacello to use MetacelloToolbox API- update comments for api documentation- help browser documentation loaded as part of default group (for Pharo....for now)- speed up running of tests ... 3x faster- postLoad and preLoad doit behavior cleaned up with regards to overriding behaviour using nil arg (i.e.,  stop preload/postload doits)- add Squeak attributes: #''squeak3.10.x'', #''squeak4.1.x'', and #''squeak4.2.x''- fix pharo bug 3516: http://code.google.com/p/pharo/issues/detail?id=3516 "Failing tests in MetaCello"- OB-Metacello commands functional in Pharo1.2'.		spec author: 'DaleHenrichs'.		spec timestamp: '1/17/2011 10:12'.		spec 			project: 'Gofer Core' with: '1.0.2.2';			project: 'Gofer Tests' with: '1.0.2.2'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.455';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.505';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.24';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.80';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.17';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.138';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.29';			package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-DaleHenrichs.87'. ].	spec for: #'gemstone' do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt'. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.19'. ].	spec for: #'squeakCommon' do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-DaleHenrichs.9'. ].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: '1.5'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.10';			package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.24'. ].	spec for: #'pharo1.2.x' do: [		spec 			project: 'OB' with: '1.2.3';			project: 'ProfStef' with: '1.6'. ].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.10'. ].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta28ea0: spec	<version: '1.0-beta.28-ea.0' imports: #('1.0-beta.28-ea-baseline' )>	spec for: #common do: [		spec blessing: #development.		spec description: '- snap off an early access version so folks can play with symbolic versions, etc. while I continue development- pick up #versionKey from work done with Simon during ESUG 2010- add MetacelloPlatform>>primeStackCacheWith:doing: from work done with Simon during ESUG 2010- deprecate MetacelloPlatform>>primeStackCacheFor:doing:defaultDictionary:- add primeStackCache tests- dynamic caching for 5x speedup of #currentVersion- standard Pharo version attributes: #''pharo1.x'', #''pharo1.0.x'', #''pharo1.1.x'', #''pharo1.2.x''- throw an error when a version is not found- collapse running zeroes in a version number in absence of a numeric element- integrated changes from 1.0-beta.27.5- introduce MetacelloBaseConfiguration added so that Configurations can have a superclass (or not)- introduce symbolic versions.   - #development, #stable, and #bleedingEdge are standard versions.  - a default is defined for each of them in the abstract configuration- if versionString not defined for project reference, #bleedingEdge version is used as the default (instead of latest version)- stop using #lastMetacelloVersionLoad altogether- add Configuration validation '.		spec author: 'DaleHenrichs'.		spec timestamp: '11/4/2010 12:35'.		spec 			project: 'Gofer Core' with: '1.0.2.1';			project: 'Gofer Tests' with: '1.0.2.1'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.3';			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.379';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.438';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.23';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.60';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.16';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.12';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.116';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.10'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #gemstone10beta24PreLoadDoIt. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.16'.].	spec for: #squeakCommon do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-tbn.3'.].	spec for: #pharo do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.17'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta28ea1: spec	<version: '1.0-beta.28-ea.1' imports: #('1.0-beta.28-ea-baseline' )>	spec for: #common do: [		spec blessing: #development.		spec description: '- clean up undefined symbols refs in Metacello-Base- adjust validation to provide warning when no version is specified - differentiate between versions not specified, but resolved and versions not resolved in validation- validation for duplicate attribute blocks- fix Issue 100: http://code.google.com/p/metacello/issues/detail?id=100 "last block wins when there are duplicate attribute blocks"- add symbolic versions to version chooser in OB-Metacello- recursive validation option- extended validation to restrict recursive validation of a particular version '.		spec author: 'DaleHenrichs'.		spec timestamp: '11/5/2010 11:13'.		spec 			project: 'Gofer Core' with: '1.0.2.1';			project: 'Gofer Tests' with: '1.0.2.1'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.4';			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.385';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.439';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.23';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.62';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.16';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.12';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.118';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.10'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #gemstone10beta24PreLoadDoIt. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.16'.].	spec for: #squeakCommon do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-tbn.3'.].	spec for: #pharo do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.17'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta28ea2: spec	<version: '1.0-beta.28-ea.2' imports: #('1.0-beta.28-ea-baseline' )>	spec for: #common do: [		spec blessing: #development.		spec description: '- only bleedingEdge has a standard default ... most other versions like #stable and #development should have a static version specidifed instead of a dynamic version- pragma for default version methods i.e., <defaultSymbolicVersion: #bleedingEdge>- symbolic versions (Including default) are resolved during project construction, so all version information is in the spec- changed labels in OB-Metacello to use ''Configuration'' instead of ''Project'', renamed classes to reflect this change- added two new commands for OB-Metacello: ''Validate Configuration'' and ''ValidateConfiguration Version'''.		spec author: 'DaleHenrichs'.		spec timestamp: '11/8/2010 11:22'.		spec 			project: 'Gofer Core' with: '1.0.2.1';			project: 'Gofer Tests' with: '1.0.2.1'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.5';			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.388';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.442';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.23';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.63';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.16';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.12';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.118';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.10'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #gemstone10beta24PreLoadDoIt. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.16'.].	spec for: #squeakCommon do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-tbn.3'.].	spec for: #pharo do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.17'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta28ea3: spec	<version: '1.0-beta.28-ea.3' imports: #('1.0-beta.28-ea.3-baseline' )>	spec for: #common do: [		spec blessing: #development.		spec description: '- add MetacelloMCVersion>>difference: for getting differences between two versions ... primarily listing added/removed/modified mcz files and project version strings.- add loop detection to validation- stop using deprecated in Pharo1.2 methods (sortBy:)- Metacello Tool box'.		spec author: 'DaleHenrichs'.		spec timestamp: '11/12/2010 17:00'.		spec 			project: 'Gofer Core' with: '1.0.2.1';			project: 'Gofer Tests' with: '1.0.2.1'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.5';			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.398';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.453';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.23';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.65';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.16';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.118';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.10';			package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-DaleHenrichs.6'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #gemstone10beta24PreLoadDoIt. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.16'.].	spec for: #squeakCommon do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-tbn.3'.].	spec for: #pharo do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.17'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta28ea4: spec	<version: '1.0-beta.28-ea.4' imports: #('1.0-beta.28-ea.3-baseline' )>	spec for: #common do: [		spec blessing: #development.		spec description: '- additional validation conditions- more tool box work- update ProfStef tutorial to include MetacelloToolBox examples'.		spec author: 'DaleHenrichs'.		spec timestamp: '11/14/2010 15:35'.		spec 			project: 'Gofer Core' with: '1.0.2.1';			project: 'Gofer Tests' with: '1.0.2.1'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.5';			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.401';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.455';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.23';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.66';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.16';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.118';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.10';			package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-DaleHenrichs.11'.].	spec for: #gemstone do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #gemstone10beta24PreLoadDoIt. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.16'.].	spec for: #squeakCommon do: [		spec 			project: 'OB' with: '1.1.4';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-tbn.3'.].	spec for: #pharo do: [		spec project: 'ProfStef' with: '1.0'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.3';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.17'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.5'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta28ea5: spec	<version: '1.0-beta.28-ea.5' imports: #('1.0-beta.28-ea.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: '- transferred tutorial lessons to ProfStef- convert OB-Metacello to use MetacelloToolbox API- validate configuration before saving- portable copyClass for toolbox- use #notDefined when a symbolicVersion is not defined ... that way you can define a symbolic version for #common and "undefine" the symbolic version for #pharo- allow a symbolicVersion to reference another symbolic version ... do loop detection etc...improved- add auto-generated Metacello method and class based Help Browser entries- add ability to exclude validation issues (moral equivalent of expected failure in SUnit)- fine tune recommended development process- update comments for api documentation- help browser documentation loaded as part of default group (for Pharo....for now)'.		spec author: 'DaleHenrichs'.		spec timestamp: '12/1/2010 12:35'.		spec 			project: 'Gofer Core' with: '1.0.3';			project: 'Gofer Tests' with: '1.0.3'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.7';			package: 'Metacello-Core' with: 'Metacello-Core-DaleHenrichs.429';			package: 'Metacello-MC' with: 'Metacello-MC-DaleHenrichs.480';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-DaleHenrichs.24';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.78';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.16';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-DaleHenrichs.118';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-DaleHenrichs.16';			package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-DaleHenrichs.59'.].	spec for: #'gemstone' do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt'. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.18'.].	spec for: #'squeakCommon' do: [		spec 			project: 'OB' with: '1.2.1';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-DaleHenrichs.4'.].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: '1.5'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.7';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.22'.].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.7'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta29: spec	<version: '1.0-beta.29' imports: #('1.0-beta.29-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- fix a problem with a "naked" project: call in a version method ... run into this error during automated generation- fix Issue 123: broken development scenario  http://code.google.com/p/metacello/issues/detail?id=123- fix Issue 120:lessons methods disapppeared in Metacello-Tutorial-DaleHenrichs.24  http://code.google.com/p/metacello/issues/detail?id=120- proposed fix for Issue 122: misleading error message regarding stable versions  http://code.google.com/p/metacello/issues/detail?id=122- parrallel current version calculations...(actually found real-life case where parallel is better)- minor toolbox tweak ... commitMethod should be okay with no methodSpec ... just noop- fix Issue 118: dirty package after merge skews currentVersion calculation  http://code.google.com/p/metacello/issues/detail?id=118- MetacelloCurrentVersionTest>>testIssue118 added to validate the fix- OPEN 1.0-beta.29 FOR DEVELOPMENT ***************** following from 1.0-beta.28.4 merge- improve MetacelloToolBox class>>stripVersionStringForSelector: algorithm- fix Issue 108:	Need to update Metacello (tests and Gofer config) to integrate changes from Pharo Issue 3660  http://code.google.com/p/metacello/issues/detail?id=108- add MetacelloToolBox class>>stableVersion:for:platformAttribute: for MetacelloBrowser- warn about newer versions when saving modified packages- check for possibly newer versions when saving configuration- testing (so there''s a halt in here too)- warning is better than a halt ... any daypick up patch for Pharo  Issue 3763: assert failure during Decompiler>>popIntoTemporaryVariable:  http://code.google.com/p/pharo/issues/detail?id=3763- integrate the parallel currentVersion calculation ... no ill affectcts yet- another sent but not implemented cleanup for GemStone- fix a problem with a "naked" project: call in a version method ... run into this error during automated generation- proposed fix for Issue 122: misleading error message regarding stable versions  http://code.google.com/p/metacello/issues/detail?id=122- parrallel current version calculations...(actually found real-life case where parallel is better)***************** preceding from 1.0-beta.28.4 merge- open 1.0-beta.29 for development- merge 1.0-beta.28.3.2 and 1.0-beta.28.4 development threads- turns out that MetacelloBrowser needs the new development stuff anyway & MetacelloBrowser can live in a development image anyway - MetacelloIssue115TestCase currently in limbo- tests for Issue 115- getting started on a caching scheme for goferReferences for use during the fetch phase ...- SIGNIFICANT speedup for fetch:  - cache repository contents for duration of fetch cycle  - use packageCache (when available) for loading version info1.0-beta.29 (dkh.582):- cache only network-based repositories in MetacelloGofer- clear cacheGofer when setting cacheRepository for MetacelloLoaderPolicy1.0-beta.29 (dkh.583):- clear ensuredMap when setting cacheRepository for MetacelloLoaderPolicy1.0-beta.29 (dkh.584):- add in support for branching configurations (mcz level branch)1.0-beta.29 (dkh.585):- help system loaded by default in Squeak, too- add configuration help support1.0-beta.29 (dkh.588):- config help should allow for inclusion of a class (like custom help)- include MetacelloHelp (if installed) in ConfigurationOfMetacello help..1.0-beta.29 (dkh.590):- in case HelpSystem not installed ...1.0-beta.29 (dkh.591):- better logic for default installation help1.0-beta.29 (dkh.592):- another tweak to logic: #stable version, class-side load, latest version load- fix a bug1.0-beta.29 (dkh.594):- support for update projects command in MetacelloBrowser1.0-beta.29 (dkh.595):- restore a method to avoid upgrade issuestweak1.0-beta.29 (dkh.598):- fixed a bug in MetacelloToolBox class>>saveModifiedDevelopmentPackages:for:description:1.0-beta.29 ():- implement GoferVersionReference>>metacelloPackageNameWithBranch ... improve branching support1.0-beta.29 (dkh.600):- add support for _creating_ configuration branches1.0-beta.29 (dkh.601):- use Gofer 1.0.5 (integerate Pharo branch changes into Squeak and GemStone versions)- clean up repositories left in default MCRepositoryGroup ...1.0-beta.29 (dkh.606):- merge changes from 1.0-beta.28.51.0-beta.29 (dkh.607):- remove expectedFailures ... 1.0-beta.29 (dkh.608):- 379 run, 379 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes- tests finalized for issues 108, 115, and 1181.0-beta.29 (dkh.611):- empty package Metacello-Issue3758, so that expectedFailures aren''t left intact1.0-beta.29 (dkh.612):- better information in transcript on retry1.0-beta.29 (dkh.612):- add MetacelloToolBox class>>currentlyLoadedExtensionClassesInVersion in support of Naviode1.0-beta.29 (dkh.615):- fix Issue 112: direct version load (upgrade) of config doesn''t update already loaded mcz files  http://code.google.com/p/metacello/issues/detail?id=1121.0-beta.29 (dkh.619):- defaultTimeout to be compatible with Squeak test cases'.		spec author: 'dkh'.		spec timestamp: '6/7/2011 16:02'.		spec 			project: 'Gofer Core' with: '1.0.5';			project: 'Gofer Tests' with: '1.0.5'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.465';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.522';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.25';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.81';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.17';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.153';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.31';			package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-dkh.105'. ].	spec for: #'gemstone' do: [		spec project: 'Monticello' with: '0.236'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt'. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-DaleHenrichs.20'. ].	spec for: #'squeakCommon' do: [		spec 			project: 'OB' with: #'stable';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-dkh.11'. ].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: #'stable'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.10';			package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-DaleHenrichs.25'. ].	spec for: #'pharo1.2.x' do: [		spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2'. ].	spec for: #'pharo1.3.x' do: [		spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2'. ].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.10'. ].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta2: spec	<version: '1.0-beta.2' imports: #('1.0-beta.0-baseline')>	spec for: #common do: [		spec blessing: #beta.		spec description: 'Bugfixes:- change name of method used for bootstrapping to avoid confusion with methods actually used for loading.- port to Squeak (Squeak3..10.10.2-Trunk-090912)'.		spec author: 'dkh'.		spec timestamp: '10/12/2009 13:31'.		spec 			package: 'Gofer' with: 'Gofer-dkh.65';			package: 'Metacello-Core' with: [				spec					file: 'Metacello-Core-dkh.268';					includes: #('Metacello-Reference' ) ];			package: 'Metacello-MC' with: 'Metacello-MC-dkh.197';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.12';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.25';			package: 'Metacello-ConfigTests' with: 'Metacello-ConfigTests-dkh.7';			package: 'Metacello-ReferenceTests' with: 'Metacello-ReferenceTests-dkh.1'.].	spec for: #gemstone do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.4'.].	spec for: #pharo do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.7'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.3'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta30: spec	<version: '1.0-beta.30' imports: #('1.0-beta.30-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '1.0-beta.30 (dkh.621):- another round of performance improvements with significant speedups for #currentVersion, #project,  #versionStatus and friends1.0-beta.30 (dkh.622):- minor tweaks for performance enhancements- tweak MetacelloToolBox class>>saveModifiedPackagesAndConfigurationIn:description: so that description is updated when you package updates are needed.1.0-beta.30 (dkh.623):- persistent author initials can be set by defining #''GS_tODE_AuthorInitials'' in UserGlobals with desired author initials string (in support of tODE) [GemStone only]1.0-beta.30 (dkh.624):- allow configuration branches to be used in a project reference (className: is name sans branch, file: is name with branch)1.0-beta.30 (dkh.625):- fix validation when branched configuration is used1.0-beta.30 (dkh.626):- fix Issue 136: load of referenced project can fail with missing version error  http://code.google.com/p/metacello/issues/detail?id=1361.0-beta.30 (dkh.627):- fix Issue 146:unrecognized SystemVersion results in assuming system is on #gemstone...  http://code.google.com/p/metacello/issues/detail?id=146- tests pass in Pharo1.4, though ProfStef apparently has not been ported (yet)'.		spec author: 'dkh'.		spec timestamp: '9/9/2011 15:48'.		spec 			project: 'Gofer Core' with: '1.0.5';			project: 'Gofer Tests' with: '1.0.5'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.467';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.527';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.25';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.81';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.17';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.155';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.32';			package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-DataCurator.106'. ].	spec for: #'gemstone' do: [		spec project: 'Monticello' with: '0.237.2'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt'. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.21'. ].	spec for: #'squeakCommon' do: [		spec 			project: 'OB' with: #'stable';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-dkh.11'. ].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: #'stable'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.10';			package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.27'. ].	spec for: #'pharo1.2.x' do: [		spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2'. ].	spec for: #'pharo1.3.x' do: [		spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2'. ].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.10'. ].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'SeanDeNigris 6/18/2012 20:59'!version10beta3113: spec	<version: '1.0-beta.31.1.3' imports: #('1.0-beta.31.1.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '1.0-beta.31.1.3 (spd.695);- add LatAm squeaksource mirror for dependent projects'.		spec author: 'spd'.		spec timestamp: '06/18/2012 20:57'.		spec 			project: 'Gofer Core' with: '1.0.5.1';			project: 'Gofer Tests' with: '1.0.5.1'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.468';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.531';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.25';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.82';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.17';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.158';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.32';			package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-dkh.107'. ].	spec for: #'gemstone' do: [		spec 			project: 'OB' with: #'stable';			project: 'Monticello' with: '0.242'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt'. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-dkh.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.23'. ].	spec for: #'squeakCommon' do: [		spec 			project: 'OB' with: #'stable';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-dkh.11'. ].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: #'stable'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.10';			package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.27'. ].	spec for: #'pharo1.2.x' do: [		spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2'. ].	spec for: #'pharo1.3.x' do: [		spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2'. ].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.10'. ].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'SeanDeNigris 6/27/2012 22:16'!version10beta3114: spec	<version: '1.0-beta.31.1.4' imports: #('1.0-beta.31.1.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '1.0-beta.31.1.4;- split Platform.pharo package for 2.0'.		spec author: 'spd'.		spec timestamp: '06/27/2012 22:10'.		spec 			project: 'Gofer Core' with: '1.0.5.1';			project: 'Gofer Tests' with: '1.0.5.1'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.468';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.531';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.25';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.82';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.17';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.158';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.32';			package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-dkh.107'. ].	spec for: #'gemstone' do: [		spec 			project: 'OB' with: #'stable';			project: 'Monticello' with: '0.242'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt'. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-dkh.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.23'. ].	spec for: #'squeakCommon' do: [		spec 			project: 'OB' with: #'stable';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-dkh.11'. ].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: #'stable'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.10';			package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.27'. ].	spec for: #'pharo1.2.x' do: [		spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2'. ].	spec for: #'pharo1.3.x' do: [		spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2'. ].		spec for: #'pharo2.x' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo20-SeanDeNigris.28'. ].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.10'. ].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 9/16/2012 18:09'!version10beta3115: spec    <version: '1.0-beta.31.1.5' imports: #('1.0-beta.31.1.5-baseline')>    spec        for: #'common'        do: [             spec blessing: #'release'.            spec                description:                    '1.0-beta.31.1.5;- fis Issue 73 - update Metacello-MC to a version which adds custom project attribute support to MetacelloConfigTemplate  https://github.com/dalehenrich/metacello-work/issues/73- fix Issue 114 - get all of the unit tests passing  https://github.com/dalehenrich/metacello-work/issues/114- fix Issue 120 - nested `version:imports:` cause trouble (1.0-beta.31.1.5)  https://github.com/dalehenrich/metacello-work/issues/120- fix Issue 110 - allow attribute lists in #for:do: statement  https://github.com/dalehenrich/metacello-work/issues/110- fix Issue 69 - MetacelloConfigurationTutorial undefined reference to ToolSet  https://github.com/dalehenrich/metacello-work/issues/69- fix Issue 115 - Version generated from a baseline can have empty package versions in a platform-specific section  https://github.com/dalehenrich/metacello-work/issues/115- support for Issue 129 - deployment scripts  https://github.com/dalehenrich/metacello-work/issues/129'.            spec author: 'dkh'.            spec timestamp: '9/14/2012 16:49'.            spec                project: 'Gofer Core' with: '1.0.5.1';                project: 'Gofer Tests' with: '1.0.5.1'.            spec                package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';                package: 'Metacello-Core' with: 'Metacello-Core-dkh.492';                package: 'Metacello-MC' with: 'Metacello-MC-dkh.664';                package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';                package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.25';                package: 'OB-Metacello' with: 'OB-Metacello-dkh.82';                package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.17';                package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';                package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.351';                package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.33';                package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-dkh.130' ].    spec        for: #'gemstone'        do: [             spec                project: 'OB' with: #'stable';                project: 'Monticello' with: '0.242'.            spec                package: 'Metacello-MC' with: [ spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt' ];                package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-dkh.2';                package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.23' ].    spec        for: #'squeakCommon'        do: [             spec                project: 'OB' with: #'stable';                project: 'Help System' with: '1.1'.            spec                package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';                package: 'Metacello-Help' with: 'Metacello-Help-dkh.11' ].    spec        for: #'pharo'        do: [             spec project: 'ProfStef' with: #'stable'.            spec                package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-dkh.13';                package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-dkh.5';                package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.27' ].    spec for: #'pharo1.0.x' do: [ spec package: 'Metacello-ProfStef' with: 'Metacello-ProfStef.toolset-dkh.12' ].    spec for: #'pharo1.1.x' do: [ spec package: 'Metacello-ProfStef' with: 'Metacello-ProfStef.toolset-dkh.12' ].    spec        for: #'pharo1.2.x'        do: [             spec                package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2';                package: 'Metacello-ProfStef' with: 'Metacello-ProfStef.toolset-dkh.12' ].    spec for: #'pharo1.3.x' do: [ spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2' ].    spec for: #'pharo2.x' do: [ spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo20-SeanDeNigris.28' ].    spec for: #'squeak' do: [ spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.14' ]! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 3/21/2013 15:54'!version10beta3116: spec    <version: '1.0-beta.31.1.6' imports: #('1.0-beta.31.1.5-baseline')>    spec        for: #'common'        do: [             spec blessing: #'release'.            spec                description:                    '1.0-beta.31.1.6 (dkh.753);- fix Issue 141 - squeak4.3.x and squeak4.4.x added as platform attributes  https://github.com/dalehenrich/metacello-work/issues/141'.            spec author: 'dkh'.            spec timestamp: '3/21/2013 14:10'.            spec                project: 'Gofer Core' with: '1.0.5.1';                project: 'Gofer Tests' with: '1.0.5.1'.            spec                package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';                package: 'Metacello-Core' with: 'Metacello-Core-dkh.492';                package: 'Metacello-MC' with: 'Metacello-MC-dkh.664';                package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';                package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.25';                package: 'OB-Metacello' with: 'OB-Metacello-dkh.82';                package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.17';                package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';                package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.351';                package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.33';                package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-dkh.130' ].    spec        for: #'gemstone'        do: [             spec                project: 'OB' with: #'stable';                project: 'Monticello' with: '0.242'.            spec                package: 'Metacello-MC' with: [ spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt' ];                package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-dkh.2';                package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.23' ].    spec        for: #'squeakCommon'        do: [             spec                project: 'OB' with: #'stable';                project: 'Help System' with: '1.1'.            spec                package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';                package: 'Metacello-Help' with: 'Metacello-Help-dkh.11' ].    spec        for: #'pharo'        do: [             spec project: 'ProfStef' with: #'stable'.            spec                package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-dkh.13';                package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-dkh.5';                package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.27' ].    spec for: #'pharo1.0.x' do: [ spec package: 'Metacello-ProfStef' with: 'Metacello-ProfStef.toolset-dkh.12' ].    spec for: #'pharo1.1.x' do: [ spec package: 'Metacello-ProfStef' with: 'Metacello-ProfStef.toolset-dkh.12' ].    spec        for: #'pharo1.2.x'        do: [             spec                package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2';                package: 'Metacello-ProfStef' with: 'Metacello-ProfStef.toolset-dkh.12' ].    spec for: #'pharo1.3.x' do: [ spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2' ].    spec for: #'pharo2.x' do: [ spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo20-SeanDeNigris.28' ].    spec for: #'squeak' do: [ spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.17' ]! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 06/29/2013 08:23'!version10beta3117: spec  <version: '1.0-beta.31.1.7' imports: #('1.0-beta.31.1.7-baseline')>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec description: '1.0-beta.31.1.7 (dkh.774):- fix Issue #172: Metacello-Base bootstrap code and configurations should reference seaside.gemtalksystems.com repos  https://github.com/dalehenrich/metacello-work/issues/172'.      spec author: 'dkh'.      spec timestamp: '6/29/2013 08:23'.      spec        project: 'Gofer Core' with: '1.0.5.1';        project: 'Gofer Tests' with: '1.0.5.1'.      spec        package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';        package: 'Metacello-Core' with: 'Metacello-Core-dkh.492';        package: 'Metacello-MC' with: 'Metacello-MC-dkh.664';        package: 'Metacello-Reference'          with: 'Metacello-Reference-DaleHenrichs.31';        package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.25';        package: 'OB-Metacello' with: 'OB-Metacello-dkh.82';        package: 'Metacello-TestsReference'          with: 'Metacello-TestsReference-DaleHenrichs.17';        package: 'Metacello-TestsCore'          with: 'Metacello-TestsCore-DaleHenrichs.14';        package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.351';        package: 'Metacello-TestsTutorial'          with: 'Metacello-TestsTutorial-dkh.33';        package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-dkh.130' ].  spec    for: #'gemstone'    do: [       spec        project: 'OB' with: #'stable';        project: 'Monticello' with: '0.242'.      spec        package: 'Metacello-MC'          with: [ spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt' ];        package: 'Metacello-TestsPlatform'          with: 'Metacello-TestsPlatform.gemstone-dkh.2';        package: 'Metacello-Platform'          with: 'Metacello-Platform.gemstone-dkh.23' ].  spec    for: #'squeakCommon'    do: [       spec        project: 'OB' with: #'stable';        project: 'Help System' with: '1.1'.      spec        package: 'Metacello-TestsPlatform'          with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';        package: 'Metacello-Help' with: 'Metacello-Help-dkh.11' ].  spec    for: #'pharo'    do: [       spec project: 'ProfStef' with: #'stable'.      spec        package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-dkh.13';        package: 'Metacello-TestsProfStef'          with: 'Metacello-TestsProfStef-dkh.5';        package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.27' ].  spec    for: #'pharo1.0.x'    do: [ spec package: 'Metacello-ProfStef' with: 'Metacello-ProfStef.toolset-dkh.12' ].  spec    for: #'pharo1.1.x'    do: [ spec package: 'Metacello-ProfStef' with: 'Metacello-ProfStef.toolset-dkh.12' ].  spec    for: #'pharo1.2.x'    do: [       spec        package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2';        package: 'Metacello-ProfStef' with: 'Metacello-ProfStef.toolset-dkh.12' ].  spec    for: #'pharo1.3.x'    do: [ spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2' ].  spec    for: #'pharo2.x'    do: [       spec        package: 'Metacello-Platform'        with: 'Metacello-Platform.pharo20-SeanDeNigris.28' ].  spec    for: #'squeak'    do: [ spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.17' ]! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 7/23/2013 16:31'!version10beta3118: spec  <version: '1.0-beta.31.1.8' imports: #('1.0-beta.31.1.7-baseline')>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec description: '1.0-beta.31.1.8 (dkh.789):- fix Issue #188: Problems using <version:imports:> for structural reasons  https://github.com/dalehenrich/metacello-work/issues/188'.      spec author: 'dkh'.      spec timestamp: '7/23/2013 09:48'.      spec        project: 'Gofer Core' with: '1.0.5.1';        project: 'Gofer Tests' with: '1.0.5.1'.      spec        package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';        package: 'Metacello-Core' with: 'Metacello-Core-dkh.494';        package: 'Metacello-MC' with: 'Metacello-MC-dkh.664';        package: 'Metacello-Reference'          with: 'Metacello-Reference-DaleHenrichs.31';        package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.25';        package: 'OB-Metacello' with: 'OB-Metacello-dkh.82';        package: 'Metacello-TestsReference'          with: 'Metacello-TestsReference-DaleHenrichs.17';        package: 'Metacello-TestsCore'          with: 'Metacello-TestsCore-DaleHenrichs.14';        package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.353';        package: 'Metacello-TestsTutorial'          with: 'Metacello-TestsTutorial-dkh.33';        package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-dkh.130' ].  spec    for: #'gemstone'    do: [       spec        project: 'OB' with: #'stable';        project: 'Monticello' with: '0.242'.      spec        package: 'Metacello-MC'          with: [ spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt' ];        package: 'Metacello-TestsPlatform'          with: 'Metacello-TestsPlatform.gemstone-dkh.2';        package: 'Metacello-Platform'          with: 'Metacello-Platform.gemstone-dkh.23' ].  spec    for: #'squeakCommon'    do: [       spec        project: 'OB' with: #'stable';        project: 'Help System' with: '1.1'.      spec        package: 'Metacello-TestsPlatform'          with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';        package: 'Metacello-Help' with: 'Metacello-Help-dkh.11' ].  spec    for: #'pharo'    do: [       spec project: 'ProfStef' with: #'stable'.      spec        package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-dkh.13';        package: 'Metacello-TestsProfStef'          with: 'Metacello-TestsProfStef-dkh.5';        package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.27' ].  spec    for: #'pharo1.0.x'    do: [ spec package: 'Metacello-ProfStef' with: 'Metacello-ProfStef.toolset-dkh.12' ].  spec    for: #'pharo1.1.x'    do: [ spec package: 'Metacello-ProfStef' with: 'Metacello-ProfStef.toolset-dkh.12' ].  spec    for: #'pharo1.2.x'    do: [       spec        package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2';        package: 'Metacello-ProfStef' with: 'Metacello-ProfStef.toolset-dkh.12' ].  spec    for: #'pharo1.3.x'    do: [ spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2' ].  spec    for: #'pharo2.x'    do: [       spec        package: 'Metacello-Platform'        with: 'Metacello-Platform.pharo20-SeanDeNigris.28' ].  spec    for: #'squeak'    do: [ spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.17' ]! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta311: spec	<version: '1.0-beta.31.1' imports: #('1.0-beta.31.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '1.0-beta.31.1 (dkh.642);- open 1.0-beta.31.1 for development- GemStone/S 2.4.5 support- missing OB dependency for GemStone1.0-beta.31.1 (dkh.643);- GsMonticello 0.2421.0-beta.31.1 (dkh.644);- trigger #gemstone10beta311PostLoadDoIt1.0-beta.31.1 (dkh.645);- fix Issue 155: Notification for skipped config loads  http://code.google.com/p/metacello/issues/detail?id=1551.0-beta.31.1 (dkh.646):- help fix GemStone Issue 307: http://code.google.com/p/glassdb/issues/detail?id=3071.0-beta.31.1 (dkh.647):- log when loading over modified package ... part of Issue 155'.		spec author: 'dkh'.		spec timestamp: '11/17/2011 13:33'.		spec 			project: 'Gofer Core' with: '1.0.5.1';			project: 'Gofer Tests' with: '1.0.5.1'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.468';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.531';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.25';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.82';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.17';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.158';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.32';			package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-dkh.107'. ].	spec for: #'gemstone' do: [		spec 			project: 'OB' with: #'stable';			project: 'Monticello' with: '0.242'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt'. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-dkh.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.23'. ].	spec for: #'squeakCommon' do: [		spec 			project: 'OB' with: #'stable';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-dkh.11'. ].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: #'stable'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.10';			package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.27'. ].	spec for: #'pharo1.2.x' do: [		spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2'. ].	spec for: #'pharo1.3.x' do: [		spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2'. ].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.10'. ].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta312: spec	<version: '1.0-beta.31.2' imports: #('1.0-beta.31.1-baseline')>	spec		for: #common		do: [ 			spec blessing: #development.			spec				description:					'1.0-beta.31.2 (dkh.649):- fix Issue 163: MetacellMCProjectSpec>>ensureProjectLoaded doesn''t honor cacheRepository: or overrideRepository:  http://code.google.com/p/metacello/issues/detail?id=1631.0-beta.31.2 (dkh.650):- clean up logging for Issue 1631.0-beta.31.2 (dkh.651):- more logging clean up1.0-beta.31.2 (dkh.652):- during ensured configuration loads, need to clear more of the cache.1.0-beta.31.2 (dkh.653):- when loading a new version of a config, ALL references to the project need to be nuked.1.0-beta.31.2 (dkh.654):- cached packages should only be loaded during an ensureLoad.1.0-beta.31.2 (dkh.655):- fix Issue 150: #stable version shouldn''t cause upgrade from project reference  http://code.google.com/p/metacello/issues/detail?id=150'.			spec author: 'dkh'.			spec timestamp: '1/3/2012 11:15'.			spec				project: 'Gofer Core' with: '1.0.5.1';				project: 'Gofer Tests' with: '1.0.5.1'.			spec				package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';				package: 'Metacello-Core' with: 'Metacello-Core-dkh.468';				package: 'Metacello-MC' with: 'Metacello-MC-dkh.538';				package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';				package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.25';				package: 'OB-Metacello' with: 'OB-Metacello-dkh.82';				package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.17';				package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';				package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.161';				package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.32';				package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-dkh.107' ].	spec		for: #gemstone		do: [ 			spec				project: 'OB' with: #stable;				project: 'Monticello' with: '0.242'.			spec				package: 'Metacello-MC' with: [ spec preLoadDoIt: #gemstone10beta24PreLoadDoIt ];				package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-dkh.2';				package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.23' ].	spec		for: #squeakCommon		do: [ 			spec				project: 'OB' with: #stable;				project: 'Help System' with: '1.1'.			spec				package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';				package: 'Metacello-Help' with: 'Metacello-Help-dkh.11' ].	spec		for: #pharo		do: [ 			spec project: 'ProfStef' with: #stable.			spec				package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.10';				package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-DaleHenrichs.1';				package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.27' ].	spec for: #'pharo1.2.x' do: [ spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2' ].	spec for: #'pharo1.3.x' do: [ spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2' ].	spec for: #squeak do: [ spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.10' ]! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta31: spec	<version: '1.0-beta.31' imports: #('1.0-beta.31-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '1.0-beta.31 (dkh.633);- clean up port to GemStone1.0-beta.31 (dkh.635):- fix for GemStone version of Pharo Issue 4613 .... derive attributes from GemStone version string- get Monticello configuration from correct repository1.0-beta.31 (dkh.636):- use Gofer 1.0.5.1 (for GemStone)1.0-beta.31 (dkh.637):- changing the comparison logic for Monticello branches. It used to be that branched Monticello packages had a funky sort order based on lenght of the branch, etc ... total malarkey really. For Metacello when a branched package is compared to a non-branched package that just just fail the comparisons and there is no "latest" relationship in either direction ... this has the effect of forcing an override of non-branched by branched and vice versa. Also if two versions differ in author name only, they compare equal ... no good can come of that situation no matter how you cut it.  Considering that I believe that GemStone is the only place where branched Monticello packages are regularly used in a configuration, I feel pretty confident that if I make GemStone happy everyone else will be happy as well.1.0-beta.31 (dkh.638):- previous checkin was too aggressive ... there needs to be a consistent package ordering scheme or else seesaw loading will ensue- version number is the primary sorting key when package names are the same ... branch then author is used only when version numbers are the same '.		spec author: 'dkh'.		spec timestamp: '10/20/2011 14:33'.		spec 			project: 'Gofer Core' with: '1.0.5.1';			project: 'Gofer Tests' with: '1.0.5.1'.		spec 			package: 'Metacello-Base' with: 'Metacello-Base-DaleHenrichs.19';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.467';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.529';			package: 'Metacello-Reference' with: 'Metacello-Reference-DaleHenrichs.31';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.25';			package: 'OB-Metacello' with: 'OB-Metacello-DaleHenrichs.81';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-DaleHenrichs.17';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-DaleHenrichs.14';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.157';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.32';			package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-dkh.107'. ].	spec for: #'gemstone' do: [		spec project: 'Monticello' with: '0.237.2'.		spec 			package: 'Metacello-MC' with: [				spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt'. ];			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-dkh.2';			package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.22'. ].	spec for: #'squeakCommon' do: [		spec 			project: 'OB' with: #'stable';			project: 'Help System' with: '1.1'.		spec 			package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.2';			package: 'Metacello-Help' with: 'Metacello-Help-dkh.11'. ].	spec for: #'pharo' do: [		spec project: 'ProfStef' with: #'stable'.		spec 			package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-DaleHenrichs.10';			package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-DaleHenrichs.1';			package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.27'. ].	spec for: #'pharo1.2.x' do: [		spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2'. ].	spec for: #'pharo1.3.x' do: [		spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2'. ].	spec for: #'squeak' do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.10'. ].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'topa 1/28/2015 00:43'!version10beta321: spec  <version: '1.0-beta.32.1' imports: #('1.0-beta.32.1-baseline')>  spec    for: #'common'    do: [       spec blessing: #'development'.      spec        description:          '- add squeak4.5.x as platform attribute- minor hack to get Metacello Preview to bootstrap (again) on Squeak4.4 and Squeak4.51.0-beta.32.1 (dkh.758):- Issue #65: port to Pharo-2.0  https://github.com/dalehenrich/metacello-work/issues/651.0-beta.32.1 (dkh.762):- adjust dependencies for tests- fix tests when loaded from mcz files1.0-beta.32.1 (dkh.764):- switch to using http://smalltalkhub.com/mc/dkh/metacello/main as alternate repository to http://seaside.gemstone.com/ss/metacello- fix Issue #151: travis builds hanging for Squeak-4.4 and Squeak4.5  https://github.com/dalehenrich/metacello-work/issues/1511.0-beta.32.1 (dkh.765):- workaround for SmalltalkHub Issue 21: corrupted package .... Metacello-Reference.dkh.35  https://code.google.com/p/smalltalk-hub/issues/detail?id=211.0-beta.32.1 (dkh.767):- workaround for SmalltalkHub Issue 21: corrupted package .... Metacello-TestsPlatform.squeakCommon-dkh.9- bootstrap from Metacello-Base needs to load Metacello-PharoCommonPlatform1.0-beta.32.1 (dkh.774):- fix Issue #172: Metacello-Base bootstrap code and configurations should reference seaside.gemtalksystems.com repos  https://github.com/dalehenrich/metacello-work/issues/1721.0-beta.32.1 (dkh.780):- pick up latest package versions from git repo ... preparing for release1.0-beta.32.1 (dkh.781):- fix Issue #170: location of ConfigurationOfOsProcess for Pharo2.0+ changed  https://github.com/dalehenrich/metacello-work/issues/1701.0-beta.32.1 (dkh.782):- split tests into two groups to avoid travis-ci 30 minute limit- fix google Issue 184: github zip download failures due to filesystem issues  https://code.google.com/p/metacello/issues/detail?id=184- fix Issue #175: MCGitHubRepository and cache  https://github.com/dalehenrich/metacello-work/issues/175- fix Issue #174: `lock` should work with symbolic versions  https://github.com/dalehenrich/metacello-work/issues/174- fix Issue #176: attempt to modify immutable project spec  https://github.com/dalehenrich/metacello-work/issues/176- fix Issue #181: The case for `unconditional` baseline loading  https://github.com/dalehenrich/metacello-work/issues/1811.0-beta.32.1 (dkh.782):- final fix for Issue #187: avoid OSProcess dependency for Pharo3.0  https://github.com/dalehenrich/metacello-work/issues/1811.0-beta.32.1 (dkh.797):- Issue #281: backport PR #2571.0-beta.32.1 (dkh.798):- Issue #281: backport Issue #2271.0-beta.32.1 (dkh.799):- Issue #281: backport Issue #226 fix.- Pick up current WebClient for Squeak, to actually be able to use Metacello on Mac with SqueakSSL'.			spec postLoadDoIt: #metacelloPrimeRegistry.			spec author: 'topa'.			spec timestamp: '1/28/2015 00:42' "printIt: [MetacelloPlatform current timestamp]".			spec project: 'FileTree' with: #stable;				 project: 'Gofer' with: #stable;				 project: 'Gofer Tests' with: #stable.			spec package: 'Metacello-Base' with: 'Metacello-Base-dkh.109';				 package: 'Metacello-Core' with: 'Metacello-Core-dkh.695';				 package: 'Metacello-FileTree' with: 'Metacello-FileTree-dkh.29';				 package: 'Metacello-GitHub' with: 'Metacello-GitHub-dkh.29';				 package: 'Metacello-MC' with: 'Metacello-MC-dkh.680';				 package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.36';				 package: 'Metacello-TestsCommonMC' with: 'Metacello-TestsCommonMC.common-dkh.3';				 package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.35';				 package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.387';				 package: 'Metacello-TestsMCA' with: 'Metacello-TestsMCA-dkh.7';				 package: 'Metacello-TestsMCB' with: 'Metacello-TestsMCB-dkh.13';				 package: 'Metacello-TestsMCCore' with: 'Metacello-TestsMCCore-dkh.5';				 package: 'Metacello-TestsMCResources' with: 'Metacello-TestsMCResources-dkh.4';				 package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.20';				 package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-ChristopheDemarey.41';				 package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-dkh.134';				 package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.26'].	spec		for: #squeakCommon		do: [spec project: 'HelpSystem' with: '1.1'.			spec package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.squeakCommon-dkh.11';				 package: 'Metacello-Help' with: 'Metacello-Help-dkh.12'].	spec		for: #pharo		do: [spec project: 'ProfStef' with: #stable;				 project: 'OSProcess' with: #stable.			spec package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-dkh.13';				 package: 'Metacello-TestsProfStef' with: 'Metacello-TestsProfStef-ChristopheDemarey.5';				 package: 'Metacello-PharoCommonPlatform' with: 'Metacello-PharoCommonPlatform-dkh.3'].	spec		for: #'pharo1.x'		do: [spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.34'].	spec		for: #'pharo1.2.x'		do: [spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2'].	spec		for: #'pharo1.3.x'		do: [spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2'].	spec		for: #'pharo2.x'		do: [spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo20-dkh.40';				 package: 'Metacello-TestsCommonMC' with: 'Metacello-TestsCommonMC.pharo20-dkh.3'].	spec		for: #'pharo3.x'		do: [spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo30-ChristopheDemarey.3';				 package: 'Metacello-TestsCommonMC' with: 'Metacello-TestsCommonMC.pharo20-dkh.3'].	spec		for: #squeak		do: [spec project: 'WebClient' with: #stable;				 package: 'SqueakSSL-Core' with: 'SqueakSSL-Core-ar.26';				 package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-tfel.25'].	spec		for: #gemstone		do: [spec project: 'GsCore' with: '0.247';				 project: 'GsMonticello' with: '0.244.2'.			spec				package: 'Metacello-MC'				with: [spec preLoadDoIt: #gemstone10beta24PreLoadDoIt];				 package: 'Metacello-TestsPlatform' with: 'Metacello-TestsPlatform.gemstone-.6';				 package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.33']! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 12/18/2013 14:59'!version10beta32: spec  <version: '1.0-beta.32' imports: #('1.0-beta.32-baseline')>  spec    for: #'common'    do: [       spec blessing: #'development'.      spec        description:          'equivalent to 6fb14916d605429808f10bb2bc90be8f320beb42snap off a release for GLASS 1.0-beta.9- unimplemented message being sent in MetacelloProjectSpec>>asProjectRegistration  https://github.com/dalehenrich/metacello-work/issues/139- squeak4.3.x and squeak4.4.x added as platform attributes  https://github.com/dalehenrich/metacello-work/issues/140- add squeak4.5.x as platform attribute- minor hack to get Metacello Preview to bootstrap (again) on Squeak4.4 and Squeak4.5'.      spec author: 'dkh'.      spec timestamp: '5/5/2013 14:46'.      spec postLoadDoIt: #'metacelloPrimeRegistryFor10beta32'.      spec        project: 'FileTree' with: '1.0.1';        project: 'Gofer' with: '1.0.5.1';        project: 'Gofer Tests' with: '1.0.5.1'.      spec        package: 'Metacello-Base' with: 'Metacello-Base-dkh.103';        package: 'Metacello-Core' with: 'Metacello-Core-dkh.669';        package: 'Metacello-FileTree' with: 'Metacello-FileTree-dkh.29';        package: 'Metacello-GitHub' with: 'Metacello-GitHub-dkh.22';        package: 'Metacello-MC' with: 'Metacello-MC-dkh.669';        package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.35';        package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.26';        package: 'OB-Metacello' with: 'OB-Metacello-dkh.83';        package: 'Metacello-TestsReference'          with: 'Metacello-TestsReference-dkh.20';        package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.31';        package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.352';        package: 'Metacello-TestsTutorial'          with: 'Metacello-TestsTutorial-dkh.40';        package: 'Metacello-ToolBox' with: 'Metacello-ToolBox-dkh.131' ].  spec    for: #'squeakCommon'    do: [       spec        project: 'OSProcess' with: '4.4.5';        project: 'OmniBrowser' with: #'stable';        project: 'HelpSystem' with: '1.1'.      spec        package: 'Metacello-TestsPlatform'          with: 'Metacello-TestsPlatform.squeakCommon-dkh.8';        package: 'Metacello-Help' with: 'Metacello-Help-dkh.12' ].  spec    for: #'pharo'    do: [       spec project: 'ProfStef' with: #'stable'.      spec        package: 'Metacello-ProfStef' with: 'Metacello-ProfStef-dkh.13';        package: 'Metacello-TestsProfStef'          with: 'Metacello-TestsProfStef-dkh.4';        package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.30' ].  spec    for: #'pharo1.2.x'    do: [ spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2' ].  spec    for: #'pharo1.3.x'    do: [ spec package: 'Metacello-Issue3758' with: 'Metacello-Issue3758-dkh.2' ].  spec    for: #'pharo2.x'    do: [ spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo20-dkh.30' ].  spec    for: #'squeak'    do: [ spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.21' ].  spec    for: #'gemstone'    do: [       spec        project: 'OmniBrowser' with: #'stable';        project: 'GsCore' with: '0.247';        project: 'GsMonticello' with: '0.244.2'.      spec        package: 'Metacello-MC'          with: [ spec preLoadDoIt: #'gemstone10beta24PreLoadDoIt' ];        package: 'Metacello-TestsPlatform'          with: 'Metacello-TestsPlatform.gemstone-dkh.4';        package: 'Metacello-Platform'          with: 'Metacello-Platform.gemstone-dkh.29' ]! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta3: spec	<excludedValidationIssues: #('1.0-beta.3' #(noVersionSpecified))>	<version: '1.0-beta.3' imports: #('1.0-beta.3-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: 'Bugfixes:- update to latest Gofer (Gofer-lr.67)- fix a package overrides: bug- pull in some old tests that still apply- recast tutorial to new API plus tutorial tests- fix platform attribute bug- use strings instead of symbols for imports- class-side project- fix doit bug- tools load ''ALL''- deactive ''Update Repositories'' command'.		spec author: 'dkh'.		spec timestamp: '10/14/2009 10:06'.		spec 			package: 'Gofer' with: 'Gofer-lr.67';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.271';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.201';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.13';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.12';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.27';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.1';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.1';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.2';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.1'.].	spec for: #gemstone do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.4'.].	spec for: #pharo do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.7'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.3'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta4: spec	<excludedValidationIssues: #('1.0-beta.4' #(noVersionSpecified))>	<version: '1.0-beta.4' imports: #('1.0-beta.3-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: 'Bugfixes:- add platform attribute tests- fix bug in project reference- need to pass project into constructor (sometimes)- duplication of #projectAttributes- correct update package logic when package branches involved (<package name>.<branch name>-<author>.<version number>'.		spec author: 'dkh'.		spec timestamp: '10/15/2009 11:41'.		spec 			package: 'Gofer' with: 'Gofer-lr.67';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.273';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.205';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.13';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.12';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.27';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.1';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.1';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.4';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.1'.].	spec for: #gemstone do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.4'.].	spec for: #pharo do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.7'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.3'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta5: spec	<excludedValidationIssues: #('1.0-beta.5' #(noVersionSpecified))>	<version: '1.0-beta.5' imports: #('1.0-beta.5-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- GemStone port- fix a bug in #project:copyFrom:with:- rewrite null loader to use IVs for recording state- get started on project ref tutorial- ensure that imported versions exist- use Gofer for direct loading of packages like from pojects, since configuration must be loaded immediately whether or not w are doing atomic/linear loads- add project load test (coverage for Doru''s bug report)'.		spec author: 'dkh'.		spec timestamp: '10/18/2009 10:41'.		spec 			package: 'Gofer' with: 'Gofer-dkh.68';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.276';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.208';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.15';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.13';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.27';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.2';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.1';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.7';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.2'.].	spec for: #gemstone do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.5'.].	spec for: #pharo do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.7'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.3'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta6: spec	<excludedValidationIssues: #('1.0-beta.6' #(noVersionSpecified))>	<version: '1.0-beta.6' imports: #('1.0-beta.5' )>	spec for: #common do: [		spec blessing: #beta.		spec description: 'Bugfixes:- asNumber throws Error (as of 10487) and Errors are not resumable- bump up ensureMetacello methods to use versions from 1.0-beta.6- use latest version of Gofer'.		spec author: 'dkh'.		spec timestamp: '10/19/2009 10:50'.		spec 			package: 'Gofer' with: 'Gofer-lr.70';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.277';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.209';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.14'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta7: spec	<excludedValidationIssues: #('1.0-beta.7' #(noVersionSpecified))>	<version: '1.0-beta.7' imports: #('1.0-beta.5-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- finish project ref tutorial'.		spec author: 'dkh'.		spec timestamp: '10/19/2009 13:50'.		spec 			package: 'Gofer' with: 'Gofer-lr.70';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.277';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.209';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.15';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.15';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.27';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.2';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.1';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.7';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.3'.].	spec for: #gemstone do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.5'.].	spec for: #pharo do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.7'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.3'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta8: spec	<excludedValidationIssues: #('1.0-beta.8' #(noVersionSpecified))>	<version: '1.0-beta.8' imports: #('1.0-beta.5-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- protect senders of asNumber with error handler'.		spec author: 'dkh'.		spec timestamp: '10/20/2009 11:30'.		spec 			package: 'Gofer' with: 'Gofer-lr.70';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.277';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.210';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.15';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.15';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.27';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.2';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.1';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.7';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.3'.].	spec for: #gemstone do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.5'.].	spec for: #pharo do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.7'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.3'.].! !!ConfigurationOfMetacello methodsFor: 'versions' stamp: 'dkh 6/12/2012 09:37:55.692'!version10beta9: spec	<excludedValidationIssues: #('1.0-beta.9' #(noVersionSpecified))>	<version: '1.0-beta.9' imports: #('1.0-beta.5-baseline' )>	spec for: #common do: [		spec blessing: #beta.		spec description: '- second cut at package query api for MetacellMCVersion requested by Simon, Read the method comments for documentation:	- groups	- packages	- projects	- packagesForSpecNamed:	- allPackagesForSpecNamed:- add #repository:username:password: to configuration API in support of repositories that require authentication.'.		spec author: 'dkh'.		spec timestamp: '10/22/2009 10:38'.		spec 			package: 'Gofer' with: 'Gofer-lr.70';			package: 'Metacello-Core' with: 'Metacello-Core-dkh.279';			package: 'Metacello-MC' with: 'Metacello-MC-dkh.215';			package: 'Metacello-Reference' with: 'Metacello-Reference-dkh.16';			package: 'Metacello-Tutorial' with: 'Metacello-Tutorial-dkh.15';			package: 'OB-Metacello' with: 'OB-Metacello-dkh.27';			package: 'Metacello-TestsReference' with: 'Metacello-TestsReference-dkh.3';			package: 'Metacello-TestsCore' with: 'Metacello-TestsCore-dkh.1';			package: 'Metacello-TestsMC' with: 'Metacello-TestsMC-dkh.10';			package: 'Metacello-TestsTutorial' with: 'Metacello-TestsTutorial-dkh.3'.].	spec for: #gemstone do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.gemstone-dkh.5'.].	spec for: #pharo do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.pharo-dkh.7'.].	spec for: #squeak do: [		spec package: 'Metacello-Platform' with: 'Metacello-Platform.squeak-dkh.3'.].! !"ConfigurationOfMetacello"!SystemOrganization addCategory: #'Metacello-Core-Model'!Magnitude subclass: #MetacelloVersion	instanceVariableNames: 'spec versionNumber importedVersions versionStatus'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Model'!Magnitude variableSubclass: #MetacelloVersionNumber	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Model'!!MetacelloVersionNumber commentStamp: 'dkh 6/22/2012 12:00' prior: 0!# Metacello version formatThanks to [Mozilla Toolkit version format](https://developer.mozilla.org/en/Toolkit_version_format) for inspiration.##Version FormatA version string consists of one or more version parts, separated with dots or dashes.A version part with a leading dot is numeric. A version part with a leading dash is string.The rationale behind splitting a version part into a sequence of strings and numbers is that when comparing version parts, the numeric parts are compared as numbers, e.g. '1.0-pre.1' < '1.0-pre.10', while the strings are compared bytewise. See the next section for details on how versions are compared.##Comparing versionsWhen two version strings are compared, their version parts are compared left to right. Empty parts are ignored.If at some point a version part of one version string is greater than the corresponding version part of another version string, then the first version string is greater than the other one.If a version string has extra parts and the common parts are equal, the shorter version string is less than the longer version string (1.0 is less than 1.0.0).Otherwise, the version strings are equal. ##Comparing version partsVersion parts are also compared left to right, A string-part that exists is always less-then a nonexisting string-part (1.6-a is less than 1.6).Examples```1 == 1. < 1.0 == 1..--0< 1.1-a < 1.1-aa < 1.1-ab < 1.1-b < 1.1-c< 1.1-pre < 1.1-pre.0 < 1.1-pre.1-a < 1.1-pre.1-aa < 1.1-pre.1-b < 1.1-pre.1< 1.1-pre.2< 1.1-pre.10< 1.1 < 1.1.0 < 1.1.00< 1.10< 2.0```!SystemOrganization addCategory: #'Metacello-Core-Exceptions'!Error subclass: #MetacelloCannotUpdateReleasedVersionError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions'!Error subclass: #MetacelloProjectSpecLoadError	instanceVariableNames: 'projectSpec'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions'!MetacelloProjectSpecLoadError subclass: #MetacelloProjectSpecLoadConflict	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions'!Error subclass: #MetacelloVersionDoesNotExistError	instanceVariableNames: 'project versionString'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions'!MetacelloVersionDoesNotExistError subclass: #MetacelloSymbolicVersionDoesNotExistError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions'!MetacelloSymbolicVersionDoesNotExistError subclass: #MetacelloSymbolicVersionNotDefinedError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions'!SystemOrganization addCategory: #'Metacello-Core-Constructors'!Object subclass: #MetacelloAbstractConstructor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!MetacelloAbstractConstructor subclass: #MetacelloAbstractVersionConstructor	instanceVariableNames: 'root configuration project attributeMap attributeOrder symbolicVersion currentContext'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!MetacelloAbstractVersionConstructor subclass: #MetacelloToolBoxConstructor	instanceVariableNames: 'currentSection methodSections'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!MetacelloAbstractVersionConstructor subclass: #MetacelloVersionConstructor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!SystemOrganization addCategory: #'Metacello-Core-Validation'!MetacelloAbstractConstructor subclass: #MetacelloVersionValidator	instanceVariableNames: 'configurationClass exludededValidations validationReport recurse debug visited'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Validation'!MetacelloVersionValidator class	instanceVariableNames: 'reasonCodeDescriptions'!Object subclass: #MetacelloMethodSection	instanceVariableNames: 'attributes'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!MetacelloMethodSection subclass: #MetacelloSymbolicVersionSpec	instanceVariableNames: 'versionString'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!MetacelloMethodSection subclass: #MetacelloVersionMethodSection	instanceVariableNames: 'block versionSpec parent methodSections'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!Object subclass: #MetacelloMethodSpec	instanceVariableNames: 'project selector category versionString methodSections'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!MetacelloMethodSpec subclass: #MetacelloSymbolicVersionMethodSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!MetacelloMethodSpec subclass: #MetacelloVersionMethodSpec	instanceVariableNames: 'imports'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!Object subclass: #MetacelloPlatform	instanceVariableNames: 'bypassProgressBars bypassGoferLoadUpdateCategories'	classVariableNames: 'Current'	poolDictionaries: ''	category: 'Metacello-Core-Model'!Object subclass: #MetacelloProject	instanceVariableNames: 'versionMap symbolicVersionMap loader loaderClass loadType configuration projectAttributes'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Model'!SystemOrganization addCategory: #'Metacello-Core-Specs'!Object subclass: #MetacelloSpec	instanceVariableNames: 'project loader'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!MetacelloSpec subclass: #MetacelloAbstractPackageSpec	instanceVariableNames: 'name requires includes answers'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!MetacelloAbstractPackageSpec subclass: #MetacelloGroupSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!MetacelloAbstractPackageSpec subclass: #MetacelloProjectReferenceSpec	instanceVariableNames: 'projectReference'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!SystemOrganization addCategory: #'Metacello-Core-Members'!MetacelloSpec subclass: #MetacelloMemberListSpec	instanceVariableNames: 'list memberMap'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Members'!MetacelloMemberListSpec subclass: #MetacelloPackagesSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!MetacelloSpec subclass: #MetacelloMemberSpec	instanceVariableNames: 'name spec'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Members'!MetacelloMemberSpec subclass: #MetacelloAddMemberSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Members'!MetacelloMemberSpec subclass: #MetacelloCopyMemberSpec	instanceVariableNames: 'sourceName'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Members'!MetacelloMemberSpec subclass: #MetacelloMergeMemberSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Members'!MetacelloMemberSpec subclass: #MetacelloRemoveMemberSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Members'!MetacelloSpec subclass: #MetacelloProjectSpec	instanceVariableNames: 'name className versionString operator loads preLoadDoIt postLoadDoIt'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!MetacelloSpec subclass: #MetacelloValueHolderSpec	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!MetacelloSpec subclass: #MetacelloVersionSpec	instanceVariableNames: 'versionString blessing description author timestamp preLoadDoIt postLoadDoIt'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!SystemOrganization addCategory: #'Metacello-Core-Loaders'!Object subclass: #MetacelloSpecLoader	instanceVariableNames: 'spec'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Loaders'!Object subclass: #MetacelloValidationIssue	instanceVariableNames: 'configurationClass explanation reasonCode callSite'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Validation'!MetacelloValidationIssue subclass: #MetacelloValidationCriticalWarning	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Validation'!!MetacelloValidationCriticalWarning commentStamp: '<historical>' prior: 0!MetacelloValidationCriticalWarning indicates that there is a logical inconsistency that may not be intentional and that could cause incorrect loads!MetacelloValidationIssue subclass: #MetacelloValidationError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Validation'!!MetacelloValidationError commentStamp: '<historical>' prior: 0!MetacelloValidationError indicates that errors are to be expected if an attempt to use the configuration/version is made!MetacelloValidationIssue subclass: #MetacelloValidationWarning	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Validation'!!MetacelloValidationWarning commentStamp: '<historical>' prior: 0!MetacelloValidationWarning indicates that there is a logical inconsistency that is not likely to cause any functional problems!Array variableSubclass: #MetacelloMethodSectionPath	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!Notification subclass: #MetacelloCleanNotification	instanceVariableNames: 'version'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions'!MetacelloCleanNotification subclass: #MetacelloCleanLoadAndTestsNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions'!MetacelloCleanNotification subclass: #MetacelloCleanLoadNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions'!Notification subclass: #MetacelloClearStackCacheNotification	instanceVariableNames: 'cacheNames'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions'!Notification subclass: #MetacelloSkipDirtyPackageLoad	instanceVariableNames: 'packageSpec'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions'!Notification subclass: #MetacelloStackCacheNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions'!Notification subclass: #MetacelloValidationNotification	instanceVariableNames: 'issue'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions'!!Integer methodsFor: '*metacello-core' stamp: 'dkh 8/13/2009 10:38'!metacelloIntegerLessThanSelf: anInteger	^anInteger < self! !!Integer methodsFor: '*metacello-core' stamp: 'dkh 8/13/2009 12:04'!metacelloStringLessThanSelf: aString	"string version components are always '<' integer component"		^true! !!Integer methodsFor: '*metacello-core' stamp: 'dkh 8/13/2009 10:36'!metacelloVersionComponentLessThan: aMetacelloVersonComponent	^aMetacelloVersonComponent metacelloIntegerLessThanSelf: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 06/03/2009 12:41'!addToMetacelloPackages: aMetacelloPackagesSpec	| spec |	spec := 		(aMetacelloPackagesSpec project packageSpec)			file: self;			yourself.	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec addMember 			name: spec name;			spec: spec;			yourself)! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/14/2009 09:31'!asMetacelloVersionNumber	^MetacelloVersionNumber fromString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/6/2009 11:59'!mergeIntoMetacelloPackages: aMetacelloPackagesSpec	| spec |	spec := 		(aMetacelloPackagesSpec project packageSpec)			file: self;			yourself.	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec mergeMember 			name: spec name;			spec: spec;			yourself)! !!String methodsFor: '*metacello-core-version comparison' stamp: 'dkh 8/13/2009 12:04'!metacelloIntegerLessThanSelf: anInteger	"integer version components are always '>' string component"	^false! !!String methodsFor: '*metacello-core-version comparison' stamp: 'dkh 8/13/2009 11:23'!metacelloStringLessThanSelf: aString	^aString < self! !!String methodsFor: '*metacello-core-version comparison' stamp: 'dkh 8/13/2009 11:22'!metacelloVersionComponentLessThan: aMetacelloVersonComponent	^aMetacelloVersonComponent metacelloStringLessThanSelf: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/6/2009 11:59'!removeFromMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec removeMember 			name: self;			yourself)! !!String methodsFor: '*metacello-core' stamp: 'dkh 10/7/2009 00:13'!setAuthorInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setAuthorWithString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 9/13/2009 07:45'!setAuthorInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setAuthor: 		(aMetacelloVersionSpec project valueHolderSpec			value: self;			yourself)! !!String methodsFor: '*metacello-core' stamp: 'dkh 10/7/2009 00:10'!setBlessingInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setBlessingWithString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2009 11:48'!setBlessingInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setBlessing: 		(aMetacelloVersionSpec project valueHolderSpec			value: self;			yourself)! !!String methodsFor: '*metacello-core' stamp: 'dkh 10/7/2009 00:14'!setDescriptionInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setDescriptionWithString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2009 11:51'!setDescriptionInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setDescription: 		(aMetacelloVersionSpec project valueHolderSpec			value: self;			yourself)! !!String methodsFor: '*metacello-core' stamp: 'dkh 9/23/2009 08:46'!setIncludesInMetacelloPackage: aMetacelloPackageSpec	aMetacelloPackageSpec setIncludes: { self }.! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/8/2009 19:02'!setLoadsInMetacelloProject: aMetacelloPackageSpec	aMetacelloPackageSpec setLoads: { self }.! !!String methodsFor: '*metacello-core' stamp: 'dkh 10/9/2009 11:28'!setPackage: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setPackage: aString withString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 10/9/2009 11:16'!setProject: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setProject: aString withString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/6/2009 10:08'!setRequiresInMetacelloPackage: aMetacelloPackageSpec	aMetacelloPackageSpec setRequires: { self }.! !!String methodsFor: '*metacello-core' stamp: 'dkh 10/7/2009 00:15'!setTimestampInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setTimestampWithString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 9/13/2009 07:47'!setTimestampInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setTimestamp: 		(aMetacelloVersionSpec project valueHolderSpec			value: self;			yourself)! !!MetacelloVersion class methodsFor: 'instance creation' stamp: 'tg 8/30/2009 18:07'!fromSpec: aMetacelloVersionSpec	^(self fromString: aMetacelloVersionSpec versionString) 		spec: aMetacelloVersionSpec;		yourself! !!MetacelloVersion class methodsFor: 'instance creation' stamp: 'dkh 8/31/2009 05:13'!fromString: aString	^self new versionNumber: aString asMetacelloVersionNumber! !!MetacelloVersion methodsFor: 'comparing' stamp: 'dkh 6/14/2009 09:40'!< aMetacelloVersion	aMetacelloVersion species = self species ifFalse: [ ^false ].	^self versionNumber < aMetacelloVersion versionNumber! !!MetacelloVersion methodsFor: 'comparing' stamp: 'dkh 6/14/2009 09:41'!= aMetacelloVersion	aMetacelloVersion species = self species ifFalse: [ ^false ].	^self versionNumber = aMetacelloVersion versionNumber! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 10/13/2009 13:00'!author	^self spec author value! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 8/9/2009 11:48'!blessing	^self spec blessing value! !!MetacelloVersion methodsFor: 'private' stamp: 'dkh 7/8/2011 22:26'!computeVersionStatus	"		#allLoadedToSpec - all projects and packages are loaded and match specification		#loadedToSpec - all loaded projects and packages match specifications (at least one package loaded)		#loadedMatchConstraints - all loaded projects and packages match constraints (at least one package loaded)		#somethingLoaded - at least one package loaded	"	self spec computeVersionStatus: [ :status | ^ status ].	^ #noStatus! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 7/31/2009 11:48'!description	^self spec description value! !!MetacelloVersion methodsFor: 'comparing' stamp: 'dkh 6/14/2009 09:41'!hash	^self versionNumber hash! !!MetacelloVersion methodsFor: 'accessing' stamp: 'dkh 1/7/2010 18:48'!importedVersions	importedVersions == nil ifTrue: [ importedVersions := #() ].	^importedVersions! !!MetacelloVersion methodsFor: 'accessing' stamp: 'dkh 1/7/2010 18:57'!importedVersions: aCollection	importedVersions := aCollection! !!MetacelloVersion methodsFor: 'testing' stamp: 'DaleHenrichs 2/5/2010 10:56'!isAllLoadedToSpec	"all projects and packages are loaded and match specification"		^self spec isAllLoadedToSpec! !!MetacelloVersion methodsFor: 'testing' stamp: 'DaleHenrichs 2/5/2010 11:08'!isLoadedMatchConstraints	"all loaded projects and packages match constraints"		^self spec isLoadedMatchConstraints! !!MetacelloVersion methodsFor: 'testing' stamp: 'DaleHenrichs 2/5/2010 11:07'!isLoadedToSpec	"all loaded projects and packages match specifications"		^self spec isLoadedToSpec! !!MetacelloVersion methodsFor: 'testing' stamp: 'DaleHenrichs 2/4/2010 10:19'!isPossibleBaseline	^self spec isPossibleBaseline! !!MetacelloVersion methodsFor: 'testing' stamp: 'DaleHenrichs 2/5/2010 11:15'!isSomethingLoaded	"at least one project or package has been loaded"		^self spec isSomethingLoaded! !!MetacelloVersion methodsFor: 'actions' stamp: 'dkh 6/8/2009 17:45'!load	^self subclassResponsibility! !!MetacelloVersion methodsFor: 'actions' stamp: 'dkh 6/8/2009 17:45'!load: required	^self subclassResponsibility! !!MetacelloVersion methodsFor: 'querying' stamp: 'DaleHenrichs 10/27/2010 11:30'!loader	^self spec loader! !!MetacelloVersion methodsFor: 'testing' stamp: 'DaleHenrichs 2/8/2010 11:42'!name	^self versionString! !!MetacelloVersion methodsFor: 'printing' stamp: 'DaleHenrichs 11/16/2010 11:14'!printOn: aStream	| label vs |	self blessing ~~ #broken		ifTrue: [ 			(vs := self versionStatus) == #somethingLoaded				ifTrue: [ aStream nextPutAll: '<>' ].			vs == #loadedMatchConstraints				ifTrue: [ aStream nextPutAll: '>=' ].			vs == #loadedToSpec				ifTrue: [ aStream nextPut: $~ ] ].	self versionNumber printOn: aStream.	self spec ~~ nil		ifTrue: [ 			(label := self spec projectLabel) isEmpty				ifFalse: [ aStream nextPutAll: ' [' , label , ']' ] ]! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 6/8/2009 16:03'!project	^self spec project! !!MetacelloVersion methodsFor: 'accessing' stamp: 'DaleHenrichs 3/9/2010 16:32'!projectLabel	^self spec projectLabel! !!MetacelloVersion methodsFor: 'accessing' stamp: 'dkh 05/04/2009 20:26'!spec	^spec! !!MetacelloVersion methodsFor: 'accessing' stamp: 'dkh 05/04/2009 20:26'!spec: aMetacellVersionSpec	spec := aMetacellVersionSpec! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 10/13/2009 13:01'!timestamp	^self spec timestamp value! !!MetacelloVersion methodsFor: 'actions' stamp: 'dkh 05/04/2009 20:26'!unload	^self spec unload! !!MetacelloVersion methodsFor: 'querying' stamp: 'DaleHenrichs 9/22/2010 13:52'!versionKey	"version printString, without the versionStatus decorations, suitable for using as a unique key for the 	 receiver in a dictionary"	^ String streamContents: [:aStream| |label|		self versionNumber printOn: aStream.		self spec ~~ nil			ifTrue: [(label := self spec projectLabel) isEmpty					ifFalse: [aStream nextPutAll: ' [' , label , ']']] ]! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 6/14/2009 09:39'!versionNumber	^versionNumber! !!MetacelloVersion methodsFor: 'accessing' stamp: 'dkh 6/14/2009 09:39'!versionNumber: aVersionNumber	versionNumber := aVersionNumber! !!MetacelloVersion methodsFor: 'accessing' stamp: 'dkh 6/15/2009 20:07'!versionSpec	^self spec! !!MetacelloVersion methodsFor: 'accessing' stamp: 'DaleHenrichs 2/6/2010 16:49'!versionStatus	versionStatus == nil ifTrue: [ versionStatus := self computeVersionStatus].	^versionStatus! !!MetacelloVersion methodsFor: 'accessing' stamp: 'DaleHenrichs 2/4/2010 10:10'!versionStatus: aSymbol	versionStatus := aSymbol! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 8/31/2009 05:11'!versionString	^self versionNumber versionString ! !!MetacelloVersion methodsFor: 'comparing' stamp: 'dkh 6/14/2009 12:42'!~> aMetacelloVersion	aMetacelloVersion species = self species ifFalse: [ ^false ].	^self versionNumber ~> aMetacelloVersion versionNumber! !!MetacelloVersionNumber class methodsFor: 'private' stamp: 'TestRunner 10/19/2009 10:22'!extractNumericComponent: subString	"$. separated components are integers"	| number |	number := [subString asNumber] 						on: Error 						do: [:ex | ex return: subString ].	^number asString = subString		ifTrue: [ number ]		ifFalse: [ subString ]! !!MetacelloVersionNumber class methodsFor: 'instance creation' stamp: 'dkh 8/13/2009 12:20'!fromString: aString	| new components |	components := OrderedCollection new.	(aString findTokens: '.') do: [:subString | | strs |		strs := subString findTokens: '-'.		"first subString token could be an integer"		components add: (self extractNumericComponent: strs first).		strs size > 1			ifTrue: [				"remaining are uncoditionally Strings, because of leading $-"				components addAll: strs allButFirst ]].	new := self new: components size.	1 to: components size do: [:i | new at: i put: (components at: i) ].	^new! !!MetacelloVersionNumber methodsFor: 'comparing' stamp: 'DaleHenrichs 10/6/2010 11:14'!< aMetacelloVersionNumber	| condensed aCondensed |	aMetacelloVersionNumber species = self species		ifFalse: [ ^ false ].	condensed := self collapseZeros.	aCondensed := aMetacelloVersionNumber collapseZeros.	(condensed ~~ self or: [ aCondensed ~~ aMetacelloVersionNumber ])		ifTrue: [ ^ condensed compareLessThan: aCondensed ].	^ self compareLessThan: aMetacelloVersionNumber! !!MetacelloVersionNumber methodsFor: 'comparing' stamp: 'DaleHenrichs 10/6/2010 11:14'!= aMetacelloVersionNumber	| condensed aCondensed |	aMetacelloVersionNumber species = self species		ifFalse: [ ^ false ].	condensed := self collapseZeros.	aCondensed := aMetacelloVersionNumber collapseZeros.	(condensed ~~ self or: [ aCondensed ~~ aMetacelloVersionNumber ])		ifTrue: [ ^ condensed compareEqualTo: aCondensed ].	^ self compareEqualTo: aMetacelloVersionNumber! !!MetacelloVersionNumber methodsFor: 'accessing' stamp: 'dkh 6/14/2009 13:29'!approximateBase	| base |	base := self copyFrom: 1 to: self size - 1.	base at: base size put: (base at: base size) + 1.	^base! !!MetacelloVersionNumber methodsFor: 'converting' stamp: 'dkh 6/14/2009 09:29'!asMetacelloVersionNumber	^self! !!MetacelloVersionNumber methodsFor: 'private' stamp: 'DaleHenrichs 10/16/2010 10:15'!collapseZeros	"the rule must be that zeros can be collapsed as long as the series of zeros ends in a string term"	| collection newSize new j lastElementIsStringOrZero canCollapse |	(self size = 0 or: [ self at: 1 ]) == 0		ifTrue: [ ^ self ].	collection := OrderedCollection new.	lastElementIsStringOrZero := true.	canCollapse := true.	self size to: 1 by: -1 do: [ :i | 		| element |		element := self at: i.		(canCollapse and: [ element == 0 ])			ifTrue: [ 				lastElementIsStringOrZero					ifFalse: [ 						canCollapse := false.						collection addFirst: element.]]			ifFalse: [ 				collection addFirst: element.				canCollapse := lastElementIsStringOrZero := element isString ] ].	collection size = self size		ifTrue: [ ^ self ].	newSize := collection size.	new := self species new: newSize.	j := 0.	collection		do: [ :element | 			new at: j + 1 put: element.			j := j + 1 ].	^ new! !!MetacelloVersionNumber methodsFor: 'private' stamp: 'DaleHenrichs 10/5/2010 17:31'!compareEqualTo: aMetacelloVersionNumber	| mySize |	aMetacelloVersionNumber species = self species ifFalse: [ ^false ].	mySize := self size.	mySize = aMetacelloVersionNumber size 		ifFalse: [ ^false ].	1 to: mySize do: [:i |		(self at: i) = (aMetacelloVersionNumber at: i) ifFalse: [ ^false ]].	^true! !!MetacelloVersionNumber methodsFor: 'private' stamp: 'DaleHenrichs 10/5/2010 17:29'!compareLessThan: aMetacelloVersionNumber	| mySize aSize commonSize count more |	mySize := self size.	aSize := aMetacelloVersionNumber size.	commonSize :=  mySize min: aSize.	count := 0.	more := true.	[ more and: [ count < commonSize ]] whileTrue: [		(self at: count + 1) = (aMetacelloVersionNumber at: count + 1)			ifTrue: [ count := count + 1 ]			ifFalse: [ more := false ]].	count < commonSize		ifTrue: [ 			^(self at: count + 1) 				metacelloVersionComponentLessThan: (aMetacelloVersionNumber at: count + 1) ].	mySize < aSize		ifTrue: [ 			mySize = 0 ifTrue: [ ^true ].			"if the versions at commonSize are equal and the next version slot in aMetacelloVersionNumber 			 is a string, then it's considered that I'm > aMetacelloVersionNumber			 (i.e., '2.9.9' is greater than '2.9.9-alpha.2')"			(self at: commonSize) = (aMetacelloVersionNumber at: commonSize)				ifFalse: [ ^true ]. 			^(aMetacelloVersionNumber at: commonSize+1) isString not]		ifFalse: [ 			mySize = aSize ifTrue: [ ^false ].			aSize <= 0 ifTrue: [ ^false ].			"if the versions at commonSize are equal and the next version slot is a string, 			 then it's considered that I'm < aMetacelloVersionNumber			 (i.e., '2.9.9-alpha.2' is less than '2.9.9')"			(self at: commonSize) = (aMetacelloVersionNumber at: commonSize)				ifFalse: [ ^false ].			 ^(self at: commonSize+1) isString]! !!MetacelloVersionNumber methodsFor: 'copying' stamp: 'dkh 6/14/2009 12:53'!copyFrom: start to: stop 	"Answer a copy of a subset of the receiver, starting from element at 	index start until element at index stop."	| newSize new j |	newSize := stop - start + 1.	new := self species new: newSize.	j := 0.	start to: stop do: [:i |		new at: j + 1 put: (self at: i).		j := j + 1 ].	^new! !!MetacelloVersionNumber methodsFor: 'operations' stamp: 'DaleHenrichs 11/15/2010 13:33'!decrementMinorVersionNumber	| int |	self size to: 1 by: -1 do: [ :index | 		(int := self at: index) isString			ifFalse: [ 				int > 0					ifTrue: [ self at: index put: int - 1 ].				^ self ] ]! !!MetacelloVersionNumber methodsFor: 'enumerating' stamp: 'dkh 6/14/2009 09:37'!do: aBlock 	"Refer to the comment in Collection|do:."	1 to: self size do:		[:index | aBlock value: (self at: index)]! !!MetacelloVersionNumber methodsFor: 'enumerating' stamp: 'dkh 6/14/2009 09:37'!do: elementBlock separatedBy: separatorBlock	"Evaluate the elementBlock for all elements in the receiver,	and evaluate the separatorBlock between."	| beforeFirst | 	beforeFirst := true.	self do:		[:each |		beforeFirst			ifTrue: [beforeFirst := false]			ifFalse: [separatorBlock value].		elementBlock value: each]! !!MetacelloVersionNumber methodsFor: 'comparing' stamp: 'dkh 06/15/2009 14:30'!hash"Returns a numeric hash key for the receiver."| mySize interval hashValue |(mySize := self size) == 0  ifTrue: [ ^15243 ]."Choose an interval so that we sample at most 5 elements of the receiver"interval := ((mySize - 1) // 4) max: 1.hashValue := 4459.1 to: mySize by: interval do: [ :i | | anElement |  anElement := self at: i.  (anElement isKindOf: SequenceableCollection)    ifTrue: [      hashValue := (hashValue bitShift: -1) bitXor: anElement size.      ]    ifFalse: [      hashValue := (hashValue bitShift: -1) bitXor: anElement hash.      ].  ].^ hashValue abs! !!MetacelloVersionNumber methodsFor: 'operations' stamp: 'dkh 10/7/2009 14:28'!incrementMinorVersionNumber	| int |	self size to: 1 by: -1 do: [:index | 		(int := self at: index) isString 			ifFalse: [ 				self at: index put: int + 1.				^self ]].! !!MetacelloVersionNumber methodsFor: 'comparing' stamp: 'dkh 12/21/2009 13:32'!match: aVersionPattern	"Answer whether the version number of the receiver matches the given pattern string.	 A Metacello version number is made up of version sequences delimited by the characters $. and $-.	 The $. introduces a numeric version sequence and $- introduces an alphanumeric version sequence.	 	 A version pattern is made up of version pattern match sequences. also delimited by the characters $. 	 and $-.. Each pattern match sequence is tested against the corresponding version sequence of the 	 receiver, using the 'standard' pattern matching rules. All sequences must answer true for a match.		 The special pattern sequence '?' is a match for the corresponding version sequence and all subsequent 	 version sequences. '?' as the version pattern matches all versions. No more version pattern 	 sequences are permitted once the '?' sequence is used. If used, it is the last version pattern	 sequence. "		| patternVersion mySize patternSize |	patternVersion := aVersionPattern asMetacelloVersionNumber.	mySize := self size.	patternSize := patternVersion size.	mySize = patternSize 		ifFalse: [ 			mySize < patternSize ifTrue: [ ^false ].			(patternVersion at: patternSize) ~= '?' ifTrue: [ ^false ].			mySize := patternSize ].	1 to: mySize do: [:i | | pattern |		pattern := (patternVersion at: i) asString.		pattern = '?'			ifTrue: [i = mySize ifFalse: [ ^self error: 'Invalid version match pattern: ', aVersionPattern printString ]]			ifFalse: [ (pattern match: (self at: i) asString)  ifFalse: [ ^false ]]].	^true"  '1.1.1' asMetacelloVersionNumber match: '*.*.*'. -> true  '1.1.1' asMetacelloVersionNumber match: '*.#.*'. -> true  '1.10.1' asMetacelloVersionNumber match: '*.#.*'. -> false  '1.1.1' asMetacelloVersionNumber match: '*.*'. -> false  '1.1.1' asMetacelloVersionNumber match: '*.?'. -> true  '1.0' asMetacelloVersionNumber match: '1.?'. -> true  '2.0' asMetacelloVersionNumber match: '1.?'. -> false  '1.1.1' asMetacelloVersionNumber match: '?'. -> true  '1' asMetacelloVersionNumber match: '*.?'. -> false  '1-alpha5.0' asMetacelloVersionNumber match: '1-alpha*.?'. -> true  '1-alpha15.0.1' asMetacelloVersionNumber match: '1-alpha*.?'. -> true  '1.1' asMetacelloVersionNumber match: '?.?'. -> ERROR: invalid version match pattern"! !!MetacelloVersionNumber methodsFor: 'printing' stamp: 'dkh 6/14/2009 09:59'!printOn: aStream	| beforeFirst | 	beforeFirst := true.	self do:		[:each |		beforeFirst			ifTrue: [beforeFirst := false]			ifFalse: [				each isString					ifTrue: [ aStream nextPut: $- ]					ifFalse: [ aStream nextPut: $. ] ].		aStream nextPutAll: each asString ]! !!MetacelloVersionNumber methodsFor: 'accessing' stamp: 'dkh 6/14/2009 09:57'!versionString	| strm |	strm := WriteStream on: String new.	self printOn: strm.	^strm contents! !!MetacelloVersionNumber methodsFor: 'comparing' stamp: 'dkh 6/14/2009 13:30'!~> aMetacelloVersionNumber	aMetacelloVersionNumber size == 1 ifTrue: [ ^false ].	^self >= aMetacelloVersionNumber and: [ self < aMetacelloVersionNumber approximateBase ]! !!DateAndTime methodsFor: '*metacello-core' stamp: 'dkh 9/13/2009 07:49'!setTimestampInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setTimestamp: 		(aMetacelloVersionSpec project valueHolderSpec			value: self printString;			yourself)! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 11/3/2009 10:28'!asMetacelloVersionNumber	^MetacelloVersionNumber fromString: ''! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 9/13/2009 07:46'!setAuthorInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setAuthor: self! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2009 10:56'!setBlessingInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setBlessing: self! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2009 11:52'!setDescriptionInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setDescription: self! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'DaleHenrichs 12/21/2010 13:52'!setPostLoadDoItInMetacelloSpec: aMetacelloSpec	aMetacelloSpec setPostLoadDoIt: 		(aMetacelloSpec project valueHolderSpec			value: self;			yourself)! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'DaleHenrichs 12/21/2010 13:51'!setPreLoadDoItInMetacelloSpec: aMetacelloSpec	aMetacelloSpec setPreLoadDoIt: 		(aMetacelloSpec project valueHolderSpec			value: self;			yourself)! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 12/11/2009 13:29'!setProject: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setProject: aString withString: self! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 9/13/2009 07:47'!setTimestampInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setTimestamp: self! !!MetacelloCannotUpdateReleasedVersionError methodsFor: 'private' stamp: 'DaleHenrichs 12/20/2010 11:52'!isResumable	"Determine whether an exception is resumable."	^ true! !!MetacelloProjectSpecLoadConflict methodsFor: 'private' stamp: 'DaleHenrichs 2/5/2010 16:16'!isResumable	"Determine whether an exception is resumable."	^ true! !!MetacelloProjectSpecLoadError class methodsFor: 'instance creation' stamp: 'DaleHenrichs 1/19/2010 11:28'!projectSpec: aMetacelloMCProjectSpec	^self new		projectSpec: aMetacelloMCProjectSpec;		yourself! !!MetacelloProjectSpecLoadError methodsFor: 'private' stamp: 'DaleHenrichs 2/5/2010 16:18'!isResumable	"Determine whether an exception is resumable."	^ false! !!MetacelloProjectSpecLoadError methodsFor: 'accessing' stamp: 'DaleHenrichs 1/19/2010 11:29'!projectSpec	^projectSpec! !!MetacelloProjectSpecLoadError methodsFor: 'accessing' stamp: 'DaleHenrichs 1/19/2010 11:29'!projectSpec: aMetacelloMCProjectSpec	projectSpec := aMetacelloMCProjectSpec! !!MetacelloSymbolicVersionDoesNotExistError methodsFor: 'printing' stamp: 'dkh 3/18/2011 15:00'!description	"Return a textual description of the exception."	^'The symbolic version ', self versionString printString, ' is not defined in ', self project label, ' for the current platform.'! !!MetacelloSymbolicVersionNotDefinedError methodsFor: 'printing' stamp: 'dkh 3/18/2011 15:00'!description	"Return a textual description of the exception."	^'The symbolic version ', self versionString printString, ' is EXPLICITLY not defined in ', self project label, ' for the current platform.'! !!MetacelloVersionDoesNotExistError class methodsFor: 'instance creation' stamp: 'DaleHenrichs 9/24/2010 11:58'!project: aMetacelloProject versionString: aVersionString	^(self new)		project: aMetacelloProject;		versionString: aVersionString;		yourself! !!MetacelloVersionDoesNotExistError methodsFor: 'printing' stamp: 'DaleHenrichs 9/24/2010 12:01'!description	"Return a textual description of the exception."	^'Version ', self versionString printString, ' is not defined in ', self project label! !!MetacelloVersionDoesNotExistError methodsFor: 'accessing' stamp: 'DaleHenrichs 9/24/2010 11:57'!project	^ project! !!MetacelloVersionDoesNotExistError methodsFor: 'accessing' stamp: 'DaleHenrichs 9/24/2010 11:57'!project: anObject	project := anObject! !!MetacelloVersionDoesNotExistError methodsFor: 'accessing' stamp: 'DaleHenrichs 9/24/2010 11:46'!versionString	^ versionString! !!MetacelloVersionDoesNotExistError methodsFor: 'accessing' stamp: 'DaleHenrichs 9/24/2010 11:46'!versionString: anObject	versionString := anObject! !!MetacelloAbstractConstructor methodsFor: 'accessing' stamp: 'DaleHenrichs 11/3/2010 11:41'!configurationClass	^self subclassResponsibility! !!MetacelloAbstractConstructor methodsFor: 'pragma extraction' stamp: 'DaleHenrichs 11/3/2010 11:44'!extractAllVersionPragmas	| aDict |	aDict := Dictionary new.	self extractPragmas: #version: into: aDict.	self extractPragmas: #version:imports: into: aDict.	^aDict! !!MetacelloAbstractConstructor methodsFor: 'pragma extraction' stamp: 'DaleHenrichs 11/8/2010 10:16'!extractCommonDefaultSymbolicVersionPragmas	| aDict |	aDict := Dictionary new.	self extractPragmas: #defaultSymbolicVersion: for: MetacelloBaseConfiguration into: aDict.	^aDict! !!MetacelloAbstractConstructor methodsFor: 'pragma extraction' stamp: 'DaleHenrichs 11/8/2010 09:58'!extractDefaultSymbolicVersionPragmas	| aDict |	aDict := Dictionary new.	self extractPragmas: #defaultSymbolicVersion: into: aDict.	^aDict! !!MetacelloAbstractConstructor methodsFor: 'private' stamp: 'DaleHenrichs 11/8/2010 10:02'!extractPragmas: pragmaKeyword for: aClass into: versionDict	| versionString  pragmas |	(Pragma 		allNamed: pragmaKeyword		in: aClass) do: [:pragma |			versionString := pragma argumentAt: 1.			pragmas := versionDict 				at: versionString 				ifAbsent: [ | list |					list := OrderedCollection new.					versionDict at: versionString put: list.					list ].			pragmas add: pragma ].! !!MetacelloAbstractConstructor methodsFor: 'private' stamp: 'DaleHenrichs 11/8/2010 10:02'!extractPragmas: pragmaKeyword into: versionDict	^self extractPragmas: pragmaKeyword for: self configurationClass into: versionDict! !!MetacelloAbstractConstructor methodsFor: 'pragma extraction' stamp: 'DaleHenrichs 11/3/2010 11:43'!extractSymbolicVersionPragmas	| aDict |	aDict := Dictionary new.	self extractPragmas: #symbolicVersion: into: aDict.	^aDict! !!MetacelloAbstractConstructor methodsFor: 'pragma extraction' stamp: 'DaleHenrichs 11/3/2010 11:43'!extractVersionImportPragmas	| aDict |	aDict := Dictionary new.	self extractPragmas: #version:imports: into: aDict.	^aDict! !!MetacelloAbstractConstructor methodsFor: 'pragma extraction' stamp: 'DaleHenrichs 11/3/2010 11:43'!extractVersionPragmas	| aDict |	aDict := Dictionary new.	self extractPragmas: #version: into: aDict.	^aDict! !!MetacelloAbstractVersionConstructor class methodsFor: 'method generation' stamp: 'DaleHenrichs 11/13/2010 18:13'!symbolicMethodSelectorAndPragma: selector symbolicVersionSymbol: symbolicVersionSymbol on: strm	strm		nextPutAll: selector asString , ' spec';		cr;		tab;		nextPutAll: '<symbolicVersion: #' , symbolicVersionSymbol asString printString;		nextPutAll: '>';		cr! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: 'DaleHenrichs 12/4/2010 09:56'!addAttribute: anAttribute	self attributeOrder add: anAttribute! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: 'dkh 10/3/2009 16:28'!attributeMap	attributeMap == nil ifTrue: [ attributeMap := Dictionary new ].	^attributeMap! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: 'dkh 10/5/2009 16:41'!attributeOrder	attributeOrder == nil ifTrue: [ attributeOrder := OrderedCollection new ].	^attributeOrder! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!author: aBlockOrString	aBlockOrString setAuthorInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!blessing: aBlockOrString	aBlockOrString setBlessingInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!className: anObject	self root className: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: 'dkh 10/3/2009 16:26'!configuration	^configuration! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: 'dkh 10/3/2009 16:26'!configuration: aConfig	configuration := aConfig! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: 'DaleHenrichs 11/3/2010 11:41'!configurationClass	^self configuration class! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!description: aBlockOrString	aBlockOrString setDescriptionInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'private' stamp: 'DaleHenrichs 11/12/2010 12:28'!evaluatePragma: pragma	currentContext := pragma.	[ self configuration perform: pragma selector with: self ] ensure: [ currentContext := nil ]! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!file: anObject	self root file: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'dkh 9/6/2012 07:41'!for: attributeListOrSymbol do: aBlock    "conditional version support"    attributeListOrSymbol setForDo: aBlock withInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'dkh 9/6/2012 07:41'!for: attributeListOrSymbol version: aString    "conditional symbolicVersion support"    attributeListOrSymbol setForVersion: aString withInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!group: aString overrides: aStringOrCollection	| spec |	spec := 		(self project groupSpec)			name: aString;			includes: aStringOrCollection;			yourself.	self root packages add: spec.! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!group: aString with: aStringOrCollection	| spec |	spec := 		(self project groupSpec)			name: aString;			includes: aStringOrCollection;			yourself.	self root packages merge: spec.! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!includes: anObject	self root includes: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!loads: anObject	self root loads: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!name: anObject	self root name: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!operator: anObject	self root operator: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!package: aString	| spec |	spec := 		(self project packageSpec)			name: aString;			yourself.	self root packages add: spec.! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!package: aString overrides: aBlock	| spec |	spec := 		(self project packageSpec)			name: aString;			yourself.	self root packages add: spec.	self with: spec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!package: aString with: aBlockOrString	aBlockOrString setPackage: aString withInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!postLoadDoIt: aSymbol	self validateDoItSelector: aSymbol.	self root postLoadDoIt: aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!preLoadDoIt: aSymbol	self validateDoItSelector: aSymbol.	self root preLoadDoIt: aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 03/12/2011 22:11'!project: aString	self project: aString with: ''! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!project: aString copyFrom: oldSpecName with: aBlock	| spec projectSpec |	projectSpec := 		(self project projectSpec)			name: aString;			projectPackage: self project packageSpec;			yourself.	spec := 		(self project projectReferenceSpec)			name: aString;			projectReference: projectSpec;			yourself.	self root packages copy: oldSpecName to: spec.	self with: projectSpec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!project: aString overrides: aBlock	| spec projectSpec |	projectSpec := 		(self project projectSpec)			name: aString;			projectPackage: self project packageSpec;			yourself.	projectSpec projectPackage: self project packageSpec.	spec := 		(self project projectReferenceSpec)			name: aString;			projectReference: projectSpec;			yourself.	self root packages add: spec.	self with: projectSpec during: aBlock	! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!project: aString with: aBlockOrString	aBlockOrString setProject: aString withInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!projectPackage: aBlock	| spec |	(spec := self root projectPackage) == nil		ifTrue: [ 			spec := self project packageSpec.			self root projectPackage: spec ].	self with: spec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!removeGroup: aString	| spec |	spec := 		(self project groupSpec)			name: aString;			yourself.	self root packages remove: spec.! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!removePackage: aString	| spec |	spec := 		(self project packageSpec)			name: aString;			yourself.	self root packages remove: spec.! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!removeProject: aString	| spec |	spec := 		(self project projectReferenceSpec)			name: aString;			yourself.	self root packages remove: spec.! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!repositories: aBlock	self with: self root repositories during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!repository: anObject	self root repository: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!repository: description username: username password: password	self root repository: description username: username password: password! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!requires: anObject	self root requires: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'initialization' stamp: 'dkh 10/5/2009 16:42'!reset	attributeMap := attributeOrder := nil! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: 'dkh 10/3/2009 16:36'!root	^root! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: 'dkh 10/3/2009 16:37'!root: aMetacelloSpec	root := aMetacelloSpec! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'DaleHenrichs 11/12/2010 09:54'!setAuthorWithBlock: aBlock	| spec |	(spec := self root getAuthor) == nil		ifTrue: [ 			spec := self project valueHolderSpec.			self root setAuthor: spec ].	self with: spec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'DaleHenrichs 11/12/2010 09:54'!setAuthorWithString: aString	self root author: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'DaleHenrichs 11/12/2010 09:54'!setBlessingWithBlock: aBlock	| spec |	(spec := self root getBlessing) == nil		ifTrue: [ 			spec := self project valueHolderSpec.			self root setBlessing: spec ].	self with: spec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'DaleHenrichs 11/12/2010 09:54'!setBlessingWithString: aString	self root blessing: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'DaleHenrichs 11/12/2010 09:54'!setDescriptionWithBlock: aBlock	| spec |	(spec := self root getDescription) == nil		ifTrue: [ 			spec := self project valueHolderSpec.			self root setDescription: spec ].	self with: spec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'DaleHenrichs 11/12/2010 09:54'!setDescriptionWithString: aString	self root description: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!setFor: attributeList do: aBlock    "conditional version support"    attributeList asMetacelloAttributeList        do: [ :attribute |             | blockList |            blockList := self attributeMap                at: attribute                ifAbsent: [ self attributeMap at: attribute put: (blockList := OrderedCollection new) ].            blockList add: aBlock.            self addAttribute: attribute ]! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!setFor: attributeList version: aString    "conditional symbolicVersion support"    attributeList asMetacelloAttributeList        do: [ :attribute |             self attributeMap at: attribute put: aString.            self addAttribute: attribute ]! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'DaleHenrichs 11/12/2010 09:54'!setPackage: aString withBlock: aBlock	| spec |	spec := 		(self project packageSpec)			name: aString;			yourself.	self root packages merge: spec.	self with: spec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'DaleHenrichs 11/12/2010 09:54'!setPackage: aString withString: aFile	| spec |	spec := 		(self project packageSpec)			name: aString;			file: aFile;			yourself.	self root packages merge: spec.! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: 'DaleHenrichs 03/12/2011 22:10'!setProject: aProject	project := aProject! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'DaleHenrichs 11/12/2010 09:54'!setProject: aString withBlock: aBlock	| spec projectSpec |	projectSpec := 		(self project projectSpec)			name: aString;			projectPackage: self project packageSpec;			yourself.	projectSpec projectPackage: self project packageSpec.	spec := 		(self project projectReferenceSpec)			name: aString;			projectReference: projectSpec;			yourself.	self root packages merge: spec.	self with: projectSpec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'DaleHenrichs 11/12/2010 09:54'!setProject: aString withString: versionString	| spec projectSpec |	projectSpec := 		(self project projectSpec)			name: aString;			versionString: versionString;			yourself.	spec := 		(self project projectReferenceSpec)			name: aString;			projectReference: projectSpec;			yourself.	self root packages merge: spec.! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'DaleHenrichs 11/12/2010 09:54'!setTimestampWithBlock: aBlock	| spec |	(spec := self root getTimestamp) == nil		ifTrue: [ 			spec := self project valueHolderSpec.			self root setTimestamp: spec ].	self with: spec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'DaleHenrichs 11/12/2010 09:54'!setTimestampWithString: aString	self root timestamp: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!supplyingAnswers: aCollection	self root answers: aCollection! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: 'DaleHenrichs 9/22/2010 16:43'!symbolicVersion	^symbolicVersion! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: 'DaleHenrichs 9/22/2010 16:43'!symbolicVersion: aSymbol	symbolicVersion := aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!timestamp: aBlockOrString	aBlockOrString setTimestampInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'validation' stamp: 'DaleHenrichs 11/12/2010 10:28'!validateDoItSelector: anObject	anObject == nil ifTrue: [ ^ self ].	anObject isSymbol ifFalse: [ self error: 'Invalid message selector for doit: ', anObject printString ].! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!value: anObject	self root value: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!version: anObject	self root versionString: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54'!versionString: anObject	self root versionString: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'private' stamp: 'dkh 10/3/2009 16:31'!with: aMetacelloSpec during: aBlock 	| previousRoot |	previousRoot := self root.	self root: aMetacelloSpec.	aBlock		ensure: [self root: previousRoot]! !!MetacelloToolBoxConstructor methodsFor: 'private' stamp: 'DaleHenrichs 12/22/2010 09:56'!evaluateMethodSection: methodSection version: sourceVersionString	| versionSpec |	versionSpec := self project versionSpec.	versionSpec versionString: sourceVersionString.	methodSection versionSpec: versionSpec.	currentSection := methodSection.	self with: versionSpec during: methodSection block.	methodSection methodSections do: [ :ms | self evaluateMethodSection: ms version: sourceVersionString ]! !!MetacelloToolBoxConstructor methodsFor: 'extraction' stamp: 'DaleHenrichs 12/22/2010 11:07'!extractMethodSectionsFor: sourceVersionString	| coll pragma |	coll := self extractAllVersionPragmas at: sourceVersionString ifAbsent: [ ^ #() ].	coll size > 1		ifTrue: [ self error: 'More than one pragma defining ' , sourceVersionString printString ].	pragma := coll at: 1.	self evaluatePragma: pragma.	self methodSections do: [ :methodSection | self evaluateMethodSection: methodSection version: sourceVersionString ].! !!MetacelloToolBoxConstructor methodsFor: 'extraction' stamp: 'DaleHenrichs 11/15/2010 10:06'!extractSymbolicVersionSpecsFor: sourceVersionSymbol	| coll versionSpec pragma |	coll := self extractSymbolicVersionPragmas at: sourceVersionSymbol ifAbsent: [ ^ #() ].	coll size > 1		ifTrue: [ self error: 'More than one pragma defining ' , sourceVersionSymbol printString ].	pragma := coll at: 1.	self evaluatePragma: pragma.	^ self methodSections! !!MetacelloToolBoxConstructor methodsFor: 'private' stamp: 'DaleHenrichs 12/23/2010 15:21'!methodSection: methodSection do: aBlock	methodSection methodSections do: aBlock.	methodSection methodSections do: [ :ms | self methodSection: ms do: aBlock ]! !!MetacelloToolBoxConstructor methodsFor: 'private' stamp: 'dkh 9/7/2012 10:43'!methodSection: methodSection inEvaluationOrder: attributes do: aBlock    | selected |    selected := IdentitySet new.    attributes        do: [ :attribute |             methodSection methodSections                do: [ :ms |                     (ms attributes includes: attribute)                        ifTrue: [ selected add: ms ] ] ].    selected do: aBlock.    attributes size == 1        ifTrue: [ ^ self ].    selected        do: [ :ms | self methodSection: ms inEvaluationOrder: (attributes copyFrom: 2 to: attributes size) do: aBlock ]! !!MetacelloToolBoxConstructor methodsFor: 'accessing' stamp: 'dkh 9/13/2012 16:09'!methodSectionAttributes    | attributes |    attributes := Set new.    self methodSectionsDo: [ :methodSection | attributes addAll: methodSection attributes ].    ^ attributes! !!MetacelloToolBoxConstructor methodsFor: 'private' stamp: 'DaleHenrichs 11/14/2010 02:08'!methodSections	methodSections == nil ifTrue: [ methodSections := OrderedCollection new ].	^methodSections! !!MetacelloToolBoxConstructor methodsFor: 'enumeration' stamp: 'DaleHenrichs 12/23/2010 15:10'!methodSectionsDo: aBlock	self methodSection: self do: aBlock! !!MetacelloToolBoxConstructor methodsFor: 'enumeration' stamp: 'dkh 9/7/2012 10:40'!methodSectionsInEvaluationOrder: attributes do: aBlock    "breadth first traversal ... to collect selected sections, then evaluate individual sections in attribute order"    | selected processed |    selected := IdentitySet new.    self methodSection: self inEvaluationOrder: attributes do: [ :methodSection | selected add: methodSection ].    processed := IdentitySet new.    attributes        do: [ :attribute |             | list |            list := OrderedCollection new.            selected                do: [ :methodSection |                     (processed includes: methodSection)                        ifFalse: [                             (methodSection attributes includes: attribute)                                ifTrue: [                                     list add: methodSection.                                    processed add: methodSection ] ] ].            list do: aBlock ]! !!MetacelloToolBoxConstructor methodsFor: 'initialization' stamp: 'DaleHenrichs 11/18/2010 16:40'!reset	super reset.	"not needed, but included for completeness"	methodSections := nil! !!MetacelloToolBoxConstructor methodsFor: 'api callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!setFor: attributeList do: aBlock    "conditional version support"    | methodSection |    methodSection := MetacelloVersionMethodSection new        attributes: attributeList asMetacelloAttributeList;        block: aBlock;        yourself.    currentSection ~~ nil        ifTrue: [ currentSection addMethodSection: methodSection ]        ifFalse: [ self methodSections add: methodSection ]! !!MetacelloToolBoxConstructor methodsFor: 'api callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!setFor: attributeList version: aString    "conditional symbolicVersion support"    self methodSections        add:            (MetacelloSymbolicVersionSpec new                attributes: attributeList asMetacelloAttributeList;                versionString: aString;                yourself)! !!MetacelloVersionConstructor class methodsFor: 'instance creation' stamp: 'DaleHenrichs 11/12/2010 09:47'!on: aConfig	^(self new)		on: aConfig;		yourself! !!MetacelloVersionConstructor class methodsFor: 'instance creation' stamp: 'DaleHenrichs 11/12/2010 09:47'!on: aConfig project: aProject	^(self new)		on: aConfig project: aProject;		yourself! !!MetacelloVersionConstructor class methodsFor: 'deprecated' stamp: 'DaleHenrichs 11/18/2010 16:48'!spawnPackageMethodIn: aConfig category: methodCategory named: newSelector sourceVersion: sourceVersionString targetVersion: targetVersionString blessing: blessing	self deprecated: 'see MetacelloToolBox class>>createDevelopment:for:importFromBaseline:description: for a similar example'.	^self new		spawnPackageMethodIn: aConfig 		category: methodCategory 		named: newSelector		sourceVersion: sourceVersionString 		targetVersion: targetVersionString		blessing: blessing! !!MetacelloVersionConstructor class methodsFor: 'deprecated' stamp: 'DaleHenrichs 11/18/2010 16:48'!spawnPackageMethodIn: aConfig named: newSelector sourceVersion: sourceVersionString targetVersion: targetVersionString	self deprecated: 'see MetacelloToolBox class>>createDevelopment:for:importFromBaseline:description: for a similar example'.	^self 		spawnPackageMethodIn: aConfig 		category: 'versions'		named: newSelector 		sourceVersion: sourceVersionString 		targetVersion: targetVersionString 		blessing: #development! !!MetacelloVersionConstructor class methodsFor: 'deprecated' stamp: 'DaleHenrichs 11/18/2010 16:48'!spawnPackageMethodIn: aConfig named: newSelector sourceVersion: sourceVersionString targetVersion: targetVersionString blessing: blessing	self deprecated: 'see MetacelloToolBox class>>createDevelopment:for:importFromBaseline:description: for a similar example'.	^self new		spawnPackageMethodIn: aConfig 		category: 'versions'		named: newSelector 		sourceVersion: sourceVersionString 		targetVersion: targetVersionString		blessing: blessing! !!MetacelloVersionConstructor class methodsFor: 'deprecated' stamp: 'DaleHenrichs 12/20/2010 10:05'!updatePackageMethodIn: aConfig sourceVersion: sourceVersionString	self deprecated: 'see MetacelloToolBox class>>updateDevelopment:for:updateProjects:description: for a similar example'.	^self new		updatePackageMethodIn: aConfig 		sourceVersion: sourceVersionString! !!MetacelloVersionConstructor methodsFor: 'initialization' stamp: 'dkh 7/8/2011 18:57'!calculate: aConfig project: aProject	| versionMap symbolicVersionMap executionBlock |	self setProject: aProject.	self configuration: aConfig.	versionMap := Dictionary new.	symbolicVersionMap := Dictionary new.	executionBlock := self specResolverBlock.	self collectAllVersionsFromVersionPragmasInto: versionMap using: executionBlock.	self		collectAllVersionsFromVersionImportPragmasInto: versionMap		using: executionBlock		satisfiedPragmas: (self versionImportPragmasVerifiedDefinedIn: versionMap).	self collectAllSymbolicVersionsFromVersionPragmasInto: symbolicVersionMap using: self symbolicVersionResolverBlock.	self project map: versionMap.	self project symbolicVersionMap: symbolicVersionMap.	self project configuration: aConfig.	"now that we have a nearly complete project, we can collect the defaultSymbolicVersions, which expect the project to be fully constructed"	self		collectDefaultSymbolicVersionsFromVersionPragmasFrom: self extractDefaultSymbolicVersionPragmas		into: symbolicVersionMap		using: self defaultSymbolicVersionResolverBlock.	"Pick up defaults from MetacelloBaseConfiguration"	self		collectDefaultSymbolicVersionsFromVersionPragmasFrom: self extractCommonDefaultSymbolicVersionPragmas		into: symbolicVersionMap		using: self commonDefaultSymbolicVersionResolverBlock.	"now resolive symbolicVersions defined as symbolicVersions"	symbolicVersionMap copy		keysAndValuesDo: [ :symbolic :original | 			| versionString visited |			versionString := original.			visited := Set new.			[ 			visited add: versionString.			versionString isSymbol and: [ versionString ~~ #notDefined ] ]				whileTrue: [ 					versionString := symbolicVersionMap						at: versionString						ifAbsent: [ self error: 'Cannot resolve symbolic version ' , original printString ].					(visited includes: versionString)						ifTrue: [ self error: 'Loop detected resolving symbolic version ' , original printString ] ].			symbolicVersionMap at: symbolic put: versionString ]! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'DaleHenrichs 11/12/2010 09:50'!collectAllSymbolicVersionsFromVersionPragmasInto: symbolicVersionMap using: executionBlock	| defined versionPragmaDict versionString |	versionPragmaDict := self extractSymbolicVersionPragmas.	versionPragmaDict		keysAndValuesDo: [ :versionSymbol :pragmaColl | 			defined := false.			pragmaColl				do: [ :pragma | 					defined := true.					versionString := executionBlock value: versionSymbol value: pragma ].			defined				ifTrue: [ 					versionString == nil						ifFalse: [ symbolicVersionMap at: versionSymbol put: versionString ]].			self reset ]! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'dkh 9/5/2012 06:03'!collectAllVersionsFromVersionImportPragmasInto: versionMap using: executionBlock satisfiedPragmas: pragmaDict    | defined done completed count |    done := false.    completed := IdentitySet new.    count := 0.    [     count := count + 1.    count > 10000        ifTrue: [ self error: 'Apparent loop in import expansion' ].    done ]        whileFalse: [             done := true.            pragmaDict                keysAndValuesDo: [ :versionString :pragmaColl |                     | versionSpec |                    versionSpec := nil.                    defined := false.                    pragmaColl                        do: [ :pragma |                             (completed includes: pragma)                                ifFalse: [                                     | imports |                                    done := false.                                    imports := pragma argumentAt: 2.                                    imports                                        detect: [ :importedVersion | (versionMap includesKey: importedVersion) not ]                                        ifNone: [                                             imports                                                do: [ :importedVersion |                                                     | version |                                                    (version := versionMap at: importedVersion ifAbsent: [  ]) ~~ nil                                                        ifTrue: [                                                             defined := true.                                                            completed add: pragma.                                                            versionSpec == nil                                                                ifTrue: [ versionSpec := version spec copy ]                                                                ifFalse: [ versionSpec := versionSpec mergeSpec: version spec copy ].                                                            versionSpec versionString: versionString.                                                            executionBlock value: versionSpec value: pragma ] ] ] ] ].                    defined                        ifTrue: [                             | version importedVersions |                            importedVersions := OrderedCollection new.                            version := versionSpec createVersion.                            pragmaColl do: [ :pragma | importedVersions addAll: (pragma argumentAt: 2) ].                            version importedVersions: importedVersions.                            self validateVersionString: versionString againstSpec: versionSpec.                            versionMap at: versionSpec versionString put: version ].                    self reset ] ]! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'DaleHenrichs 11/12/2010 09:50'!collectAllVersionsFromVersionPragmasInto: versionMap using: executionBlock	| defined versionPragmaDict |	versionPragmaDict := self extractVersionPragmas.	versionPragmaDict		keysAndValuesDo: [ :versionString :pragmaColl | 			| versionSpec |			versionSpec := self project versionSpec.			versionSpec versionString: versionString.			defined := false.			pragmaColl				do: [ :pragma | 					defined := true.					executionBlock value: versionSpec value: pragma ].			defined				ifTrue: [ 					self validateVersionString: versionString againstSpec: versionSpec.					versionMap at: versionSpec versionString put: versionSpec createVersion ].			self reset ]! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'DaleHenrichs 11/12/2010 09:50'!collectDefaultSymbolicVersionsFromVersionPragmasFrom: versionPragmaDict into: symbolicVersionMap using: executionBlock	| defined versionString |	versionPragmaDict		keysAndValuesDo: [ :versionSymbol :pragmaColl | 			defined := false.			symbolicVersionMap				at: versionSymbol				ifAbsent: [ 					"process the defaultSymbolicVersion only if the symbolicVersion is not defined yet"					pragmaColl						do: [ :pragma | 							defined := true.							versionString := executionBlock value: versionSymbol value: pragma ].					defined						ifTrue: [ 							versionString == nil								ifFalse: [ symbolicVersionMap at: versionSymbol put: versionString ] ].					self reset ] ]! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'DaleHenrichs 11/12/2010 09:50'!commonDefaultSymbolicVersionResolverBlock	^ self defaultSymbolicVersionResolverBlock: (MetacelloBaseConfiguration new project: self project)! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'DaleHenrichs 11/12/2010 09:50'!defaultSymbolicVersionResolverBlock	^ self defaultSymbolicVersionResolverBlock: self configuration! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'DaleHenrichs 11/12/2010 09:50'!defaultSymbolicVersionResolverBlock: receiver	^ [ :symbolicVrsn :pragma | 	| result |	result := nil.	(pragma argumentAt: 1) = symbolicVrsn		ifTrue: [ 			self symbolicVersion: symbolicVrsn.			result := [ receiver perform: pragma selector ] on: MetacelloVersionDoesNotExistError do: [ :ex | ex return: nil ] ].	result ]! !!MetacelloVersionConstructor methodsFor: 'initialization' stamp: 'dkh 7/8/2011 18:58'!on: aConfig	| cacheKey |	cacheKey := aConfig class.	project := MetacelloPlatform current		stackCacheFor: #versionConstructor		at: cacheKey		doing: [ :cache | 			self calculate: aConfig project: nil.			cache at: cacheKey put:  self project ].	self setProject: project.! !!MetacelloVersionConstructor methodsFor: 'initialization' stamp: 'dkh 7/8/2011 19:47'!on: aConfig project: aProject	| cacheKey cachedProject |	cacheKey := aConfig class.	cachedProject := MetacelloPlatform current		stackCacheFor: #versionConstructor		at: cacheKey		doing: [ :cache | 			self calculate: aConfig project: aProject.			cache at: cacheKey put:  self project.			^self ].	aProject map: cachedProject map.	aProject symbolicVersionMap: cachedProject symbolicVersionMap.	aProject configuration: aConfig.	self setProject: aProject! !!MetacelloVersionConstructor methodsFor: 'deprecated' stamp: 'DaleHenrichs 11/18/2010 16:48'!prepareForMethodUpdate: aConfig sourceVersion: sourceVersionString forceUpdate: forceUpdate generating: generateBlock	| pragmaDict versionSpecs pragmaMap updatedPackageSpecs updatedPackageSpecsMap reversed pragmaColl seenUpdatedPackageSpecs |	self deprecated: 'see MetacelloToolBox for replacement methods'.	self configuration: aConfig.	versionSpecs := Dictionary new.	pragmaMap := Dictionary new.	pragmaDict := self extractAllVersionPragmas.	pragmaColl := pragmaDict at: sourceVersionString ifAbsent: [ ^ self ].	pragmaColl		do: [ :pragma | 			| specs versionSpec |			specs := Dictionary new.			self evaluatePragma: pragma.			self attributeMap				keysAndValuesDo: [ :attribute :blockList | 					versionSpec := self project versionSpec.					versionSpec versionString: sourceVersionString.					specs at: attribute put: versionSpec.					blockList do: [ :block | self with: versionSpec during: block ] ].			versionSpecs				at: pragma selector				put:					{specs.					(self attributeOrder).					nil}.			pragmaMap at: pragma selector put: pragma.			self reset ].	versionSpecs		keysAndValuesDo: [ :selector :ar | 			updatedPackageSpecsMap := Dictionary new.			seenUpdatedPackageSpecs := Dictionary new.			ar at: 3 put: updatedPackageSpecsMap.			reversed := aConfig project attributes reverse.			reversed				do: [ :attribute | 					| vs |					(vs := (ar at: 1) at: attribute ifAbsent: [  ]) ~~ nil						ifTrue: [ 							updatedPackageSpecs := forceUpdate								ifTrue: [ vs forceUpdatedPackageSpecs ]								ifFalse: [ vs updatedPackageSpecs ].							updatedPackageSpecs associations								do: [ :assoc | 									| filename |									(filename := seenUpdatedPackageSpecs at: assoc key ifAbsent: [  ]) == nil										ifTrue: [ 											assoc value == #uptodate												ifTrue: [ 													"#uptodate means that the spec is up-to-date and we mark it as										 seen so that the spec is not update for a 'later' spec"													seenUpdatedPackageSpecs at: assoc key put: #uptodate ]												ifFalse: [ seenUpdatedPackageSpecs at: assoc key put: assoc value file ] ]										ifFalse: [ 											"if the spec was already seen as up-to-date or the file is the same as 								 the one already seen don't propogate the file"											(filename == #uptodate or: [ assoc value == #uptodate or: [ filename = assoc value file ] ])												ifTrue: [ updatedPackageSpecs removeKey: assoc key ] ] ].							updatedPackageSpecsMap at: attribute put: updatedPackageSpecs ] ].	"clear out #uptodate markers"			updatedPackageSpecsMap				valuesDo: [ :d | 					d associations						do: [ :assoc | 							assoc value == #uptodate								ifTrue: [ d removeKey: assoc key ] ] ].	"remove shadowed packages"			1 to: reversed size do: [ :index | 				| attribute d |				attribute := reversed at: index.				((d := updatedPackageSpecsMap at: attribute ifAbsent: [  ]) ~~ nil and: [ d keys size > 0 ])					ifTrue: [ 						index + 1 to: reversed size do: [ :shadowIndex | 							d								keysDo: [ :key | 									| dict |									(dict := updatedPackageSpecsMap at: (reversed at: shadowIndex) ifAbsent: [  ]) ~~ nil										ifTrue: [ dict removeKey: key ifAbsent: [  ] ] ] ] ] ].			updatedPackageSpecsMap keys				do: [ :key | 					| d |					d := updatedPackageSpecsMap at: key.					d isEmpty						ifTrue: [ updatedPackageSpecsMap removeKey: key ] ].	"ready to generate source for method"			generateBlock				value: selector				value: pragmaMap				value: ar				value: updatedPackageSpecsMap ]! !!MetacelloVersionConstructor methodsFor: 'deprecated' stamp: 'DaleHenrichs 12/4/2010 09:53'!spawnPackageMethodIn: aConfig category: methodCategory named: newSelector sourceVersion: sourceVersionString targetVersion: targetVersionString blessing: blessing	self deprecated: 'see MetacelloToolBox class>>createBaseline:for:from:description: for replacement method'.	self 		prepareForMethodUpdate: aConfig 		sourceVersion: sourceVersionString 		forceUpdate: blessing ~~ #baseline		generating: [:selector :pragmaMap :ar :updatedPackageSpecsMap | | strm |			strm := WriteStream on: String new.			strm 				nextPutAll: newSelector asString, ' spec'; cr;				tab; nextPutAll: 						'<version: ', 						targetVersionString printString, 						' imports: #(', sourceVersionString printString, 						')>';cr.			(ar at: 2) do: [:attribute | | vs d |				vs := (ar at: 1) at: attribute.				(d := updatedPackageSpecsMap at: attribute ifAbsent: []) ~~ nil					ifTrue: [ 						vs packagesSpec list do: [:member | | x |							x := d at: member spec name ifAbsent: [].						 	member spec updateForSpawnMethod: x ]]					ifFalse: [						vs packagesSpec list do: [:member |							member spec updateForSpawnMethod: member spec copy ]].				strm cr; tab; nextPutAll: 'spec for: ', attribute printString, ' do: ['; cr.				attribute == #common					ifTrue: [						vs 							author: MetacelloPlatform current authorName;							timestamp: MetacelloPlatform current timestamp.						blessing ~~ nil							ifTrue: [ vs blessing: blessing ]].				vs configSpawnMethodOn: strm indent: 2.				strm nextPutAll: '].'].				(aConfig class						compile: strm contents					classified: methodCategory) == nil 						ifTrue: [ self error: 'Error compiling the method' ]].	^true! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'DaleHenrichs 11/12/2010 12:28'!specResolverBlock	^ [ :versionSpec :pragma | 	(pragma argumentAt: 1) = versionSpec versionString		ifTrue: [ 			self evaluatePragma: pragma.			self project attributes				do: [ :attribute | 					| blockList |					(blockList := self attributeMap at: attribute ifAbsent: [  ]) ~~ nil						ifTrue: [ blockList do: [ :block | self with: versionSpec during: block ] ] ] ] ]! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'DaleHenrichs 11/12/2010 12:28'!symbolicVersionResolverBlock	^ [ :symbolicVrsn :pragma | 	| result |	result := nil.	(pragma argumentAt: 1) = symbolicVrsn		ifTrue: [ 			self symbolicVersion: symbolicVrsn.			self evaluatePragma: pragma.			self project attributes				do: [ :attribute | 					| versionString |					versionString := self attributeMap at: attribute ifAbsent: [  ].					versionString ~~ nil						ifTrue: [ result := versionString ] ] ].	result ]! !!MetacelloVersionConstructor methodsFor: 'deprecated' stamp: 'DaleHenrichs 12/4/2010 09:54'!updatePackageMethodIn: aConfig sourceVersion: sourceVersionString	self deprecated: 'see MetacelloToolBox class>>updateDevelopment:for:updateProjects:description: for replacement method'.	self 		prepareForMethodUpdate: aConfig 		sourceVersion: sourceVersionString 		forceUpdate: false		generating: [:selector :pragmaMap :ar :updatedPackageSpecsMap | | strm pragma |			updatedPackageSpecsMap isEmpty ifTrue: [ ^false ].			strm := WriteStream on: String new.			strm 				nextPutAll: selector asString, ' spec'; cr;				tab; nextPutAll: '<version: ', sourceVersionString printString.			pragma := pragmaMap at: selector.			pragma numArgs = 2				ifTrue: [					strm nextPutAll: ' imports: #('.					(pragma argumentAt: 2) do: [:versionString |						strm nextPutAll: versionString printString; space ]].			strm nextPutAll: ')>';cr.			(ar at: 2) do: [:attribute | | vs d |				vs := (ar at: 1) at: attribute.				(d := updatedPackageSpecsMap at: attribute ifAbsent: []) ~~ nil					ifTrue: [ 						vs packagesSpec list do: [:member | 							member spec file ~~ nil								ifTrue: [ | x |									(((x := d at: member spec name ifAbsent: []) ~~ nil) and: [ x ~~ #uptodate ])						 				ifTrue: [ member spec file: x file ]]]].				strm cr; tab; nextPutAll: 'spec for: ', attribute printString, ' do: ['; cr.				attribute == #common					ifTrue: [ 						vs 							author: MetacelloPlatform current authorName;							timestamp: MetacelloPlatform current timestamp ].				vs configMethodOn: strm indent: 2.				strm nextPutAll: '].'].			(aConfig class						compile: strm contents					classified: (aConfig class whichCategoryIncludesSelector: pragma selector)) == nil						ifTrue: [ self error: 'Error compiling the method' ]].	^true! !!MetacelloVersionConstructor methodsFor: 'validation' stamp: 'DaleHenrichs 11/30/2010 13:25'!validateVersionString: versionString againstSpec: versionSpec	versionString = versionSpec versionString		ifFalse: [ 			MetacelloValidationNotification				signal:					(MetacelloValidationError						configurationClass: self configurationClass						reasonCode: #incorrectVersionString						callSite: #validateVersionString:againstSpec						explanation:							'The version declared in the pragma ', versionString printString , ' does not match the version in the spec '								, versionSpec versionString printString) ].! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'DaleHenrichs 11/12/2010 09:49'!versionImportPragmasVerifiedDefinedIn: versionMap 	| pragmaDict |	pragmaDict := self extractVersionImportPragmas.	pragmaDict		keysAndValuesDo: [:versionString :pragmaColl | pragmaColl				do: [:pragma | (pragma argumentAt: 2)						do: [:importedVersion | versionMap								at: importedVersion								ifAbsent: [pragmaDict										at: importedVersion										ifAbsent: [^ self error: 'The imported version:' , importedVersion printString , ' referenced from the method: ' , pragma selector printString , ' in configuration ' , configuration class printString , ' has not been defined.']]]]].	^ pragmaDict! !!MetacelloVersionValidator class methodsFor: 'accessing' stamp: 'DaleHenrichs 12/17/2010 15:16'!descriptionForReasonCode: reasonCode	^ self reasonCodeDescriptions at: reasonCode ifAbsent: [ self error: 'Unknown reasonCode: ' , reasonCode printString ]! !!MetacelloVersionValidator class methodsFor: 'private' stamp: 'DaleHenrichs 1/24/2011 12:41'!populateReasonCodeDescriptions	| dict |	dict := Dictionary new.	"Warnings"	dict at: #onlyBaselineVersion put: 'one or more baseline versions have been defined, but no non-baseline versions are defined.'.	"Critical Warnings"	dict at: #duplicateVersionDefinitions put: 'there are multiple pragma methods specifying the same version.'.	dict at: #packageNameMismatch put: 'the name in the packageSpec does not match the name of the mcz file.'.	dict at: #projectClassNameFileMismatch put: 'the class name of the configuration does not match the mcz file containing the configuration.'.	"Errors"	dict at: #cannotResolveVersion put: 'the version (project reference or symbolic version) was not found in the specified configuration.'.	dict at: #duplicateNames put: 'multiple independent definitions for an entity with same name (project, package, or group).'.	dict at: #incompleteProjectSpec put: 'missing required fields in project reference (className and/or repository).'.	dict at: #incorrectVersionString put: 'the version declared in pragma doesn''t match version in versionSpec.'.	dict at: #invalidDoItSelector put: 'doit select must be a Symbol.'.	dict at: #invalidVersionString put: 'versionString must be a String.'.	dict at: #missingVersionImport put: 'version specified in import pragma not defined in configuration.'.	dict at: #noVersionsDefined put: 'no usable baseline or version defined in configuration ... configuration cannot be loaded.'.	dict at: #projectCreationError put: 'error occured while resolving project reference.'.	dict at: #shadowedNames put: 'name duplication between packages and projects.'.	dict at: #versionCompositionError put: 'error while creating versionSpec from pragmas.'.	^dict! !!MetacelloVersionValidator class methodsFor: 'accessing' stamp: 'DaleHenrichs 12/17/2010 14:50'!reasonCodeDescriptions	reasonCodeDescriptions ifNil: [ reasonCodeDescriptions := self populateReasonCodeDescriptions ].	^reasonCodeDescriptions! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'DaleHenrichs 12/4/2010 08:39'!validateConfiguration: configurationClass	^self validateConfiguration: configurationClass debug: #() recurse: false! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'DaleHenrichs 11/24/2010 09:02'!validateConfiguration: configurationClass debug: debugList recurse: aBool	^ ((self new)		configurationClass: configurationClass;		debug: debugList;		recurse: aBool;		yourself) validate! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'DaleHenrichs 12/4/2010 08:39'!validateConfiguration: configurationClass recurse: aBool	^self validateConfiguration: configurationClass debug: #() recurse: aBool! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'DaleHenrichs 12/4/2010 08:40'!validateProject: aMetacelloProject	^self validateProject: aMetacelloProject debug: #() recurse: false! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'DaleHenrichs 11/24/2010 09:01'!validateProject: aMetacelloProject debug: debugList recurse: aBool	^ ((self new)		recurse: aBool;		debug: debugList;		configurationClass: aMetacelloProject configuration class;		yourself) validateProject: aMetacelloProject! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'DaleHenrichs 12/4/2010 08:40'!validateProject: aMetacelloProject recurse: aBool	^self validateProject: aMetacelloProject debug: #() recurse: aBool! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'DaleHenrichs 12/4/2010 08:43'!validateProject: aMetacelloProject version: versionString	^self validateProject: aMetacelloProject version: versionString debug: #() recurse: false! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'DaleHenrichs 12/4/2010 08:43'!validateProject: aMetacelloProject version: versionString debug: debugList	^self validateProject: aMetacelloProject version: versionString debug: debugList recurse: false! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'DaleHenrichs 12/4/2010 08:42'!validateProject: aMetacelloProject version: versionString debug: debugList recurse: aBool	^ ((self new)		configurationClass: aMetacelloProject configuration class;		debug: debugList;		recurse: aBool;		yourself) validateProject: aMetacelloProject version: versionString! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'DaleHenrichs 12/4/2010 08:41'!validateProject: aMetacelloProject version: versionString debug: debugList recurse: aBool visited: visitied	^(self new		configurationClass: aMetacelloProject configuration class;		debug: debugList;		recurse: aBool;		visited: visitied;		yourself) validateProject: aMetacelloProject version: versionString! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'DaleHenrichs 11/3/2010 11:42'!configurationClass	^ configurationClass! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'DaleHenrichs 11/3/2010 11:41'!configurationClass: anObject	configurationClass := anObject! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'DaleHenrichs 12/17/2010 13:04'!criticalWarningReasonCodes	^ #(#packageNameMismatch #projectClassNameFileMismatch #duplicateVersionDefinitions)! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'DaleHenrichs 11/24/2010 08:59'!debug	debug == nil ifTrue: [ debug := #() ].	^ debug! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'DaleHenrichs 11/24/2010 09:00'!debug: aCollection	"Any combination of: #error, #criticalWarning, #warning"	debug := aCollection! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'DaleHenrichs 11/30/2010 11:51'!errorReasonCodes	^ #(#duplicateNames #shadowedNames #invalidDoItSelector #invalidVersionString #missingVersionImport #projectCreationError #noVersionsDefined #cannotResolveVersion #incompleteProjectSpec #incorrectVersionString #versionCompositionError)! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'DaleHenrichs 11/30/2010 13:17'!exludededValidations	exludededValidations == nil ifTrue: [ exludededValidations := self extractExcludedValidations ].	^exludededValidations! !!MetacelloVersionValidator methodsFor: 'pragma extraction' stamp: 'DaleHenrichs 11/30/2010 14:33'!extractExcludedValidations	| exclusionDict |	exclusionDict := Dictionary new.	(Pragma 		allNamed: #excludedValidationIssues:		in: self configurationClass) do: [:pragma | | exclusions |			exclusions := pragma argumentAt: 1.			1 to: exclusions size by: 2 do: [:index |			exclusionDict 				at: (exclusions at: index) 				put: (exclusions at: index + 1) ]].	^exclusionDict! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'DaleHenrichs 11/30/2010 13:30'!recordValidationCriticalWarning: aString callSite: callSite reasonCode: aSymbol	^self recordValidationCriticalWarning: aString versionString: nil callSite: callSite reasonCode: aSymbol! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'DaleHenrichs 11/30/2010 13:28'!recordValidationCriticalWarning: aString versionString: versionString callSite: callSite reasonCode: aSymbol	"reasonCodes:		#packageNameMismatch		#projectClassNameFileMismatch		#duplicateVersionDefinitions		#duplicateAttributeBlocks	"	(self criticalWarningReasonCodes includes: aSymbol)		ifFalse: [ self error: 'Unknown critical warning reason code' ].	((self exludededValidations at: versionString ifAbsent: [ #() ]) includes: aSymbol)		ifTrue: [ ^self ].	(self debug includes: #criticalWarning) ifTrue: [ self halt: 'Debug triggered for critical warning: ', aString ].	self validationReport		add:			(MetacelloValidationCriticalWarning				configurationClass:					(self recurse						ifTrue: [ self configurationClass ]						ifFalse: [ nil ])				reasonCode: aSymbol				callSite: callSite				explanation: aString)! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'DaleHenrichs 12/3/2010 10:50'!recordValidationError: aString callSite: callSite reasonCode: aSymbol	^self recordValidationError: aString versionString: nil callSite: callSite reasonCode: aSymbol! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'DaleHenrichs 11/30/2010 13:28'!recordValidationError: aString versionString: versionString callSite: callSite reasonCode: aSymbol	"reasonCodes:		#noVersionForSymbolicVersion		#duplicateNames		#shadowedNames		#invalidDoItSelector		#invalidVersionString		#missingVersionImport		#projectCreationError		#noVersionsDefined		#cannotResolveVersion		#incompleteProjectSpec		#incorrectVersionString	"	(self errorReasonCodes includes: aSymbol)		ifFalse: [ self error: 'Unknown error reason code' ].	((self exludededValidations at: versionString ifAbsent: [ #() ]) includes: aSymbol)		ifTrue: [ ^self ].	(self debug includes: #error) ifTrue: [ self halt: 'Debug triggered for error: ', aString ].	self validationReport		add:			(MetacelloValidationError				configurationClass:					(self recurse						ifTrue: [ self configurationClass ]						ifFalse: [ nil ])				reasonCode: aSymbol				callSite: callSite				explanation: aString)! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'DaleHenrichs 11/30/2010 13:30'!recordValidationWarning: aString callSite: callSite reasonCode: aSymbol					^self recordValidationWarning: aString versionString: nil callSite: callSite reasonCode: aSymbol! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'DaleHenrichs 11/30/2010 13:29'!recordValidationWarning: aString versionString: versionString callSite: callSite reasonCode: aSymbol	"reasonCodes:		#onlyBaselineVersion		#noVersionSpecified	"	(self warningReasonCodes includes: aSymbol)		ifFalse: [ self error: 'Unknown warning reason code' ].	((self exludededValidations at: versionString ifAbsent: [ #() ]) includes: aSymbol)		ifTrue: [ ^self ].	(self debug includes: #warning) ifTrue: [ self halt: 'Debug triggered for critical warning: ', aString ].	self validationReport		add:			(MetacelloValidationWarning				configurationClass:					(self recurse						ifTrue: [ self configurationClass ]						ifFalse: [ nil ])				reasonCode: aSymbol				callSite: callSite				explanation: aString)! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'DaleHenrichs 11/5/2010 09:56'!recurse	recurse == nil ifTrue: [ recurse := false ].	^ recurse! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'DaleHenrichs 11/5/2010 09:39'!recurse: anObject	recurse := anObject! !!MetacelloVersionValidator methodsFor: 'validation' stamp: 'DaleHenrichs 11/4/2010 10:36'!validate	"Issue 5: 		[]no shadowing of names across project/package/group boundaries	 Issue 6: 		[]package version supplied for each package		[]no released (stable/bleedingEdge) versions (only development version)		package spec used instead of project spec in baseline (ConfigurationOfPharo-DaleHenrichs.50)	Issue 20:		[]pre and post load doits must be symbols, not blocks	Others:		[]symbolic versions can be resolved.		[]Ensure that versions are Strings and symbolic versions are symbols.	 	[]Ensure that imported versions are defined."	self validatePragmas.	^self validateProject! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'DaleHenrichs 11/3/2010 16:46'!validateBaselineVersionSpec: versionSpec	self subclassResponsibility! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'DaleHenrichs 12/21/2010 11:48'!validateDoIts: aSpec versionString: versionString errorMessage: errorMessage	| ar |	ar := {		#preLoadDoIt.	'preLoadDoIt selector for '.		#postLoadDoIt.	'postLoadDoIt selector for '.	}.	1 to: ar size by: 2 do: [ :i | 		| selector |		selector := (aSpec perform: (ar at: i)) value.		selector ~~ nil			ifTrue: [ 				selector isSymbol					ifFalse: [ 						self							recordValidationError: (ar at: i + 1) , errorMessage , ' is not a symbol'							versionString: versionString							callSite: #validateDoIts:versionString:errorMessage:							reasonCode: #invalidDoItSelector ] ] ]! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'DaleHenrichs 11/30/2010 13:37'!validatePragmas	"Ensure that versions are Strings and symbolic versions are symbols.	 Ensure that imported versions are defined"	| versionPragmas versionImportPragmas symbolicVersionPragmas versionStrings |	versionPragmas := self extractVersionPragmas.	versionImportPragmas := self extractVersionImportPragmas.	symbolicVersionPragmas := self extractSymbolicVersionPragmas.	versionStrings := Set new.	versionPragmas keys , versionImportPragmas keys , symbolicVersionPragmas keys		do: [ :versionString | 			(versionStrings includes: versionString)				ifTrue: [ 					self						recordValidationCriticalWarning: 'version ' , versionString printString , ' is defined multiple times.'						versionString: versionString						callSite: #validatePragmas						reasonCode: #duplicateVersionDefinitions ]				ifFalse: [ versionStrings add: versionString ] ].	versionPragmas		keysAndValuesDo: [ :versionString :pragmaList | 			versionString isString				ifFalse: [ 					self						recordValidationError: 'version ' , versionString printString , ' is not a String.'						versionString: versionString						callSite: #validatePragmas						reasonCode: #invalidVersionString ].			pragmaList size > 1				ifTrue: [ 					self						recordValidationCriticalWarning: 'version ' , versionString printString , ' is defined multiple times.'						versionString: versionString						callSite: #validatePragmas						reasonCode: #duplicateVersionDefinitions ] ].	symbolicVersionPragmas		keysAndValuesDo: [ :versionString :pragmaList | 			versionString isSymbol				ifFalse: [ 					self						recordValidationError: 'symbolic version ' , versionString printString , ' is not a Symbol.'						versionString: versionString						callSite: #validatePragmas						reasonCode: #invalidVersionString ].			pragmaList size > 1				ifTrue: [ 					self						recordValidationCriticalWarning: 'version ' , versionString printString , ' is defined multiple times.'						versionString: versionString						callSite: #validatePragmas						reasonCode: #duplicateVersionDefinitions ] ].	versionImportPragmas		keysAndValuesDo: [ :versionString :pragmaList | 			versionString isString				ifFalse: [ 					self						recordValidationError: 'version ' , versionString printString , ' is not a String.'						versionString: versionString						callSite: #validatePragmas						reasonCode: #invalidVersionString ].			pragmaList size > 1				ifTrue: [ 					self						recordValidationCriticalWarning: 'version ' , versionString printString , ' is defined multiple times.'						versionString: versionString						callSite: #validatePragmas						reasonCode: #duplicateVersionDefinitions ].			pragmaList				do: [ :versionImportPragma | 					(versionImportPragma arguments at: 2)						do: [ :importedVersionString | 							(versionStrings includes: importedVersionString)								ifFalse: [ 									self										recordValidationError:											'version ' , importedVersionString printString , ' referenced in import list of version ' , versionString printString												, ' has not been defined.'										versionString: versionString										callSite: #validatePragmas										reasonCode: #missingVersionImport ] ] ] ]! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'DaleHenrichs 11/30/2010 13:46'!validateProject	| project |	project := self		validateProjectCreationFrom: self configurationClass		onError: [ :ex | 			self				recordValidationError:					'Error creating project: ' , ex description , ' to reproduce evalutate the following: '''						, self configurationClass name asString , ' project'''				callSite: #validateProject				reasonCode: #projectCreationError.			^ self validationReport ].	^ self validateProject: project! !!MetacelloVersionValidator methodsFor: 'validation' stamp: 'DaleHenrichs 11/30/2010 13:49'!validateProject: project	| hasNoBaseline hasNoVersion |	(self visited includes: project configuration class)		ifTrue: [ ^ self validationReport ].	self visited add: project configuration class.	hasNoBaseline := hasNoVersion := true.	project versions		do: [ :version | 			| spec |			spec := version spec.			[ 			spec blessing value == #baseline				ifTrue: [ 					hasNoBaseline := false.					self validateBaselineVersionSpec: spec ]				ifFalse: [ 					hasNoVersion := false.					self validateVersionSpec: spec ] ]				on: Error				do: [ :ex | 					self						recordValidationError: 'Error composing version ' , version versionString printString , ': ' , ex description						versionString: version versionString						callSite: #validateProject:						reasonCode: #versionCompositionError ] ].	project symbolicVersionMap keys		do: [ :symbolicVersion | 			| version |			version := [ project version: symbolicVersion ]				on: Error , MetacelloSymbolicVersionNotDefinedError				do: [ :ex | 					"MetacelloSymbolicVersionNotDefinedError are explicitly not defined, so are not validation errors"					(ex isKindOf: MetacelloSymbolicVersionNotDefinedError)						ifFalse: [ 							self								recordValidationError:									'symbolic version ' , symbolicVersion printString , ' does not resolve to a literal version.'								callSite: #validatePragmas								reasonCode: #cannotResolveVersion ].					ex return: nil ].			version ~~ nil				ifTrue: [ self validateVersionSpecForSymbolicVersion: version spec symbolicVersion: symbolicVersion ] ].	hasNoVersion		ifTrue: [ 			hasNoBaseline				ifTrue: [ 					self						recordValidationError: 'No usable baseline or versions defined.'						callSite: #validatePragmas						reasonCode: #noVersionsDefined ]				ifFalse: [ 					self						recordValidationWarning: 'Only baseline defined (no version defined).'						callSite: #validatePragmas						reasonCode: #onlyBaselineVersion ] ].	^ self validationReport! !!MetacelloVersionValidator methodsFor: 'validation' stamp: 'DaleHenrichs 12/21/2010 10:39'!validateProject: project version: versionString	| version spec |	(self visited includes: project configuration class)		ifTrue: [ ^ self validationReport ].	self visited add: project configuration class.	[ version := project version: versionString ]		on: Error		do: [ :ex | 			self				recordValidationError: 'Could not resolve version ' , versionString printString , ' due to error: ' , ex description				versionString: versionString				callSite: #validateProject:version:				reasonCode: #cannotResolveVersion.			^ self validationReport ].	spec := version spec.	[ 	spec blessing value == #baseline		ifTrue: [ self validateBaselineVersionSpec: spec ]		ifFalse: [ self validateVersionSpec: spec ] ]		on: Error		do: [ :ex | 			self				recordValidationError: 'Error composing version ' , version versionString printString , ': ' , ex description				versionString: version versionString				callSite: #validateProject:version:				reasonCode: #versionCompositionError ].	^ self validationReport! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'DaleHenrichs 12/4/2010 09:55'!validateProjectCreationFrom: aConfigurationClass onError: aBlock	[ ^ aConfigurationClass project ]		on: Error , MetacelloValidationNotification		do: [ :ex | 			(ex isKindOf: MetacelloValidationNotification)				ifTrue: [ 					self validationReport add: ex issue.					ex resume ].			^ aBlock value: ex ]! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'DaleHenrichs 12/4/2010 10:53'!validateProjectVersion: versionString	| project |	project := self		validateProjectCreationFrom: self configurationClass		onError: [ :ex | 			self				recordValidationError:					'Error creating project: ' , ex description , ' to reproduce evalutate the following: '''						, self configurationClass name asString , ' project'''				callSite: #validateProject				reasonCode: #projectCreationError.			^ self validationReport ].	^ self validateProject: project version: versionString! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'DaleHenrichs 11/12/2010 10:44'!validateVersionSpec: versionSpec	self subclassResponsibility! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'DaleHenrichs 11/12/2010 10:44'!validateVersionSpecForSymbolicVersion: versionSpec symbolicVersion: symbolicVersionString	self subclassResponsibility! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'DaleHenrichs 11/3/2010 14:02'!validationReport		validationReport == nil ifTrue: [ validationReport := OrderedCollection new ].	^ validationReport! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'DaleHenrichs 11/3/2010 14:01'!validationReport: anObject	validationReport := anObject! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'DaleHenrichs 11/08/2010 14:45'!visited	visited == nil ifTrue: [ visited := IdentitySet new ].	^visited! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'DaleHenrichs 11/08/2010 14:49'!visited: anIdentitySet	visited := anIdentitySet! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'DaleHenrichs 11/30/2010 11:45'!warningReasonCodes	^ #(#onlyBaselineVersion )! !!MetacelloMethodSection methodsFor: 'accessing' stamp: 'dkh 9/7/2012 10:45'!attribute    self deprecated: 'Use attributes instead'.    self attributes size > 1        ifTrue: [ self error: 'invalid use of attribute' ].    self attributes isEmpty        ifTrue: [ ^ nil ].    ^ self attributes first! !!MetacelloMethodSection methodsFor: 'accessing' stamp: 'dkh 9/7/2012 10:49'!attribute: anObject    self deprecated: 'Use attributes: instead'.    self attributes size > 1        ifTrue: [ self error: 'invalid use of attribute:' ].    attributes := OrderedCollection with: anObject! !!MetacelloMethodSection methodsFor: 'printing' stamp: 'dkh 9/12/2012 09:46'!attributePrintString    | stream |    stream := WriteStream on: String new.    self attributes size = 1        ifTrue: [ stream nextPutAll: '#' , attributes first asString printString ]        ifFalse: [             stream nextPutAll: '#('.            self attributes                do: [ :attribute |                     stream                        nextPutAll: '#' , attribute asString printString;                        space ].            stream nextPut: $) ].    ^ stream contents! !!MetacelloMethodSection methodsFor: 'accessing' stamp: 'dkh 9/7/2012 06:42'!attributes    attributes ifNil: [ attributes := OrderedCollection new ].    ^ attributes! !!MetacelloMethodSection methodsFor: 'accessing' stamp: 'dkh 9/8/2012 05:41'!attributes: aCollectionOrSymbol    attributes := aCollectionOrSymbol asMetacelloAttributeList! !!MetacelloMethodSection methodsFor: 'testing' stamp: 'dkh 9/13/2012 19:12'!includesAttributeFrom: attributeCollection    ^ (attributeCollection asSet intersection: self attributes asSet) notEmpty! !!MetacelloSymbolicVersionSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 11/14/2010 10:12'!versionString	^ versionString! !!MetacelloSymbolicVersionSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 11/14/2010 10:12'!versionString: anObject	versionString := anObject! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!addMethodSection: methodSection	methodSection parent: self.	self methodSections add: methodSection! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!attributeOrPath    ^ self parent == nil        ifTrue: [             self attributes size == 1                ifTrue: [ self attributes first ]                ifFalse: [ self attributes ] ]        ifFalse: [ self attributePath ]! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!attributePath    | path |    path := MetacelloMethodSectionPath with: self attributes.    ^ self parent == nil        ifTrue: [ path ]        ifFalse: [ self parent attributePath , path ]! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!block	^ block! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!block: anObject	block := anObject! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!methodSections	methodSections ifNil: [ methodSections := OrderedCollection new ].	^methodSections! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!parent	^ parent! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!parent: anObject	parent := anObject! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!topParent	self parent == nil		ifTrue: [ ^ self ].	^ self parent topParent! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!versionSpec	^ versionSpec! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!versionSpec: anObject	versionSpec := anObject! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 11/14/2010 01:21'!category	^ category! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 11/14/2010 01:21'!category: anObject	category := anObject! !!MetacelloMethodSpec methodsFor: 'method generation' stamp: 'DaleHenrichs 11/14/2010 01:47'!compileMethod	(project configuration class		compile: self methodSource		classified: self category) == nil		ifTrue: [ self error: 'Error compiling the method' ]! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 11/14/2010 01:36'!methodSections	methodSections == nil ifTrue: [ methodSections := OrderedCollection new ].	^ methodSections! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 11/14/2010 01:35'!methodSections: anObject	methodSections := anObject! !!MetacelloMethodSpec methodsFor: 'method generation' stamp: 'DaleHenrichs 11/14/2010 01:44'!methodSource	self subclassResponsibility! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 11/14/2010 01:51'!project	^ project! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 11/14/2010 01:51'!project: anObject	project := anObject! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 11/14/2010 00:45'!selector	^ selector! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 11/14/2010 00:45'!selector: anObject	selector := anObject! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 11/14/2010 00:46'!versionString	^ versionString! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 11/19/2010 10:36'!versionString: aStringOrSymbol	versionString := aStringOrSymbol! !!MetacelloSymbolicVersionMethodSpec methodsFor: 'adding' stamp: 'dkh 9/9/2012 07:33'!addMethodSection: attribute versionString: aString    self methodSections        add:            (MetacelloSymbolicVersionSpec new                attributes: attribute asMetacelloAttributeList;                versionString: aString;                yourself)! !!MetacelloSymbolicVersionMethodSpec methodsFor: 'method generation' stamp: 'dkh 9/7/2012 10:44'!methodSource    | strm |    strm := WriteStream on: String new.    self symbolicMethodSelectorAndPragma: self selector symbolicVersionSymbol: self versionString on: strm.    (self methodSections asArray sort: [ :a :b | a attributes first <= b attributes first ])        do: [ :methodSection |             | vs |            strm                cr;                tab;                nextPutAll: 'spec for: ' , methodSection attributePrintString , ' version: '.            vs := methodSection versionString.            vs isSymbol                ifTrue: [ strm nextPut: $# ].            strm                nextPutAll: vs asString printString , '.';                cr ].    ^ strm contents! !!MetacelloSymbolicVersionMethodSpec methodsFor: 'method generation' stamp: 'dkh 6/5/2012 19:01:24'!symbolicMethodSelectorAndPragma: aSelector symbolicVersionSymbol: symbolicVersionSymbol on: strm	strm		nextPutAll: aSelector asString , ' spec';		cr;		tab;		nextPutAll: '<symbolicVersion: #' , symbolicVersionSymbol asString printString;		nextPutAll: '>';		cr! !!MetacelloSymbolicVersionMethodSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!versionString: aStringOrSymbol	aStringOrSymbol isSymbol ifFalse: [ self error: 'Version symbol ', aStringOrSymbol printString, ' for symbolic version method must be a Symbol' ].	super versionString: aStringOrSymbol! !!MetacelloVersionMethodSpec methodsFor: 'adding' stamp: 'dkh 6/5/2012 19:01:24'!addMethodSection: attributePath versionSpec: versionSpec    | attributeList methodSection index sections found |    attributeList := attributePath last.    methodSection := MetacelloVersionMethodSection new        attributes: attributeList;        versionSpec: versionSpec;        yourself.    attributePath size > 1        ifTrue: [             index := 1.            sections := self methodSections.            found := true.            [ found ]                whileTrue: [                     found := false.                    sections                        do: [ :ms |                             ms attributes = (attributePath at: index)                                ifTrue: [                                     index == (attributePath size -1)                                        ifTrue: [                                             ms methodSections add: methodSection.                                            ^ self ].                                    sections := ms methodSections.                                    index := index + 1.                                    found := true ] ] ].            self error: 'Method section for attribute: ' , (attributePath at: index) printString , ' not found.' ]        ifFalse: [ self methodSections add: methodSection ]! !!MetacelloVersionMethodSpec methodsFor: 'adding' stamp: 'dkh 9/6/2012 10:03:17'!findMethodSection: attributeOrPath sectionIndex: sectionIndex    | attributePath index sections found |    attributePath := attributeOrPath asMetacelloAttributePath.    index := 1.    sections := self methodSections.    found := true.    [ found ]        whileTrue: [             found := false.            sections                do: [ :ms |                     ms attributes = (attributePath at: index)                        ifTrue: [                             index == attributePath size                                ifTrue: [ ^ ms ].                            sections := ms methodSections.                            index := index + 1.                            found := true ] ] ].    self error: 'Method section for attribute: ' , attributePath printString , ' not found.'! !!MetacelloVersionMethodSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!imports	imports == nil ifTrue: [ imports := #() ].	^ imports! !!MetacelloVersionMethodSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!imports: anObject	imports := anObject! !!MetacelloVersionMethodSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24'!methodSection: methodSection pre: preBlock last: last post: postBlock indent: indent	| list |	methodSection ~~ self		ifTrue: [ preBlock value: methodSection value: indent ].	list := methodSection methodSections.	1 to: list size		do: [ :index | | ms | 			ms := list at: index.			self				methodSection: ms				pre: preBlock				last: index ~= list size				post: postBlock				indent: indent + 1 ].	methodSection ~~ self		ifTrue: [ postBlock value: methodSection value: indent value: last ]! !!MetacelloVersionMethodSpec methodsFor: 'method generation' stamp: 'dkh 6/5/2012 19:01:24'!methodSelectorAndPragma: aSelector imports: importList versionString: aString on: strm	strm		nextPutAll: aSelector asString , ' spec';		cr;		tab;		nextPutAll: '<version: ' , aString printString.	importList notEmpty		ifTrue: [ 			strm nextPutAll: ' imports: #('.			importList				do: [ :importVersionString | 					strm						nextPutAll: importVersionString printString;						space ].			strm nextPut: $) ].	strm		nextPutAll: '>';		cr! !!MetacelloVersionMethodSpec methodsFor: 'method generation' stamp: 'dkh 6/5/2012 19:01:24'!methodSource    | strm |    strm := WriteStream on: String new.    self        methodSelectorAndPragma: self selector        imports: self imports        versionString: self versionString        on: strm.    self        methodSection: self        pre: [ :methodSection :indent |             strm                cr;                tab: indent;                nextPutAll: 'spec for: ' , methodSection attributePrintString , ' do: [';                cr.            methodSection versionSpec configMethodOn: strm last: methodSection methodSections isEmpty indent: indent + 1 ]        last: false        post: [ :methodSection :indent :last |             strm nextPutAll: ' ].'.            (last or: [ indent = 1 or: [ methodSection methodSections isEmpty and: [ indent = 1 ] ] ])                ifTrue: [ strm cr ] ]        indent: 0.    ^ strm contents! !!MetacelloVersionMethodSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!versionString: aStringOrSymbol	aStringOrSymbol isSymbol ifTrue: [ self error: 'Version string ', aStringOrSymbol printString, ' for version method must be a String' ].	super versionString: aStringOrSymbol! !!MetacelloPlatform class methodsFor: 'accessing' stamp: 'dkh 7/24/2009 15:21'!current	Current		ifNil: [Current := MetacelloPlatform new].	^ Current! !!MetacelloPlatform class methodsFor: 'initialize-release' stamp: 'dkh 7/24/2009 15:29'!initialize	"MetacelloPlatform initialize"	"MetacelloGemStonePlatform initialize"	"MetacelloPharoPlatform initialize"	"MetacelloSqueakPlatform initialize"	Current := self new! !!MetacelloPlatform methodsFor: 'utilities' stamp: 'dkh 10/28/2009 10:53'!authorName	Smalltalk at: #Author ifPresent: [:cl | ^cl perform: #initials ].	^'no developer initials'! !!MetacelloPlatform methodsFor: 'utilities' stamp: 'dkh 1/5/2011 16:47'!authorName: aString	"Primarily used for testing"	self subclassResponsibility! !!MetacelloPlatform methodsFor: 'accessing' stamp: 'DaleHenrichs 12/18/2010 13:37'!bypassGoferLoadUpdateCategories	bypassGoferLoadUpdateCategories == nil ifTrue: [ bypassGoferLoadUpdateCategories := false ].	^ bypassGoferLoadUpdateCategories! !!MetacelloPlatform methodsFor: 'accessing' stamp: 'DaleHenrichs 12/18/2010 13:37'!bypassGoferLoadUpdateCategories: anObject	bypassGoferLoadUpdateCategories := anObject! !!MetacelloPlatform methodsFor: 'accessing' stamp: 'DaleHenrichs 3/11/2010 19:24'!bypassProgressBars	bypassProgressBars == nil ifTrue: [ bypassProgressBars := false ].	^ bypassProgressBars! !!MetacelloPlatform methodsFor: 'accessing' stamp: 'DaleHenrichs 3/11/2010 19:24'!bypassProgressBars: anObject	bypassProgressBars := anObject! !!MetacelloPlatform methodsFor: 'caching' stamp: 'dkh 4/6/2011 23:14'!clearCurrentVersionCache	MetacelloClearStackCacheNotification signal: #(#currentVersion #currentVersionAgainst: #currentVersionInfo)! !!MetacelloPlatform methodsFor: 'notification' stamp: 'DaleHenrichs 3/11/2010 19:26'!collection: aCollection do: aBlock displaying: aString	aCollection do: aBlock! !!MetacelloPlatform methodsFor: 'user interaction' stamp: 'dkh 8/12/2009 17:51'!confirm: aString		^(Smalltalk hasClassNamed: #UIManager)		ifTrue: [ (Smalltalk classNamed: #UIManager) default perform: #confirm: with: aString ]		ifFalse: [			"throw warning and answer true, if no way to announce"			Warning signal: aString.			true ]! !!MetacelloPlatform methodsFor: 'reflection' stamp: 'DaleHenrichs 11/18/2010 16:14'!copyClass: oldClass as: newName inCategory: newCategoryName	self subclassResponsibility! !!MetacelloPlatform methodsFor: 'repository creation' stamp: 'TestRunner 12/22/2009 11:50'!createRepository: aRepositorySpec	| type |	type := aRepositorySpec type.	type = 'http'		ifTrue: [^ MCHttpRepository				location: aRepositorySpec description				user: aRepositorySpec username				password: aRepositorySpec password].	type = 'directory'		ifTrue: [^ MCDirectoryRepository new				directory: (FileDirectory on: aRepositorySpec description)].	type = 'dictionary'		ifTrue: [	| description headerSize globalName |				description := aRepositorySpec description.			headerSize := 'dictionary://' size.			globalName := (description copyFrom: headerSize + 1 to: description size) asSymbol. 			^Smalltalk at: globalName ifAbsent: [Smalltalk at: globalName put: MCDictionaryRepository new ]].	^ nil! !!MetacelloPlatform methodsFor: 'attributes' stamp: 'dkh 9/8/2011 13:47'!defaultPlatformAttributes	| versionString |	Smalltalk at: #SystemVersion ifPresent: [:cl |		versionString := cl current version.		(versionString beginsWith: 'Pharo')			ifTrue: [ ^ #(#squeakCommon #pharo ) ].		(versionString beginsWith: 'Squeak')			ifTrue: [^ #(#squeakCommon #squeak )].		"see http://code.google.com/p/metacello/issues/detail?id=146"		(versionString includesSubString: 'Pharo')			ifTrue: [ ^ #(#squeakCommon #pharo ) ].		(versionString includesSubString: 'Squeak')			ifTrue: [^ #(#squeakCommon #squeak )].		self error: 'Unrecognized version of Squeak/Pharo: ', versionString ].	^ #(#gemstone )! !!MetacelloPlatform methodsFor: 'tests' stamp: 'dkh 6/7/2011 15:58'!defaultTimeout	"squeak compatability"	^60! !!MetacelloPlatform methodsFor: 'notification' stamp: 'DaleHenrichs 03/08/2010 13:31'!do: aBlock displaying: aString	aBlock value! !!MetacelloPlatform methodsFor: 'repository creation' stamp: 'tbn 6/9/2010 13:56'!extractTypeFromDescription: description	description == nil ifTrue: [ ^nil ].	((description beginsWith: '/') or: [ description second = $:]) ifTrue: [ ^'directory' ].	(description beginsWith: 'dictionary://') ifTrue: [ ^'dictionary' ].	^'http'! !!MetacelloPlatform methodsFor: 'reflection' stamp: 'dkh 1/16/2011 11:08'!globalNamed: globalName	^Smalltalk at: globalName! !!MetacelloPlatform methodsFor: 'reflection' stamp: 'dkh 1/16/2011 11:08'!globalNamed: globalName ifAbsent: absentBlock	^Smalltalk at: globalName ifAbsent: absentBlock! !!MetacelloPlatform methodsFor: 'caching' stamp: 'DaleHenrichs 9/22/2010 14:58'!primeStackCacheFor: cacheName doing: noArgBlock defaultDictionary: aDictionary	self deprecated: 'use #primeStackCacheWith:doing:'.	self 		useStackCacheDuring: [:dict | | cache |			cache := dict at: cacheName ifAbsent: [].			cache == nil				ifTrue: [ 					cache := Dictionary new.					dict at: cacheName put: cache ].			^noArgBlock value ] 		defaultDictionary: aDictionary! !!MetacelloPlatform methodsFor: 'caching' stamp: 'DaleHenrichs 9/22/2010 14:26'!primeStackCacheWith: aDictionary doing: noArgBlock	self 		useStackCacheDuring: [:dict | ^noArgBlock value ] 		defaultDictionary: aDictionary! !!MetacelloPlatform methodsFor: 'caching' stamp: 'dkh 4/6/2011 22:44'!stackCacheFor: cacheName at: key doing: aBlock	^self stackCacheFor: cacheName cacheClass: Dictionary at: key doing: aBlock! !!MetacelloPlatform methodsFor: 'caching' stamp: 'dkh 4/6/2011 22:41'!stackCacheFor: cacheName cacheClass: cacheClass at: key doing: aBlock	self 		useStackCacheDuring: [:dict | | cache |			cache := dict at: cacheName ifAbsent: [].			cache ~~ nil				ifTrue: [ | value hasEntry |					hasEntry := true.					value := cache at: key ifAbsent: [ hasEntry := false ].					hasEntry ifTrue: [ ^value ]]				ifFalse: [ 					cache := cacheClass new.					dict at: cacheName put: cache ].			^aBlock value: cache ] 		defaultDictionary: nil! !!MetacelloPlatform methodsFor: 'utilities' stamp: 'dkh 10/7/2009 10:51'!timestamp	^DateAndTime now printString! !!MetacelloPlatform methodsFor: 'transactions' stamp: 'dkh 10/23/2009 11:59'!transact: aBlock	"On GemStone, we want to optionally abort before command execution and commit after 	 common execution. Other plaforms don't need to do anything special.	 Returning out of block, skips commit."		aBlock value! !!MetacelloPlatform methodsFor: 'caching' stamp: 'dkh 4/6/2011 23:24'!useStackCacheDuring: aBlock defaultDictionary: defaultDictionary	| dict |	dict := MetacelloStackCacheNotification signal.	dict == nil		ifTrue: [ 			dict := defaultDictionary == nil				ifTrue: [ Dictionary new ]				ifFalse: [ defaultDictionary ] ].	[ ^ aBlock value: dict ]		on: MetacelloStackCacheNotification , MetacelloClearStackCacheNotification		do: [ :ex | 			(ex isKindOf: MetacelloStackCacheNotification)				ifTrue: [ ex resume: dict ].			(ex isKindOf: MetacelloClearStackCacheNotification)				ifTrue: [ 					| keys |					keys := ex cacheNames.					keys ifNil: [ keys := dict keys ].					keys						do: [ :k | 							(dict includesKey: k)								ifTrue: [ 									| c |									c := dict at: k.									c keys do: [ :ck | c removeKey: ck ].									dict removeKey: k ] ].					ex resume ] ]! !!MetacelloProject class methodsFor: 'instance creation' stamp: 'dkh 9/4/2009 01:43'!new	| inst |	inst := self basicNew.	^inst configuration: inst; yourself! !!MetacelloProject class methodsFor: 'instance creation' stamp: 'dkh 9/4/2009 01:43'!on: aConfig	^self basicNew configuration: aConfig; yourself! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 10/14/2009 16:33'!attributes	^(OrderedCollection with: #common)		addAll: self platformAttributes;		yourself! !!MetacelloProject methodsFor: 'versions' stamp: 'DaleHenrichs 11/2/2010 13:20'!bleedingEdge	^self version: #bleedingEdge! !!MetacelloProject methodsFor: 'accessing' stamp: 'tg 8/30/2009 17:48'!configuration	^ configuration! !!MetacelloProject methodsFor: 'accessing' stamp: 'tg 8/30/2009 17:48'!configuration: anObject	configuration := anObject! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 7/8/2011 19:56'!currentVersion	| cacheKey cv |	cacheKey := self configuration class.	^ MetacelloPlatform current		stackCacheFor: #currentVersion		at: cacheKey		doing: [ :cache | 			cv := self currentVersionAgainst: nil.			^ cache at: cacheKey put: cv ]! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 7/11/2011 16:19'!currentVersionAgainst: resolvedPackageAndProjectNames	| cacheKey |	cacheKey := resolvedPackageAndProjectNames isNil		ifTrue: [ Array with: self configuration class with: nil ]		ifFalse: [ Array with: self configuration class with: (resolvedPackageAndProjectNames sort: [ :a :b | a <= b ]) ].	^ MetacelloPlatform current		stackCacheFor: #currentVersionAgainst:		at: cacheKey		doing: [ :cache | 			| cv versions latestSomethingLoaded |			cv := nil.			versions := self sortedAndFilteredVersions.			versions				do: [ :version | 					| status matchBlock |					status := resolvedPackageAndProjectNames isNil						ifTrue: [ version spec isPartiallyCurrent ]						ifFalse: [ version spec isPartiallyCurrentAgainst: resolvedPackageAndProjectNames ].					matchBlock := [ :matchStatus | 					cv := version copy.					cv versionStatus: matchStatus.					^ cache at: cacheKey put: cv ].					status isAllLoadedToSpec: matchBlock.					status isLoadedToSpec: matchBlock.					status isLoadedMatchConstraints: matchBlock.					status						isSomethingLoaded: [ :matchStatus | 							latestSomethingLoaded isNil								ifTrue: [ 									cv := version copy.									cv versionStatus: matchStatus.									latestSomethingLoaded := cv ] ] ].			latestSomethingLoaded ifNotNil: [ ^ cache at: cacheKey put: latestSomethingLoaded ].			^ cache at: cacheKey put: nil ]! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 6/18/2009 12:52'!defaultBlessing	^#release! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/9/2009 16:03'!defaultLoaderClass	^MetacelloSpecLoader! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 7/24/2009 15:37'!defaultPlatformAttributes	^ MetacelloPlatform current defaultPlatformAttributes! !!MetacelloProject methodsFor: 'versions' stamp: 'DaleHenrichs 11/2/2010 16:58'!development	^self version: #development! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 10/7/2009 10:05'!excludeFromLatestVersion	^#(development broken baseline)! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 10/4/2009 12:17'!groupSpec	^self groupSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 10/4/2009 12:18'!groupSpecClass	^MetacelloGroupSpec! !!MetacelloProject methodsFor: 'versions' stamp: 'DaleHenrichs 11/12/2010 06:43'!hasVersion: versionString	self version: versionString ifAbsent: [ ^false ].	^true! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 9/10/2009 15:14'!label	^self configuration class name! !!MetacelloProject methodsFor: 'versions' stamp: 'DaleHenrichs 01/24/2011 13:33'!lastVersion	| coll |	coll := (self map values asArray sort: [:a :b | a <= b ]) asOrderedCollection.	coll isEmpty ifTrue: [ ^nil ].	^coll last! !!MetacelloProject methodsFor: 'versions' stamp: 'DaleHenrichs 11/2/2010 13:27'!latestVersion	| excluded |"	self deprecated: 'Please use #stableVersion instead.'."	self flag: 'deprecate after version 1.0'.	excluded := self excludeFromLatestVersion.	^(self map values select: [:version |  		(excluded includes: version blessing) not ]) detectMax: [:version | version ]! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 8/26/2009 10:07'!latestVersion: blessing	^(self map values select: [:version | blessing = version blessing ]) detectMax: [:version | version ]! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 1/5/2010 10:43'!latestVersionMatching: versionPatternString	"Answer whether the version number of the receiver matches the given pattern string.	 A Metacello version number is made up of version sequences delimited by the characters $. and $-.	 The $. introduces a numeric version sequence and $- introduces an alphanumeric version sequence.	 	 A version pattern is made up of version pattern match sequences. also delimited by the characters $. 	 and $-.. Each pattern match sequence is tested against the corresponding version sequence of the 	 receiver, using the 'standard' pattern matching rules. All sequences must answer true for a match.		 The special pattern sequence '?' is a match for the corresponding version sequence and all subsequent 	 version sequences. '?' as the version pattern matches all versions. No more version pattern 	 sequences are permitted once the '?' sequence is used. If used, it is the last version pattern	 sequence."	^self 		latestVersionMatching: versionPatternString 		includedBlessings: #()		excludedBlessings: self excludeFromLatestVersion! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 12/21/2009 14:04'!latestVersionMatching: versionPatternString excludedBlessings: excluded	^self 		latestVersionMatching: versionPatternString 		includedBlessings: #()		excludedBlessings: excluded! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 12/21/2009 13:59'!latestVersionMatching: versionPatternString includedBlessings: included	^self 		latestVersionMatching: versionPatternString 		includedBlessings: included		excludedBlessings: self excludeFromLatestVersion! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 12/21/2009 14:41'!latestVersionMatching: versionPatternString includedBlessings: included excludedBlessings: excludedBlessings	| excluded |	excluded := excludedBlessings asSet copy.	excluded removeAllFoundIn: included.	^(self map values select: [:version |		(included isEmpty or: [ included includes: version blessing ]) 			and: [ (excluded includes: version blessing) not 				and: [ version versionNumber match: versionPatternString ]]])		detectMax: [:version | version ]! !!MetacelloProject methodsFor: 'loading' stamp: 'dkh 9/10/2009 15:09'!load: aVersionString	^(self version: aVersionString) load! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 9/10/2009 13:27'!loadType	"#atomic or #linear"	loadType == nil ifTrue: [ ^#atomic ].	^loadType! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 9/10/2009 13:27'!loadType: aSymbol	"#atomic or #linear"	loadType := aSymbol! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/18/2009 10:10'!loader	^loader! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/18/2009 10:10'!loader: aLoader	loader := aLoader! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/9/2009 16:04'!loaderClass	loaderClass == nil ifTrue: [ loaderClass := self defaultLoaderClass ].	^loaderClass! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/9/2009 16:05'!loaderClass: aMetacelloSpecLoader	loaderClass := aMetacelloSpecLoader! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 6/24/2011 15:58'!map	versionMap ifNil: [ ^ Dictionary new ].	^ versionMap! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 10/3/2009 17:31'!map: aDictionary	versionMap := aDictionary! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 10/4/2009 12:18'!packagesSpec	^self packagesSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 10/4/2009 12:18'!packagesSpecClass	^MetacelloPackagesSpec! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 10/17/2009 09:32'!platformAttributes	 ^self projectPlatformAttributes! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 7/28/2009 16:42'!pragmaKeywords	^#(version:attribute: blessing:attribute: description:attribute: required:attribute: groups:attribute: doits:attribute:)! !!MetacelloProject methodsFor: 'printing' stamp: 'DaleHenrichs 12/7/2010 02:54'!printOn: aStream	| label |	self configuration class printOn: aStream.	aStream nextPut: $(.	self versions		do: [ :vrsn | 			aStream nextPutAll: vrsn versionString.			vrsn spec ~~ nil				ifTrue: [ 					(label := vrsn spec projectLabel) isEmpty						ifFalse: [ aStream nextPutAll: ' [' , label , ']' ] ].			aStream				nextPut: $,;				space ].	aStream nextPut: $)! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 9/2/2009 06:02'!project	^self! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 9/2/2009 08:31'!projectAttributes	projectAttributes ~~ nil ifTrue: [ ^projectAttributes ].	^#()! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 9/2/2009 08:31'!projectAttributes: aList	projectAttributes := aList! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 9/2/2009 07:38'!projectPlatformAttributes	| list aBlock |	list := OrderedCollection new.	(aBlock := self projectAttributes) ~~ nil 		ifTrue: [ list addAll: aBlock value ].	^self defaultPlatformAttributes, list! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 10/4/2009 12:18'!projectReferenceSpec	^self projectReferenceSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 10/4/2009 12:18'!projectReferenceSpecClass	^MetacelloProjectReferenceSpec! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 06/01/2009 14:54'!projectSpec	^self projectSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: 'DaleHenrichs 10/27/2010 11:15'!projectSpecClass	^self subclassResponsibility! !!MetacelloProject methodsFor: 'private' stamp: 'DaleHenrichs 11/10/2010 16:13'!sortedAndFilteredVersions		^(self map values asArray sort: [:a :b | a >= b ]) select: [:vrsn | (#(broken baseline) includes: vrsn blessing) not ].! !!MetacelloProject methodsFor: 'versions' stamp: 'DaleHenrichs 1/17/2011 11:23'!stableVersion	^self version: #stable! !!MetacelloProject methodsFor: 'accessing' stamp: 'DaleHenrichs 9/23/2010 15:26'!symbolicVersionMap	^symbolicVersionMap								! !!MetacelloProject methodsFor: 'accessing' stamp: 'DaleHenrichs 9/23/2010 15:26'!symbolicVersionMap: aDictionary	symbolicVersionMap := aDictionary								! !!MetacelloProject methodsFor: 'versions' stamp: 'DaleHenrichs 01/24/2011 13:33'!symbolicVersionSymbols	^self symbolicVersionMap keys asArray sort: [:a :b | a <= b ]! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2009 11:47'!valueHolderSpec	^self valueHolderSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2009 11:47'!valueHolderSpecClass	^MetacelloValueHolderSpec! !!MetacelloProject methodsFor: 'versions' stamp: 'DaleHenrichs 11/18/2010 15:58'!version: aVersionString	| vrsn |	aVersionString isSymbol		ifTrue: [ 			| symbolicVersionString |			symbolicVersionString := self symbolicVersionMap				at: aVersionString				ifAbsent: [ (MetacelloSymbolicVersionDoesNotExistError project: self project versionString: aVersionString) signal ].			symbolicVersionString == #notDefined				ifTrue: [ (MetacelloSymbolicVersionNotDefinedError project: self project versionString: aVersionString) signal ].			^ self map				at: symbolicVersionString				ifAbsent: [ (MetacelloSymbolicVersionDoesNotExistError project: self project versionString: symbolicVersionString) signal ] ].	^ self map		at: aVersionString		ifAbsent: [ (MetacelloVersionDoesNotExistError project: self project versionString: aVersionString) signal ]! !!MetacelloProject methodsFor: 'versions' stamp: 'DaleHenrichs 11/2/2010 17:13'!version: aVersionString ifAbsent: aBlock	^[ self version: aVersionString ] on: MetacelloVersionDoesNotExistError do: [:ex | aBlock value ].! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 06/01/2009 11:00'!versionSpec	^self versionSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/4/2009 18:51'!versionSpecClass	^MetacelloVersionSpec! !!MetacelloProject methodsFor: 'versions' stamp: 'DaleHenrichs 11/10/2010 16:13'!versions	^self map values asArray sort: [:a :b | a <= b ]! !!MetacelloAbstractPackageSpec methodsFor: 'adding' stamp: 'dkh 10/5/2009 12:07'!addToMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec addMember 			name: self name;			spec: self;			yourself)! !!MetacelloAbstractPackageSpec methodsFor: 'querying' stamp: 'dkh 1/4/2010 18:54'!answers	answers == nil ifTrue: [ answers := #() ].	^answers! !!MetacelloAbstractPackageSpec methodsFor: 'accessing' stamp: 'dkh 1/4/2010 19:01'!answers: aListOfPairs	self setAnswers: aListOfPairs! !!MetacelloAbstractPackageSpec methodsFor: 'printing' stamp: 'DaleHenrichs 1/14/2011 15:09'!configMethodBodyOn: aStream hasName: hasName cascading: cascading indent: indent	| hasCascading hasRequires hasIncludes hasAnswers |	hasCascading := cascading.	hasRequires := self requires isEmpty not.	hasIncludes := self includes isEmpty not.	hasAnswers := self answers isEmpty not.	hasRequires		ifTrue: [ 			hasName | hasIncludes | hasAnswers | hasCascading				ifTrue: [ aStream cr; tab: indent ].			aStream nextPutAll: 'requires: #('.			self requires do: [:str | aStream nextPutAll: str printString, ' ' ].			hasIncludes | hasAnswers | hasCascading				ifTrue: [ aStream nextPutAll: ');' ]				ifFalse: [ aStream nextPut: $) ]].	hasIncludes		ifTrue: [ 			hasName | hasRequires | hasAnswers | hasCascading				ifTrue: [ aStream cr; tab: indent ].			aStream nextPutAll: 'includes: #('.			self includes do: [:str | aStream nextPutAll: str printString, ' ' ].			hasAnswers | hasCascading				ifTrue: [ aStream nextPutAll: ');' ]				ifFalse: [ aStream nextPut: $) ]].	hasAnswers		ifTrue: [ 			hasName | hasRequires | hasIncludes | hasCascading				ifTrue: [ aStream cr; tab: indent ].			aStream nextPutAll: 'supplyingAnswers: #( '.			self answers do: [:ar | 				aStream nextPutAll: '#( '.				ar do: [:val | 					(val isString or: [ val isNumber or: [ val isSymbol or: [ val isCharacter ]]])						ifTrue: [  aStream nextPutAll: val printString, ' ' ].					val == true						ifTrue: [  aStream nextPutAll: 'true ' ].					val == false						ifTrue: [  aStream nextPutAll: 'false ' ]].				aStream nextPutAll: ') ' ].			hasCascading				ifTrue: [ aStream nextPutAll: ');' ]				ifFalse: [ aStream nextPut: $) ]].! !!MetacelloAbstractPackageSpec methodsFor: 'printing' stamp: 'dkh 10/5/2009 12:41'!configMethodCascadeOn: aStream member: aMember last: lastCascade indent: indent	self subclassResponsibility! !!MetacelloAbstractPackageSpec methodsFor: 'printing' stamp: 'DaleHenrichs 12/21/2010 15:22'!configMethodOn: aStream for: aValue selector: selector cascading: cascading cascade: cascade indent: indent	| valuePrintString |	aValue == nil ifTrue: [ ^self ].	cascading ifTrue: [ aStream cr; tab: indent ].	valuePrintString := aValue value isSymbol		ifTrue: [ '#' , aValue value asString printString ]		ifFalse: [ aValue value printString ].	aStream  nextPutAll: selector, valuePrintString.	cascade ifTrue: [ aStream nextPut: $; ]! !!MetacelloAbstractPackageSpec methodsFor: 'querying' stamp: 'dkh 9/23/2009 08:45'!includes	includes == nil ifTrue: [ includes := #() ].	^includes! !!MetacelloAbstractPackageSpec methodsFor: 'accessing' stamp: 'dkh 9/23/2009 08:45'!includes: aCollection	aCollection setIncludesInMetacelloPackage: self! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: 'dkh 10/10/2009 10:59'!includesForPackageOrdering	^#()! !!MetacelloAbstractPackageSpec methodsFor: 'printing' stamp: 'DaleHenrichs 3/9/2010 16:33'!label	^self name! !!MetacelloAbstractPackageSpec methodsFor: 'merging' stamp: 'dkh 6/23/2009 11:22'!mergeIntoMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec mergeMember 			name: self name;			spec: self;			yourself)! !!MetacelloAbstractPackageSpec methodsFor: 'merging' stamp: 'DaleHenrichs 1/21/2010 20:36'!mergeMap	| map |	map := super mergeMap.	map at: #requires put: requires.	map at: #includes put: includes.	map at: #answers put: answers.	^map! !!MetacelloAbstractPackageSpec methodsFor: 'merging' stamp: 'DaleHenrichs 1/21/2010 20:21'!mergeSpec: anotherSpec	| newSpec map anotherRequires anotherIncludes anotherAnswers |	newSpec := super mergeSpec: anotherSpec.	map := anotherSpec mergeMap.	anotherSpec name ~~ nil 		ifTrue: [ newSpec name: anotherSpec name ].	(anotherRequires := map at: #requires) ~~ nil		ifTrue: [ newSpec setRequires: self requires, anotherRequires ].	(anotherIncludes := map at: #includes) ~~ nil		ifTrue: [ newSpec setIncludes: self includes, anotherIncludes ].	(anotherAnswers := map at: #answers) ~~ nil		ifTrue: [ newSpec setAnswers: self answers, anotherAnswers ].	^newSpec	! !!MetacelloAbstractPackageSpec methodsFor: 'querying' stamp: 'dkh 6/23/2009 11:24'!name	^name! !!MetacelloAbstractPackageSpec methodsFor: 'accessing' stamp: 'dkh 6/23/2009 11:24'!name: aString	name := aString! !!MetacelloAbstractPackageSpec methodsFor: 'merging' stamp: 'DaleHenrichs 1/21/2010 20:21'!nonOverridable	^#( includes requires answers )! !!MetacelloAbstractPackageSpec methodsFor: 'copying' stamp: 'dkh 1/4/2010 18:55'!postCopy	super postCopy.	requires := requires copy.	includes := includes copy.	answers := answers copy.! !!MetacelloAbstractPackageSpec methodsFor: 'visiting' stamp: 'dkh 10/5/2009 09:38'!projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	self subclassResponsibility! !!MetacelloAbstractPackageSpec methodsFor: 'accessing' stamp: 'dkh 10/24/2009 19:41'!referencedSpec	^self! !!MetacelloAbstractPackageSpec methodsFor: 'removing' stamp: 'dkh 6/23/2009 11:24'!removeFromMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec removeMember 			name: self name;			spec: self;			yourself)! !!MetacelloAbstractPackageSpec methodsFor: 'querying' stamp: 'dkh 6/23/2009 11:25'!requires	requires == nil ifTrue: [ requires := #() ].	^requires! !!MetacelloAbstractPackageSpec methodsFor: 'accessing' stamp: 'dkh 6/23/2009 11:25'!requires: aCollection	aCollection setRequiresInMetacelloPackage: self! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: 'dkh 1/4/2010 18:54'!setAnswers: aCollection	answers := aCollection! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: 'dkh 9/23/2009 08:45'!setIncludes: aCollection	includes := aCollection! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: 'dkh 6/23/2009 11:25'!setRequires: aCollection	requires := aCollection! !!MetacelloGroupSpec methodsFor: 'accessing' stamp: 'dkh 1/4/2010 19:02'!answers: aListOfPairs	self shouldNotImplement! !!MetacelloGroupSpec methodsFor: 'printing' stamp: 'dkh 10/24/2009 15:09'!configMethodCascadeOn: aStream member: aMember last: lastCascade indent: indent	aMember methodUpdateSelector == #remove:		ifTrue: [ aStream nextPutAll: 'removeGroup: ', self name printString. ]		ifFalse: [			aStream 				nextPutAll: 'group: ', self name printString;				space; 				nextPutAll: aMember methodUpdateSelector asString, ' #('.			self includes do: [:str | aStream nextPutAll: str printString, ' ' ].			aStream nextPut: $) ].	lastCascade		ifTrue: [ aStream nextPut: $. ]		ifFalse: [ aStream nextPut: $;; cr ].! !!MetacelloGroupSpec methodsFor: 'printing' stamp: 'dkh 1/6/2010 18:39'!configMethodOn: aStream indent: indent	aStream 		tab: indent;		nextPutAll: 'spec '; cr;		tab: indent + 1;		nextPutAll: 'name: ', self name printString, ';'.	self configMethodBodyOn: aStream hasName: true cascading: false indent: indent + 1.	aStream nextPut: $.! !!MetacelloGroupSpec methodsFor: 'visiting' stamp: 'dkh 10/5/2009 09:39'!projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	groupBlock value: self! !!MetacelloGroupSpec methodsFor: 'accessing' stamp: 'dkh 10/4/2009 09:41'!requires: aCollection	self shouldNotImplement! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: 'dkh 1/4/2010 19:02'!answers: aListOfPairs	self shouldNotImplement! !!MetacelloProjectReferenceSpec methodsFor: 'printing' stamp: 'DaleHenrichs 11/16/2010 13:52'!configMethodCascadeOn: aStream member: aMember last: lastCascade indent: indent	aMember methodUpdateSelector == #remove:		ifTrue: [ aStream nextPutAll: 'removeProject: ' , self name printString ]		ifFalse: [ 			self projectReference == nil				ifTrue: [ ^ self ].			aStream nextPutAll: 'project: ' , self projectName printString , ' '.			(aMember methodUpdateSelector == #copy: and: [ self projectReference hasNonVersionStringField ])				ifTrue: [ aStream nextPutAll: 'copyFrom: ' , aMember sourceName printString , ' ' ].			self projectReference configShortCutMethodOn: aStream member: aMember indent: indent + 1 ].	lastCascade		ifTrue: [ aStream nextPut: $. ]		ifFalse: [ 			aStream				nextPut: $;;				cr ]! !!MetacelloProjectReferenceSpec methodsFor: 'printing' stamp: 'dkh 6/25/2011 19:25'!configMethodOn: aStream indent: indent	aStream 		tab: indent; nextPutAll: 'spec '; cr;		tab: indent + 1; nextPutAll: 'name: ', self name printString; nextPut: $;; cr;		tab: indent + 1; nextPutAll: 'projectReference: '; nextPut: $[; cr.	aStream 		tab: indent + 2; nextPutAll: 'spec'.	self projectReference ifNotNil: [ self projectReference configMethodBodyOn: aStream indent: indent + 2].	aStream nextPutAll: ' ].'! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: 'dkh 10/5/2009 10:13'!includes: aCollection	self shouldNotImplement! !!MetacelloProjectReferenceSpec methodsFor: 'merging' stamp: 'dkh 10/5/2009 11:31'!mergeMap	| map |	map := super mergeMap.	map at: #projectReference put: projectReference.	^map! !!MetacelloProjectReferenceSpec methodsFor: 'merging' stamp: 'DaleHenrichs 1/21/2010 20:00'!mergeSpec: anotherSpec	| newSpec map anotherProjectReference |	newSpec := super mergeSpec: anotherSpec.	map := anotherSpec mergeMap.	(anotherProjectReference := map at: #projectReference) ~~ nil		ifTrue: [ 			newSpec projectReference: 				(newSpec projectReference == nil					ifTrue: [ anotherProjectReference ]					ifFalse: [ newSpec projectReference mergeSpec: anotherProjectReference ])].	^newSpec! !!MetacelloProjectReferenceSpec methodsFor: 'merging' stamp: 'dkh 10/8/2009 20:32'!nonOverridable	^super nonOverridable, #( projectReference )! !!MetacelloProjectReferenceSpec methodsFor: 'copying' stamp: 'DaleHenrichs 11/17/2010 12:43'!postCopy	super postCopy.	projectReference := projectReference copy.! !!MetacelloProjectReferenceSpec methodsFor: 'visiting' stamp: 'dkh 10/24/2009 19:43'!projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	projectBlock value: self! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: 'dkh 9/23/2009 10:51'!projectName	^self projectReference name! !!MetacelloProjectReferenceSpec methodsFor: 'querying' stamp: 'dkh 9/23/2009 10:51'!projectReference	^ projectReference! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: 'dkh 9/23/2009 10:51'!projectReference: anObject	projectReference := anObject! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: 'dkh 10/24/2009 19:42'!referencedSpec	^self projectReference! !!MetacelloProjectReferenceSpec methodsFor: 'querying' stamp: 'DaleHenrichs 2/5/2010 13:42'!relativeCurrentVersion	^self projectReference relativeCurrentVersion! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: 'dkh 10/4/2009 11:40'!requires: aCollection	self shouldNotImplement! !!MetacelloProjectReferenceSpec methodsFor: 'querying' stamp: 'dkh 10/24/2009 10:38'!version	^self projectReference version! !!MetacelloProjectReferenceSpec methodsFor: 'querying' stamp: 'DaleHenrichs 11/5/2010 16:00'!versionOrNil	^self projectReference versionOrNil! !!MetacelloProjectReferenceSpec methodsFor: 'querying' stamp: 'DaleHenrichs 11/16/2010 12:41'!versionString: aString	^self projectReference versionString: aString! !!MetacelloMemberListSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24'!add: aSpec	self subclassResponsibility! !!MetacelloMemberListSpec methodsFor: 'adding' stamp: 'dkh 6/5/2012 19:01:24'!addMember: aMember	self list add: aMember.	self clearMemberMap! !!MetacelloMemberListSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24'!clearMemberMap	memberMap := nil.! !!MetacelloMemberListSpec methodsFor: 'enumeration' stamp: 'dkh 6/5/2012 19:01:24'!collect: aBlock 	| newCollection |	newCollection :=OrderedCollection new.	self do: [:each | newCollection add: (aBlock value: each)].	^ newCollection! !!MetacelloMemberListSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24'!copy: aMemberSpec	self addMember: aMemberSpec! !!MetacelloMemberListSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24'!copy: specNamed to: aSpec	self subclassResponsibility! !!MetacelloMemberListSpec methodsFor: 'toolbox support' stamp: 'dkh 9/12/2012 14:16'!deleteSpec: aSpec    "remove the spec from list"    | member |    member := self list detect: [ :aMember | aMember spec = aSpec ] ifNone: [ ^ self ].    self list remove: member! !!MetacelloMemberListSpec methodsFor: 'enumeration' stamp: 'dkh 6/5/2012 19:01:24'!detect: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the first element for which aBlock evaluates to true."	^ self detect: aBlock ifNone: [ self error: 'Object is not in the collection.' ]! !!MetacelloMemberListSpec methodsFor: 'enumeration' stamp: 'dkh 6/5/2012 19:01:24'!detect: aBlock ifNone: exceptionBlock	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the first element for which aBlock evaluates to true. If none  	evaluate to true, then evaluate the argument, exceptionBlock."	self		do: [ :each | 			(aBlock value: each)				ifTrue: [ ^ each ] ].	^ exceptionBlock value! !!MetacelloMemberListSpec methodsFor: 'enumeration' stamp: 'dkh 6/5/2012 19:01:24'!do: aBlock	self map values do: aBlock! !!MetacelloMemberListSpec methodsFor: 'testing' stamp: 'dkh 6/5/2012 19:01:24'!isEmpty	^self list isEmpty! !!MetacelloMemberListSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!list	list == nil ifTrue: [ list := OrderedCollection new ].	^list! !!MetacelloMemberListSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!list: aCollection	list := aCollection.	self clearMemberMap! !!MetacelloMemberListSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!map		| map |	memberMap ~~ nil ifTrue: [ ^memberMap ].	map := Dictionary new.	self list do: [:member | 		member			applyAdd: [:memberSpec | self mapAdd: memberSpec into: map ] 			copy: [:memberSpec | self mapCopy: memberSpec into: map ]			merge: [:memberSpec | self mapMerge: memberSpec into: map ] 			remove: [:memberSpec | self mapRemove: memberSpec into: map ]].	memberMap := map.	^memberMap! !!MetacelloMemberListSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24'!mapAdd: aMemberSpec into: map		map at: aMemberSpec name put: aMemberSpec spec! !!MetacelloMemberListSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24'!mapCopy: aMemberSpec into: map	| spec |	spec :=  map at: aMemberSpec sourceName ifAbsent: [].	spec == nil		ifTrue: [ ^self error: 'Source spec named ',  aMemberSpec sourceName printString, ' not found'. ]		ifFalse: [ map at: aMemberSpec name put: (spec copy mergeSpec: aMemberSpec spec copy)]! !!MetacelloMemberListSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24'!mapMerge: aMemberSpec into: map	| spec |	spec :=  map at: aMemberSpec name ifAbsent: [].	spec == nil		ifTrue: [ map at: aMemberSpec name put: aMemberSpec spec copy ]		ifFalse: [ map at: aMemberSpec name put: (spec mergeSpec: aMemberSpec spec)]! !!MetacelloMemberListSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24'!mapRemove: aMemberSpec into: map		map removeKey: aMemberSpec name ifAbsent: []! !!MetacelloMemberListSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24'!merge: aSpec	self subclassResponsibility! !!MetacelloMemberListSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24'!mergeSpec: anotherSpec	| newSpec val |	newSpec := super mergeSpec: anotherSpec.	newSpec list: self list copy.	anotherSpec list do: [:groupMember | groupMember applyToList: newSpec ].	^newSpec! !!MetacelloMemberListSpec methodsFor: 'testing' stamp: 'dkh 6/5/2012 19:01:24'!notEmpty	^self list notEmpty! !!MetacelloMemberListSpec methodsFor: 'copying' stamp: 'dkh 6/5/2012 19:01:24'!postCopy	super postCopy.	list := list copy.	self clearMemberMap! !!MetacelloMemberListSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24'!remove: aSpec	self subclassResponsibility! !!MetacelloMemberListSpec methodsFor: 'enumeration' stamp: 'dkh 6/5/2012 19:01:24'!select: aBlock 	| newCollection |	newCollection := OrderedCollection new.	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection! !!MetacelloMemberListSpec methodsFor: 'enumeration' stamp: 'dkh 6/5/2012 19:01:24'!specListDetect: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the first element for which aBlock evaluates to true."	^ self specListDetect: aBlock ifNone: [ self error: 'Object is not in the collection.' ]! !!MetacelloMemberListSpec methodsFor: 'enumeration' stamp: 'dkh 6/5/2012 19:01:24'!specListDetect: aBlock ifNone: exceptionBlock	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the first element for which aBlock evaluates to true. If none  	evaluate to true, then evaluate the argument, exceptionBlock."	self		specListDo: [ :each | 			(aBlock value: each)				ifTrue: [ ^ each ] ].	^ exceptionBlock value! !!MetacelloMemberListSpec methodsFor: 'enumeration' stamp: 'dkh 6/5/2012 19:01:24'!specListDo: aBlock	self list do: [:member |  aBlock value: member spec ]! !!MetacelloMemberListSpec methodsFor: 'enumeration' stamp: 'dkh 6/5/2012 19:01:24'!specListSelect: aBlock 	| newCollection |	newCollection := OrderedCollection new.	self specListDo: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection! !!MetacelloPackagesSpec methodsFor: 'actions' stamp: 'dkh 10/4/2009 11:23'!add: aSpec	aSpec addToMetacelloPackages: self! !!MetacelloPackagesSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 7/23/2010 13:24'!applyIncludesTo: orderedSpecs for: pkgSpec firstTime: firstTime	| movedSpecs baseIndex includedSpec result |	movedSpecs := Set new.	baseIndex := orderedSpecs indexOf: pkgSpec.	pkgSpec includesForPackageOrdering		do: [:includedSpecName | 			includedSpec := orderedSpecs						detect: [:spec | spec name = includedSpecName ]						ifNone: [].			(self slideIn: orderedSpecs spec: includedSpec baseIndex: baseIndex seen: IdentitySet new firstTime: firstTime)				ifTrue: [ movedSpecs add: includedSpec name ]].	^ movedSpecs! !!MetacelloPackagesSpec methodsFor: 'printing' stamp: 'dkh 10/22/2009 10:33'!configMethodOn: aStream indent: indent	| packageSpecs |	packageSpecs := self map values.	packageSpecs size = 0 ifTrue: [ ^aStream nextPutAll: 'spec add: []' ].	packageSpecs size = 1		ifTrue: [			aStream 				tab: indent; 				nextPutAll: 'spec add: ['; cr.			packageSpecs first configMethodOn: aStream indent: indent + 1.			aStream nextPut: $]; cr ]		ifFalse: [			aStream 				tab: indent; 				nextPutAll: 'spec'.			1 to: packageSpecs size do: [:index | | packageSpec |				packageSpec := packageSpecs at: index.				aStream 					tab: indent + 1;					nextPutAll: 'add: ['; cr.				packageSpec configMethodOn: aStream indent: indent + 2.				aStream nextPut: $].				index < packageSpecs size					ifTrue: [ aStream nextPut: $; ].				aStream cr ]]! !!MetacelloPackagesSpec methodsFor: 'actions' stamp: 'dkh 10/4/2009 11:22'!copy: specNamed to: spec	self addMember: 		(self copyMember 			name: spec name;			sourceName: specNamed;			spec: spec;			yourself)! !!MetacelloPackagesSpec methodsFor: 'actions' stamp: 'dkh 10/4/2009 11:23'!merge: aSpec	aSpec mergeIntoMetacelloPackages: self! !!MetacelloPackagesSpec methodsFor: 'accessing' stamp: 'dkh 10/9/2009 13:01'!packageNamed: aString ifAbsent: aBlock	^self map at: aString ifAbsent: aBlock! !!MetacelloPackagesSpec methodsFor: 'accessing' stamp: 'dkh 9/5/2012 05:46'!packageSpecsInLoadOrder    | orderedSpecs moved lastMovedSpecs count terminationLimit map specsWithIncludes firstTime |    "specification order is the default order"    map := self map.    orderedSpecs := OrderedCollection new.    self list        do: [ :member |             | spec |            spec := map at: member name ifAbsent: [  ].            (spec == nil or: [ orderedSpecs includes: spec ])                ifFalse: [ orderedSpecs add: spec ] ].    orderedSpecs isEmpty        ifTrue: [ ^ orderedSpecs ].    moved := true.    count := 0.    terminationLimit := orderedSpecs size * 2.    [ moved ]        whileTrue: [             count := count + 1.            count > terminationLimit                ifTrue: [                     "Cheap termination hack - an APPARENT loop"                    self error: 'Apparent loop in before/after dependency definitions' ].            moved := false.            orderedSpecs                do: [ :packageSpec | moved := moved or: [ self sortPackageSpecs: orderedSpecs for: packageSpec ] ] ].    lastMovedSpecs := Set new.    moved := true.    count := 0.    specsWithIncludes := orderedSpecs select: [ :pkgSpec | pkgSpec includesForPackageOrdering isEmpty not ].    firstTime := true.    [ moved ]        whileTrue: [             | result |            count := count + 1.	"count > terminationLimit"            count > 14                ifTrue: [                     "Cheap termination hack - an APPARENT loop"                    self error: 'Apparent loop in before/after dependency definitions' ].            moved := false.            result := Set new.            specsWithIncludes                do: [ :packageSpec | result addAll: (self applyIncludesTo: orderedSpecs for: packageSpec firstTime: firstTime) ].            result size = lastMovedSpecs size                ifTrue: [                     result                        do: [ :name |                             (lastMovedSpecs includes: name)                                ifFalse: [ moved := true ] ] ]                ifFalse: [ moved := true ].            lastMovedSpecs := result.            firstTime := false ].    ^ orderedSpecs! !!MetacelloPackagesSpec methodsFor: 'actions' stamp: 'dkh 10/4/2009 11:23'!remove: aSpec	aSpec removeFromMetacelloPackages: self! !!MetacelloPackagesSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 7/23/2010 13:27'!slideIn: orderedSpecs spec: targetSpec baseIndex: baseIndex seen: seen firstTime: firstTime	| targetIndex requires targetRequires targetRequiresIndexes minIndex baseSpec required |	(seen includes: targetSpec) ifTrue: [ ^false ].	targetIndex := orderedSpecs indexOf: targetSpec.	baseIndex >= targetIndex ifTrue: [ ^false ].	required := false.	baseSpec := orderedSpecs at: baseIndex.	baseIndex + 1 to: targetIndex - 1 do: [:index | | spec |		spec := orderedSpecs at: index.		(spec requires includes: baseSpec name) ifTrue: [ required := true ]].	firstTime ifFalse: [ required ifFalse: [ ^false ]].	requires := targetSpec requires.	targetRequires := orderedSpecs				select: [:spec | requires includes: spec name].	targetRequiresIndexes := targetRequires				collect: [:spec | orderedSpecs indexOf: spec].	targetRequiresIndexes add: baseIndex.	minIndex := targetRequiresIndexes				detectMax: [:each | each].	minIndex + 1 < targetIndex		ifTrue: [			orderedSpecs remove: targetSpec.			orderedSpecs add: targetSpec afterIndex: minIndex.			seen add: targetSpec ]		ifFalse: [ ^self slideIn: orderedSpecs spec: (orderedSpecs at: minIndex) baseIndex: 1 seen: seen firstTime: firstTime].	^true! !!MetacelloPackagesSpec methodsFor: 'private' stamp: 'dkh 10/10/2009 10:14'!sortPackageSpecs: orderedSpecs for: packageSpec	| packageIndex moved movePackage targetPackage targetIndex targetPackages |	packageIndex := orderedSpecs indexOf: packageSpec.	moved := movePackage := false.	targetPackages := packageSpec requires.	targetPackages do: [:targetPackageName |		targetPackage := orderedSpecs 			detect: [:each | each name = targetPackageName ] 			ifNone: [].		targetIndex := orderedSpecs indexOf: targetPackage.		movePackage := movePackage or: [ packageIndex <= targetIndex ]].	movePackage 		ifTrue: [			moved := true.			orderedSpecs remove: packageSpec ifAbsent: [ ^self error: 'unexpected error removing package' ].			targetIndex := 0.			targetPackages do: [:targetPackageName | 				(targetPackage := orderedSpecs detect: [:each | 					each name = targetPackageName ] ifNone: []) ~~ nil						ifTrue: [ targetIndex := targetIndex max: (orderedSpecs indexOf: targetPackage) ]].			targetIndex == 0				ifTrue: [ orderedSpecs add: packageSpec beforeIndex: packageIndex ]				ifFalse: [ orderedSpecs add: packageSpec afterIndex: targetIndex ]].	^moved! !!MetacelloAddMemberSpec methodsFor: 'actions' stamp: 'dkh 10/4/2009 10:16'!applyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock	addBlock value: self! !!MetacelloAddMemberSpec methodsFor: 'actions' stamp: 'dkh 06/02/2009 18:26'!applyToList: aListSpec	aListSpec add: self! !!MetacelloAddMemberSpec methodsFor: 'accessing' stamp: 'dkh 10/9/2009 11:43'!methodUpdateSelector	^#overrides:! !!MetacelloCopyMemberSpec methodsFor: 'actions' stamp: 'dkh 10/4/2009 10:18'!applyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock	copyBlock value: self! !!MetacelloCopyMemberSpec methodsFor: 'actions' stamp: 'dkh 10/4/2009 10:19'!applyToList: aListSpec	aListSpec copy: self! !!MetacelloCopyMemberSpec methodsFor: 'accessing' stamp: 'dkh 10/4/2009 10:19'!methodUpdateSelector	^#copy:! !!MetacelloCopyMemberSpec methodsFor: 'accessing' stamp: 'dkh 10/4/2009 10:35'!sourceName	^sourceName! !!MetacelloCopyMemberSpec methodsFor: 'accessing' stamp: 'dkh 10/4/2009 10:36'!sourceName: aString	sourceName := aString! !!MetacelloMemberSpec methodsFor: 'actions' stamp: 'dkh 10/4/2009 10:15'!applyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock	self subclassResponsibility! !!MetacelloMemberSpec methodsFor: 'actions' stamp: 'dkh 06/02/2009 18:25'!applyToList: aListSpec	self subclassResponsibility! !!MetacelloMemberSpec methodsFor: 'printing' stamp: 'dkh 10/5/2009 12:39'!configMethodCascadeOn: aStream last: lastCascade indent: indent	self spec 		configMethodCascadeOn: aStream 		member: self 		last: lastCascade 		indent: indent! !!MetacelloMemberSpec methodsFor: 'printing' stamp: 'dkh 10/26/2009 13:34'!configMethodOn: aStream indent: indent	aStream nextPutAll: self class name asString, ' member: ('.	self spec configMethodOn: aStream indent: indent.	aStream nextPutAll: ')'.! !!MetacelloMemberSpec methodsFor: 'accessing' stamp: 'dkh 6/15/2009 10:27'!methodUpdateSelector	^self subclassResponsibility! !!MetacelloMemberSpec methodsFor: 'accessing' stamp: 'dkh 06/02/2009 16:36'!name	^name! !!MetacelloMemberSpec methodsFor: 'accessing' stamp: 'dkh 06/02/2009 16:36'!name: aString	name := aString! !!MetacelloMemberSpec methodsFor: 'accessing' stamp: 'dkh 10/4/2009 10:35'!sourceName	^self name! !!MetacelloMemberSpec methodsFor: 'accessing' stamp: 'dkh 06/02/2009 16:50'!spec	^spec! !!MetacelloMemberSpec methodsFor: 'accessing' stamp: 'dkh 06/02/2009 16:50'!spec: aMetacelloSpec	spec := aMetacelloSpec! !!MetacelloMergeMemberSpec methodsFor: 'actions' stamp: 'dkh 10/4/2009 10:16'!applyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock	mergeBlock value: self! !!MetacelloMergeMemberSpec methodsFor: 'actions' stamp: 'dkh 6/5/2009 16:06'!applyToList: aListSpec	aListSpec merge: self! !!MetacelloMergeMemberSpec methodsFor: 'accessing' stamp: 'dkh 10/9/2009 11:43'!methodUpdateSelector	^#with:! !!MetacelloRemoveMemberSpec methodsFor: 'actions' stamp: 'dkh 10/4/2009 10:16'!applyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock	removeBlock value: self! !!MetacelloRemoveMemberSpec methodsFor: 'actions' stamp: 'dkh 06/02/2009 18:27'!applyToList: aListSpec	aListSpec remove: self! !!MetacelloRemoveMemberSpec methodsFor: 'accessing' stamp: 'dkh 6/15/2009 10:27'!methodUpdateSelector	^#remove:! !!MetacelloProjectSpec methodsFor: 'adding' stamp: 'dkh 10/4/2009 11:51'!addToMetacelloPackages: aMetacelloPackagesSpec	| spec |	spec := (aMetacelloPackagesSpec project projectReferenceSpec)			name: self name;			projectReference: self copy;			yourself.	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec addMember 			name: spec name;			spec: spec;			yourself)			! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 06/02/2009 20:27'!className	^className! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'dkh 06/02/2009 20:31'!className: aString	className := aString! !!MetacelloProjectSpec methodsFor: 'printing' stamp: 'DaleHenrichs 01/16/2011 13:54'!configMethodBodyOn: aStream indent: indent	| hasVersionString hasOperator hasProjectPackage hasLoads hasClassName hasPreLoadDoIt hasPostLoadDoIt |	hasClassName := self className ~~ nil.	hasVersionString := self versionString ~~ nil.	hasOperator := operator ~~ nil.	hasProjectPackage := self projectPackage ~~ nil		and: [ self projectPackage packageRepository ~~ nil or: [ self projectPackage name ~= self className ] ].	hasLoads := self loads ~~ nil.	hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.	hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.	hasClassName		ifTrue: [ 			hasVersionString | hasOperator | hasProjectPackage | hasLoads				ifTrue: [ 					aStream						cr;						tab: indent + 1 ]				ifFalse: [ aStream space ].			aStream nextPutAll: 'className: ' , self className printString.			hasVersionString | hasPreLoadDoIt | hasPostLoadDoIt | hasOperator | hasProjectPackage | hasLoads				ifTrue: [ aStream nextPut: $; ] ].	hasVersionString		ifTrue: [ 			| vs |			hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPreLoadDoIt | hasPostLoadDoIt				ifTrue: [ 					aStream						cr;						tab: indent + 1 ]				ifFalse: [ aStream space ].			vs := self versionString.			aStream nextPutAll: 'versionString: '.			vs isSymbol				ifTrue: [ aStream nextPut: $# ].			aStream nextPutAll: vs asString printString.			hasPreLoadDoIt | hasPostLoadDoIt | hasOperator | hasProjectPackage | hasLoads				ifTrue: [ aStream nextPut: $; ] ].	hasPreLoadDoIt		ifTrue: [ 			hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPreLoadDoIt				ifTrue: [ 					aStream						cr;						tab: indent + 1 ]				ifFalse: [ aStream space ].			aStream nextPutAll: 'preLoadDoIt: '.			self preLoadDoIt value isSymbol				ifTrue: [ 					aStream 						nextPut: $#;						nextPutAll: self preLoadDoIt value asString printString]				ifFalse: [ aStream nextPutAll: self preLoadDoIt value asString ].			hasPostLoadDoIt | hasOperator | hasProjectPackage | hasLoads				ifTrue: [ aStream nextPut: $; ] ].	hasPostLoadDoIt		ifTrue: [ 			hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPostLoadDoIt				ifTrue: [ 					aStream						cr;						tab: indent + 1 ]				ifFalse: [ aStream space ].			aStream nextPutAll: 'postLoadDoIt: '.			self postLoadDoIt value isSymbol				ifTrue: [ 					aStream 						nextPut: $#;						nextPutAll: self postLoadDoIt value asString printString]				ifFalse: [ aStream nextPutAll: self postLoadDoIt value asString ].			hasOperator | hasProjectPackage | hasLoads				ifTrue: [ aStream nextPut: $; ] ].	hasOperator		ifTrue: [ 			hasClassName | hasVersionString | hasProjectPackage | hasLoads | hasPreLoadDoIt | hasPostLoadDoIt				ifTrue: [ 					aStream						cr;						tab: indent + 1 ]				ifFalse: [ aStream space ].			aStream nextPutAll: 'operator: #' , self operator asString printString.			hasProjectPackage | hasLoads				ifTrue: [ aStream nextPut: $; ] ].	hasLoads		ifTrue: [ 			hasClassName | hasVersionString | hasOperator | hasProjectPackage | hasPreLoadDoIt | hasPostLoadDoIt				ifTrue: [ 					aStream						cr;						tab: indent + 1 ]				ifFalse: [ aStream space ].			aStream nextPutAll: 'loads: #('.			self loads do: [ :str | aStream nextPutAll: str printString , ' ' ].			aStream nextPut: $).			hasProjectPackage				ifTrue: [ aStream nextPut: $; ] ].	hasProjectPackage		ifTrue: [ 			| hasName hasRepo |			hasName := self projectPackage name ~= self className.			hasRepo := self projectPackage packageRepository ~~ nil.			hasName				ifTrue: [ 					hasClassName | hasVersionString | hasOperator | hasLoads | hasPreLoadDoIt | hasPostLoadDoIt						ifTrue: [ 							aStream								cr;								tab: indent + 1 ]						ifFalse: [ aStream space ].					aStream nextPutAll: 'file: ' , self projectPackage name printString.					hasRepo						ifTrue: [ aStream nextPut: $; ] ].			hasRepo				ifTrue: [ 					| repos |					repos := self projectPackage repositories.					repos map values size = 1						ifTrue: [ 							hasClassName | hasVersionString | hasOperator | hasLoads | hasPreLoadDoIt | hasPostLoadDoIt								ifTrue: [ 									aStream										cr;										tab: indent + 1 ]								ifFalse: [ aStream space ].							self projectPackage packageRepository configMethodCascadeOn: aStream lastCascade: true ]						ifFalse: [ 							aStream cr.							self projectPackage repositories configMethodCascadeOn: aStream indent: indent ] ] ]! !!MetacelloProjectSpec methodsFor: 'printing' stamp: 'dkh 10/24/2009 19:56'!configMethodOn: aStream indent: indent	aStream 		tab: indent;		nextPutAll: 'spec '; cr;		tab: indent + 1;		nextPutAll: 'name: ', self name printString, ';'.	self configMethodBodyOn: aStream indent: indent.	aStream nextPut: $.! !!MetacelloProjectSpec methodsFor: 'printing' stamp: 'DaleHenrichs 1/12/2011 12:28'!configShortCutMethodOn: aStream member: aMember indent: indent	| hasVersionString hasOperator hasProjectPackage hasLoads hasClassName hasPreLoadDoIt hasPostLoadDoIt |	hasClassName := self className ~~ nil.	hasVersionString := self versionString ~~ nil.	hasOperator := operator ~~ nil.	hasProjectPackage := self projectPackage ~~ nil		and: [ self projectPackage name ~~ nil or: [ self projectPackage packageRepository ~~ nil ] ].	hasLoads := self loads ~~ nil.	hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.	hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.	hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPreLoadDoIt | hasPostLoadDoIt		ifTrue: [ 			(aMember methodUpdateSelector == #copy: or: [ aMember methodUpdateSelector == #with: ])				ifTrue: [ 					aStream						nextPutAll: 'with: [';						cr ]				ifFalse: [ 					aStream						nextPutAll: 'overrides: [';						cr ].			aStream				tab: indent;				nextPutAll: 'spec'.			self configMethodBodyOn: aStream indent: indent.			aStream nextPutAll: ' ]'.			^ self ].	hasVersionString		ifTrue: [ 			| vs |			vs := self versionString.			aStream nextPutAll: 'with: '.			vs isSymbol				ifTrue: [ aStream nextPut: $# ].			aStream nextPutAll: vs asString printString ]! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'DaleHenrichs 12/21/2010 13:44'!getPostLoadDoIt	^postLoadDoIt! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'DaleHenrichs 12/21/2010 13:44'!getPreLoadDoIt	^preLoadDoIt! !!MetacelloProjectSpec methodsFor: 'printing' stamp: 'DaleHenrichs 3/9/2010 16:33'!label	^self name! !!MetacelloProjectSpec methodsFor: 'loading' stamp: 'dkh 6/9/2009 10:16'!load	self subclassResponsibility! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 10/4/2009 12:04'!loads	^ loads! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'dkh 10/4/2009 12:05'!loads: aCollection	aCollection setLoadsInMetacelloProject: self! !!MetacelloProjectSpec methodsFor: 'merging' stamp: 'DaleHenrichs 1/21/2010 19:34'!mergeMap	| map |	map := super mergeMap.	map at: #name put: name.	map at: #className put: className.	map at: #versionString put: versionString.	map at: #operator put: operator.	map at: #loads put: loads.	map at: #preLoadDoIt put: preLoadDoIt.	map at: #postLoadDoIt put: postLoadDoIt.	^map! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 06/02/2009 20:32'!name	^name! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'dkh 06/02/2009 20:32'!name: aString	name := aString! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 10/6/2009 15:39'!operator	operator == nil ifTrue: [ ^#>= ].	^ operator! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/14/2009 13:37'!operator: anObject	" #= #~= #> #< #>= #<= #~> "		operator := anObject! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'DaleHenrichs 1/21/2010 18:15'!postLoadDoIt	^postLoadDoIt! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 12/21/2010 13:56'!postLoadDoIt: anObject	anObject setPostLoadDoItInMetacelloSpec: self! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'DaleHenrichs 12/21/2010 13:56'!preLoadDoIt	^preLoadDoIt! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 12/21/2010 13:56'!preLoadDoIt: anObject	anObject setPreLoadDoItInMetacelloSpec: self! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 10/5/2009 11:47'!projectPackage	^nil! !!MetacelloProjectSpec methodsFor: 'private' stamp: 'dkh 10/4/2009 12:04'!setLoads: aCollection	loads := aCollection! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 12/21/2010 13:52'!setPostLoadDoIt: aSymbol	postLoadDoIt := aSymbol! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 12/21/2010 13:53'!setPreLoadDoIt: aSymbol	preLoadDoIt := aSymbol! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'DaleHenrichs 9/22/2010 13:52'!versionKey	"suitable for using as a unique key for the receiver's version in a dictionary"	^ self version versionKey! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 6/7/2009 09:20'!versionString	^ versionString! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/7/2009 09:20'!versionString: anObject	versionString := anObject! !!MetacelloSpec class methodsFor: 'instance creation' stamp: 'dkh 05/01/2009 12:22'!for: aVersionMap	^(self platformClass new)		for: aVersionMap;		yourself! !!MetacelloSpec class methodsFor: 'accessing' stamp: 'dkh 04/22/2009 12:22'!platformClass	^self! !!MetacelloSpec methodsFor: 'spec creation' stamp: 'dkh 06/02/2009 16:54'!addMember	^MetacelloAddMemberSpec for: self project! !!MetacelloSpec methodsFor: 'querying' stamp: 'DaleHenrichs 4/9/2010 12:47'!answers	^#()! !!MetacelloSpec methodsFor: 'printing' stamp: 'dkh 10/5/2009 09:14'!configMethodOn: aStream	self configMethodOn: aStream indent: 0! !!MetacelloSpec methodsFor: 'printing' stamp: 'dkh 10/5/2009 09:14'!configMethodOn: aStream indent: indent	self subclassResponsibility! !!MetacelloSpec methodsFor: 'spec creation' stamp: 'dkh 10/4/2009 10:44'!copyMember	^MetacelloCopyMemberSpec for: self project! !!MetacelloSpec methodsFor: 'doits' stamp: 'dkh 12/30/2009 13:17'!doItBlock: selector	selector == nil ifTrue: [ ^nil ].	selector numArgs = 0		ifTrue: [ ^[ self project configuration perform: selector ] ].	selector numArgs = 1		ifTrue: [ ^[:aLoader | self project configuration perform: selector with: aLoader ] ].	selector numArgs = 2		ifTrue: [ ^[:aLoader :pkgSpec | self project configuration perform: selector with: aLoader with: pkgSpec ] ].	^nil! !!MetacelloSpec methodsFor: 'initialization' stamp: 'dkh 06/02/2009 18:05'!for: aProject	project := aProject! !!MetacelloSpec methodsFor: 'printing' stamp: 'DaleHenrichs 3/9/2010 16:33'!label	^self printString! !!MetacelloSpec methodsFor: 'accessing' stamp: 'dkh 6/18/2009 10:30'!loader	loader == nil 		ifTrue: [ | prjctLoader |			(prjctLoader := self project loader) == nil				ifTrue: [ self loader: (self project loaderClass on: self) ]				ifFalse: [ self loader: prjctLoader ]].	^loader! !!MetacelloSpec methodsFor: 'accessing' stamp: 'dkh 6/18/2009 09:46'!loader: aLoader	"We're interested in propogating the loader state, _except_ for the spec"	loader := aLoader copy.	loader spec: self! !!MetacelloSpec methodsFor: 'merging' stamp: 'dkh 06/04/2009 14:40'!mergeMap	^Dictionary new.! !!MetacelloSpec methodsFor: 'spec creation' stamp: 'dkh 06/02/2009 16:54'!mergeMember	^MetacelloMergeMemberSpec for: self project! !!MetacelloSpec methodsFor: 'merging' stamp: 'DaleHenrichs 11/27/2010 12:16'!mergeSpec: aSpec	| newSpec nonOverridable |	aSpec class = self class		ifFalse: [ self error: 'The project spec ', self name printString, ' in project ', self project label, ' has imcompatible specs.' ].	newSpec := self copy.	nonOverridable := self nonOverridable.	aSpec mergeMap		keysAndValuesDo: [ :key :value | 			(nonOverridable includes: key)				ifFalse: [ 					value ~~ nil						ifTrue: [ newSpec instVarNamed: key asString put: value ] ] ].	^ newSpec! !!MetacelloSpec methodsFor: 'merging' stamp: 'dkh 9/23/2009 11:41'!nonOverridable	^#()! !!MetacelloSpec methodsFor: 'copying' stamp: 'dkh 10/4/2009 18:56'!postCopy	super postCopy.	loader ~~ nil  ifTrue: [ self loader: loader ]! !!MetacelloSpec methodsFor: 'doits' stamp: 'dkh 12/30/2009 13:20'!postLoadDoIt	"noop unless non-nil value returned"	^nil! !!MetacelloSpec methodsFor: 'doits' stamp: 'DaleHenrichs 12/21/2010 11:47'!postLoadDoItBlock	^self doItBlock: self postLoadDoIt value! !!MetacelloSpec methodsFor: 'doits' stamp: 'dkh 12/30/2009 13:20'!preLoadDoIt	"noop unless non-nil value returned"		^nil! !!MetacelloSpec methodsFor: 'doits' stamp: 'DaleHenrichs 12/21/2010 11:49'!preLoadDoItBlock	^self doItBlock: self preLoadDoIt value! !!MetacelloSpec methodsFor: 'printing' stamp: 'dkh 10/5/2009 11:08'!printOn: aStream	self configMethodOn: aStream indent: 0! !!MetacelloSpec methodsFor: 'querying' stamp: 'dkh 06/02/2009 14:42'!project	^project! !!MetacelloSpec methodsFor: 'spec creation' stamp: 'dkh 06/02/2009 16:54'!removeMember	^MetacelloRemoveMemberSpec for: self project! !!MetacelloValueHolderSpec methodsFor: 'printing' stamp: 'dkh 10/5/2009 12:23'!configMethodOn: aStream indent: indent	aStream tab: indent; nextPutAll: 'spec value: ', self value printString! !!MetacelloValueHolderSpec methodsFor: 'merging' stamp: 'dkh 6/5/2009 11:46'!mergeMap	| map |	map := super mergeMap.	map at: #value put: value.	^map! !!MetacelloValueHolderSpec methodsFor: 'private' stamp: 'dkh 9/13/2009 07:46'!setAuthorInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setAuthor: self! !!MetacelloValueHolderSpec methodsFor: 'private' stamp: 'dkh 6/5/2009 10:49'!setBlessingInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setBlessing: self! !!MetacelloValueHolderSpec methodsFor: 'private' stamp: 'dkh 6/5/2009 11:54'!setDescriptionInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setDescription: self! !!MetacelloValueHolderSpec methodsFor: 'private' stamp: 'DaleHenrichs 12/21/2010 13:54'!setPostLoadDoItInMetacelloSpec: aMetacelloSpec	aMetacelloSpec setPostLoadDoIt: self! !!MetacelloValueHolderSpec methodsFor: 'private' stamp: 'DaleHenrichs 12/21/2010 13:54'!setPreLoadDoItInMetacelloSpec: aMetacelloSpec	aMetacelloSpec setPreLoadDoIt: self! !!MetacelloValueHolderSpec methodsFor: 'private' stamp: 'dkh 9/13/2009 07:47'!setTimestampInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setTimestamp: self! !!MetacelloValueHolderSpec methodsFor: 'querying' stamp: 'dkh 6/5/2009 11:46'!value	^ value! !!MetacelloValueHolderSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2009 11:46'!value: anObject	value := anObject! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 9/13/2009 07:42'!author	author == nil 		ifTrue: [			^self project valueHolderSpec				value: '';				yourself].	^ author! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 9/13/2009 07:43'!author: anObject	anObject setAuthorInMetacelloVersion: self! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 8/26/2009 10:10'!blessing	blessing == nil 		ifTrue: [			^self project valueHolderSpec				value: self project defaultBlessing;				yourself].	^ blessing! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2009 10:44'!blessing: anObject	anObject setBlessingInMetacelloVersion: self! !!MetacelloVersionSpec methodsFor: 'printing' stamp: 'DaleHenrichs 12/23/2010 10:03'!configMethodOn: aStream for: spec selector: selector last: last indent: indent	spec == nil		ifTrue: [ ^ self ].	aStream		tab: indent;		nextPutAll: 'spec ' , selector , ' [';		cr.	spec configMethodOn: aStream indent: indent + 1.	aStream nextPutAll: ' ].'.	last		ifFalse: [ aStream cr ]! !!MetacelloVersionSpec methodsFor: 'printing' stamp: 'DaleHenrichs 12/23/2010 14:27'!configMethodOn: aStream indent: indent	self configMethodOn: aStream last: true indent: indent! !!MetacelloVersionSpec methodsFor: 'printing' stamp: 'DaleHenrichs 12/23/2010 09:51'!configMethodOn: aStream last: last indent: indent	| values lastIndex lastBlock |	last		ifTrue: [ 			"need to calculate last statement with a value"			values := {(self getBlessing).			(self getDescription).			(self getPreLoadDoIt).			(self getPostLoadDoIt).			(self getAuthor).			(self getTimestamp)}.			1 to: values size do: [ :index | 				(values at: index) ~~ nil					ifTrue: [ lastIndex := index ] ].			lastBlock := [ :arg | arg = lastIndex ] ]		ifFalse: [ lastBlock := [ :arg | false ] ].	self		configMethodValueOn: aStream		for: self getBlessing		selector: 'blessing:'		last: (lastBlock value: 1)		indent: indent.	self		configMethodValueOn: aStream		for: self getDescription		selector: 'description:'		last: (lastBlock value: 2)		indent: indent.	self		configMethodValueOn: aStream		for: self getPreLoadDoIt		selector: 'preLoadDoIt:'		last: (lastBlock value: 3)		indent: indent.	self		configMethodValueOn: aStream		for: self getPostLoadDoIt		selector: 'postLoadDoIt:'		last: (lastBlock value: 4)		indent: indent.	self		configMethodValueOn: aStream		for: self getAuthor		selector: 'author:'		last: (lastBlock value: 5)		indent: indent.	self		configMethodValueOn: aStream		for: self getTimestamp		selector: 'timestamp:'		last: (lastBlock value: 6)		indent: indent! !!MetacelloVersionSpec methodsFor: 'printing' stamp: 'DaleHenrichs 12/23/2010 09:38'!configMethodValueOn: aStream for: spec selector: selector last: last indent: indent	| valuePrintString |	spec == nil		ifTrue: [ ^ self ].	valuePrintString := spec value isSymbol		ifTrue: [ '#' , spec value asString printString ]		ifFalse: [ spec value printString ].	aStream		tab: indent;		nextPutAll: 'spec ' , selector , ' ' , valuePrintString , '.'.	last		ifFalse: [ aStream cr ]! !!MetacelloVersionSpec methodsFor: 'printing' stamp: 'DaleHenrichs 12/23/2010 09:39'!configSpawnMethodOn: aStream indent: indent	self configMethodValueOn: aStream for: self getBlessing selector: 'blessing:' last: false indent: indent.	self configMethodValueOn: aStream for: self getAuthor selector: 'author:' last: false indent: indent.	self configMethodValueOn: aStream for: self getTimestamp selector: 'timestamp:' last: false indent: indent.! !!MetacelloVersionSpec methodsFor: 'private' stamp: 'dkh 10/7/2009 14:45'!createVersion	^self versionClass fromSpec: self! !!MetacelloVersionSpec methodsFor: 'toolbox support' stamp: 'dkh 9/12/2012 14:26'!deleteSpec: aSpec    "remove the spec from packages"    self packages deleteSpec: aSpec! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 8/26/2009 10:35'!description	description == nil 		ifTrue: [			^self project valueHolderSpec				value: '';				yourself].	^ description! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2009 11:40'!description: anObject	anObject setDescriptionInMetacelloVersion: self! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 10/3/2009 16:42'!getAuthor	^author! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 10/3/2009 16:41'!getBlessing	^blessing! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 10/3/2009 16:41'!getDescription	^description! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 12/30/2009 13:25'!getPostLoadDoIt	^postLoadDoIt! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 12/30/2009 13:25'!getPreLoadDoIt	^preLoadDoIt! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 10/3/2009 16:42'!getTimestamp	^timestamp! !!MetacelloVersionSpec methodsFor: 'testing' stamp: 'dkh 12/14/2009 10:20'!isPartiallyCurrent: notLoadedMatters useEquality: useEquality	self subclassResponsibility! !!MetacelloVersionSpec methodsFor: 'testing' stamp: 'dkh 12/14/2009 10:20'!isPossibleBaseline	self subclassResponsibility! !!MetacelloVersionSpec methodsFor: 'printing' stamp: 'DaleHenrichs 3/9/2010 16:34'!label	^self versionString, ' [', self projectLabel, ']'! !!MetacelloVersionSpec methodsFor: 'merging' stamp: 'dkh 12/30/2009 14:17'!mergeMap	| map |	map := super mergeMap.	map at: #versionString put: versionString.	map at: #blessing put: blessing.	map at: #description put: description.	map at: #author put: author.	map at: #timestamp put: timestamp.	map at: #preLoadDoIt put: preLoadDoIt.	map at: #postLoadDoIt put: postLoadDoIt.	^map! !!MetacelloVersionSpec methodsFor: 'copying' stamp: 'dkh 10/4/2009 19:10'!postCopy	super postCopy.	blessing := blessing copy.	description := description copy.	author := author copy.	timestamp := timestamp copy.	! !!MetacelloVersionSpec methodsFor: 'querying' stamp: 'dkh 12/30/2009 13:14'!postLoadDoIt	^postLoadDoIt! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 12/21/2010 13:51'!postLoadDoIt: anObject	anObject setPostLoadDoItInMetacelloSpec: self! !!MetacelloVersionSpec methodsFor: 'querying' stamp: 'dkh 12/30/2009 13:15'!preLoadDoIt	^preLoadDoIt! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 12/21/2010 13:50'!preLoadDoIt: anObject	anObject setPreLoadDoItInMetacelloSpec: self! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 3/9/2010 16:31'!projectLabel	^self project label! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 9/13/2009 07:44'!setAuthor: anObject	author := anObject! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2009 10:44'!setBlessing: anObject	blessing := anObject! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2009 11:40'!setDescription: anObject	description := anObject! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 12/21/2010 11:37'!setPostLoadDoIt: aSymbol	postLoadDoIt := aSymbol! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 12/21/2010 11:37'!setPreLoadDoIt: aSymbol	preLoadDoIt := aSymbol! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 9/13/2009 07:44'!setTimestamp: anObject	timestamp := anObject! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 9/13/2009 07:42'!timestamp	timestamp == nil 		ifTrue: [			^self project valueHolderSpec				value: '';				yourself].	^ timestamp! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 9/13/2009 07:44'!timestamp: anObject	anObject setTimestampInMetacelloVersion: self! !!MetacelloVersionSpec methodsFor: 'private' stamp: 'dkh 10/7/2009 14:44'!versionClass	^MetacelloVersion! !!MetacelloVersionSpec methodsFor: 'querying' stamp: 'dkh 8/31/2009 05:10'!versionString	versionString == nil ifTrue: [ ^'' ].	^ versionString! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/4/2009 18:50'!versionString: anObject	versionString := anObject! !!MetacelloSpecLoader class methodsFor: 'instance creation' stamp: 'dkh 04/23/2009 11:24'!on: aMetacelloPackagesSpec	^(self new) 		spec: aMetacelloPackagesSpec;		yourself! !!MetacelloSpecLoader methodsFor: 'actions' stamp: 'dkh 04/23/2009 11:21'!load	self subclassResponsibility! !!MetacelloSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/12/2009 14:17'!loadType	"#atomic or #linear"		^self project loadType! !!MetacelloSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/12/2009 14:17'!project	^self spec project! !!MetacelloSpecLoader methodsFor: 'accessing' stamp: 'dkh 04/23/2009 11:20'!spec	^spec! !!MetacelloSpecLoader methodsFor: 'accessing' stamp: 'dkh 04/23/2009 11:20'!spec: aMetacelloPackagesSpec	spec := aMetacelloPackagesSpec! !!MetacelloSpecLoader methodsFor: 'actions' stamp: 'dkh 04/23/2009 11:48'!unload	self subclassResponsibility! !!MetacelloValidationCriticalWarning methodsFor: 'testing' stamp: 'DaleHenrichs 11/4/2010 12:27'!isCriticalWarning	^true! !!MetacelloValidationCriticalWarning methodsFor: 'accessing' stamp: 'DaleHenrichs 11/4/2010 12:27'!label	^'Critical Warning'! !!MetacelloValidationError methodsFor: 'testing' stamp: 'DaleHenrichs 11/3/2010 16:44'!isError	^true! !!MetacelloValidationError methodsFor: 'accessing' stamp: 'DaleHenrichs 11/3/2010 16:37'!label	^'Error'! !!MetacelloValidationIssue class methodsFor: 'instance creation' stamp: 'DaleHenrichs 11/30/2010 13:25'!configurationClass: aClass reasonCode: aSymbol callSite: aCallSite explanation: aString	^(self new)		configurationClass: aClass;		reasonCode: aSymbol;		callSite: aCallSite;		explanation: aString;		yourself! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: 'DaleHenrichs 11/20/2010 07:23'!callSite	^ callSite! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: 'DaleHenrichs 11/20/2010 07:23'!callSite: anObject	callSite := anObject! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: 'DaleHenrichs 11/5/2010 10:20'!configurationClass	^ configurationClass! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: 'DaleHenrichs 11/5/2010 10:20'!configurationClass: aClass	configurationClass := aClass! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: 'DaleHenrichs 11/3/2010 13:57'!explanation	^ explanation! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: 'DaleHenrichs 11/3/2010 13:58'!explanation: aString	explanation := aString! !!MetacelloValidationIssue methodsFor: 'testing' stamp: 'DaleHenrichs 11/4/2010 12:27'!isCritical	^self isError or: [ self isCriticalWarning ]! !!MetacelloValidationIssue methodsFor: 'testing' stamp: 'DaleHenrichs 11/4/2010 12:26'!isCriticalWarning	^false! !!MetacelloValidationIssue methodsFor: 'testing' stamp: 'DaleHenrichs 11/3/2010 16:44'!isError	^false! !!MetacelloValidationIssue methodsFor: 'testing' stamp: 'DaleHenrichs 11/3/2010 16:44'!isWarning	^false! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: 'DaleHenrichs 11/3/2010 16:37'!label	^''! !!MetacelloValidationIssue methodsFor: 'printing' stamp: 'DaleHenrichs 12/4/2010 10:29'!printOn: aStream	aStream		nextPutAll: self label;		nextPut: $:;		space;		nextPutAll: self explanation.	self reasonCode ~~ #none		ifTrue: [ 			aStream				space;				nextPut: ${;				space;				nextPutAll: self reasonCode asString;				space;				nextPut: $} ].	(self configurationClass ~~ nil or: [ self callSite ~~ nil ])		ifTrue: [ 			aStream				space;				nextPut: $[;				space.			self configurationClass ~~ nil				ifTrue: [ 					aStream						nextPutAll: self configurationClass name asString;						space ].			self callSite ~~ nil				ifTrue: [ 					aStream						nextPutAll: self callSite name asString;						space ].			aStream nextPut: $] ]! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: 'DaleHenrichs 11/3/2010 20:36'!reasonCode	reasonCode == nil ifTrue: [ reasonCode := #none ].	^ reasonCode! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: 'DaleHenrichs 11/3/2010 20:32'!reasonCode: anObject	reasonCode := anObject! !!MetacelloValidationWarning methodsFor: 'testing' stamp: 'DaleHenrichs 11/3/2010 16:45'!isWarning	^true! !!MetacelloValidationWarning methodsFor: 'accessing' stamp: 'DaleHenrichs 11/3/2010 16:37'!label	^'Warning'! !!Object methodsFor: '*metacello-core' stamp: 'dkh 8/13/2009 10:37'!metacelloIntegerLessThanSelf: anInteger	^self error: 'Invalid Metacello verson component - should be String or Integer.'! !!Object methodsFor: '*metacello-core' stamp: 'dkh 8/13/2009 11:22'!metacelloStringLessThanSelf: anInteger	^self error: 'Invalid Metacello verson component - should be String or Integer.'! !!Object methodsFor: '*metacello-core' stamp: 'dkh 8/13/2009 10:20'!metacelloVersionComponentLessThan: aMetacelloVersonComponent	^self error: 'Invalid Metacello verson component - should be String or Integer.'! !!MetacelloMethodSectionPath methodsFor: 'conversion' stamp: 'dkh 9/7/2012 14:00'!asAttributeOrPath    self size = 1        ifTrue: [             | attribute |            attribute := self at: 1.            ^ attribute size = 1                ifTrue: [ attribute at: 1 ]                ifFalse: [ attribute ] ].    ^ self! !!MetacelloMethodSectionPath methodsFor: 'conversion' stamp: 'dkh 9/7/2012 13:41'!asMetacelloAttributePath    ^ self! !!MetacelloCleanNotification class methodsFor: 'exceptioninstantiator' stamp: 'DaleHenrichs 11/21/2010 19:16'!signal: aMetacelloVersion	^ self new signal: aMetacelloVersion! !!MetacelloCleanNotification methodsFor: 'signaling' stamp: 'DaleHenrichs 11/21/2010 19:16'!signal: aMetacelloVersion	self version: aMetacelloVersion.	^ self signal! !!MetacelloCleanNotification methodsFor: 'accessing' stamp: 'DaleHenrichs 11/21/2010 19:16'!version	^ version! !!MetacelloCleanNotification methodsFor: 'accessing' stamp: 'DaleHenrichs 11/21/2010 19:16'!version: anObject	version := anObject! !!MetacelloClearStackCacheNotification methodsFor: 'accessing' stamp: 'dkh 4/6/2011 23:14'!cacheNames	^ cacheNames! !!MetacelloClearStackCacheNotification methodsFor: 'accessing' stamp: 'dkh 4/6/2011 23:14'!cacheNames: anArray	cacheNames := anArray! !!MetacelloClearStackCacheNotification methodsFor: 'signaling' stamp: 'dkh 4/6/2011 23:15'!signal: anArray	"Signal the occurrence of an exceptional condition with a specified cacheName."	self cacheNames: anArray.	^ self signal! !!MetacelloSkipDirtyPackageLoad class methodsFor: 'signalling' stamp: 'dkh 11/16/2011 10:12'!signal: aMetacelloPackageSpec	^(self new packageSpec: aMetacelloPackageSpec) signal! !!MetacelloSkipDirtyPackageLoad methodsFor: 'accessing' stamp: 'dkh 11/16/2011 10:13'!defaultAction	"Default action is to skip the load of a dirty package"	^true! !!MetacelloSkipDirtyPackageLoad methodsFor: 'accessing' stamp: 'dkh 11/16/2011 10:10'!packageSpec	^packageSpec! !!MetacelloSkipDirtyPackageLoad methodsFor: 'accessing' stamp: 'dkh 11/16/2011 10:10'!packageSpec: aMetacelloPackageSpec	packageSpec := aMetacelloPackageSpec! !!MetacelloValidationNotification class methodsFor: 'exceptioninstantiator' stamp: 'DaleHenrichs 11/4/2010 10:00'!signal: aMetacelloValidationIssue	^ self new signal: aMetacelloValidationIssue! !!MetacelloValidationNotification methodsFor: 'accessing' stamp: 'DaleHenrichs 11/4/2010 10:01'!issue	^ issue! !!MetacelloValidationNotification methodsFor: 'accessing' stamp: 'DaleHenrichs 11/4/2010 10:01'!issue: anObject	issue := anObject! !!MetacelloValidationNotification methodsFor: 'signaling' stamp: 'DaleHenrichs 11/4/2010 10:01'!signal: aMetacelloValidationIssue	self issue: aMetacelloValidationIssue.	^ self signal! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 10/7/2009 00:12'!setAuthorInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setAuthorWithBlock: self! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 10/7/2009 00:12'!setBlessingInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setBlessingWithBlock: self! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 10/7/2009 00:14'!setDescriptionInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setDescriptionWithBlock: self! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 10/9/2009 11:28'!setPackage: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setPackage: aString withBlock: self! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 10/9/2009 11:17'!setProject: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setProject: aString withBlock: self! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 10/7/2009 00:15'!setTimestampInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setTimestampWithBlock: self! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 6/6/2009 11:45'!addToMetacelloPackages: aMetacelloPackagesSpec	self do: [:each | each addToMetacelloPackages: aMetacelloPackagesSpec ]! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 9/6/2012 10:03:17'!asMetacelloAttributeList    ^ self! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 9/6/2012 10:03:17'!asMetacelloAttributePath    ^ MetacelloMethodSectionPath withAll: self! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 6/6/2009 11:46'!mergeIntoMetacelloPackages: aMetacelloPackagesSpec	self do: [:each | each mergeIntoMetacelloPackages: aMetacelloPackagesSpec ]! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 6/6/2009 11:42'!removeFromMetacelloPackages: aMetacelloPackagesSpec	self do: [:each | each removeFromMetacelloPackages: aMetacelloPackagesSpec ]! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 9/6/2012 07:42'!setForDo: aBlock withInMetacelloConfig: aMetacelloConstructore    aMetacelloConstructore setFor: self do: aBlock! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 9/6/2012 07:43'!setForVersion: aString withInMetacelloConfig: aMetacelloConstructore    aMetacelloConstructore setFor: self version: aString! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 9/23/2009 08:46'!setIncludesInMetacelloPackage: aMetacelloPackageSpec	aMetacelloPackageSpec setIncludes: self asArray.! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 6/8/2009 19:02'!setLoadsInMetacelloProject: aMetacelloPackageSpec	aMetacelloPackageSpec setLoads: self asArray.! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 6/6/2009 10:08'!setRequiresInMetacelloPackage: aMetacelloPackageSpec	aMetacelloPackageSpec setRequires: self asArray.! !!Symbol methodsFor: '*metacello-core' stamp: 'dkh 9/6/2012 10:03:17'!asMetacelloAttributeList    ^ {self}! !!Symbol methodsFor: '*metacello-core' stamp: 'dkh 9/6/2012 10:03:17'!asMetacelloAttributePath    ^ MetacelloMethodSectionPath with: {self}! !!Symbol methodsFor: '*metacello-core' stamp: 'dkh 9/5/2012 06:26:03.064'!setForDo: aBlock withInMetacelloConfig: aMetacelloConstructore    aMetacelloConstructore setFor: {self} do: aBlock! !!Symbol methodsFor: '*metacello-core' stamp: 'dkh 9/5/2012 06:26:03.064'!setForVersion: aString withInMetacelloConfig: aMetacelloConstructore    aMetacelloConstructore setFor: {self} version: aString! !!Symbol methodsFor: '*metacello-core' stamp: 'DaleHenrichs 12/21/2010 13:54'!setPostLoadDoItInMetacelloSpec: aMetacelloSpec	aMetacelloSpec setPostLoadDoIt: 		(aMetacelloSpec project valueHolderSpec			value: self;			yourself)! !!Symbol methodsFor: '*metacello-core' stamp: 'DaleHenrichs 12/21/2010 13:55'!setPreLoadDoItInMetacelloSpec: aMetacelloSpec	aMetacelloSpec setPreLoadDoIt: 		(aMetacelloSpec project valueHolderSpec			value: self;			yourself)! !"Metacello-Core"!SystemOrganization addCategory: #'Metacello-MC-Validation'!MetacelloVersionValidator subclass: #MetacelloMCVersionValidator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Validation'!!MetacelloMCVersionValidator commentStamp: '<historical>' prior: 0!Performs configuration validation.For programmatically decoding reason codes use:  MetacellMCVersionValidator fullDescriptionForReasonCode: <reasonCode>Warning reason codes:	#notDevelopmentVersion			- the symbolic version #development refers to a non-development literal version.	#loadWarning 						- Warning signalled during load [load validation].	#onlyBaselineVersion 				- one or more baseline versions have been defined, but no non-baseline versions are defined.	#stableDevelopmentVersion		- a version whose blessing is #development has been declared as a #stable versionCritical Warning reason codes:	#duplicateVersionDefinitions 		- there are multiple pragma methods specifying the same version	#loadDeprecation					- deprecation warning signalled while loading configuration [load validation]	#noLoadableVersions 				- no non #baseline versions defined in configuration	#noTests 							- no test cases defined in loaded configuration [load validation]	#noVersionSpecified 				- no version defined for the project reference or package. The version specified in the baseline or the latest version of the project or package in the repository will be used.	#packageNameMismatch 			- the name in the packageSpec does not match the name of the mcz file	#projectClassNameFileMismatch 	- the class name of the configuration does not match the mcz file containing the configuration	#testDeprecation 					- deprecation warning signalled while running configuration tests [load validation]Error reason codes:	#cannotResolveVersion 			- the version (project reference or symbolic version) was not found in the specified configuration	#duplicateNames 					- multiple independent definitions for an entity with same name (project, package, or group)	#incompleteProjectSpec 			- missing required fields in project reference (className and/or repository)	#incorrectVersionString 			- the version declared in pragma doesn't match version in versionSpec	#invalidDoItSelector 				- doit select must be a Symbol	#invalidVersionString 				- versionString must be a String	#loadError 							- error occured while loading configuration [load validation]	#missingVersionImport 			- version specified in import pragma not defined in configuration	#noVersionsDefined 				- no usable baseline or version defined in configuration ... configuration cannot be loaded	#projectCreationError 				- error occured while resolving project reference	#shadowedNames 					- name duplication between packages and projects	#testFailures						- test failures while running tests [load validation]	#versionCompositionError 			- error while creating versionSpec from pragmas!SystemOrganization addCategory: #'Metacello-MC-Model'!MetacelloVersion subclass: #MetacelloMCVersion	instanceVariableNames: 'loaderPolicy'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Model'!Object subclass: #MetacelloConfigTemplate	instanceVariableNames: 'project'	classVariableNames: 'LastVersionLoad'	poolDictionaries: ''	category: 'Metacello-MC-Model'!!MetacelloConfigTemplate commentStamp: '<historical>' prior: 0!Copy me to create a new configuration or edit and evaluate the following doits.        "Create configuration class and initial baseline method"        MetacelloToolBox                 createBaseline: '1.0-baseline'                for: 'MyProject'                repository: 'http://www.example.com/MyProjectRepository'                requiredProjects: #('Gofer')                packages: #('MyProject-Core' 'MyProject-Tests')                dependencies:                        {('MyProject-Core' -> #('Gofer')).                         ('MyProject-Tests' -> #('MyProject-Core'))}                groups:                        {('default' -> #('Core')).                        ('Core' -> #('MyProject-Core')).                        ('Tests' -> #('MyProject-Tests'))}.	   "create initial development method from the baseline"         MetacelloToolBox               createDevelopment: '1.0'               for: 'MyProject'                importFromBaseline: '1.0-baseline'                description: 'initial version'.!SystemOrganization addCategory: #'Metacello-MC-Directives'!Object subclass: #MetacelloDirective	instanceVariableNames: 'spec loader'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Directives'!MetacelloDirective subclass: #MetacelloPackageLoadDirective	instanceVariableNames: 'resolvedReference externalReference'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Directives'!MetacelloDirective subclass: #MetacelloPrePostLoadDirective	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Directives'!MetacelloPrePostLoadDirective subclass: #MetacelloPostLoadDirective	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Directives'!MetacelloPrePostLoadDirective subclass: #MetacelloPreLoadDirective	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Directives'!MetacelloDirective subclass: #MetacelloVersionLoadDirective	instanceVariableNames: 'loadDirectives'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Directives'!MetacelloVersionLoadDirective subclass: #MetacelloAtomicLoadDirective	instanceVariableNames: 'packageloads preloads postloads'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Directives'!MetacelloVersionLoadDirective subclass: #MetacelloExplicitLoadDirective	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Directives'!MetacelloVersionLoadDirective subclass: #MetacelloLinearLoadDirective	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Directives'!SystemOrganization addCategory: #'Metacello-MC-Loaders'!Object subclass: #MetacelloLoadData	instanceVariableNames: 'dataMap versionInfoMap packageNameMap'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Loaders'!Object subclass: #MetacelloLoaderPolicy	instanceVariableNames: 'overrideRepositories repositoryMap ensuredMap cacheRepository cacheGofer ignoreImage loadData loadDirective silently'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Loaders'!SystemOrganization addCategory: #'Metacello-MC-Specs'!Object subclass: #MetacelloMCPartiallyLoadedStatus	instanceVariableNames: 'hasNoPackage hasNoProject aProjectIsLoaded aPackageIsLoaded aLoadedProjectIsExact aLoadedPackageIsExact aLoadedProjectIsCurrent aLoadedPackageIsCurrent aLoadedProjectIsNotCurrent aLoadedPackageIsNotCurrent aProjectNotLoaded aPackageNotLoaded vrsnStatus abort'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!Object subclass: #MetacelloMCVersionDiffReport	instanceVariableNames: 'additions configuration modifications removals from to'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Model'!Object subclass: #MetacelloMCVersionSpecLoader	instanceVariableNames: 'versionSpec required packages loader loaderPolicy'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Loaders'!Object subclass: #MetacelloVisitedPackages	instanceVariableNames: 'groups packages projects'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!SystemOrganization addCategory: #'Metacello-MC-Gofer'!Gofer subclass: #MetacelloGofer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Gofer'!MetacelloSpec subclass: #MetacelloRepositorySpec	instanceVariableNames: 'description username password type'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!MetacelloVersionSpec subclass: #MetacelloMCVersionSpec	instanceVariableNames: 'packages repositories'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!GoferResolvedReference subclass: #MetacelloCachingGoferResolvedReference	instanceVariableNames: 'cachedVersion'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Gofer'!MetacelloMemberListSpec subclass: #MetacelloRepositoriesSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!MetacelloSpecLoader subclass: #MetacelloCommonMCSpecLoader	instanceVariableNames: 'operator loaderPolicy disablePackageCache'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Loaders'!MetacelloCommonMCSpecLoader subclass: #MetacelloFetchingMCSpecLoader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Loaders'!MetacelloFetchingMCSpecLoader subclass: #MetacelloNullRecordingMCSpecLoader	instanceVariableNames: 'afterLoads beforeLoads evalDoits'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Loaders'!MetacelloCommonMCSpecLoader subclass: #MetacelloLoadingMCSpecLoader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Loaders'!GoferPackageReference subclass: #MetacelloGoferPackage	instanceVariableNames: 'packageFilename version workingCopy'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Gofer'!MetacelloAbstractPackageSpec subclass: #MetacelloPackageSpec	instanceVariableNames: 'file repositories goferPackage preLoadDoIt postLoadDoIt'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!MetacelloProject subclass: #MetacelloMCProject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Model'!MetacelloProjectSpec subclass: #MetacelloMCProjectSpec	instanceVariableNames: 'projectPackage'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!GoferCommit subclass: #MetacelloGoferCommit	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Gofer'!GoferLoad subclass: #MetacelloGoferLoad	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Gofer'!!MetacelloMCVersionValidator class methodsFor: 'private' stamp: 'DaleHenrichs 1/24/2011 12:41'!populateReasonCodeDescriptions	| dict |	dict := super populateReasonCodeDescriptions.	"Warnings"	dict at: #notDevelopmentVersion put: 'the symbolic version #development refers to a non-development literal version.'.	dict at: #loadWarning put: 'Warning signalled during load [load validation].'.	dict at: #stableDevelopmentVersion put: 'a version whose blessing is #development has been declared as a #stable version.'.	"Critical Warnings"	dict at: #loadDeprecation put: 'deprecation warning signalled while loading configuration [load validation].'.	dict at: #noLoadableVersions put: 'no non #baseline versions defined in configuration.'.	dict at: #noTests 		 put: 'no test cases defined in loaded configuration [load validation].'.	dict at: #noVersionSpecified put: 'no version defined for the project reference or package. The version specified in the baseline or the latest version of the project or package in the repository will be used.'.	dict at: #testDeprecation  put: 'deprecation warning signalled while running configuration tests [load validation].'.	"Errors"	dict at: #loadError put: 'error occured while loading configuration [load validation].'.	dict at: #testFailures put: 'test failures while running tests [load validation].'.	^dict! !!MetacelloMCVersionValidator class methodsFor: 'instance creation' stamp: 'DaleHenrichs 11/19/2010 14:17'!validateConfigurationLoad: configurationClass	^ ((self new)		configurationClass: configurationClass;		yourself) validateProjectLoad! !!MetacelloMCVersionValidator class methodsFor: 'instance creation' stamp: 'DaleHenrichs 12/7/2010 02:48'!validateConfigurationLoad: configurationClass version: versionString	^self validateConfigurationLoad: configurationClass version: versionString loads: #()! !!MetacelloMCVersionValidator class methodsFor: 'instance creation' stamp: 'DaleHenrichs 12/7/2010 02:45'!validateConfigurationLoad: configurationClass version: versionString loads: loadList	^ ((self new)		configurationClass: configurationClass;		yourself) validateProjectVersionLoad: versionString loads: loadList! !!MetacelloMCVersionValidator methodsFor: 'private' stamp: 'DaleHenrichs 11/30/2010 11:46'!criticalWarningReasonCodes	^ super criticalWarningReasonCodes		, #(#noLoadableVersions #noTests #testDeprecation #loadDeprecation #noVersionSpecified)! !!MetacelloMCVersionValidator methodsFor: 'private' stamp: 'DaleHenrichs 11/20/2010 07:25'!errorReasonCodes	^ super errorReasonCodes, #(#loadError #testFailures )! !!MetacelloMCVersionValidator methodsFor: 'validation' stamp: 'DaleHenrichs 12/4/2010 08:45'!validateBaselineVersionSpec: versionSpec	| projectNames packageNames groupNames versionMessage |	self		validateDoIts: versionSpec		versionString: versionSpec versionString		errorMessage: ' version ' , versionSpec versionString printString.	projectNames := Set new.	packageNames := Set new.	groupNames := Set new.	versionMessage := ' in version ' , versionSpec versionString printString.	versionSpec		projectDo: [ :projectSpec | 			(projectSpec resolveProjectSpec className == nil or: [ projectSpec resolveProjectSpec repository == nil ])				ifTrue: [ 					self						recordValidationError:							'Missing required fields (className: and/or repository:) for project reference ' , projectSpec name printString								, ' in version ' , versionSpec versionString printString						versionString: versionSpec versionString						callSite: #validateBaselineVersionSpec:						reasonCode: #incompleteProjectSpec ]				ifFalse: [ 					(self recurse and: [ projectSpec versionString ~~ nil ])						ifTrue: [ 							| project |							projectSpec resolveProjectSpec ensureProjectLoaded.							project := self								validateProjectCreationFrom: projectSpec resolveProjectSpec projectClass								onError: [ :ex | 									self										recordValidationError: 'Error creating project reference: ' , ex description										versionString: versionSpec versionString										callSite: #validateBaselineVersionSpec:										reasonCode: #projectCreationError.									nil ].							project ~~ nil								ifTrue: [ 									self validationReport										addAll:											(self class												validateProject: project												version: projectSpec versionString												debug: self debug												recurse: self recurse												visited: self visited) ] ] ].			self				validateDoIts: projectSpec				versionString: versionSpec versionString				errorMessage: projectSpec name printString , versionMessage.			(projectNames includes: projectSpec name)				ifTrue: [ 					self						recordValidationError: 'Duplicate projects named' , projectSpec name printString , versionMessage						versionString: versionSpec versionString						callSite: #validateBaselineVersionSpec:						reasonCode: #duplicateNames ]				ifFalse: [ projectNames add: projectSpec name ] ]		packageDo: [ :packageSpec | 			self				validateDoIts: packageSpec				versionString: versionSpec versionString				errorMessage: packageSpec name printString , versionMessage.			(packageNames includes: packageSpec name)				ifTrue: [ 					self						recordValidationError: 'Duplicate packages named' , packageSpec name printString , versionMessage						versionString: versionSpec versionString						callSite: #validateBaselineVersionSpec:						reasonCode: #duplicateNames ]				ifFalse: [ projectNames add: packageSpec name ] ]		groupDo: [ :groupSpec | 			(groupNames includes: groupSpec name)				ifTrue: [ 					self						recordValidationError: 'Duplicate groups named' , groupSpec name printString , versionMessage						versionString: versionSpec versionString						callSite: #validateBaselineVersionSpec:						reasonCode: #duplicateNames ]				ifFalse: [ projectNames add: groupSpec name ] ].	(packageNames intersection: projectNames) notEmpty		ifTrue: [ 			self				recordValidationError: 'Names duplicated between packages and projects' , versionMessage				versionString: versionSpec versionString				callSite: #validateBaselineVersionSpec:				reasonCode: #shadowedNames ].	(groupNames intersection: projectNames) notEmpty		ifTrue: [ 			self				recordValidationError: 'Names duplicated between groups and projects' , versionMessage				versionString: versionSpec versionString				callSite: #validateBaselineVersionSpec:				reasonCode: #shadowedNames ].	(projectNames intersection: packageNames) notEmpty		ifTrue: [ 			self				recordValidationError: 'Names duplicated between projects and packages' , versionMessage				versionString: versionSpec versionString				callSite: #validateBaselineVersionSpec:				reasonCode: #shadowedNames ].	(groupNames intersection: packageNames) notEmpty		ifTrue: [ 			self				recordValidationError: 'Names duplicated between groups and packages' , versionMessage				versionString: versionSpec versionString				callSite: #validateBaselineVersionSpec:				reasonCode: #shadowedNames ].	(projectNames intersection: groupNames) notEmpty		ifTrue: [ 			self				recordValidationError: 'Names duplicated between projects and groups' , versionMessage				versionString: versionSpec versionString				callSite: #validateBaselineVersionSpec:				reasonCode: #shadowedNames ].	(packageNames intersection: groupNames) notEmpty		ifTrue: [ 			self				recordValidationError: 'Names duplicated between packages and groups' , versionMessage				versionString: versionSpec versionString				callSite: #validateBaselineVersionSpec:				reasonCode: #shadowedNames ]! !!MetacelloMCVersionValidator methodsFor: 'loading' stamp: 'DaleHenrichs 12/7/2010 02:49'!validateCleanLoadAndTestsForVersion: version loads: loadList	| cleanLoad cleanTests |	cleanTests := cleanLoad := false.	[ 	self validateVersionLoad: version loads: loadList.	cleanLoad := true ]		on: Error , Warning		do: [ :ex | 			(ex isKindOf: Error)				ifTrue: [ 					self						recordValidationError:							'Error while loading version ' , version versionString printString , ' in ' , self configurationClass name asString								, ' ' , ex description						versionString: version versionString						callSite: #validateCleanLoadAndTestsForVersion:loads:						reasonCode: #loadError ].			(ex isKindOf: Warning)				ifTrue: [ 					(ex isKindOf: Deprecation)						ifTrue: [ 							self								recordValidationCriticalWarning:									'Deprecation while loading version ' , version versionString printString , ' in '										, self configurationClass name asString , ' ' , ex description								versionString: version versionString								callSite: #validateCleanLoadAndTestsForVersion:loads:								reasonCode: #loadDeprecation ]						ifFalse: [ 							self								recordValidationWarning:									'Warning while loading version ' , version versionString printString , ' in ' , self configurationClass name asString										, ' ' , ex description								versionString: version versionString								callSite: #validateCleanLoadAndTestsForVersion:loads:								reasonCode: #loadWarning.							Smalltalk								at: #UndeclaredVariableWarning								ifPresent: [ :undeclaredWrning | 									(ex isKindOf: undeclaredWrning)										ifTrue: [ ex resume: true ] ].							ex resume ] ] ].	cleanLoad		ifTrue: [ 			cleanTests := [ self validateVersionTests: version ]				on: Deprecation				do: [ :ex | 					| message |					message := 'Deprecation warning while running tests for version ' , version versionString printString , ' in '						, self configurationClass name asString , ' ' , ex description.	"Deprecation warning for release tests is the same as a test failure"					self						recordValidationCriticalWarning: message						versionString: version versionString						callSite: #validateCleanLoadAndTestsForVersion:loads:						reasonCode: #testDeprecation.					ex return: false ].			cleanTests				ifTrue: [ MetacelloCleanLoadAndTestsNotification signal: version ]				ifFalse: [ MetacelloCleanLoadNotification signal: version ] ]! !!MetacelloMCVersionValidator methodsFor: 'loading' stamp: 'DaleHenrichs 12/7/2010 02:55'!validateProjectLoad	| issues project versions currentVersion collectedIssues |	(issues := self validateProject select: [ :issue | issue isError ]) notEmpty		ifTrue: [ ^ issues ].	project := self configurationClass project.	collectedIssues := issues.	versions := project versions		select: [ :version | 			validationReport := nil.			version blessing ~~ #broken				and: [ 					version blessing ~~ #baseline						and: [ (issues := (self validateProject: project version: version versionString) select: [ :issue | issue isCritical ]) isEmpty ] ] ].	validationReport := collectedIssues.	versions isEmpty		ifTrue: [ 			self				recordValidationCriticalWarning: 'No non #baseline versions  available  in ' , self configurationClass name asString				callSite: #validateProjectLoad				reasonCode: #noLoadableVersions.			^ self validationReport ].	(currentVersion := project currentVersion) ~~ nil		ifTrue: [ 			| index |			index := versions indexOf: currentVersion.			versions := versions copyFrom: index to: versions size ].	versions do: [ :version | self validateCleanLoadAndTestsForVersion: version loads: #('ALL') ].	^ self validationReport! !!MetacelloMCVersionValidator methodsFor: 'loading' stamp: 'DaleHenrichs 12/17/2010 14:39'!validateProjectVersionLoad: versionString loads: loadList	| issues project currentVersion version |	(issues := (self validateProjectVersion: versionString) select: [ :issue | issue isError ]) notEmpty		ifTrue: [ ^ issues ].	project := self configurationClass project.	version := project		version: versionString		ifAbsent: [ 			self				recordValidationError: 'Version ' , versionString printString , ' does not exist.'				callSite: #validateProjectVersionLoad:loads:				reasonCode: #cannotResolveVersion.			^ self validationReport ].	version blessing = #broken		ifTrue: [ self error: 'The specified version is #broken' ].	self validateCleanLoadAndTestsForVersion: version loads: loadList.	^ self validationReport! !!MetacelloMCVersionValidator methodsFor: 'loading' stamp: 'DaleHenrichs 12/7/2010 02:54'!validateVersionLoad: version loads: loadList	| list |	list := loadList asOrderedCollection.	list isEmpty		ifTrue: [ list add: 'default' ].	(version groups includes: 'Tests')		ifTrue: [ list add: 'Tests' ].	version load: list! !!MetacelloMCVersionValidator methodsFor: 'private' stamp: 'dkh 07/21/2011 15:40'!validateVersionSpec: versionSpec	versionSpec blessing value == #broken		ifTrue: [ ^ self ].	versionSpec		projectDo: [ :projectSpec | 			| referencedProjectSpec |			projectSpec versionString == nil				ifTrue: [ 					self						recordValidationCriticalWarning:							'No version specified for the project reference ' , projectSpec name printString , ' in version '								, versionSpec versionString printString						versionString: versionSpec versionString						callSite: #validateVersionSpec:						reasonCode: #noVersionSpecified ].			referencedProjectSpec := projectSpec referencedSpec.			referencedProjectSpec projectPackage == nil				ifTrue: [ 					self						recordValidationError:							'The specification for the project reference ' , projectSpec name printString , ' in version '								, versionSpec versionString printString , ' is missing the required repository field'						versionString: versionSpec versionString						callSite: #validateVersionSpec:						reasonCode: #incompleteProjectSpec ]				ifFalse: [ 					(referencedProjectSpec file beginsWith: referencedProjectSpec className)						ifFalse: [ 							self								recordValidationCriticalWarning:									'The class name of project ' , referencedProjectSpec className printString , ' does not match the file name '										, referencedProjectSpec file printString , ' in version ' , versionSpec versionString printString								versionString: versionSpec versionString								callSite: #validateVersionSpec:								reasonCode: #projectClassNameFileMismatch ].					referencedProjectSpec ensureProjectLoaded.					[ projectSpec version ]						on: MetacelloVersionDoesNotExistError						do: [ :ex | 							| explanation |							explanation := projectSpec versionString == nil								ifTrue: [ 'the default version' ]								ifFalse: [ 'version ' , projectSpec versionString printString ].							self								recordValidationError:									'Cannot resolve ' , explanation , ' for the project reference ' , projectSpec name printString , ' in version '										, versionSpec versionString printString								versionString: versionSpec versionString								callSite: #validateVersionSpec:								reasonCode: #cannotResolveVersion ] ] ]		packageDo: [ :packageSpec | 			(packageSpec file beginsWith: packageSpec name)				ifFalse: [ 					self						recordValidationCriticalWarning:							'The name of package ' , packageSpec name printString , ' does not match the file name ' , packageSpec file printString								, ' in version ' , versionSpec versionString printString						versionString: versionSpec versionString						callSite: #validateVersionSpec:						reasonCode: #packageNameMismatch ].			packageSpec file = packageSpec name				ifTrue: [ 					self						recordValidationCriticalWarning:							'No version specified for the package ' , packageSpec name printString , ' in version '								, versionSpec versionString printString						versionString: versionSpec versionString						callSite: #validateVersionSpec:						reasonCode: #noVersionSpecified ] ]		groupDo: [ :ignored |  ].	self validateBaselineVersionSpec: versionSpec! !!MetacelloMCVersionValidator methodsFor: 'private' stamp: 'DaleHenrichs 11/30/2010 13:52'!validateVersionSpecForSymbolicVersion: versionSpec symbolicVersion: symbolicVersionString	| blessing |	versionSpec blessing value == #broken		ifTrue: [ ^ self ].	blessing := versionSpec blessing value.	(symbolicVersionString == #development and: [ blessing ~~ #development ])		ifTrue: [ 			self				recordValidationWarning:					'Symbolic version ' , symbolicVersionString printString , ' refers to a version' , versionSpec versionString printString						, ' whose blessing ' , blessing printString , ' is not #development'				versionString: versionSpec versionString				callSite: #validateVersionSpecForSymbolicVersion:symbolicVersion:				reasonCode: #notDevelopmentVersion ]! !!MetacelloMCVersionValidator methodsFor: 'loading' stamp: 'DaleHenrichs 12/5/2010 10:08'!validateVersionTests: version	| testCases cleanTests |	testCases := IdentitySet new.	cleanTests := true.	version currentlyLoadedClassesInVersion		do: [ :class | 			((class inheritsFrom: TestCase) and: [ class isAbstract not ])				ifTrue: [ testCases add: class ] ].	testCases		do: [ :testCase | 			| testResults |			testResults := testCase suite run.			testResults defects notEmpty				ifTrue: [ 					self						recordValidationError:							'Test failures in tests ' , testCase name asString , ' for ' , version versionString printString , ' in '								, self configurationClass name asString , ' ' , testResults printString						versionString: version versionString						callSite: #validateVersionTests:						reasonCode: #testFailures.					cleanTests := false ] ].	testCases isEmpty		ifTrue: [ 			self				recordValidationCriticalWarning:					'No test cases for ' , version versionString printString , ' in ' , self configurationClass name asString				versionString: version versionString				callSite: #validateVersionTests:				reasonCode: #noTests.			cleanTests := false ].	^ cleanTests! !!MetacelloMCVersionValidator methodsFor: 'private' stamp: 'DaleHenrichs 12/4/2010 10:32'!warningReasonCodes	^ super warningReasonCodes, #(#loadWarning #notDevelopmentVersion #stableDevelopmentVersion)! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 10/21/2009 19:15'!allPackagesForSpecNamed: aStringOrArray	"resolves list of packages associated with the named spec.	   If the spec is a packages, answer a list including the package and the transitive closure on 			its #requires: and #includes: fields.	   If the spec is a project, answer a list of the packages associated with the project,			following the transitive closure on packages reachable starting with the #loads: field.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"	"In essence, this query answers the list of all packages that would be loaded if the package 		named <aString> were loaded."	"If there is no spec named <aString>, answers an empty list"	^self allPackagesForSpecNamed: aStringOrArray ifAbsent: [ ^#() ]! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 10/21/2009 19:16'!allPackagesForSpecNamed: aStringOrArray ifAbsent: aBlock	"resolves list of packages associated with the named spec.	   If the spec is a packages, answer a list including the package and the transitive closure on 			its #requires: and #includes: fields.	   If the spec is a project, answer a list of the packages associated with the project,			following the transitive closure on packages reachable starting with the #loads: field.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"	"In essence, this query answers the list of all packages that would be loaded if the package 		named <aString> were loaded."	"If there is no spec named <aString>, aBlock is evaluated"	^aStringOrArray 		resolvePackageSpecsNamedForMetacelloMCVersion: self 		visited: MetacelloVisitedPackages new 		ifAbsent: aBlock ! !!MetacelloMCVersion methodsFor: 'private' stamp: 'dkh 10/21/2009 19:17'!allPackagesForSpecs: pkgSpecs visited: visited 	| coll |	coll := Dictionary new.	pkgSpecs		do: [:pkgSpec | (pkgSpec resolveToAllPackagesIn: self spec visited: visited)				do: [:pkg | coll at: pkg name put: pkg ]].	^ coll values asOrderedCollection! !!MetacelloMCVersion methodsFor: 'accessing' stamp: 'DaleHenrichs 3/29/2010 15:32'!cacheRepository: repository 	"by default cacheRepository is an MCDictionaryRepository"		self loaderPolicy cacheRepository: repository ! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'DaleHenrichs 11/20/2010 08:14'!currentlyLoadedClassesInVersion	^self spec currentlyLoadedClassesInVersion! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 5/11/2011 14:36'!currentlyLoadedExtensionClassesInVersion	^self spec currentlyLoadedExtensionClassesInVersion! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 11/9/2010 16:41'!defaultPackageNamesToLoad	"Answer the list of packages and projects to be loaded --> packages already loaded"		^ self defaultPackageNamesToLoad: self spec defaultPackageNames! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'DaleHenrichs 10/25/2010 15:32'!defaultPackageNamesToLoad: defaultList	"Answer the list of packages and projects to be loaded: packages already loaded plust defaultList"		^ self packageAndProjectNamesToLoad: defaultList loader: self loader! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'DaleHenrichs 11/8/2010 12:58'!difference: aMetacelloVersion	"Return a a dictionary of additions, removals and modifications"		^self spec difference: aMetacelloVersion spec! !!MetacelloMCVersion methodsFor: 'private' stamp: 'DaleHenrichs 4/9/2010 14:48'!doFetchRequiredFromArray: anArray	| oldPolicy oldBypassProgress displayString |	displayString := self versionNumber printString, ' of ', self spec projectLabel.	Transcript cr; show: 'Fetching ', displayString, '...'.	oldPolicy := loaderPolicy. 	oldBypassProgress := MetacelloPlatform current bypassProgressBars.	self loaderPolicy silently ifTrue: [ MetacelloPlatform current bypassProgressBars: true ].	[ 	| ans |		ans := self fetchRequiredFromArray: anArray.		Transcript cr; show: '...finished ', self versionNumber printString.		^ans ]			ensure: [ 				MetacelloPlatform current bypassProgressBars: oldBypassProgress.				loaderPolicy := oldPolicy ]	! !!MetacelloMCVersion methodsFor: 'private' stamp: 'dkh 6/6/2011 10:24'!doLoadRequiredFromArray: anArray	| displayString oldPolicy oldBypassProgress |	displayString := self versionNumber printString, ' of ', self spec projectLabel.	Transcript cr; show: 'Loading ', displayString, '...'.	oldPolicy := loaderPolicy. 	oldBypassProgress := MetacelloPlatform current bypassProgressBars.	self loaderPolicy silently ifTrue: [ MetacelloPlatform current bypassProgressBars: true ].	[	| fetchLoader |		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).		MetacelloPlatform current			do:  [  fetchLoader doLoad ]			displaying: 'Loading ', displayString.		Transcript cr; show: '...finished ', self versionNumber printString.		^fetchLoader ]		ensure: [ 			MetacelloPlatform current bypassProgressBars: oldBypassProgress.			loaderPolicy := oldPolicy ]! !!MetacelloMCVersion methodsFor: 'private' stamp: 'DaleHenrichs 4/9/2010 14:48'!doRecordRequiredFromArray: anArray	| originalLoader oldPolicy displayString oldBypassProgress |	displayString := self versionNumber printString, ' of ', self spec projectLabel.	Transcript cr; show: 'Recording ', displayString, '...'.	originalLoader := self versionSpec loader.	oldPolicy := loaderPolicy. 	oldBypassProgress := MetacelloPlatform current bypassProgressBars.	self loaderPolicy silently ifTrue: [ MetacelloPlatform current bypassProgressBars: true ].	[	MetacelloPlatform current			do:  [ | ans |				self versionSpec loader: originalLoader recordingSpecLoader.				ans := (self executeLoadFromArray: anArray) copy.				Transcript cr; show: '...finished ', self versionNumber printString.				^ans ]			displaying: 'Recording ', displayString ]				ensure: [					MetacelloPlatform current bypassProgressBars: oldBypassProgress.					self versionSpec loader: originalLoader.					loaderPolicy := oldPolicy ]! !!MetacelloMCVersion methodsFor: 'private' stamp: 'DaleHenrichs 11/2/2010 16:09'!executeLoadFromArray: anArray	| loader mcLoader |	loader := MetacelloMCVersionSpecLoader on: self spec.	loader required: anArray.	loaderPolicy notNil ifTrue: [ loader loaderPolicy: loaderPolicy ].	^loader load! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'DaleHenrichs 2/4/2010 10:32'!expandToLoadableSpecNames: nameList	"Just like #resolveToLoadableSpecs:, but returns list of spec names instead of specs"		^self spec expandToLoadableSpecNames: nameList! !!MetacelloMCVersion methodsFor: 'actions' stamp: 'DaleHenrichs 3/7/2010 08:25'!fetch	^self doFetchRequiredFromArray: self spec defaultPackageNames! !!MetacelloMCVersion methodsFor: 'actions' stamp: 'DaleHenrichs 3/7/2010 08:25'!fetch: required	^required fetchRequiredForMetacelloMCVersion: self! !!MetacelloMCVersion methodsFor: 'private' stamp: 'dkh 4/6/2011 22:23'!fetchRequiredFromArray: anArray	| originalLoader displayString newLoader |	originalLoader := self versionSpec loader.	newLoader := originalLoader fetchingSpecLoader.	displayString := newLoader actionLabel , self versionNumber printString , ' of ' , self spec projectLabel.	MetacelloPlatform current		do: [ 			[ 			self versionSpec loader: newLoader.			MetacelloPlatform current				useStackCacheDuring: [ :dict | ^ self executeLoadFromArray: anArray ]				defaultDictionary: Dictionary new ] ensure: [ self versionSpec loader: originalLoader ] ]		displaying: displayString! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 10/21/2009 14:37'!groups	"Answers the list of groups associated with this version"		| groups |	groups := OrderedCollection new.	self spec projectDo: [:ignored | ] packageDo: [:ignored | ] groupDo: [:grp | groups add: grp ].	^groups! !!MetacelloMCVersion methodsFor: 'accessing' stamp: 'DaleHenrichs 3/29/2010 15:31'!ignoreImage: aBool 	"by default ignoreImage is false"		self loaderPolicy ignoreImage: aBool ! !!MetacelloMCVersion methodsFor: 'actions' stamp: 'DaleHenrichs 3/4/2010 15:37'!load	^self doLoadRequiredFromArray: self spec defaultPackageNames! !!MetacelloMCVersion methodsFor: 'actions' stamp: 'dkh 6/15/2009 22:34'!load: required	^required loadRequiredForMetacelloMCVersion: self! !!MetacelloMCVersion methodsFor: 'private' stamp: 'DaleHenrichs 3/11/2010 14:06'!loadRequiredFromArray: anArray	| displayString |	displayString := 'Loading ', self versionNumber printString, ' of ', self spec projectLabel.	MetacelloPlatform current		do: [ ^self executeLoadFromArray: anArray ]		displaying: displayString! !!MetacelloMCVersion methodsFor: 'private' stamp: 'dkh 6/18/2009 10:12'!loader: aLoader	self versionSpec loader: aLoader! !!MetacelloMCVersion methodsFor: 'accessing' stamp: 'DaleHenrichs 3/6/2010 08:21'!loaderPolicy	loaderPolicy == nil ifTrue: [ loaderPolicy := MetacelloLoaderPolicy new ].	^ loaderPolicy! !!MetacelloMCVersion methodsFor: 'accessing' stamp: 'DaleHenrichs 3/6/2010 08:20'!loaderPolicy: anObject	loaderPolicy := anObject! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'DaleHenrichs 10/25/2010 15:32'!packageAndProjectNamesToLoad: defaultList loader: aLoader	"Answer the list of packages and projects to be loaded: packages already loaded plust defaultList"		| loadedPackageNames projectMap loadedProjectNames list |	loadedPackageNames := ((self packages select: [:pkg | pkg isPackageLoaded: aLoader ]) 		collect: [:pkg | pkg name ]) asSet, 			defaultList.	projectMap := Dictionary new.	self  projects do: [:prj | 		prj className ~~ nil			ifTrue: [ | coll loaded |				coll := projectMap at: prj className ifAbsent: [					coll := OrderedCollection new.					projectMap at: prj className put: coll.					coll].				(loaded := prj loadedPackageNames: aLoader) isEmpty 					ifFalse: [  coll add: prj -> (loaded -> prj loadPackageList) ]]].	loadedProjectNames := Set new.	projectMap keysAndValuesDo: [:prjClass :coll |		coll size <= 1			ifTrue: [ coll do: [:assoc | loadedProjectNames add: assoc key name ]]			ifFalse: [ 				"multiple project references against the same configuration ... only count project as loaded				 if there is an exact match for loaded projects...				 See http://code.google.com/p/metacello/issues/detail?id=86"				coll do: [:assoc | | loaded packageList |					loaded := assoc value key. "loaded packages from project"					packageList := assoc value value. "loadlist for project"					(packageList difference: loaded) isEmpty						ifTrue: [ loadedProjectNames add: assoc key name ]]]].	list := loadedPackageNames, loadedProjectNames.	list isEmpty ifTrue: [ ^self spec defaultPackageNames].	^list! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 10/24/2009 20:02'!packageNamed: aString	^self packageNamed: aString ifAbsent: [ ^nil ].! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 10/24/2009 20:04'!packageNamed: aString ifAbsent: aBlock	| pkg |	(pkg := self spec packageNamed: aString ifAbsent: []) == nil		ifTrue: [ ^aBlock value ].	^pkg referencedSpec! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 10/21/2009 14:37'!packages	"Answers the list of packages associated with this version"	| packages |	packages := OrderedCollection new.	self spec projectDo: [:ignored | ] packageDo: [:pkg | packages add: pkg ] groupDo: [:ignored | ].	^packages! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 10/21/2009 15:06'!packagesForSpecNamed: aString	"resolves list of packages associated with the named spec.	   If the spec is a packages, answer a list including only the package. #requires: and #includes:			fields in the package are ignored.	   If the spec is a project, answers an empty list.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"	"If there is no spec named <aString>, answers an empty list"	^self packagesForSpecNamed: aString ifAbsent: [ ^#() ]! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 10/21/2009 15:20'!packagesForSpecNamed: aString ifAbsent: aBlock	"resolves list of packages associated with the named spec.	   If the spec is a packages, answer a list including only the package. #requires: and #includes:			fields in the package are ignored.	   If the spec is a project, answers an empty list.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"	"If there is no spec named <aString>, aBlock is evaluated"	| pkgSpec |	pkgSpec := self spec packageNamed: aString ifAbsent: aBlock.	^pkgSpec resolveToPackagesIn: self spec visited: MetacelloVisitedPackages new! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 10/24/2009 19:45'!projects	"Answers the list of projects associated with this version"	| projects |	projects := OrderedCollection new.	self spec projectDo: [:prj | projects add: prj projectReference ] packageDo: [:ignored | ] groupDo: [:ignored | ].	^projects! !!MetacelloMCVersion methodsFor: 'actions' stamp: 'DaleHenrichs 3/11/2010 10:07'!record	^self doRecordRequiredFromArray: self spec defaultPackageNames! !!MetacelloMCVersion methodsFor: 'actions' stamp: 'DaleHenrichs 3/11/2010 10:06'!record: required	^required recordRequiredForMetacelloMCVersion: self! !!MetacelloMCVersion methodsFor: 'accessing' stamp: 'DaleHenrichs 3/7/2010 08:11'!repositoryOverrides: repositoriesCollection 	self loaderPolicy overrideRepositories: repositoriesCollection! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'DaleHenrichs 2/3/2010 15:43'!resolveToLoadableSpecs: nameList	"Resolves names in namelist to the  list of packages and projects in the version that would be loaded. Projects are 	not traversed during the transitive closure. The scope is that of the version itself.	   If the spec is a package, answer a list including the package and the transitive closure on 			its #requires: and #includes: fields.	   If the spec is a project, answer the project.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"	^self spec resolveToLoadableSpecs: nameList! !!MetacelloMCVersion methodsFor: 'accessing' stamp: 'DaleHenrichs 3/29/2010 15:32'!silently: aBool 	"by default silently is false"		self loaderPolicy silently: aBool! !!MCFileBasedRepository methodsFor: '*metacello-mc' stamp: 'dkh 10/20/2009 11:25'!versionInfoFromVersionNamed: aString	| versions |	versions := self allVersionNames		select: [ :each | each beginsWith: aString ].	versions isEmpty ifTrue: [ ^ nil ].	versions := versions asSortedCollection: [ :a :b |		([ (a copyAfterLast: $.) asNumber ] on: Error do: [:ex | ex return: 0 ]) <= 			([ (b copyAfterLast: $.) asNumber ] on: Error do: [:ex | ex return: 0 ]) ].	^ self versionInfoFromFileNamed: versions last , '.mcz'! !!MetacelloConfigTemplate class methodsFor: 'development support' stamp: 'DaleHenrichs 12/17/2010 10:23'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!MetacelloConfigTemplate class methodsFor: 'private' stamp: 'DaleHenrichs 11/2/2010 16:51'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!MetacelloConfigTemplate class methodsFor: 'private' stamp: 'DaleHenrichs 12/6/2010 13:34'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!MetacelloConfigTemplate class methodsFor: 'private' stamp: 'DaleHenrichs 11/4/2010 10:23'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!MetacelloConfigTemplate class methodsFor: 'metacello tool support' stamp: 'DaleHenrichs 11/2/2010 14:58'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!MetacelloConfigTemplate class methodsFor: 'loading' stamp: 'DaleHenrichs 11/29/2010 15:00'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!MetacelloConfigTemplate class methodsFor: 'loading' stamp: 'DaleHenrichs 11/29/2010 15:00'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!MetacelloConfigTemplate class methodsFor: 'loading' stamp: 'DaleHenrichs 11/29/2010 15:00'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!MetacelloConfigTemplate class methodsFor: 'accessing' stamp: 'dkh 10/13/2009 10:36'!project	^self new project! !!MetacelloConfigTemplate class methodsFor: 'development support' stamp: 'DaleHenrichs 1/13/2011 15:37'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!MetacelloConfigTemplate methodsFor: 'accessing' stamp: 'SeanDeNigris 7/12/2012 09:41'!customProjectAttributes	 "Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttrributes"	^ #().! !!MetacelloConfigTemplate methodsFor: 'accessing' stamp: 'SeanDeNigris 7/12/2012 09:41'!project	^ project ifNil: [ | constructor |		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		project := MetacelloMCProject new projectAttributes: self customProjectAttributes. 		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self project: project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!MetacelloDirective class methodsFor: 'instance creation' stamp: 'DaleHenrichs 3/9/2010 16:42'!loadPackage: aPackageSpec externalReference: externalReference loader: aLoader	^MetacelloPackageLoadDirective new		spec: aPackageSpec externalReference: externalReference  loader: aLoader ! !!MetacelloDirective class methodsFor: 'instance creation' stamp: 'DaleHenrichs 3/9/2010 12:19'!loader: aLoader	^self new		loader: aLoader! !!MetacelloDirective class methodsFor: 'instance creation' stamp: 'DaleHenrichs 3/9/2010 10:48'!postLoadSpec: packageOrVersionSpec loader: aLoader	^MetacelloPostLoadDirective new		spec: packageOrVersionSpec loader: aLoader! !!MetacelloDirective class methodsFor: 'instance creation' stamp: 'DaleHenrichs 3/9/2010 10:48'!preLoadSpec: packageOrVersionSpec loader: aLoader	^MetacelloPreLoadDirective new		spec: packageOrVersionSpec loader: aLoader! !!MetacelloDirective methodsFor: 'actions' stamp: 'DaleHenrichs 3/9/2010 12:11'!addTo: aLoaderDirective	aLoaderDirective add: self! !!MetacelloDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 3/10/2010 15:48'!directivesDo: aBlock	aBlock value: self! !!MetacelloDirective methodsFor: 'printing' stamp: 'DaleHenrichs 3/9/2010 16:36'!label	^self spec label! !!MetacelloDirective methodsFor: 'actions' stamp: 'DaleHenrichs 3/9/2010 14:53'!loadUsing: aLoaderDirective gofer: aGofer	self subclassResponsibility! !!MetacelloDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/9/2010 10:44'!loader	^loader! !!MetacelloDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/9/2010 12:19'!loader: aLoader	loader := aLoader! !!MetacelloDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 3/11/2010 13:40'!packageDirectivesDo: aBlock! !!MetacelloDirective methodsFor: 'actions' stamp: 'DaleHenrichs 3/11/2010 13:49'!packageDo: aBlock! !!MetacelloDirective methodsFor: 'actions' stamp: 'DaleHenrichs 4/8/2010 16:31'!postLoadDo: aBlock	! !!MetacelloDirective methodsFor: 'actions' stamp: 'DaleHenrichs 4/8/2010 16:31'!preLoadDo: aBlock! !!MetacelloDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 4/7/2010 12:25'!prepostLoadDirectivesDo: aBlock! !!MetacelloDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 4/7/2010 12:26'!prepostLoadDo: aBlock! !!MetacelloDirective methodsFor: 'printing' stamp: 'DaleHenrichs 3/9/2010 11:53'!printOn: aStream	self printOn: aStream indent: 0! !!MetacelloDirective methodsFor: 'printing' stamp: 'DaleHenrichs 3/9/2010 16:35'!printOn: aStream indent: indent	indent timesRepeat: [ aStream tab ].	aStream		nextPutAll: self title;		nextPutAll: ' : ';		nextPutAll: self label.! !!MetacelloDirective methodsFor: 'printing' stamp: 'DaleHenrichs 12/6/2010 23:00'!printString	"Explicit override of superclass implementation. When you are printing a loadDirective it is annoying to have it truncated."	^String streamContents: [:s | self printOn: s]! !!MetacelloDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/10/2010 11:06'!spec	^spec! !!MetacelloDirective methodsFor: 'initialize-release' stamp: 'DaleHenrichs 3/9/2010 10:46'!spec: packageOrVersionSpec loader: aLoader	spec := packageOrVersionSpec.	loader := aLoader! !!MetacelloDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/9/2010 16:35'!title	self subclassResponsibility! !!MetacelloDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 12/7/2010 02:21'!versionDirectivesDepthFirstDo: aBlock! !!MetacelloDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 3/12/2010 10:27'!versionDirectivesDo: aBlock! !!MetacelloDirective methodsFor: 'actions' stamp: 'DaleHenrichs 4/7/2010 12:32'!versionDo: aBlock! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/9/2010 16:42'!externalReference	^ externalReference! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/9/2010 16:39'!file	^self externalReference name! !!MetacelloPackageLoadDirective methodsFor: 'printing' stamp: 'DaleHenrichs 3/9/2010 16:36'!label	^self file! !!MetacelloPackageLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 3/9/2010 14:58'!loadUsing: aLoaderDirective gofer: aGofer	aLoaderDirective loadPackageDirective: self gofer: aGofer! !!MetacelloPackageLoadDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 3/11/2010 21:09'!packageDirectivesDo: aBlock	aBlock value: self! !!MetacelloPackageLoadDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 3/11/2010 13:55'!packageDo: aBlock	aBlock value: self! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/12/2010 09:29'!packageName	^self externalReference packageName! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/9/2010 16:39'!repository	^self externalReference repository! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/9/2010 15:24'!resolvedReference	^ resolvedReference! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/9/2010 15:24'!resolvedReference: anObject	resolvedReference := anObject! !!MetacelloPackageLoadDirective methodsFor: 'initialize-release' stamp: 'DaleHenrichs 3/9/2010 16:41'!spec: aPackageSpec externalReference: anExternalReference loader: aLoader	super spec: aPackageSpec loader: aLoader.	externalReference := anExternalReference! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/9/2010 16:35'!title	^'load'! !!MetacelloPostLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 12/21/2010 11:46'!addTo: aLoaderDirective	spec postLoadDoIt value ~~ nil ifTrue: [ aLoaderDirective add: self ]! !!MetacelloPostLoadDirective methodsFor: 'printing' stamp: 'DaleHenrichs 12/21/2010 11:47'!label	^super label, ' >> ', self spec postLoadDoIt value asString! !!MetacelloPostLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 4/14/2010 14:30'!loadUsing: aLoaderDirective gofer: aGofer	aLoaderDirective loadPostloadDirective: self.! !!MetacelloPostLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 4/8/2010 16:15'!postLoadDo: aBlock	aBlock value: self! !!MetacelloPostLoadDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/9/2010 16:35'!title	^'postload'! !!MetacelloPreLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 12/21/2010 11:48'!addTo: aLoaderDirective	spec preLoadDoIt value ~~ nil ifTrue: [ aLoaderDirective add: self ]! !!MetacelloPreLoadDirective methodsFor: 'printing' stamp: 'DaleHenrichs 12/21/2010 11:49'!label	^super label, ' >> ', self spec preLoadDoIt value asString! !!MetacelloPreLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 4/14/2010 14:30'!loadUsing: aLoaderDirective gofer: aGofer	aLoaderDirective loadPreloadDirective: self.	! !!MetacelloPreLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 4/8/2010 16:16'!preLoadDo: aBlock	aBlock value: self! !!MetacelloPreLoadDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/9/2010 16:35'!title	^'preload'! !!MetacelloPrePostLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 4/9/2010 12:45'!evaluateSupplyingAnswers: loadBlock	| answers |	(answers := self spec answers) notEmpty		ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]		ifFalse: [ loadBlock value]! !!MetacelloPrePostLoadDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 4/8/2010 16:22'!prepostLoadDirectivesDo: aBlock	aBlock value: self! !!MetacelloPrePostLoadDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 4/8/2010 16:23'!prepostLoadDo: aBlock	aBlock value: self! !!MetacelloAtomicLoadDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 4/9/2010 13:01'!directivesDo: aBlock	aBlock value: self.	self preloads do: [:directive | directive directivesDo: aBlock ].	self loadDirectives do: [:directive | directive directivesDo: aBlock ].	self postloads do: [:directive | directive directivesDo: aBlock ].! !!MetacelloAtomicLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 4/14/2010 14:28'!finalizeLoad: aGofer	"load the accumulated packages (if any), reset the package list"	| pkgLoads |	self preloads do: [:directive | super loadPreloadDirective: directive ].	preloads := nil.	(pkgLoads := self packageloads) notEmpty 		ifTrue: [			self loader loadingSpecLoader 				loadPackageDirectives: pkgLoads 				gofer: aGofer.			self packageloads: nil ].	self postloads do: [:directive | super loadPostloadDirective: directive ].	postloads := nil! !!MetacelloAtomicLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 3/21/2010 16:20'!loadAtomicLoadDirective: aLoaderDirective gofer: aGofer	aLoaderDirective loadDirectives do: [:directive | directive loadUsing: self gofer: aGofer ].! !!MetacelloAtomicLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 4/13/2010 17:27'!loadLinearLoadDirective: aLoaderDirective gofer: aGofer	self finalizeLoad: aGofer.	super loadLinearLoadDirective: aLoaderDirective gofer: aGofer! !!MetacelloAtomicLoadDirective methodsFor: 'loading' stamp: 'DaleHenrichs 3/16/2010 01:53'!loadPackageDirective: aPackageLoadDirective gofer: aGofer	"accumulate packages"		self packageloads add: aPackageLoadDirective! !!MetacelloAtomicLoadDirective methodsFor: 'loading' stamp: 'DaleHenrichs 4/14/2010 14:23'!loadPostloadDirective: aPostloadDirective	"accumulate postloads"	self postloads add: aPostloadDirective! !!MetacelloAtomicLoadDirective methodsFor: 'loading' stamp: 'DaleHenrichs 4/14/2010 14:23'!loadPreloadDirective: aPreloadDirective 	"accumulate preloads"	self preloads add: aPreloadDirective! !!MetacelloAtomicLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 4/14/2010 14:21'!loadUsing: aLoaderDirective gofer: aGofer	self loadDirectives isEmpty ifTrue: [ ^self ].	aLoaderDirective loadAtomicLoadDirective: self gofer: aGofer.! !!MetacelloAtomicLoadDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/9/2010 15:05'!packageloads	packageloads == nil ifTrue: [ packageloads := OrderedCollection new ].	^ packageloads! !!MetacelloAtomicLoadDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/9/2010 15:04'!packageloads: anObject	packageloads := anObject! !!MetacelloAtomicLoadDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 4/9/2010 13:00'!postloads	postloads == nil ifTrue: [ postloads := OrderedCollection new ].	^ postloads! !!MetacelloAtomicLoadDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 4/9/2010 13:00'!preloads	preloads == nil ifTrue: [ preloads := OrderedCollection new ].	^ preloads! !!MetacelloAtomicLoadDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 4/9/2010 13:03'!prepostLoadDirectivesDo: aBlock	self preloads do: [:directive | directive prepostLoadDirectivesDo: aBlock ].	self loadDirectives do: [:directive | directive prepostLoadDirectivesDo: aBlock ].	self postloads do: [:directive | directive prepostLoadDirectivesDo: aBlock ].! !!MetacelloAtomicLoadDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 4/9/2010 13:03'!prepostLoadsDo: aBlock	self preloads do: [:directive | directive prepostLoadDo: aBlock ].	self loadDirectives do: [:directive | directive prepostLoadDo: aBlock ].	self postloads do: [:directive | directive prepostLoadDo: aBlock ].	! !!MetacelloAtomicLoadDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/9/2010 16:35'!title	^'atomic load'! !!MetacelloExplicitLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 3/21/2010 13:39'!explicitLoadUsing: aLoaderDirective gofer: aGofer	aLoaderDirective loadLinearLoadDirective: self gofer: aGofer.! !!MetacelloExplicitLoadDirective methodsFor: 'actions' stamp: 'dkh 4/6/2011 22:34'!explicitLoadWithPolicy: aLoadPolicy	| gofer |	gofer := MetacelloGofer new.	gofer disablePackageCache.	gofer repository: aLoadPolicy cacheRepository.	self explicitLoadUsing: self gofer: gofer! !!MetacelloExplicitLoadDirective methodsFor: 'testing' stamp: 'DaleHenrichs 12/7/2010 02:25'!isExplicit	^true! !!MetacelloExplicitLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 3/21/2010 13:38'!loadUsing: aLoaderDirective gofer: aGofer	aLoaderDirective loadExplicitLoadDirective: self gofer: aGofer.! !!MetacelloExplicitLoadDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/18/2010 11:46'!title	^'explicit load'! !!MetacelloLinearLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 3/21/2010 13:40'!loadUsing: aLoaderDirective gofer: aGofer	self loadDirectives isEmpty ifTrue: [ ^self ].	aLoaderDirective loadLinearLoadDirective: self gofer: aGofer.! !!MetacelloLinearLoadDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/9/2010 16:35'!title	^'linear load'! !!MetacelloVersionLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 3/9/2010 12:14'!add: aDirective	self loadDirectives add: aDirective! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 4/7/2010 12:16'!directivesDo: aBlock	aBlock value: self.	self loadDirectives do: [:directive | directive directivesDo: aBlock ].! !!MetacelloVersionLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 3/16/2010 02:08'!finalizeLoad: aGofer	"nothing special for linear loads"! !!MetacelloVersionLoadDirective methodsFor: 'testing' stamp: 'DaleHenrichs 12/7/2010 02:24'!isExplicit	^false! !!MetacelloVersionLoadDirective methodsFor: 'printing' stamp: 'DaleHenrichs 3/10/2010 11:07'!label	self spec == nil ifTrue: [ ^'' ].	^self spec label! !!MetacelloVersionLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 3/21/2010 13:37'!loadAtomicLoadDirective: aLoaderDirective gofer: aGofer	aLoaderDirective loadDirectives do: [:directive | directive loadUsing: aLoaderDirective gofer: aGofer ].	aLoaderDirective finalizeLoad: aGofer.! !!MetacelloVersionLoadDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/9/2010 12:13'!loadDirectives	loadDirectives == nil ifTrue: [ loadDirectives := OrderedCollection new ].	^ loadDirectives! !!MetacelloVersionLoadDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 3/9/2010 12:13'!loadDirectives: anObject	loadDirectives := anObject! !!MetacelloVersionLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 3/21/2010 13:38'!loadExplicitLoadDirective: aLoaderDirective gofer: aGofer	"load has already been performed, no need to load again"! !!MetacelloVersionLoadDirective methodsFor: 'actions' stamp: 'DaleHenrichs 3/21/2010 13:39'!loadLinearLoadDirective: aLoaderDirective gofer: aGofer	aLoaderDirective loadDirectives do: [:directive | directive loadUsing: aLoaderDirective gofer: aGofer ].	aLoaderDirective finalizeLoad: aGofer.! !!MetacelloVersionLoadDirective methodsFor: 'loading' stamp: 'DaleHenrichs 4/9/2010 12:08'!loadPackageDirective: aPackageLoadDirective gofer: aGofer	aPackageLoadDirective loader loadingSpecLoader 		loadPackageDirective: aPackageLoadDirective 		gofer: aGofer! !!MetacelloVersionLoadDirective methodsFor: 'loading' stamp: 'DaleHenrichs 12/21/2010 11:47'!loadPostloadDirective: aPostloadDirective 	| block |	(block :=  aPostloadDirective spec postLoadDoItBlock) ~~ nil		ifTrue: [			aPostloadDirective evaluateSupplyingAnswers: [ block valueWithPossibleArgs: 					(Array 						with: aPostloadDirective loader 						with: aPostloadDirective spec) ].			Transcript cr; show: 'Evaluated -> ', aPostloadDirective spec label, ' >> ', aPostloadDirective spec postLoadDoIt value asString]! !!MetacelloVersionLoadDirective methodsFor: 'loading' stamp: 'DaleHenrichs 12/21/2010 11:49'!loadPreloadDirective: aPreloadDirective 	| block |	(block :=  aPreloadDirective spec preLoadDoItBlock) ~~ nil		ifTrue: [			aPreloadDirective evaluateSupplyingAnswers: [ block valueWithPossibleArgs: 					(Array 						with: aPreloadDirective loader 						with: aPreloadDirective spec) ].			Transcript cr; show: 'Evaluated -> ', aPreloadDirective spec label, ' >> ', aPreloadDirective spec preLoadDoIt value asString]! !!MetacelloVersionLoadDirective methodsFor: 'actions' stamp: 'dkh 4/6/2011 22:36'!loadWithPolicy: aLoadPolicy	| gofer |	gofer := MetacelloGofer new.	gofer disablePackageCache.	gofer repository: aLoadPolicy cacheRepository.	self loadUsing: self gofer: gofer! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 3/11/2010 13:40'!packageDirectivesDo: aBlock	self loadDirectives do: [:directive | directive packageDirectivesDo: aBlock ].! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 3/11/2010 13:49'!packagesDo: aBlock	self loadDirectives do: [:directive | directive packageDo: aBlock ].! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 4/7/2010 12:26'!prepostLoadDirectivesDo: aBlock	self loadDirectives do: [:directive | directive prepostLoadDirectivesDo: aBlock ].! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 4/7/2010 12:28'!prepostLoadsDo: aBlock	self loadDirectives do: [:directive | directive prepostLoadDo: aBlock ].! !!MetacelloVersionLoadDirective methodsFor: 'printing' stamp: 'DaleHenrichs 4/9/2010 13:04'!printLoadDirectivesOn: aStream indent: indent	self loadDirectives do: [:each |		aStream cr. 		each printOn: aStream indent: indent + 1 ].! !!MetacelloVersionLoadDirective methodsFor: 'printing' stamp: 'DaleHenrichs 4/9/2010 13:04'!printOn: aStream indent: indent	super printOn: aStream indent: indent.	self printLoadDirectivesOn: aStream indent: indent! !!MetacelloVersionLoadDirective methodsFor: 'accessing' stamp: 'DaleHenrichs 11/10/2010 16:53'!spec	"Expected to be a MetacelloVersionSpec"		(spec == nil  and: [  self loader ~~ nil ]) 		ifTrue: [ 			^[ self loader spec versionSpec ] 				on: MessageNotUnderstood				do: [:ex | ex return: self loader spec ]].	^spec! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 12/7/2010 02:22'!versionDirectivesDepthFirstDo: aBlock	self loadDirectives do: [:directive | directive versionDirectivesDepthFirstDo: aBlock ].	aBlock value: self.! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 3/12/2010 10:27'!versionDirectivesDo: aBlock	aBlock value: self.	self loadDirectives do: [:directive | directive versionDirectivesDo: aBlock ].! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 4/7/2010 12:32'!versionDo: aBlock	aBlock value: self.! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'DaleHenrichs 4/7/2010 12:32'!versionsDo: aBlock	self loadDirectives do: [:directive | directive versionDo: aBlock ].! !!MetacelloLoadData methodsFor: 'accessing' stamp: 'dkh 3/20/2011 19:02'!addVersion: version versionInfo: versionInfo resolvedReference: resolvedReference packageSpec: packageSpec	| vis |	"check for duplicates and use the one that is being added"	(vis := self packageNameMap at: packageSpec name ifAbsent: [  ]) ~~ nil		ifTrue: [ 			"remove old references"			vis				do: [ :vi | 					self dataMap removeKey: vi name.					self versionInfoMap removeKey: vi name ] ].	self dataMap		at: version info name		put:			{version.			resolvedReference.			packageSpec}.	self versionInfoMap at: versionInfo name put: {versionInfo}.	self packageNameMap at: packageSpec name put: {versionInfo}! !!MetacelloLoadData methodsFor: 'versionInfo' stamp: 'dkh 3/20/2011 17:50'!ancestorsFor: packageSpec ifAbsent: aBlock	^self versionInfoMap 		at: packageSpec file 		ifAbsent: [ 			self  packageNameMap 				at: packageSpec name				ifAbsent: aBlock ]! !!MetacelloLoadData methodsFor: 'versionInfo' stamp: 'dkh 08/10/2009 16:37'!currentVersionInfoFor: packageSpec ifAbsent: aBlock	^self versionInfoMap 		at: packageSpec file 		ifAbsent: [ 			self  packageNameMap 				at: packageSpec name				ifAbsent: aBlock ]! !!MetacelloLoadData methodsFor: 'accessing' stamp: 'dkh 07/08/2009 12:34'!dataMap	dataMap == nil ifTrue: [ dataMap := Dictionary new ].	^dataMap! !!MetacelloLoadData methodsFor: 'enumerating' stamp: 'dkh 7/29/2009 19:53'!do: aBlock	self dataMap valuesDo: [:ar |		aBlock value: (ar at: 1) value: (ar at: 2) value: (ar at: 3) ]! !!MetacelloLoadData methodsFor: 'testing' stamp: 'dkh 07/08/2009 12:38'!isEmpty	^self dataMap isEmpty! !!MetacelloLoadData methodsFor: 'accessing' stamp: 'dkh 08/10/2009 16:17'!packageNameMap	packageNameMap == nil ifTrue: [ packageNameMap := Dictionary new ].	^packageNameMap! !!MetacelloLoadData methodsFor: 'accessing' stamp: 'dkh 07/08/2009 12:48'!versionInfoMap	versionInfoMap == nil ifTrue: [ versionInfoMap := Dictionary new ].	^versionInfoMap! !!MetacelloLoaderPolicy class methodsFor: 'instance creation' stamp: 'DaleHenrichs 3/7/2010 08:10'!overrideRepositories: aCollection	^self new overrideRepositories: aCollection! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'dkh 4/7/2011 18:37'!cacheGofer	cacheGofer == nil 		ifTrue: [ 			"don't use a caching Gofer here, since we expect the contents to change during a fetch operation"			cacheGofer := Gofer new. 			cacheGofer disablePackageCache.			cacheGofer repository: self cacheRepository. ].	^ cacheGofer! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'DaleHenrichs 3/7/2010 08:34'!cacheRepository	cacheRepository == nil ifTrue: [ cacheRepository := MCDictionaryRepository new ].	^ cacheRepository! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'dkh 4/7/2011 19:41'!cacheRepository: anMCRepository	cacheRepository := anMCRepository.	"getting a new repository, so wipe out the cacheGofer and ensureMap"	ensuredMap := cacheGofer := nil! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'DaleHenrichs 03/08/2010 14:47'!ensuredMap	ensuredMap == nil ifTrue: [ ensuredMap := Dictionary new ].	^ensuredMap! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'DaleHenrichs 03/08/2010 14:47'!ensuredMap: anObject	ensuredMap := anObject! !!MetacelloLoaderPolicy methodsFor: 'testing' stamp: 'DaleHenrichs 3/7/2010 08:14'!hasRepositoryOverrides	^self overrideRepositories ~~ nil! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'DaleHenrichs 3/8/2010 11:39'!ignoreImage	^ ignoreImage! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'DaleHenrichs 3/8/2010 11:39'!ignoreImage: anObject	ignoreImage := anObject! !!MetacelloLoaderPolicy methodsFor: 'initialize-release' stamp: 'DaleHenrichs 03/08/2010 14:47'!initialize	self 		repositoryMap; 		cacheRepository;		ensuredMap.	ignoreImage := false! !!MetacelloLoaderPolicy methodsFor: 'actions' stamp: 'DaleHenrichs 3/10/2010 10:02'!load	overrideRepositories := Array with: self cacheRepository. "ensure that hasRepositoryOverrides is true"	self loadDirective loadWithPolicy: self! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'DaleHenrichs 3/11/2010 12:59'!loadData 	loadData == nil ifTrue: [ loadData := MetacelloLoadData new ].	^loadData! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'DaleHenrichs 3/10/2010 11:11'!loadDirective	loadDirective == nil ifTrue: [ loadDirective := MetacelloLinearLoadDirective new ].	^ loadDirective! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'DaleHenrichs 3/7/2010 08:09'!overrideRepositories	^ overrideRepositories! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'DaleHenrichs 3/7/2010 08:09'!overrideRepositories: anObject	overrideRepositories := anObject! !!MetacelloLoaderPolicy methodsFor: 'actions' stamp: 'DaleHenrichs 3/9/2010 16:50'!pushAtomicLoadDirectivesDuring: aBlock for: aLoader	self pushLoadDirective: (MetacelloAtomicLoadDirective loader: aLoader) during: aBlock.! !!MetacelloLoaderPolicy methodsFor: 'actions' stamp: 'DaleHenrichs 3/21/2010 13:11'!pushExplicitLoadDirectivesDuring: aBlock for: aLoader	| directive |	directive := MetacelloExplicitLoadDirective loader: aLoader.	self pushLoadDirective: directive during: aBlock.	^directive! !!MetacelloLoaderPolicy methodsFor: 'actions' stamp: 'DaleHenrichs 3/9/2010 16:50'!pushLinearLoadDirectivesDuring: aBlock for: aLoader	self pushLoadDirective: (MetacelloLinearLoadDirective loader: aLoader) during: aBlock.! !!MetacelloLoaderPolicy methodsFor: 'private' stamp: 'DaleHenrichs 3/9/2010 15:33'!pushLoadDirective: aLoaderDirective during: aBlock	|  oldRoot |	self loadDirective add: aLoaderDirective.	oldRoot := loadDirective.	loadDirective := aLoaderDirective.	aBlock ensure: [ loadDirective := oldRoot ].! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'DaleHenrichs 3/5/2010 15:11'!repositoryMap	repositoryMap == nil ifTrue: [ repositoryMap := Dictionary new ].	^repositoryMap! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'DaleHenrichs 3/5/2010 10:51'!repositoryMap: anObject	repositoryMap := anObject! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'DaleHenrichs 03/08/2010 16:23'!resetCacheGofer	cacheGofer := nil! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'DaleHenrichs 3/11/2010 19:35'!silently	silently == nil ifTrue: [ silently := false ].	^ silently! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'DaleHenrichs 3/11/2010 19:35'!silently: anObject	silently := anObject! !!MetacelloMCPartiallyLoadedStatus class methodsFor: 'instance creation' stamp: 'dkh 7/11/2011 14:47'!new	^ self basicNew initialize! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:03'!aLoadedPackageIsCurrent	^ aLoadedPackageIsCurrent! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:01'!aLoadedPackageIsCurrent: aBoolean	aLoadedPackageIsCurrent := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:03'!aLoadedPackageIsExact	^ aLoadedPackageIsExact! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:00'!aLoadedPackageIsExact: aBoolean	aLoadedPackageIsExact := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:03'!aLoadedPackageIsNotCurrent	^ aLoadedPackageIsNotCurrent! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:02'!aLoadedPackageIsNotCurrent: aBoolean	aLoadedPackageIsNotCurrent := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:01'!aLoadedProjectIsCurrent: aBoolean	aLoadedProjectIsCurrent := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:03'!aLoadedProjectIsExact	^ aLoadedProjectIsExact! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:00'!aLoadedProjectIsExact: aBoolean	aLoadedProjectIsExact := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:04'!aLoadedProjectIsNotCurrent	^ aLoadedProjectIsNotCurrent! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:01'!aLoadedProjectIsNotCurrent: aBoolean	aLoadedProjectIsNotCurrent := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:04'!aPackageIsLoaded	^aPackageIsLoaded! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:00'!aPackageIsLoaded: aBoolean	aPackageIsLoaded := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:04'!aPackageNotLoaded	^aPackageNotLoaded! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:02'!aPackageNotLoaded: aBoolean	aPackageNotLoaded := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:05'!aProjectIsLoaded	^aProjectIsLoaded! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 14:59'!aProjectIsLoaded: aBoolean	aProjectIsLoaded := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:05'!aProjectNotLoaded	^aProjectNotLoaded! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:02'!aProjectNotLoaded: aBoolean	aProjectNotLoaded := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:05'!abort	^ abort! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:02'!abort: aBoolean	abort := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'evaulation' stamp: 'dkh 7/11/2011 16:20'!evaluateStatus: validStatusList	^self abort		ifTrue: [ false ]		ifFalse: [ 			(self hasNoProject or: [ self vrsnStatus isEmpty ])				ifTrue: [ true ]				ifFalse: [ 					| valid |					valid := true.					vrsnStatus						do: [ :status | 							(validStatusList includes: status)								ifFalse: [ valid := false ] ].					valid ] ]! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:06'!hasNoPackage	^ hasNoPackage! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 14:59'!hasNoPackage: aBoolean	hasNoPackage := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:06'!hasNoProject	^ hasNoProject! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 14:55'!hasNoProject: aBoolean	hasNoProject := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'initialization' stamp: 'dkh 7/11/2011 14:52'!initialize	super initialize.	hasNoPackage := hasNoProject := true.	aProjectIsLoaded := aPackageIsLoaded := false.	aLoadedProjectIsExact := aLoadedPackageIsExact := false.	aLoadedProjectIsCurrent := aLoadedPackageIsCurrent := false.	aLoadedProjectIsNotCurrent := aLoadedPackageIsNotCurrent := false.	aProjectNotLoaded := aPackageNotLoaded := false.	vrsnStatus := Set new.	abort := false! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'testing' stamp: 'dkh 7/11/2011 15:58'!isAllLoadedToSpec: matchBlock        "all projects and packages are loaded and match specification"	(self evaluateStatus: #(#allLoadedToSpec))		ifTrue: [ 			((hasNoPackage				or: [ 					aPackageIsLoaded & aPackageNotLoaded not & aLoadedPackageIsExact & aLoadedPackageIsNotCurrent not						& aLoadedPackageIsCurrent not ])				and: [ 					hasNoProject						or: [ 							aProjectIsLoaded & aProjectNotLoaded not & aLoadedProjectIsExact & aLoadedProjectIsNotCurrent not								& aLoadedProjectIsCurrent not ] ])				ifTrue: [ matchBlock value: #allLoadedToSpec ] ]! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'testing' stamp: 'dkh 7/11/2011 16:03'!isLoadedMatchConstraints: matchBlock	"all loaded projects and packages match constraints (at least one package loaded)"	| matchStatus |	matchStatus := #loadedMatchConstraints.	(self evaluateStatus: #(#allLoadedToSpec #loadedToSpec #loadedMatchConstraints))		ifTrue: [ 			aPackageIsLoaded & aProjectIsLoaded				ifTrue: [ 					(aLoadedPackageIsExact | aLoadedPackageIsCurrent & aLoadedPackageIsNotCurrent not						and: [ aLoadedProjectIsExact | aLoadedProjectIsCurrent & aLoadedProjectIsNotCurrent not ])						ifTrue: [ matchBlock value: matchStatus ] ]				ifFalse: [ 					aPackageIsLoaded						ifTrue: [ 							aLoadedPackageIsExact | aLoadedPackageIsCurrent & aLoadedPackageIsNotCurrent not								ifTrue: [ matchBlock value: matchStatus ] ]						ifFalse: [ 							hasNoPackage & (aLoadedProjectIsExact | aLoadedProjectIsCurrent) & aLoadedProjectIsNotCurrent not								ifTrue: [ matchBlock value: matchStatus ] ] ] ]! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'testing' stamp: 'dkh 7/11/2011 16:05'!isLoadedToSpec: matchBlock	"all loaded projects and packages match specifications (at least one package loaded)"	| matchStatus |	matchStatus := #loadedToSpec.	(self evaluateStatus: #(#allLoadedToSpec #loadedToSpec))		ifTrue: [ 			aPackageIsLoaded & aProjectIsLoaded				ifTrue: [ 					(aLoadedPackageIsExact & aLoadedPackageIsCurrent not & aLoadedPackageIsNotCurrent not						and: [ aLoadedProjectIsExact & aLoadedProjectIsCurrent not & aLoadedProjectIsNotCurrent not ])						ifTrue: [ matchBlock value: matchStatus ] ]				ifFalse: [ 					aPackageIsLoaded						ifTrue: [ 							aLoadedPackageIsExact & aLoadedPackageIsCurrent not & aLoadedPackageIsNotCurrent not								ifTrue: [ matchBlock value: matchStatus ] ]						ifFalse: [ 							hasNoPackage & aLoadedProjectIsExact & aLoadedProjectIsCurrent not & aLoadedProjectIsNotCurrent not								ifTrue: [ matchBlock value: matchStatus ] ] ] ]! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'testing' stamp: 'dkh 7/11/2011 16:07'!isSomethingLoaded: somethingLoadedBlock	"at least one package loaded"	(self evaluateStatus: #(#allLoadedToSpec #loadedToSpec #loadedMatchConstraints #somethingLoaded))		ifTrue: [ 			aPackageIsLoaded				ifTrue: [ somethingLoadedBlock value: #somethingLoaded ] ]! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 7/11/2011 14:53'!vrsnStatus	^vrsnStatus! !!MetacelloMCVersionDiffReport methodsFor: 'accessing' stamp: 'DaleHenrichs 1/14/2011 11:25'!additions	additions ifNil: [ additions := Dictionary new ].	^ additions! !!MetacelloMCVersionDiffReport methodsFor: 'accessing' stamp: 'DaleHenrichs 1/14/2011 11:23'!additions: anObject	additions := anObject! !!MetacelloMCVersionDiffReport methodsFor: 'accessing' stamp: 'DaleHenrichs 1/14/2011 11:24'!configuration	^ configuration! !!MetacelloMCVersionDiffReport methodsFor: 'accessing' stamp: 'DaleHenrichs 1/14/2011 11:24'!configuration: anObject	configuration := anObject! !!MetacelloMCVersionDiffReport methodsFor: 'accessing' stamp: 'DaleHenrichs 1/14/2011 11:26'!from	^ from! !!MetacelloMCVersionDiffReport methodsFor: 'accessing' stamp: 'DaleHenrichs 1/14/2011 11:27'!from: anObject	from := anObject! !!MetacelloMCVersionDiffReport methodsFor: 'accessing' stamp: 'DaleHenrichs 1/14/2011 11:25'!modifications	modifications ifNil: [ modifications := Dictionary new ].	^ modifications! !!MetacelloMCVersionDiffReport methodsFor: 'accessing' stamp: 'DaleHenrichs 1/14/2011 11:24'!modifications: anObject	modifications := anObject! !!MetacelloMCVersionDiffReport methodsFor: 'printing' stamp: 'DaleHenrichs 1/14/2011 11:48'!printOn: aStream	| printBlock |	printBlock := [ :pkgName :ar | 	aStream		tab: 2;		nextPutAll: pkgName asString;		cr.	aStream		tab: 3;		nextPutAll: (ar at: 1) asString printString;		nextPutAll: ' to ';		nextPutAll: (ar at: 2) asString printString;		cr ].	aStream		nextPutAll: self configuration asString;		space;		nextPutAll: from asString printString;		nextPutAll: ' to ';		nextPutAll: to asString printString;		cr.	aStream		tab;		nextPutAll: 'Additions:';		cr.	self additions keysAndValuesDo: printBlock.	aStream		tab;		nextPutAll: 'Modifications:';		cr.	self modifications keysAndValuesDo: printBlock.	aStream		tab;		nextPutAll: 'Removals:';		cr.	self removals keysAndValuesDo: printBlock! !!MetacelloMCVersionDiffReport methodsFor: 'accessing' stamp: 'DaleHenrichs 1/14/2011 11:25'!removals	removals ifNil: [ removals := Dictionary new ].	^ removals! !!MetacelloMCVersionDiffReport methodsFor: 'accessing' stamp: 'DaleHenrichs 1/14/2011 11:24'!removals: anObject	removals := anObject! !!MetacelloMCVersionDiffReport methodsFor: 'accessing' stamp: 'DaleHenrichs 1/14/2011 11:27'!to	^ to! !!MetacelloMCVersionDiffReport methodsFor: 'accessing' stamp: 'DaleHenrichs 1/14/2011 11:27'!to: anObject	to := anObject! !!MetacelloMCVersionSpecLoader class methodsFor: 'instance creation' stamp: 'dkh 6/18/2009 09:53'!on: aVersionSpec	^(self new) 		versionSpec: aVersionSpec;		yourself! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/10/2010 11:19'!label	^self versionSpec label! !!MetacelloMCVersionSpecLoader methodsFor: 'loading' stamp: 'DaleHenrichs 10/25/2010 15:32'!load	| mcLoader |	packages := Dictionary new.	self resolveToLoadableSpecs.	mcLoader := self loader.			packages values do: [:pkg | 				pkg ensureLoadedForDevelopmentUsing: mcLoader.				mcLoader ignoreImage ifFalse: [(pkg 					compareCurrentVersion: self operator 					targetVersionStatus: #(allLoadedToSpec) 					using: mcLoader) 						ifTrue: [ packages removeKey: pkg name ]]].	packages notEmpty		ifTrue: [			mcLoader preLoad: self versionSpec.			mcLoader load.			mcLoader postLoad: self versionSpec ].	^mcLoader! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/6/2010 08:41'!loader	loader == nil 		ifTrue: [			loader := self versionSpec loader copy.			loader spec: self.			loaderPolicy notNil ifTrue: [ loader loaderPolicy: loaderPolicy] ].	^loader! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/6/2010 08:41'!loaderPolicy	^ loaderPolicy! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/6/2010 08:41'!loaderPolicy: anObject	loaderPolicy := anObject! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'dkh 07/03/2009 10:12'!name	^self versionSpec name! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'dkh 08/10/2009 15:13'!operator	^self loader operator! !!MetacelloMCVersionSpecLoader methodsFor: 'spec compatibility' stamp: 'dkh 8/13/2009 00:37'!packageSpecsInLoadOrder	| loadOrder packageNames |	loadOrder := self versionSpec packages ~~ nil		ifTrue: [ self versionSpec packages packageSpecsInLoadOrder ]		ifFalse: [ OrderedCollection new ].	packageNames := packages values collect: [:pkg | pkg name ].	^loadOrder select: [:pkg | packageNames includes: pkg name ]! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/11/2010 23:46'!packages	^packages! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/12/2009 14:20'!project	^self versionSpec project! !!MetacelloMCVersionSpecLoader methodsFor: 'loading' stamp: 'dkh 6/18/2009 11:04'!repositories	^self repositorySpecs! !!MetacelloMCVersionSpecLoader methodsFor: 'spec compatibility' stamp: 'dkh 1/12/2010 17:25'!repositorySpecs	| repositoryMap |	repositoryMap := self versionSpec repositories ~~ nil		ifTrue: [ self versionSpec repositories map ]		ifFalse: [ Dictionary new ].	^repositoryMap values.! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/9/2009 11:13'!required	required == nil ifTrue: [ ^#() ].	^ required! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2009 16:57'!required: anObject	required := anObject! !!MetacelloMCVersionSpecLoader methodsFor: 'loading' stamp: 'dkh 10/3/2009 19:54'!resolvePackageNames	packages := Dictionary new.	self resolveToLoadableSpecs.	^packages values collect: [:pkg | pkg name ]! !!MetacelloMCVersionSpecLoader methodsFor: 'private' stamp: 'DaleHenrichs 1/19/2010 11:57'!resolveToLoadableSpecs	self versionSpec resolveToLoadableSpecs: required map: packages! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2009 16:55'!versionSpec	^ versionSpec! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2009 16:55'!versionSpec: anObject	versionSpec := anObject! !!MetacelloMCVersionSpecLoader methodsFor: 'spec compatibility' stamp: 'DaleHenrichs 3/11/2010 17:49'!versionString	^self versionSpec versionString! !!MetacelloVisitedPackages methodsFor: 'initialize-release' stamp: 'dkh 10/21/2009 15:17'!initialize	groups := Set new.	packages := Set new.	projects := Set new.! !!MetacelloVisitedPackages methodsFor: 'visiting' stamp: 'dkh 10/22/2009 08:31'!pushProject: aBlock	| oldGroups oldPackages oldProjects |	oldGroups := groups.	oldPackages := packages.	oldProjects := projects.	groups := Set new.	packages := Set new.	^aBlock ensure: [		groups := oldGroups.		packages := oldPackages.		projects := oldProjects ]! !!MetacelloVisitedPackages methodsFor: 'visiting' stamp: 'dkh 10/21/2009 15:26'!visit: aSpec doing: aBlock	aSpec		projectDo: [:spec | 			(projects includes: spec name) ifTrue: [ ^self ].			projects add: spec name ] 		packageDo: [:spec | 			(packages includes: spec name) ifTrue: [ ^self ].			packages add: spec name ] 		groupDo: [:spec | 			(groups includes: spec name) ifTrue: [ ^self ].			groups add: spec name ].	aBlock value: aSpec! !!Object class methodsFor: '*metacello-mc' stamp: 'dkh 11/03/2009 11:05'!lastMetacelloVersionLoad	"Answer the last version loaded and the list of packages loaded for that version.	 See MetacelloConfigTemplate."	^nil -> 'default'! !!Object class methodsFor: '*metacello-mc' stamp: 'dkh 11/3/2009 10:12'!metacelloVersion: versionString loads: anArrayOrString	"Stash the last version loaded and the list of packages loaded for that version. The list	 of packages will be used by the tools when doing 'Load Package Version'.	See MetacelloConfigTemplate for example"		"noop by default"! !!MetacelloGofer methodsFor: 'private' stamp: 'dkh 4/7/2011 18:40'!basicReferencesIn: aRepository	((aRepository isKindOf: MCDictionaryRepository) or: [aRepository isKindOf: MCDirectoryRepository])		ifTrue: [ 			"No need to cache references for a dictionary repository"			^ super basicReferencesIn: aRepository ].	"Use cache for network-based repositories - the contents of repository is cached based on first access 	 and is _not_ updated afterword, so any mcz files added after the initial cache is created won't be seen"	^ MetacelloPlatform current		stackCacheFor: #goferRepository		cacheClass: IdentityDictionary		at: aRepository		doing: [ :cache | 			^ cache at: aRepository put: (super basicReferencesIn: aRepository) ]! !!MetacelloGofer methodsFor: 'operations' stamp: 'dkh 4/17/2011 14:42'!interactiveCommit	^ self execute: MetacelloGoferCommit! !!MCVersionLoader methodsFor: '*metacello-mc' stamp: 'dkh 9/9/2009 14:51'!versions	^versions! !!GoferVersionReference methodsFor: '*metacello-mc' stamp: 'dkh 4/17/2011 13:10'!metacelloPackageNameWithBranch	"answer array with package name and package name with branch name"	self branch isEmpty		ifTrue: [ 			^ {(self packageName).			(self packageName)} ].	^ {(self packageName).	(self packageName , '.' , self branch)}! !!MCRepository methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 3/5/2010 14:37'!asRepositorySpecFor: aMetacelloMCProject	self subclassResponsibility! !!MCDictionaryRepository methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 3/5/2010 14:45'!asRepositorySpecFor: aMetacelloMCProject	^(aMetacelloMCProject repositorySpec)		description:  'dictionary://Metacello_Dictionary';	 	type: 'dictionary';		yourself! !!MCDictionaryRepository methodsFor: '*metacello-mc' stamp: 'dkh 12/22/2009 12:06'!versionInfoFromVersionNamed: aString	| versions |	versions := self dictionary values select: [:version | version info name beginsWith: aString ].	versions isEmpty ifTrue: [ ^ nil ].	versions := versions asSortedCollection: [ :a :b |		([ (a info name copyAfterLast: $.) asNumber ] on: Error do: [:ex | ex return: 0 ]) <= 			([ (b info name copyAfterLast: $.) asNumber ] on: Error do: [:ex | ex return: 0 ]) ].	^ versions last info! !!MetacelloRepositorySpec methodsFor: 'adding' stamp: 'dkh 6/7/2009 10:13'!addToMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec addMember 			name: self name;			spec: self;			yourself)! !!MetacelloRepositorySpec methodsFor: 'printing' stamp: 'dkh 10/22/2009 09:54'!configMethodCascadeOn: aStream lastCascade: lastCascade	aStream nextPutAll: 'repository: ', self description printString.	(self username isEmpty not or: [ self password isEmpty not ])		ifTrue: [ aStream nextPutAll: ' username: ', self username printString, ' password: ', self password printString ].	lastCascade ifFalse: [ aStream nextPut: $;; cr ].! !!MetacelloRepositorySpec methodsFor: 'printing' stamp: 'dkh 10/22/2009 09:54'!configMethodOn: aStream indent: indent	aStream 		tab: indent; 		nextPutAll: 'spec '.	self configMethodCascadeOn: aStream lastCascade: true! !!MetacelloRepositorySpec methodsFor: 'mc support' stamp: 'dkh 10/22/2009 08:52'!createRepository	^self project createRepository: self ! !!MetacelloRepositorySpec methodsFor: 'querying' stamp: 'dkh 06/03/2009 12:16'!description	^description! !!MetacelloRepositorySpec methodsFor: 'accessing' stamp: 'dkh 06/03/2009 12:15'!description: aString	description := aString! !!MetacelloRepositorySpec methodsFor: 'private' stamp: 'TestRunner 12/7/2009 14:30'!extractTypeFromDescription	^MetacelloPlatform current extractTypeFromDescription: self description! !!MetacelloRepositorySpec methodsFor: 'private' stamp: 'dkh 6/7/2009 10:21'!mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec mergeMember 			name: self name;			spec: self;			yourself)! !!MetacelloRepositorySpec methodsFor: 'merging' stamp: 'dkh 10/22/2009 09:11'!mergeMap	| map |	map := super mergeMap.	map at: #description put: description.	map at: #type put: type.	map at: #username put: username.	map at: #password put: password.	^map! !!MetacelloRepositorySpec methodsFor: 'querying' stamp: 'dkh 6/7/2009 10:33'!name	^self description! !!MetacelloRepositorySpec methodsFor: 'querying' stamp: 'dkh 10/22/2009 08:49'!password	password == nil ifTrue: [ password := '' ].	^password! !!MetacelloRepositorySpec methodsFor: 'accessing' stamp: 'dkh 10/22/2009 08:49'!password: aString	password := aString! !!MetacelloRepositorySpec methodsFor: 'private' stamp: 'dkh 6/7/2009 10:24'!removeFromMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec removeMember 			name: self name;			spec: self;			yourself)! !!MetacelloRepositorySpec methodsFor: 'querying' stamp: 'dkh 06/03/2009 12:16'!type	type == nil ifTrue: [ type := self extractTypeFromDescription ].	^type! !!MetacelloRepositorySpec methodsFor: 'accessing' stamp: 'dkh 06/03/2009 12:15'!type: aString	type := aString! !!MetacelloRepositorySpec methodsFor: 'querying' stamp: 'dkh 10/22/2009 08:49'!username	username == nil ifTrue: [ username := '' ].	^username! !!MetacelloRepositorySpec methodsFor: 'accessing' stamp: 'dkh 10/22/2009 08:49'!username: aString	username := aString! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: 'dkh 7/8/2011 20:11'!computeVersionStatus: matchBlock	self computeVersionStatus: (self expandToLoadableSpecNames: #('ALL')) matchBlock: matchBlock! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: 'dkh 7/11/2011 15:47'!computeVersionStatus: resolvedPackageAndProjectNames matchBlock: matchBlock	| status |	status := resolvedPackageAndProjectNames isNil		ifTrue: [ self isPartiallyCurrent ]		ifFalse: [ self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames ].	status isAllLoadedToSpec: matchBlock.	status isLoadedToSpec: matchBlock.	status isLoadedMatchConstraints: matchBlock.	status isSomethingLoaded: matchBlock! !!MetacelloMCVersionSpec methodsFor: 'printing' stamp: 'DaleHenrichs 12/23/2010 13:48'!configMethodOn: aStream last: last indent: indent	| spec hasRepositories hasPackageSpecs |	hasRepositories := (spec := self repositoriesSpec) ~~ nil and: [ spec list isEmpty not ].	hasPackageSpecs := false.	self packagesSpec list		do: [ :member | 			member spec				projectDo: [ :proj | 					member spec name ~~ nil						ifTrue: [ hasPackageSpecs := true ] ]				packageDo: [ :package | 					member spec name ~~ nil						ifTrue: [ hasPackageSpecs := true ] ]				groupDo: [ :group | 					member spec name ~~ nil						ifTrue: [ hasPackageSpecs := true ] ] ].	super configMethodOn: aStream last: (hasRepositories | hasPackageSpecs) not indent: indent.	hasRepositories		ifTrue: [ 			spec map values size = 1				ifTrue: [ 					aStream						tab: indent;						nextPutAll: 'spec repository: ';						nextPutAll: spec map values first description printString , '.'.					hasPackageSpecs ifTrue: [ aStream cr ]]				ifFalse: [ 					self						configMethodOn: aStream						for: spec						selector: 'repositories:'						last: hasPackageSpecs not 						indent: indent ] ].	self configPackagesSpecMethodOn: aStream indent: indent.	last		ifFalse: [ aStream cr ]! !!MetacelloMCVersionSpec methodsFor: 'printing' stamp: 'dkh 10/6/2009 14:26'!configPackagesSpecMethodOn: aStream indent: indent	| projectSpecs packageSpecs groupSpecs |	projectSpecs := OrderedCollection new.	packageSpecs := OrderedCollection new.	groupSpecs := OrderedCollection new.	self packagesSpec list do: [:member |		member spec 			projectDo: [:proj | member spec name ~~ nil ifTrue: [ projectSpecs add: member ]]			packageDo: [:package | member spec name ~~ nil ifTrue: [ packageSpecs add: member ]]			groupDo: [:group | member spec name ~~ nil ifTrue: [ groupSpecs add: member ]]].	projectSpecs isEmpty not		ifTrue: [			aStream tab: indent; nextPutAll: 'spec '.			projectSpecs size > 1 ifTrue: [ aStream cr; tab: indent + 1 ].			1 to: projectSpecs size  do: [:index | 				(projectSpecs at: index) configMethodCascadeOn: aStream last: index == projectSpecs size indent: indent + 1.				index ~= projectSpecs size ifTrue: [ aStream tab: indent + 1 ]]].	packageSpecs isEmpty not		ifTrue: [			projectSpecs isEmpty not ifTrue: [ aStream cr ].			aStream tab: indent; nextPutAll: 'spec '.			packageSpecs size > 1 ifTrue: [ aStream cr; tab: indent + 1 ].			1 to: packageSpecs size  do: [:index | 				(packageSpecs at: index) configMethodCascadeOn: aStream last: index == packageSpecs size indent: indent + 1.				index ~= packageSpecs size ifTrue: [ aStream tab: indent + 1 ]]].	groupSpecs isEmpty not		ifTrue: [			projectSpecs isEmpty not | packageSpecs isEmpty not ifTrue: [ aStream cr ].			aStream tab: indent; nextPutAll: 'spec '.			groupSpecs size > 1 ifTrue: [ aStream cr; tab: indent + 1 ].			1 to: groupSpecs size  do: [:index | 				(groupSpecs at: index) configMethodCascadeOn: aStream last: index == groupSpecs size indent: indent + 1.				index ~= groupSpecs size ifTrue: [ aStream tab: indent + 1 ]]].! !!MetacelloMCVersionSpec methodsFor: 'printing' stamp: 'dkh 10/9/2009 20:40'!configSpawnMethodOn: aStream indent: indent	super configSpawnMethodOn: aStream indent: indent.	self configPackagesSpecMethodOn: aStream indent: indent.! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: 'DaleHenrichs 11/20/2010 08:14'!currentlyLoadedClassesInVersion	| classes |	classes := Set new.	self		projectDo: [ :ignored |  ]		packageDo: [ :packageSpec | 			| wc |			wc := [ packageSpec workingCopy ] on: Error do: [ :ex | ex return: nil ].			wc ~~ nil				ifTrue: [ classes addAll: wc packageInfo classes ] ]		groupDo: [ :ignored |  ].	^ classes! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: 'dkh 5/12/2011 16:31'!currentlyLoadedExtensionClassesInVersion	| classes |	classes := Dictionary new.	self		projectDo: [ :ignored |  ]		packageDo: [ :packageSpec | 			| wc |			wc := [ packageSpec workingCopy ] on: Error do: [ :ex | ex return: nil ].			wc ~~ nil				ifTrue: [ wc packageInfo extensionClasses do: [:cl |						classes at: cl put: (wc packageInfo extensionCategoriesForClass: cl)]] ]		groupDo: [ :ignored |  ].	^ classes! !!MetacelloMCVersionSpec methodsFor: 'loading' stamp: 'dkh 10/9/2009 13:03'!defaultPackageNames	"if there is a package named 'default' (a group) then it defines the default package names,	 otherwise answer a list of all of the package names in this version"	self packages packageNamed: 'default' ifAbsent: [ ^self packageNames ].	^#('default')! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: 'DaleHenrichs 1/14/2011 11:37'!difference: otherVersionSpec	"Return a a dictionary of additions, removals and modifications"	| report myProjectSpecs myPackageSpecs otherProjectSpecs otherPackageSpecs |	report := MetacelloMCVersionDiffReport new.	myProjectSpecs := Dictionary new.	myPackageSpecs := Dictionary new.	self		projectDo: [ :projectSpec | myProjectSpecs at: projectSpec name put: projectSpec ]		packageDo: [ :packageSpec | myPackageSpecs at: packageSpec name put: packageSpec ]		groupDo: [ :ignored |  ].	otherProjectSpecs := Dictionary new.	otherPackageSpecs := Dictionary new.	otherVersionSpec		projectDo: [ :projectSpec | otherProjectSpecs at: projectSpec name put: projectSpec ]		packageDo: [ :packageSpec | otherPackageSpecs at: packageSpec name put: packageSpec ]		groupDo: [ :ignored |  ].	myProjectSpecs		valuesDo: [ :myProjectSpec | 			| otherProjectSpec |			otherProjectSpec := otherProjectSpecs at: myProjectSpec name ifAbsent: [  ].			otherProjectSpec == nil				ifTrue: [ 					report removals						at: myProjectSpec name						put:							{(myProjectSpec versionString).							''} ]				ifFalse: [ 					myProjectSpec versionString = otherProjectSpec versionString						ifFalse: [ 							report modifications								at: myProjectSpec name								put:									{(myProjectSpec versionString).									(otherProjectSpec versionString)} ] ] ].	otherProjectSpecs		valuesDo: [ :otherProjectSpec | 			(myProjectSpecs at: otherProjectSpec name ifAbsent: [  ]) == nil				ifTrue: [ 					report additions						at: otherProjectSpec name						put:							{''.							(otherProjectSpec versionString)} ] ].	myPackageSpecs		valuesDo: [ :myPackageSpec | 			| otherPackageSpec |			otherPackageSpec := otherPackageSpecs at: myPackageSpec name ifAbsent: [  ].			otherPackageSpec == nil				ifTrue: [ 					report removals						at: myPackageSpec name						put:							{(myPackageSpec file).							''} ]				ifFalse: [ 					myPackageSpec file = otherPackageSpec file						ifFalse: [ 							report modifications								at: myPackageSpec name								put:									{(myPackageSpec file).									(otherPackageSpec file)} ] ] ].	otherPackageSpecs		valuesDo: [ :otherPackageSpec | 			(myPackageSpecs at: otherPackageSpec name ifAbsent: [  ]) == nil				ifTrue: [ 					report additions						at: otherPackageSpec name						put:							{''.							(otherPackageSpec file)} ] ].	^report! !!MetacelloMCVersionSpec methodsFor: 'loading' stamp: 'DaleHenrichs 9/24/2010 14:50'!expandToLoadableSpecNames: nameList	| cacheKey names |	cacheKey := Array with: self label with: nameList.	^MetacelloPlatform current		stackCacheFor: #loadableSpecNames		at: cacheKey		doing: [ :cache | 			names := (self resolveToLoadableSpecs: nameList) collect: [:spec | spec name ].			cache at: cacheKey put: names ].! !!MetacelloMCVersionSpec methodsFor: 'development support' stamp: 'DaleHenrichs 11/12/2010 06:30'!forceUpdatedPackageSpecs	| updatedSpecs mcLoader |	updatedSpecs := Dictionary new.	mcLoader := self loader.	self packages map valuesDo: [:pkg | pkg forceUpdatePackageSpec: updatedSpecs using: mcLoader].	^updatedSpecs! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 07/12/2011 14:08'!isAllLoadedToSpec	"all projects and packages are loaded and match specification"	self isPartiallyCurrent isAllLoadedToSpec: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 7/11/2011 16:02'!isAllLoadedToSpecAgainst: resolvedPackageAndProjectNames	"all projects and packages are loaded and match specification"	(self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames) isAllLoadedToSpec: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 07/12/2011 14:08'!isLoadedMatchConstraints	"all loaded projects and packages match constraints (at least one package loaded)"		self isPartiallyCurrent isLoadedMatchConstraints: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 7/11/2011 16:06'!isLoadedMatchConstraintsAgainst: resolvedPackageAndProjectNames	"all loaded projects and packages match constraints (at least one package loaded)"	(self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames) isLoadedMatchConstraints: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 07/12/2011 14:08'!isLoadedToSpec	"all loaded projects and packages match specifications (at least one package loaded)"		self isPartiallyCurrent isLoadedToSpec: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 07/12/2011 14:07'!isLoadedToSpecAgainst: resolvedPackageAndProjectNames	"all loaded projects and packages match specifications (at least one package loaded)"	(self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames) isLoadedToSpec: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 7/8/2011 14:45'!isPartiallyCurrent	^self isPartiallyCurrentAgainst: (self expandToLoadableSpecNames: #('ALL'))! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 7/11/2011 15:43'!isPartiallyCurrentAgainst: resolvedPackageAndProjectNames	| mcLoader status |	status := MetacelloMCPartiallyLoadedStatus new.	mcLoader := self loader.	self		specsNamed: resolvedPackageAndProjectNames		projectDo: [ :prj | 			| vrsn currentVersion |			status hasNoProject: false.			vrsn := prj versionOrNil.			vrsn ~~ nil				ifTrue: [ 					(currentVersion := prj relativeCurrentVersion) ~~ nil						ifTrue: [ status vrsnStatus add: currentVersion versionStatus ] ].			currentVersion ~~ nil				ifTrue: [ 					status aProjectIsLoaded: true.					(currentVersion perform: #= with: vrsn)						ifTrue: [ status aLoadedProjectIsExact: true ]						ifFalse: [ 							(currentVersion perform: prj projectReference operator with: vrsn)								ifTrue: [ status aLoadedProjectIsCurrent: true ]								ifFalse: [ status aLoadedProjectIsNotCurrent: true ] ] ]				ifFalse: [ status aProjectNotLoaded: true ] ]		packageDo: [ :pkg | 			status hasNoPackage: false.			pkg				currentPackageLoaded: [ :versionInfos :file | 					| wcName wcRef fileRef exact current |					status aPackageIsLoaded: true.					versionInfos isEmpty						ifTrue: [ status aLoadedPackageIsNotCurrent: true ]						ifFalse: [ 							exact := current := false.							versionInfos								do: [ :vi | 									wcName := vi name.									fileRef := GoferResolvedReference name: file.									wcRef := GoferResolvedReference name: wcName.									(wcRef compare: fileRef using: #=)										ifTrue: [ exact := true ] ].							exact								ifTrue: [ status aLoadedPackageIsExact: true ]								ifFalse: [ 									versionInfos										do: [ :vi | 											wcName := vi name.											fileRef := GoferResolvedReference name: file.											wcRef := GoferResolvedReference name: wcName.											(wcRef compare: fileRef using: #>=)												ifTrue: [ current := true ] ].									current										ifTrue: [ status aLoadedPackageIsCurrent: true ]										ifFalse: [ status aLoadedPackageIsNotCurrent: true ] ] ] ]				notLoaded: [ status aPackageNotLoaded: true ]				using: mcLoader ]		groupDo: [ :ignoredGroup | 			"if we encounter a group, trouble"			status abort: true.			^ status ].	^ status! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'DaleHenrichs 1/21/2010 13:26'!isPossibleBaseline	self 		projectDo: [:prj | prj isPossibleBaseline ifFalse: [ ^false ]] 		packageDo: [:pkg | pkg isPackageLoaded ifFalse: [ ^false ]] 		groupDo: [:ignored | ].	^true! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 07/12/2011 14:08'!isSomethingLoaded	"at least one package loaded"		self isPartiallyCurrent isSomethingLoaded: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 07/12/2011 14:07'!isSomethingLoadedAgainst: resolvedPackageAndProjectNames	"at least one package loaded"	(self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames) isSomethingLoaded: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'merging' stamp: 'dkh 10/9/2009 07:34'!mergeMap	| map |	map := super mergeMap.	map at: #packages put: self packages.	map at: #repositories put: self repositories.	^map! !!MetacelloMCVersionSpec methodsFor: 'merging' stamp: 'dkh 9/23/2009 11:54'!mergeSpec: anotherSpec	| newSpec map anotherPackages anotherRepositories |	newSpec := super mergeSpec: anotherSpec.	map := anotherSpec mergeMap.	(anotherPackages := map at: #packages) isEmpty not 		ifTrue: [ 			newSpec 				packages: (self packages isEmpty					ifTrue: [ anotherPackages ]					ifFalse: [ self packages mergeSpec: anotherPackages ]) ].	(anotherRepositories := map at: #repositories) isEmpty not		ifTrue: [ 			newSpec 				repositories: (self repositories isEmpty					ifTrue: [ anotherRepositories ]					ifFalse: [ self repositories mergeSpec: anotherRepositories ]) ].	^newSpec! !!MetacelloMCVersionSpec methodsFor: 'merging' stamp: 'dkh 9/23/2009 11:54'!nonOverridable	^super nonOverridable, #( packages repositories)! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: 'dkh 10/21/2009 13:55'!packageNamed: aString	^self packageNamed: aString ifAbsent: [ nil ]! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: 'DaleHenrichs 1/21/2010 15:52'!packageNamed: aString forMap: map ifAbsent: aBlock	| package |	package := map				at: aString				ifAbsent: [].	package == nil		ifTrue: [			(aString = 'default' or: [ aString = 'ALL'])				ifTrue: [ 					package := self project groupSpec name: aString;				 		includes: self packageNames;					 						yourself ]				ifFalse: [ ^aBlock value ]].	^package! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: 'DaleHenrichs 1/21/2010 15:52'!packageNamed: aString ifAbsent: aBlock	^self packageNamed: aString forMap: self packages map ifAbsent: aBlock! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: 'dkh 7/8/2011 09:51'!packageNames	packages == nil ifTrue: [ ^#() ].	^self packages map keys asSet ! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: 'dkh 6/17/2009 16:06'!packageSpecsInLoadOrder	^self packages packageSpecsInLoadOrder! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/17/2009 16:05'!packages	packages == nil ifTrue: [ packages := self project packagesSpec ].	^ packages! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/7/2009 08:19'!packages: anObject	packages := anObject! !!MetacelloMCVersionSpec methodsFor: 'development support' stamp: 'dkh 12/22/2009 09:56'!packagesNeedSavingVisited: visitedProjects into: aCollection	self packages map valuesDo: [:pkg | pkg packagesNeedSavingVisited: visitedProjects using: self repositories map values into: aCollection ].! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: 'dkh 9/23/2009 17:16'!packagesSpec	^self packages! !!MetacelloMCVersionSpec methodsFor: 'copying' stamp: 'dkh 10/9/2009 07:34'!postCopy	super postCopy.	packages := packages copy.	repositories := repositories copy.	! !!MetacelloMCVersionSpec methodsFor: 'enumerating' stamp: 'dkh 10/20/2009 17:16'!projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	self packageSpecsInLoadOrder do: [:pkgSpec |		pkgSpec projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock ]! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/17/2009 16:05'!repositories	repositories == nil ifTrue: [ repositories := self project repositoriesSpec ].	^ repositories! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/7/2009 08:20'!repositories: anObject	repositories := anObject! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: 'dkh 9/23/2009 17:18'!repositoriesSpec	^self repositories! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: 'dkh 10/7/2009 16:27'!repository: aString	self repositoriesSpec add: aString! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: 'dkh 10/22/2009 14:24'!repository: aString username: username password: password	self repositoriesSpec repository: aString username: username password: password! !!MetacelloMCVersionSpec methodsFor: 'loading' stamp: 'dkh 6/18/2009 10:13'!repositorySpecs	^self repositories map values! !!MetacelloMCVersionSpec methodsFor: 'loading' stamp: 'DaleHenrichs 2/5/2010 22:24'!resolveToLoadableSpec: aString forMap: map packages: packageMap 	| package |	package := self packageNamed: aString forMap: map ifAbsent: [ ^self error: 'Name not found: ' , aString ].	packageMap at: package name put: package.	^ {package}! !!MetacelloMCVersionSpec methodsFor: 'loading' stamp: 'DaleHenrichs 2/3/2010 15:42'!resolveToLoadableSpecs: nameList	"Resolves names in namelist to the  list of packages and projects in the version that would be loaded. Projects are 	not traversed during the transitive closure. The scope is that of the version itself.	   If the spec is a package, answer a list including the package and the transitive closure on 			its #requires: and #includes: fields.	   If the spec is a project, answer the project.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"	| map |	map := Dictionary new.	self resolveToLoadableSpecs: nameList map: map.	^map values! !!MetacelloMCVersionSpec methodsFor: 'loading' stamp: 'dkh 2/26/2011 10:11'!resolveToLoadableSpecs: required map: packageMap 	| reqd allReqd map newReqd spec |	reqd := required copy.	allReqd := Set new.	map := self packages map.	[ reqd isEmpty ] whileFalse: [		newReqd := Set new.		reqd do: [:req | 			(self resolveToLoadableSpec: req forMap: map packages: packageMap) 				do: [:loadableSpec | 					newReqd addAll: loadableSpec requires.					newReqd addAll: loadableSpec includes ]].		allReqd addAll: reqd.		newReqd removeAllFoundIn: allReqd.		reqd := newReqd ].	packageMap keys do: [:pkgName |		(spec := (packageMap at: pkgName) resolveToLoadableSpec) == nil			ifTrue: [ packageMap removeKey: pkgName ]			ifFalse: [ packageMap at: pkgName put: (packageMap at: pkgName) resolveToLoadableSpec ]]! !!MetacelloMCVersionSpec methodsFor: 'enumerating' stamp: 'DaleHenrichs 11/12/2010 15:31'!specListProjectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	self packages specListDo: [:pkgSpec |		pkgSpec projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock ]! !!MetacelloMCVersionSpec methodsFor: 'enumerating' stamp: 'DaleHenrichs 01/20/2010 15:50'!specsNamed: packageAndProjectNames projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	| map |	map := self packages map.	packageAndProjectNames do: [:name | | pkgSpec |		(pkgSpec := map at: name ifAbsent: [ ]) ~~ nil			ifTrue: [ pkgSpec projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock ]]! !!MetacelloMCVersionSpec methodsFor: 'development support' stamp: 'DaleHenrichs 11/17/2010 12:02'!updateForSpawnMethod: sourceSpec	"This means that this spec was used in a baseline and will be used in a version .... drop all information that isn't useful"		repositories := preLoadDoIt := postLoadDoIt := nil.! !!MetacelloMCVersionSpec methodsFor: 'development support' stamp: 'dkh 10/5/2009 16:15'!updatedPackageSpecs	| updatedSpecs mcLoader |	updatedSpecs := Dictionary new.	mcLoader := self loader.	self packages map valuesDo: [:pkg | pkg updatePackageSpec: updatedSpecs using: mcLoader].	^updatedSpecs! !!MetacelloMCVersionSpec methodsFor: 'private' stamp: 'dkh 10/7/2009 14:45'!versionClass	^MetacelloMCVersion! !!MetacelloGroupSpec methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 3/5/2010 09:46'!loadUsing: aLoader gofer: gofer	"noop"! !!MetacelloGroupSpec methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 1/19/2010 12:14'!resolveToLoadableSpec	^nil! !!MetacelloGroupSpec methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 1/21/2010 15:54'!resolveToPackagesIn: aVersionSpec into: packages visited: visited	visited 		visit: self 		doing: [:aSpec | | map |			map := aVersionSpec packages map.			aSpec includes do: [:pkgName | 				(aVersionSpec packageNamed: pkgName forMap: map ifAbsent: [])					projectDo: [:ignored | ] 					packageDo: [:pkg | packages at: pkg name put: pkg ] 					groupDo: [:grp | grp resolveToPackagesIn: aVersionSpec into: packages visited: visited ]]]! !!MetacelloGroupSpec methodsFor: '*metacello-mc' stamp: 'dkh 10/21/2009 15:23'!resolveToPackagesIn: aVersionSpec visited: visited	| packages |	packages := Dictionary new.	self resolveToPackagesIn: aVersionSpec into: packages visited: visited.	^packages values asOrderedCollection! !!GoferResolvedReference methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 1/12/2010 20:38'!asMetacelloCachingResolvedReference	^MetacelloCachingGoferResolvedReference name: self name repository: self repository! !!GoferResolvedReference methodsFor: '*metacello-mc' stamp: 'dkh 10/11/2011 22:39'!compare: aLoadableReference using: aComparisonOperator	"Compare versions using <aComparisonOperator>. package names #= then compare based upon version number	Branches and Author names are used in the case of a version number tie, because we need to avoid seesaw loading."			self packageName = aLoadableReference packageName		ifFalse: [ ^false ].	self versionNumber = aLoadableReference versionNumber		ifFalse: [ ^ self versionNumber perform: aComparisonOperator with: aLoadableReference versionNumber ].	self branch = aLoadableReference branch 		ifFalse: [ ^ self branch perform: aComparisonOperator with: aLoadableReference branch ].	^ self author perform: aComparisonOperator with: aLoadableReference author! !!MetacelloCachingGoferResolvedReference methodsFor: 'accessing' stamp: 'DaleHenrichs 1/12/2010 20:40'!version	"Answer a Monticello version of the receiver."	cachedVersion == nil ifTrue: [ cachedVersion := super version ].	^cachedVersion! !!MetacelloCachingGoferResolvedReference methodsFor: 'querying' stamp: 'DaleHenrichs 01/15/2010 17:15'!workingCopy	"Answer a working copy or throw an error if not present."	| pName |	cachedVersion == nil ifTrue: [ ^super workingCopy ].	pName := cachedVersion package name.	^MCWorkingCopy allManagers		detect: [ :each | pName = each packageName ]		ifNone: [ self error: 'Working copy for ' , self name , ' not found' ]! !!MetacelloRepositoriesSpec methodsFor: 'actions' stamp: 'dkh 10/3/2009 16:52'!add: aStringOrSpec	aStringOrSpec addToMetacelloRepositories: self! !!MetacelloRepositoriesSpec methodsFor: 'actions' stamp: 'dkh 6/7/2009 10:18'!add: description type: type	| spec |	spec := 		(self project repositorySpec)			description: description;			type: type;			yourself.	self addMember: 		(self addMember 			name: spec name;			spec: spec;			yourself)! !!MetacelloRepositoriesSpec methodsFor: 'printing' stamp: 'DaleHenrichs 11/10/2010 16:13'!configMethodCascadeOn: aStream indent: indent	| repositorySpecs |	repositorySpecs := self map values sort: [:a :b | a description <= b description ].	repositorySpecs size = 1		ifTrue: [ repositorySpecs first configMethodCascadeOn: aStream lastCascade: true ]		ifFalse: [			1 to: repositorySpecs size do: [:index | | repositorySpec |				aStream tab: indent + 1.				(repositorySpecs at: index)					configMethodCascadeOn: aStream 					lastCascade: index >= repositorySpecs size ]]! !!MetacelloRepositoriesSpec methodsFor: 'printing' stamp: 'dkh 1/2/2010 17:11'!configMethodOn: aStream indent: indent	aStream 		tab: indent; 		nextPutAll: 'spec';		cr.	self configMethodCascadeOn: aStream indent: indent! !!MetacelloRepositoriesSpec methodsFor: 'actions' stamp: 'dkh 6/7/2009 10:18'!merge: aRepositorySpec	aRepositorySpec mergeIntoMetacelloRepositories: self! !!MetacelloRepositoriesSpec methodsFor: 'actions' stamp: 'dkh 6/7/2009 20:50'!merge: description type: type	| spec |	spec := 		(self project repositorySpec)			description: description;			type: type;			yourself.	self addMember: 		(self mergeMember 			name: spec name;			spec: spec;			yourself)! !!MetacelloRepositoriesSpec methodsFor: 'actions' stamp: 'dkh 6/7/2009 10:22'!remove: aRepositorySpec	aRepositorySpec removeFromMetacelloRepositories: self! !!MetacelloRepositoriesSpec methodsFor: 'actions' stamp: 'dkh 10/6/2009 23:59'!repository: aStringOrSpec	aStringOrSpec addToMetacelloRepositories: self! !!MetacelloRepositoriesSpec methodsFor: 'actions' stamp: 'dkh 10/22/2009 09:01'!repository: description username: username password: password	| spec |	spec := 		(self project repositorySpec)			description: description;			username: username;			password: password;			yourself.	self addMember: 		(self addMember 			name: spec name;			spec: spec;			yourself)! !!MCWorkingCopy methodsFor: '*metacello-mc' stamp: 'dkh 4/17/2011 13:10'!metacelloPackageNameWithBranch	"answer array with package name and package name with branch name"	ancestry ancestors isEmpty		ifTrue: [ 			^ {(package name).			(package name)} ].	^ (GoferVersionReference name: self ancestors first name) metacelloPackageNameWithBranch! !!MCHttpRepository methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 3/5/2010 14:45'!asRepositorySpecFor: aMetacelloMCProject	^(aMetacelloMCProject repositorySpec)		description:  self description;	 	type: 'http';		yourself! !!Collection methodsFor: '*metacello-mc' stamp: 'dkh 6/7/2009 10:16'!addToMetacelloRepositories: aMetacelloRepositoriesSpec	self do: [:each | each addToMetacelloRepositories: aMetacelloRepositoriesSpec ]! !!Collection methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 3/7/2010 08:26'!fetchRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doFetchRequiredFromArray: self.! !!Collection methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 3/4/2010 15:37'!loadRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doLoadRequiredFromArray: self.! !!Collection methodsFor: '*metacello-mc' stamp: 'dkh 6/7/2009 10:19'!mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec	self do: [:each | each mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec ]! !!Collection methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 3/11/2010 10:06'!recordRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doRecordRequiredFromArray: self.! !!Collection methodsFor: '*metacello-mc' stamp: 'dkh 6/7/2009 10:23'!removeFromMetacelloRepositories: aMetacelloRepositoriesSpec	self do: [:each | each removeFromMetacelloRepositories: aMetacelloRepositoriesSpec ]! !!Collection methodsFor: '*metacello-mc' stamp: 'dkh 10/21/2009 19:18'!resolvePackageSpecsNamedForMetacelloMCVersion: aMetacelloMCVersion visited: visited ifAbsent: aBlock 	^ aMetacelloMCVersion		allPackagesForSpecs: (self collect: [:ea | 			aMetacelloMCVersion spec packageNamed: ea ifAbsent: aBlock])		visited: visited! !!MetacelloCommonMCSpecLoader class methodsFor: 'utilities' stamp: 'dkh 9/10/2009 17:23'!nameComponentsFrom: aVersionName	| ar |	ar := (aVersionName last isDigit and: [ (aVersionName indexOf: $.) > 0 ])ifFalse: [Array with: aVersionName with: '' with: 0 with: aVersionName with: self]		ifTrue: [ | vrsn str |			str := ((aVersionName copyAfterLast: $-) copyAfterLast: $.).			vrsn := str isEmpty				ifTrue: [0]				ifFalse: [str asInteger].			Array				with: (aVersionName copyUpToLast:  $-)								"base pkg name"				with: ((aVersionName copyAfterLast: $-) copyUpTo: $.)				"user"				with:  vrsn "version"				with: aVersionName				with: self ].	^ar! !!MetacelloCommonMCSpecLoader methodsFor: 'versionInfo' stamp: 'dkh 3/20/2011 17:46'!ancestorsFor: packageSpec	| cacheKey vi |	cacheKey := packageSpec file.	^MetacelloPlatform current		stackCacheFor: #ancestors		at: cacheKey		doing: [ :cache | 			vi := packageSpec ancestors.			cache at: cacheKey put: vi ].! !!MetacelloCommonMCSpecLoader methodsFor: 'versionInfo' stamp: 'DaleHenrichs 9/24/2010 14:47'!currentVersionInfoFor: packageSpec	| cacheKey vi |	cacheKey := packageSpec file.	^MetacelloPlatform current		stackCacheFor: #currentVersionInfo		at: cacheKey		doing: [ :cache | 			vi := packageSpec currentVersionInfo.			cache at: cacheKey put: vi ].! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: 'DaleHenrichs 3/10/2010 15:16'!doLoad	self subclassResponsibility! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: 'TestRunner 10/23/2009 11:33'!doingLoads: aBlock	"escape mechanism for recording and null loaders to skip doing loaderlike things"		aBlock value! !!MetacelloCommonMCSpecLoader methodsFor: 'testing' stamp: 'DaleHenrichs 3/11/2010 20:48'!ensureForDevelopment	^true! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/10/2010 14:29'!fetchingSpecLoader	^self! !!MetacelloCommonMCSpecLoader methodsFor: 'testing' stamp: 'DaleHenrichs 3/10/2010 14:40'!hasRepositoryOverrides	^self loaderPolicy hasRepositoryOverrides! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 4/12/2010 11:30'!ignoreImage	^self loaderPolicy ignoreImage! !!MetacelloCommonMCSpecLoader methodsFor: 'initialize-release' stamp: 'DaleHenrichs 3/10/2010 14:41'!initialize	self loaderPolicy! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: 'DaleHenrichs 4/9/2010 12:17'!linearLoadPackageSpec: packageSpec gofer: gofer	self subclassResponsibility! !!MetacelloCommonMCSpecLoader methodsFor: 'private' stamp: 'dkh 4/6/2011 22:33'!linearLoadPackageSpecs: packageSpecs repositories: repositories		| gofer |	gofer := MetacelloGofer new.	repositories do: [:repo | gofer repository: repo ].	packageSpecs do: [:pkg | pkg loadUsing: self gofer: gofer ].! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: 'DaleHenrichs 3/10/2010 14:33'!load	| repos |	repos := self repositoriesFrom: self spec repositorySpecs.	^ self loadType == #atomic		ifTrue: [self atomicLoadPackageSpecs: self spec packageSpecsInLoadOrder repositories: repos]		ifFalse: ["assume #linear"			self linearLoadPackageSpecs: self spec packageSpecsInLoadOrder repositories: repos ]! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: 'dkh 4/6/2011 22:32'!loadPackageDirective: aPackageLoadDirective gofer: aGofer	| packageSpec |	packageSpec := aPackageLoadDirective spec.	MetacelloPlatform current		do:  [ | loadBlock goferLoad answers resolvedReference |			aGofer disablePackageCache. "for good luck:)"			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.			resolvedReference isNil ifTrue: [ "Package version already loaded into image" ^self ].			loadBlock := [				"mcLoader preLoad: packageSpec."				goferLoad := MetacelloGoferLoad on: MetacelloGofer new.				goferLoad addResolved: resolvedReference.				goferLoad execute.				MetacelloPlatform current clearCurrentVersionCache.				"mcLoader postLoad: packageSpec" ].			(answers := packageSpec answers) notEmpty				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]				ifFalse: [ loadBlock value].			resolvedReference workingCopy repositoryGroup addRepository:  aPackageLoadDirective repository.			Transcript cr; show: 'Loaded -> ', resolvedReference name, ' --- ', aPackageLoadDirective repository description, ' --- ', resolvedReference repository description  ]		displaying: 'Loading ', packageSpec file! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: 'DaleHenrichs 4/9/2010 12:12'!loadPackageDirectives: pkgLoads gofer: aGofer	MetacelloPlatform current		do:  [ | goferLoad loadBlock answers |			goferLoad := MetacelloGoferLoad on: aGofer.			answers := OrderedCollection new.			pkgLoads do: [:packageLoadDirective | | resolvedReference |				aGofer disablePackageCache. "for good luck:)"				(resolvedReference := self 						resolvePackageSpec: packageLoadDirective spec 						gofer: aGofer) ~~ nil					ifTrue: [ 						goferLoad addResolved: resolvedReference.						answers addAll: packageLoadDirective spec answers.						packageLoadDirective resolvedReference:  resolvedReference ]].			Transcript cr; show: 'Starting atomic load'.			loadBlock := [				"pkgLoads do: [:packageLoadDirective |  mcLoader preLoad: packageLoadDirective spec ]."				goferLoad execute.				pkgLoads do: [:packageLoadDirective |					packageLoadDirective resolvedReference == nil						ifTrue: [ Transcript cr; tab; show: 'Already Loaded -> ', packageLoadDirective file ]						ifFalse: [ Transcript cr; tab; show: 'Loaded -> ', packageLoadDirective file, ' --- ',  packageLoadDirective repository description, ' --- ', packageLoadDirective resolvedReference repository description.					packageLoadDirective resolvedReference workingCopy repositoryGroup addRepository: packageLoadDirective repository ]].				MetacelloPlatform current clearCurrentVersionCache.				"pkgLoads do: [:packageLoadDirective | 					packageLoadDirective resolvedReference ~~ nil						ifTrue: [mcLoader postLoad: packageLoadDirective spec ]]"].			answers notEmpty				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]				ifFalse: [ loadBlock value].			Transcript cr; show: 'Finished atomic load' ]		displaying: 'Atomic Load...'.! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/10/2010 14:35'!loaderPolicy	loaderPolicy == nil ifTrue: [ loaderPolicy := MetacelloLoaderPolicy new ].	^loaderPolicy! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/10/2010 14:35'!loaderPolicy: anObject	loaderPolicy := anObject! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/6/2010 07:43'!loadingSpecLoader	^self! !!MetacelloCommonMCSpecLoader methodsFor: 'packages' stamp: 'dkh 07/22/2009 14:50'!nameComponentsFrom: aVersionName	^self class nameComponentsFrom: aVersionName! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 08/10/2009 15:06'!operator	operator == nil ifTrue: [ ^#= ].	^operator! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 08/10/2009 15:06'!operator: aSymbol	operator := aSymbol! !!MetacelloCommonMCSpecLoader methodsFor: 'doits' stamp: 'DaleHenrichs 03/12/2010 16:43'!postLoad: packageOrVersionSpec	"subclassResponsibility, but it gets called during an upgrade, so leave it as NOOP"! !!MetacelloCommonMCSpecLoader methodsFor: 'doits' stamp: 'DaleHenrichs 3/10/2010 14:32'!preLoad: packageOrVersionSpec	self subclassResponsibility! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/11/2010 16:37'!recordingSpecLoader	^(MetacelloNullRecordingMCSpecLoader on: self spec)		shouldDisablePackageCache: self shouldDisablePackageCache;		loaderPolicy: self loaderPolicy copy;		yourself! !!MetacelloCommonMCSpecLoader methodsFor: 'repositories' stamp: 'DaleHenrichs 3/10/2010 14:42'!repositoriesFrom: aMetacelloMVRepositorySpecs	^self repositoriesFrom: aMetacelloMVRepositorySpecs ignoreOverrides: false! !!MetacelloCommonMCSpecLoader methodsFor: 'repositories' stamp: 'DaleHenrichs 3/10/2010 14:42'!repositoriesFrom: aMetacelloMVRepositorySpecs ignoreOverrides: ignoreOverrides	| repositories repos |	(ignoreOverrides not and: [self hasRepositoryOverrides]) ifTrue: [ ^self loaderPolicy overrideRepositories ].	repositories := MCRepositoryGroup default repositories.	repos := OrderedCollection new.	aMetacelloMVRepositorySpecs do: [:aSpec | | description repo |		description := aSpec description.		(repo := repositories detect: [:rep | rep description = description ] ifNone: [ aSpec createRepository ]) ~~ nil			ifTrue: [ repos add: repo ]].	^repos! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/10/2010 14:43'!repositoryMap	^self loaderPolicy repositoryMap! !!MetacelloCommonMCSpecLoader methodsFor: 'private' stamp: 'dkh 3/20/2011 17:49'!resolvePackageSpec: packageSpec gofer: gofer	|  references resolvedReference mcVersion loadedVersionInfos |	references := self retryingResolvePackageSpecReferences: packageSpec gofer: gofer.	resolvedReference := references last asMetacelloCachingResolvedReference.	mcVersion := resolvedReference version.	(loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil		ifTrue: [ 			loadedVersionInfos do: [:info | info name = mcVersion info name 				ifTrue: [ 					"package already loaded, don't load again"					^nil ]]].	^resolvedReference! !!MetacelloCommonMCSpecLoader methodsFor: 'private' stamp: 'dkh 4/6/2011 22:32'!resolvePackageSpecReferences: packageSpec gofer: gofer	|  versionReference references localGofer |	localGofer := gofer.	self hasRepositoryOverrides not		ifTrue: [			packageSpec repositorySpecs notEmpty				ifTrue: [ 					localGofer := MetacelloGofer new.					(self repositoriesFrom: packageSpec repositorySpecs) do: [:repo | localGofer repository: repo ]]].	(packageSpec getFile == nil or: [ self shouldDisablePackageCache ])		ifTrue: [ 			"don't use package-cache when trying to get latest version"			localGofer disablePackageCache ].	versionReference := packageSpec goferLoaderReference.	references := versionReference resolveAllWith: localGofer.	localGofer enablePackageCache.	^references! !!MetacelloCommonMCSpecLoader methodsFor: 'private' stamp: 'dkh 4/26/2011 15:45'!retryingResolvePackageSpecReferences: packageSpec gofer: gofer	| retryCount references repositoryError |	retryCount := 0.	references := #().	[references isEmpty		and: [retryCount < 3]]		whileTrue: [retryCount > 0				ifTrue: [Transcript cr; show: '...RETRY->', packageSpec file ].			references := [self resolvePackageSpecReferences: packageSpec gofer: gofer]						on: Error , GoferRepositoryError						do: [:ex | 							retryCount >= 2								ifTrue: [(ex isKindOf: GoferRepositoryError)										ifTrue: [											"ignore repository errors at this point, in case an alternate repository is in the list "											Transcript cr; show: 'gofer repository error: ', ex description printString, '...ignoring'. 											repositoryError := ex.											ex resume: #()]										ifFalse: [ex pass]].							ex return: #()].			retryCount := retryCount + 1].	references isEmpty 		ifTrue: [ | repositoryString |			repositoryString := ''.			gofer repositories do: [:repo | repositoryString := repositoryString, ' ', repo description ].			Transcript cr; show: '...FAILED->', packageSpec file.			self error: 'Could not resolve: ', packageSpec name, ' [', packageSpec file, ']', ' in', repositoryString,				(repositoryError == nil 					ifTrue: [''] 					ifFalse: [						"report repository error to user here, since failure here is likely to be due to earlier repository error"						' ERROR: ', repositoryError description printString ]) ].	^references! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/10/2010 14:34'!shouldDisablePackageCache	disablePackageCache == nil ifTrue: [ disablePackageCache := false ].	^ disablePackageCache! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/10/2010 14:34'!shouldDisablePackageCache: anObject	disablePackageCache := anObject! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/11/2010 16:33'!actionLabel	^'Fetching '! !!MetacelloFetchingMCSpecLoader methodsFor: 'versionInfo' stamp: 'dkh 3/20/2011 17:51'!ancestorsFor: packageSpec	^self loadData		ancestorsFor: packageSpec 		ifAbsent: [ super ancestorsFor: packageSpec ]! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: 'DaleHenrichs 3/9/2010 12:23'!atomicLoadPackageSpecs: packageSpecs repositories: repositories	self loaderPolicy 		pushAtomicLoadDirectivesDuring: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ]		for: self! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/10/2010 14:39'!cacheRepository	^self loaderPolicy cacheRepository! !!MetacelloFetchingMCSpecLoader methodsFor: 'versionInfo' stamp: 'DaleHenrichs 3/10/2010 11:59'!currentVersionInfoFor: packageSpec	^self loadData		currentVersionInfoFor: packageSpec 		ifAbsent: [ super currentVersionInfoFor: packageSpec ]! !!MetacelloFetchingMCSpecLoader methodsFor: 'actions' stamp: 'DaleHenrichs 3/10/2010 16:42'!doLoad	self loaderPolicy copy load! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/10/2010 14:40'!ensuredMap	^self loaderPolicy ensuredMap! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: 'DaleHenrichs 3/21/2010 13:21'!explicitLoadPackageSpecs: packageSpecs repositories: repositories		| directive |	directive := self loaderPolicy 		pushExplicitLoadDirectivesDuring: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ]		for: self.	directive explicitLoadWithPolicy: self loaderPolicy.! !!MetacelloFetchingMCSpecLoader methodsFor: 'actions' stamp: 'dkh 4/6/2011 23:48'!linearLoadPackageSpec: packageSpec gofer: gofer	MetacelloPlatform current		do:  [ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |			"check to see if mcz file is already in cacheRepository"			self flag: #cleanup. "validate the comment"			"packageSpec name = 'OmniBrowser' ifTrue: [self halt: packageSpec file ]."			cachedReference := self resolvePackageSpec: packageSpec cachedGofer: self loaderPolicy cacheGofer.			(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])				ifTrue: [	 cachedReference name = packageSpec file ifTrue: [ ^self ]].			"look up mcz file"			references := self retryingResolvePackageSpecReferences: packageSpec gofer: gofer.			nearestReference := references last asMetacelloCachingResolvedReference.			"If the mcz is already in the cacheRepository, no need to copy"			(cachedReference ~~ nil and: [ cachedReference name = nearestReference name ])				ifTrue: [ ^self ].			"If the mcz is already loaded into the image, no need to copy"			(self ignoreImage not 				and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])					ifTrue: [ loadedVersionInfos do: [:info | info name = nearestReference name ifTrue: [ ^self ]]].			externalReference := (references select: [:ref | ref name = nearestReference name]) first asMetacelloCachingResolvedReference.			self repositoryMap at: externalReference name put: externalReference repository.			(self resolveDependencies: externalReference nearest: nearestReference into: (OrderedCollection with: nearestReference)) do: [:reference | | pSpec l |				mcVersion := reference version.				(l := (GoferVersionReference name: reference name) resolveAllWith: self loaderPolicy cacheGofer) isEmpty 					ifTrue:  [ 						self cacheRepository storeVersion: mcVersion.				reference == nearestReference					ifTrue: [ pSpec := packageSpec ]					ifFalse: [ 						pSpec :=  packageSpec project packageSpec.						pSpec name: mcVersion info ].				self loadData 					addVersion: mcVersion 					versionInfo: mcVersion info 					resolvedReference: reference 					packageSpec: pSpec ]].			self loaderPolicy resetCacheGofer.			self preLoad: packageSpec.			(MetacelloDirective loadPackage: packageSpec externalReference: externalReference loader: self) addTo: self loadDirective.			self postLoad: packageSpec.			Transcript cr; show: 'Fetched -> ', externalReference name, ' --- ', externalReference repository description, ' --- ', nearestReference repository description ]		displaying: 'Fetching ', packageSpec file! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: 'DaleHenrichs 3/9/2010 12:39'!linearLoadPackageSpecs: packageSpecs repositories: repositories		self loaderPolicy 		pushLinearLoadDirectivesDuring: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ]		 for: self! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/10/2010 11:58'!loadData	^self loaderPolicy loadData! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/10/2010 14:36'!loadDirective	^self loaderPolicy loadDirective! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/10/2010 10:25'!loadingSpecLoader	^(MetacelloLoadingMCSpecLoader on: self spec)		shouldDisablePackageCache: self shouldDisablePackageCache;		loaderPolicy: self loaderPolicy copy;		yourself! !!MetacelloFetchingMCSpecLoader methodsFor: 'doits' stamp: 'DaleHenrichs 3/11/2010 13:43'!postLoad: packageOrVersionSpec	(MetacelloDirective postLoadSpec: packageOrVersionSpec loader: self)  addTo: self loadDirective! !!MetacelloFetchingMCSpecLoader methodsFor: 'doits' stamp: 'DaleHenrichs 3/11/2010 13:43'!preLoad: packageOrVersionSpec	(MetacelloDirective preLoadSpec: packageOrVersionSpec loader: self) addTo: self loadDirective! !!MetacelloFetchingMCSpecLoader methodsFor: 'printing' stamp: 'DaleHenrichs 5/17/2010 16:42'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self loadDirective printOn: aStream.	aStream nextPut: $)! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: 'dkh 4/10/2011 18:03'!resolveDependencies: aResolvedReference nearest: nearestReference into: aCollection	| block retryCount coll notDone |	self flag: 'Not used, but retained to avoid upgrade issues'.	block := [ :dependency | | reference |		reference := MetacelloCachingGoferResolvedReference			name: dependency versionInfo name			repository: aResolvedReference repository.		coll add: reference.		Transcript cr; show: 'Fetched dependency -> ', reference name, ' --- ', reference repository description.		self resolveDependencies: reference nearest: reference into: coll].	retryCount := 0.	notDone := true.	coll := OrderedCollection new.	[ notDone and: [ retryCount < 3 ]]		whileTrue: [			retryCount > 0 ifTrue: [ Transcript cr; show: '...RETRY' ].			[ 					"ensure that all resolved references have cached their version while wrapped by error handler"				aCollection do: [:each | each version ]. 				nearestReference version dependencies do: block.				notDone := false ]					on: Error 					do: [:ex | 						retryCount := retryCount + 1.						retryCount >= 3 ifTrue: [ ex pass ].						coll := OrderedCollection new ]].	aCollection addAll: coll.	^aCollection! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: 'DaleHenrichs 3/4/2010 19:29'!resolvePackageSpec: packageSpec cachedGofer: gofer	|  versionReference references |	versionReference := packageSpec goferLoaderReference.	(references := versionReference resolveAllWith: gofer) isEmpty 		ifTrue: [ ^nil ].	^references last asMetacelloCachingResolvedReference.! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/11/2010 16:33'!actionLabel	^'Recording '! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/10/2010 14:50'!afterLoads	afterLoads == nil ifTrue: [ afterLoads := OrderedCollection new ].	^afterLoads! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/10/2010 14:50'!beforeLoads	beforeLoads == nil ifTrue: [ beforeLoads := OrderedCollection new ].	^beforeLoads! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'versionInfo' stamp: 'dkh 08/10/2009 16:39'!currentVersionInfoFor: packageSpec	^self loadData		currentVersionInfoFor: packageSpec 		ifAbsent: [ nil ]! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'actions' stamp: 'DaleHenrichs 3/10/2010 14:46'!doingLoads: aBlock	"escape mechanism for recording and null loaders to skip doing loaderlike things"! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'testing' stamp: 'DaleHenrichs 3/11/2010 17:18'!ensureForDevelopment	^false! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/10/2010 15:43'!evalDoits	evalDoits == nil ifTrue: [ evalDoits := false ].	^evalDoits ! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/10/2010 14:46'!evalDoits: aBool	evalDoits := aBool! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'actions' stamp: 'DaleHenrichs 4/9/2010 12:33'!linearLoadPackageSpec: packageSpec gofer: gofer	MetacelloPlatform current		do:  [ | externalReference loadBlock answers fake |			externalReference := self resolveRecordingPackageSpecReference: packageSpec gofer: gofer.			loadBlock := [					self preLoad: packageSpec.					(MetacelloDirective 						loadPackage: packageSpec 						externalReference: externalReference 						loader: self) addTo: self loadDirective.					self postLoad: packageSpec ].			(answers := packageSpec answers) notEmpty				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]				ifFalse: [ loadBlock value ].			fake := packageSpec copy.			fake name: fake file.			self loadData 				addVersion: fake				versionInfo: fake				resolvedReference: externalReference 				packageSpec: packageSpec ]		displaying: 'Recording ', packageSpec file! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'actions' stamp: 'DaleHenrichs 4/9/2010 12:08'!loadPackageDirective: aPackageLoadDirective gofer: aGofer	"Noop"! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'actions' stamp: 'DaleHenrichs 4/9/2010 12:12'!loadPackageDirectives: pkgLoads gofer: aGofer	"Noop"! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/11/2010 13:45'!loadedPackages	| packages |	packages := OrderedCollection new.	self loadDirective packageDirectivesDo: [:directive | packages add: directive file ].	^packages! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 4/21/2010 11:56'!loadedRepositories	| repos |	repos := OrderedCollection new.	self repositoryMap values collect: [:coll | repos addAll: coll ].	^repos! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 4/9/2010 12:23'!loadingSpecLoader	^self! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/11/2010 13:46'!packages	| packages |	packages := OrderedCollection new.	self loadDirective packageDirectivesDo: [:directive | packages add: directive spec ].	^packages! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'doits' stamp: 'DaleHenrichs 4/8/2010 16:11'!postLoad: packageOrVersionSpec	self evalDoits ifFalse: [ ^self ].	packageOrVersionSpec postLoadDoItBlock ~~ nil		ifTrue: [ self afterLoads add: packageOrVersionSpec name, ' load' ].	super postLoad: packageOrVersionSpec! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'doits' stamp: 'DaleHenrichs 4/8/2010 16:10'!preLoad: packageOrVersionSpec	self evalDoits ifFalse: [ ^self ].	packageOrVersionSpec preLoadDoItBlock ~~ nil		ifTrue: [ self beforeLoads add: packageOrVersionSpec name, ' load' ].	super preLoad: packageOrVersionSpec! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/11/2010 10:01'!recordingSpecLoader	^self! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'private' stamp: 'dkh 4/6/2011 22:35'!resolvePackageSpecReferences: packageSpec gofer: gofer	|  versionReference references localGofer |	localGofer := gofer.	self hasRepositoryOverrides not		ifTrue: [			packageSpec repositorySpecs notEmpty				ifTrue: [ 					localGofer := MetacelloGofer new.					(self repositoriesFrom: packageSpec repositorySpecs) do: [:repo | localGofer repository: repo ]]].	(packageSpec getFile == nil or: [ self shouldDisablePackageCache ])		ifTrue: [ 			"don't use package-cache when trying to get latest version"			localGofer disablePackageCache ].	versionReference := packageSpec goferLoaderReference.	references := versionReference resolveAllWith: localGofer.	localGofer enablePackageCache.	^references! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'private' stamp: 'DaleHenrichs 03/12/2010 15:01'!resolveRecordingPackageSpecReference: packageSpec gofer: gofer	| externalPackageReference |	externalPackageReference := packageSpec file == nil				ifTrue: [ GoferPackageReference name: packageSpec name ]				ifFalse: [ GoferResolvedReference name: packageSpec file repository: nil ].	packageSpec repositorySpecs isEmpty		ifTrue: [  self repositoryMap at: externalPackageReference packageName put: (gofer repositories reject: [:repo | repo = MCCacheRepository default ]) ]		ifFalse: [  self repositoryMap at: externalPackageReference packageName put: (packageSpec repositorySpecs collect: [:repoSpec | repoSpec createRepository ]) ].	^externalPackageReference! !!MetacelloLoadingMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/11/2010 16:33'!actionLabel	^'Loading '! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'dkh 4/6/2011 22:36'!copySpec: pkgSpec from: repositorySpecs to: repository	| gofer |	gofer := MetacelloGofer new.	(self repositoriesFrom: repositorySpecs) do: [:repo | gofer repository: repo ].	^self copySpec: pkgSpec with: gofer to: repository! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'DaleHenrichs 12/08/2010 11:06'!copySpec: pkgSpec with: gofer to: aRepository	| repository resolvedReference |	[resolvedReference := pkgSpec goferLoaderReference resolveWith: gofer]		on: Error		do: [:ignored | ^nil ].	repository := MCRepositoryGroup default repositories		detect: [ :each | each = aRepository ]		ifNone: [ aRepository ].	repository storeVersion: resolvedReference version.	^resolvedReference repository! !!MetacelloLoadingMCSpecLoader methodsFor: 'actions' stamp: 'DaleHenrichs 3/10/2010 15:16'!doLoad	"NOOP"! !!MetacelloLoadingMCSpecLoader methodsFor: 'accessing' stamp: 'DaleHenrichs 3/10/2010 14:28'!fetchingSpecLoader	^(MetacelloFetchingMCSpecLoader on: self spec)		shouldDisablePackageCache: self shouldDisablePackageCache;		loaderPolicy: self loaderPolicy copy;		yourself! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'dkh 4/17/2011 14:27'!goferCommitBranchPackage: branchName using: repositorySpecs commitMessage: commitMessage	| gofer repoSpecs wc |	repoSpecs := self spec repositorySpecs notEmpty		ifTrue: [ self spec repositorySpecs ]		ifFalse: [ repositorySpecs ].	gofer := MetacelloGofer new.	gofer disablePackageCache.	wc := self spec workingCopy.	repositorySpecs		do: [ :repoSpec | 			| repo |			repo := repoSpec createRepository.			(wc possiblyNewerVersionsIn: repo) notEmpty				ifTrue: [ 					self						notify:							'There are possibly newer versions of the package ' , self spec name printString , ' in the repository '								, repo description printString								, '. Cancel and manually merge if you want to pick up the changes from the later version.' ].			gofer repository: repo ].	gofer package: self spec name.	[ gofer interactiveCommit ]		on: MCVersionNameAndMessageRequest		do: [ :ex | 			| ref |			ref := GoferVersionReference name: ex suggestedName.			ex				resume:					{(ref packageName , '.' , branchName , '-' , ref author , '.' , ref versionNumber printString).					commitMessage} ].	^ true! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'dkh 4/6/2011 22:35'!goferCommitPackageUsing: repositorySpecs commitMessage: commitMessage	| gofer repoSpecs wc |	repoSpecs := self spec repositorySpecs notEmpty				ifTrue: [ self spec repositorySpecs ]				ifFalse: [ repositorySpecs ].	gofer := MetacelloGofer new.	gofer disablePackageCache.	wc := self spec workingCopy.	repositorySpecs do: [:repoSpec | | repo |		repo := repoSpec createRepository.		(wc possiblyNewerVersionsIn: repo) notEmpty			ifTrue: [ self notify: 'There are possibly newer versions of the package ', self spec name printString, ' in the repository ', repo description printString, '. Cancel and manually merge if you want to pick up the changes from the later version.' ].		gofer repository: repo ].	gofer package: self spec name.	gofer commit: commitMessage.	^true! !!MetacelloLoadingMCSpecLoader methodsFor: 'packages' stamp: 'dkh 4/6/2011 22:35'!latestPackage: aString fromRepository: repositorySpecs	| gofer |	gofer := MetacelloGofer new.	gofer disablePackageCache.	(self repositoriesFrom: repositorySpecs) do: [:repo | gofer repository: repo ].	^([(GoferPackageReference name: aString) resolveWith: gofer]		on: Error		do: [:ignored | ^ nil ]) name! !!MetacelloLoadingMCSpecLoader methodsFor: 'private' stamp: 'dkh 4/6/2011 22:36'!linearLoadPackageSpec: packageSpec gofer: gofer	MetacelloPlatform current		do:  [ | loadBlock goferLoad answers resolvedReference repo |			resolvedReference := self resolvePackageSpec: packageSpec gofer: gofer.			resolvedReference isNil ifTrue: [ "Package version already loaded into image" ^self ].			loadBlock := [				self preLoad: packageSpec.				goferLoad := MetacelloGoferLoad on: MetacelloGofer new.				goferLoad addResolved: resolvedReference.				goferLoad execute.				MetacelloPlatform current clearCurrentVersionCache.				self postLoad: packageSpec ].			(answers := packageSpec answers) notEmpty				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]				ifFalse: [ loadBlock value].			repo := resolvedReference repository.			self hasRepositoryOverrides				ifTrue: [					repo := self loaderPolicy repositoryMap 								at: resolvedReference name 								ifAbsent: [ resolvedReference repository ].					resolvedReference workingCopy repositoryGroup addRepository:  repo ]				ifFalse: [ resolvedReference workingCopy repositoryGroup addRepository: resolvedReference repository ].			Transcript cr; show: 'Loaded -> ', resolvedReference name, ' --- ', repo description, ' --- ', resolvedReference repository description  ]		displaying: 'Loading ', packageSpec file! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'DaleHenrichs 3/6/2010 09:04'!packagesNeedSavingUsing: repositorySpecs into: aCollection	| wc repoSpecs repo |	(wc := self spec workingCopy) == nil ifTrue: [ ^self ].	(wc ancestry ancestors notEmpty and: [ wc modified not])		ifTrue: [ ^self ].	repoSpecs := self spec repositorySpecs notEmpty				ifTrue: [ self spec repositorySpecs ]				ifFalse: [ repositorySpecs ].	repo := (self spec getFile == nil or: [ wc ancestry ancestors isEmpty ])		ifTrue: [ (self repositoriesFrom: repoSpecs ignoreOverrides: true) first ]		ifFalse: [			([ self resolveSpec: self spec from: repoSpecs ] 				on: Error 				do: [:ignored | ^self ]) repository ].	aCollection add: self spec -> repo! !!MetacelloLoadingMCSpecLoader methodsFor: 'doits' stamp: 'DaleHenrichs 3/10/2010 14:31'!postLoad: packageOrVersionSpec	| block |	(block := packageOrVersionSpec postLoadDoItBlock) ~~ nil		ifTrue: [ block valueWithPossibleArgs: { self. packageOrVersionSpec. } ]! !!MetacelloLoadingMCSpecLoader methodsFor: 'doits' stamp: 'DaleHenrichs 3/10/2010 14:31'!preLoad: packageOrVersionSpec	| block |	(block := packageOrVersionSpec preLoadDoItBlock) ~~ nil		ifTrue: [ block valueWithPossibleArgs: { self. packageOrVersionSpec. } ]! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'DaleHenrichs 3/10/2010 14:42'!repositoryFor: pkgSpec from: repositorySpecs	^([self resolveSpec: pkgSpec from: repositorySpecs]		on: Error		do: [:ignored | ^nil ]) repository! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'DaleHenrichs 3/10/2010 14:42'!repositoryFor: pkgSpec with: gofer	^([self resolveSpec: pkgSpec with: gofer]		on: Error		do: [:ignored | ^nil ]) repository! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'dkh 4/6/2011 22:36'!resolveSpec: pkgSpec from: repositorySpecs	| gofer |	gofer := MetacelloGofer new.	gofer disablePackageCache.	(self repositoriesFrom: repositorySpecs ignoreOverrides: true) 		do: [:repo | gofer repository: repo ].	^self resolveSpec: pkgSpec with: gofer! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'DaleHenrichs 3/10/2010 14:44'!resolveSpec: pkgSpec with: gofer	^pkgSpec goferLoaderReference resolveWith: gofer! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'DaleHenrichs 3/6/2010 09:04'!savePackageUsing: repositorySpecs	| wc repo repoSpecs newVersion |	(wc := self spec workingCopy) == nil ifTrue: [ ^false ].	(wc ancestry ancestors notEmpty and: [ wc modified not])		ifTrue: [ ^false ].	repoSpecs := self spec repositorySpecs notEmpty				ifTrue: [ self spec repositorySpecs ]				ifFalse: [ repositorySpecs ].	(self spec getFile == nil or: [ wc ancestry ancestors isEmpty ])		ifTrue: [ repo := (self repositoriesFrom: repoSpecs ignoreOverrides: true) first ]		ifFalse: [			[ 	| newer |				repo := (self resolveSpec: self spec from: repoSpecs) repository.				newer := wc possiblyNewerVersionsIn: repo.				newer isEmpty not 					ifTrue: [						(MetacelloPlatform current confirm: 'CAUTION!! These versions in the repository may be newer:', 							String cr, newer printString, String cr,							'Do you really want to save this version?') ifFalse: [ ^false ]] ] 				on: Error 				do: [:ignored | ^false ] ].	(newVersion :=  wc newVersion) == nil ifTrue: [ ^false ].	repo storeVersion: newVersion.	^true! !!MetacelloGoferPackage class methodsFor: 'instance creation' stamp: 'dkh 12/15/2009 10:32'!name: aString packageFilename: packageFilename	^ self basicNew initializeName: aString packageFilename: packageFilename! !!MetacelloGoferPackage class methodsFor: 'package name matching' stamp: 'DaleHenrichs 3/18/2010 16:54'!packageFileName: pkgFileName matchesPackageName: wcPkgName	^(pkgFileName beginsWith: wcPkgName) 		ifTrue: [ 			(pkgFileName size = wcPkgName size) 			or: [ ((pkgFileName at: wcPkgName size + 1) = $-) 				or: [ ((pkgFileName at: wcPkgName size + 1) = $.) 					or: [ (pkgFileName at: wcPkgName size + 1) isDigit ]]]]		ifFalse: [			pkgFileName size >= wcPkgName size ifTrue: [ ^false ].			(wcPkgName beginsWith: pkgFileName) ifFalse: [ ^false ].			^(wcPkgName at: pkgFileName size + 1) = $. ]! !!MetacelloGoferPackage methodsFor: 'querying' stamp: 'dkh 3/20/2011 17:45'!ancestors	| wc |	(wc := self workingCopy) ~~ nil		ifTrue: [ 			wc ancestry ancestors isEmpty not				ifTrue: [ ^wc ancestry ancestors ]].	^nil! !!MetacelloGoferPackage methodsFor: 'querying' stamp: 'dkh 9/25/2009 11:26'!currentVersionInfo	| wc |	(wc := self workingCopy) ~~ nil		ifTrue: [ 			wc ancestry ancestors isEmpty not				ifTrue: [ ^wc ancestry ancestors first ]].	^nil! !!MetacelloGoferPackage methodsFor: 'private' stamp: 'dkh 10/15/2009 10:48'!findWorkingCopy	"Answer a working copy, or nil if the package is not loaded."	| wcs |	wcs := MCWorkingCopy allManagers select: [ :each | self matchesWorkingCopy: each ].	wcs isEmpty ifTrue: [ ^nil ].	^wcs detectMax: [:ea | ea package name size ]! !!MetacelloGoferPackage methodsFor: 'initialization' stamp: 'dkh 12/15/2009 10:31'!initializeName: aString packageFilename: packagefilename	name := aString.	packageFilename := packagefilename! !!MetacelloGoferPackage methodsFor: 'private' stamp: 'DaleHenrichs 3/19/2010 10:04'!matches: aLoadableReference	"does Monticello-style #versionInfoFromVersionNamed: matching"		| pFilename |	(((pFilename := self packageFilename) == nil) or: [ self name = self packageFilename] ) ifTrue: [ ^super matches: aLoadableReference ].	^aLoadableReference name beginsWith: pFilename ! !!MetacelloGoferPackage methodsFor: 'private' stamp: 'DaleHenrichs 12/21/2010 10:39'!matchesWorkingCopy: aWorkingCopy	"check that the working copy package name matches the package file name and that the first ancestor's package file name	 matches the packageName"		| pFilename |	(pFilename := self packageFilename) == nil ifTrue: [ ^self error: 'cannot match working copy' ].	(self class 		packageFileName: pFilename 		matchesPackageName: aWorkingCopy package name)			ifTrue: [				aWorkingCopy ancestry ancestors isEmpty ifTrue: [ ^true ].				^self class 					packageFileName: aWorkingCopy ancestry ancestors first name 					matchesPackageName: self packageName ].	^false! !!MetacelloGoferPackage methodsFor: 'accessing' stamp: 'dkh 10/12/2009 16:25'!packageFilename	^packageFilename! !!MetacelloGoferPackage methodsFor: 'accessing' stamp: 'dkh 10/15/2009 10:00'!workingCopy		workingCopy == nil ifTrue: [ workingCopy := self findWorkingCopy ].	^workingCopy! !!MetacelloAbstractVersionConstructor methodsFor: '*metacello-mc-accessing' stamp: 'DaleHenrichs 10/27/2010 11:36'!project	project == nil ifTrue: [ project := MetacelloMCProject new].	^project! !!BlockClosure methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 1/16/2010 11:42'!valueSupplyingMetacelloAnswers: aListOfPairs	"evaluate the block using a list of questions / answers that might be called upon to	automatically respond to Object>>confirm: or FillInTheBlank requests"	^ [self value] 		on: ProvideAnswerNotification		do: 			[:notify | | answer caption |						caption := notify messageText withSeparatorsCompacted. "to remove new lines"			answer := aListOfPairs				detect: 					[:each | caption = each first or:						[(caption includesSubstring: each first caseSensitive: false) or:						[(each first match: caption) or:						[(String includesSelector: #matchesRegex:) and: 						[ [ caption matchesRegex: each first ] on: Error do: [:ignored | false ]]]]]]					ifNone: [nil].			answer				ifNotNil: [notify resume: answer second]				ifNil: 					[ | outerAnswer |					outerAnswer := ProvideAnswerNotification signal: notify messageText.					outerAnswer 						ifNil: [notify resume] 						ifNotNil: [notify resume: outerAnswer]]]! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc-querying' stamp: 'dkh 8/18/2009 11:42'!file 	"MetacelloPackageSpec compatibility"		^nil! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 11/12/2010 06:31'!forceUpdatePackageSpec: updatedSpecs using: anMCLoader	^self updatePackageSpec: updatedSpecs using: anMCLoader! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc-querying' stamp: 'DaleHenrichs 01/20/2010 13:40'!isPackageLoaded	^false! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 3/5/2010 09:46'!loadUsing: aLoader gofer: gofer	^self subclassResponsibility! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 11/12/2009 16:57'!packageRepository		^nil! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 12/22/2009 09:56'!packagesNeedSavingVisited: visitedProjects using: repos into: aCollection	"noop by default"! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc-querying' stamp: 'dkh 6/23/2009 13:55'!repository		^nil! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 08/03/2009 12:40'!repositorySpecs	^#()! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 10/21/2009 15:50'!resolveToAllPackagesIn: aVersionSpec into: packages visited: visited	visited		visit: self		doing: [:spec |			self visitingWithPackages: packages.			(spec includes, spec requires) do: [:pkgName |				(aVersionSpec packageNamed: pkgName)					projectDo: [:prj | 						(prj resolveToAllPackagesIn: aVersionSpec visited: visited) do: [:pkg | 							packages at: pkg name put: pkg ]] 					packageDo: [:pkg | 						packages at: pkg name put: pkg.						(pkg resolveToAllPackagesIn: aVersionSpec visited: visited) do: [:rpkg | 							packages at: rpkg name put: rpkg ] ] 					groupDo: [:grp | grp resolveToAllPackagesIn: aVersionSpec into: packages  visited: visited ]]]! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 10/21/2009 15:37'!resolveToAllPackagesIn: aVersionSpec visited: visited	| packages |	packages := Dictionary new.	self resolveToAllPackagesIn: aVersionSpec into: packages visited: visited.	^packages values asOrderedCollection! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 10/6/2009 15:02'!resolveToLoadableSpec	^self! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 10/21/2009 15:22'!resolveToPackagesIn: aVersionSpec visited: visited	^self subclassResponsibility! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 11/16/2010 16:31'!updateForSpawnMethod: sourceSpec	"This means that this spec was used in a baseline and will be used in a version .... drop all information that isn't useful"	answers := name := requires := includes := nil! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 08/03/2009 13:19'!updatePackageRepositoriesFor: aVersionSpec	"noop by default"		^true! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 10/5/2009 16:16'!updatePackageSpec: updatedSpecs using: anMCLoader	"Add pkg copy to updatedSpecs if the file in current image is different from the receiver's file"! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc-querying' stamp: 'dkh 10/24/2009 10:43'!version 	"MetacelloPackageSpec compatibility"		^nil! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 10/21/2009 15:50'!visitingWithPackages: packages	"noop"! !!MetacelloPackageSpec methodsFor: 'gofer' stamp: 'dkh 3/20/2011 17:45'!ancestors	^self goferPackage ancestors! !!MetacelloPackageSpec methodsFor: 'testing' stamp: 'DaleHenrichs 2/5/2010 11:36'!compareCurrentVersion: anOperator targetVersionStatus: statusIgnored using: anMCLoader	self 		currentPackageLoaded: [:bool | ^bool ] 		comparing: anOperator 		notLoaded: [:ignored | ^false ]		using: anMCLoader! !!MetacelloPackageSpec methodsFor: 'testing' stamp: 'DaleHenrichs 2/5/2010 14:03'!compareRelativeCurrentVersion: anOperator targetVersionStatus: statusIgnored using: anMCLoader	^self compareCurrentVersion: anOperator targetVersionStatus: statusIgnored using: anMCLoader! !!MetacelloPackageSpec methodsFor: 'testing' stamp: 'dkh 3/3/2011 07:56'!compareWorkingCopyNamed: wcName using: comarisonOperator	| fileRef wcRef |	fileRef := GoferResolvedReference name: self file.	wcRef := GoferResolvedReference name: wcName.	^ wcRef compare: fileRef using: comarisonOperator! !!MetacelloPackageSpec methodsFor: 'printing' stamp: 'DaleHenrichs 1/14/2011 15:02'!configMethodBodyOn: aStream hasName: hasName indent: indent	| hasFile hasRepositories hasPreLoadDoIt hasPostLoadDoIt hasRequiresOrIncludesOrAnswers |	hasFile := file ~~ nil.	hasRepositories := self repositorySpecs size > 0.	hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.	hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.	hasRequiresOrIncludesOrAnswers := (self requires isEmpty and: [ self includes isEmpty and: [self answers isEmpty ]]) not.	hasRequiresOrIncludesOrAnswers		ifTrue: [ 			self 				configMethodBodyOn: aStream 				hasName: hasName 				cascading: hasFile | hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt				indent: indent ].	self 		configMethodOn: aStream 		for: file 		selector: 'file: ' 		cascading: hasName | hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers 		cascade: hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt 		indent: indent.	hasRepositories		ifTrue: [ 			(self repositorySpecs size > 1)				ifTrue: [ 					hasName | hasFile | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers						ifTrue: [ 							aStream cr;							tab: indent. ].					aStream 						nextPutAll: 'repositories: ['; 						cr;						tab: indent + 1;						nextPutAll: 'spec'; 						cr.					self repositories configMethodCascadeOn: aStream indent: indent + 1.					aStream nextPutAll: ' ]' ]				ifFalse: [ 					hasName | hasFile | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers						ifTrue: [ aStream cr; tab: indent ].					self repositories configMethodCascadeOn: aStream indent: indent ].			hasPreLoadDoIt | hasPostLoadDoIt ifTrue: [ aStream nextPut: $; ] ].	self 		configMethodOn: aStream 		for: self getPreLoadDoIt 		selector: 'preLoadDoIt: '		cascading: hasName | hasFile | hasRepositories | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers 		cascade: hasPostLoadDoIt 		indent: indent.	self 		configMethodOn: aStream 		for: self getPostLoadDoIt 		selector: 'postLoadDoIt: ' 		cascading: hasName | hasFile | hasRepositories | hasPreLoadDoIt | hasRequiresOrIncludesOrAnswers 		cascade: false 		indent: indent.	aStream nextPut: $.! !!MetacelloPackageSpec methodsFor: 'printing' stamp: 'dkh 10/7/2009 09:36'!configMethodCascadeOn: aStream member: aMember last: lastCascade indent: indent	aMember methodUpdateSelector  == #remove:		ifTrue: [ aStream  nextPutAll: 'removePackage: ', self name printString ]		ifFalse: [ self configShortCutMethodBodyOn: aStream member: aMember indent: indent ].	lastCascade		ifTrue: [ aStream nextPut: $. ]		ifFalse: [ aStream nextPut: $;; cr ]! !!MetacelloPackageSpec methodsFor: 'printing' stamp: 'DaleHenrichs 12/21/2010 13:46'!configMethodOn: aStream indent: indent	| hasRepositories hasPreLoadDoIt hasPostLoadDoIt hasRequiresOrIncludesOrAnswers hasFile |	hasFile := file ~~ nil.	hasRepositories := self repositorySpecs size > 0.	hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.	hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.	hasRequiresOrIncludesOrAnswers := (self requires isEmpty and: [ self includes isEmpty and: [self answers isEmpty ]]) not.	aStream tab: indent; nextPutAll: 'spec '.	hasFile | hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers		ifTrue: [			aStream cr; tab: indent + 1; nextPutAll: 'name: ', self name printString; nextPut: $;.			self configMethodBodyOn: aStream hasName: true indent: indent + 1 ]		ifFalse: [			aStream nextPutAll: 'name: ', self name printString ]! !!MetacelloPackageSpec methodsFor: 'printing' stamp: 'DaleHenrichs 12/21/2010 13:46'!configShortCutMethodBodyOn: aStream member: aMember indent: indent	| hasFile hasRepositories hasPreLoadDoIt hasPostLoadDoIt hasRequiresOrIncludesOrAnswers |	hasFile := file ~~ nil.	hasRepositories := self repositorySpecs size > 0.	hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.	hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.	hasRequiresOrIncludesOrAnswers := (self requires isEmpty and: [ self includes isEmpty and: [self answers isEmpty ]]) not.	hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers		ifTrue: [			aStream 				nextPutAll: 'package: ', self name printString, ' ';				nextPutAll: aMember methodUpdateSelector asString, ' ['; cr.			aStream tab: indent + 1; nextPutAll: 'spec '.			self configMethodBodyOn: aStream hasName: false indent: indent + 2.			aStream nextPutAll: ' ]'.			^self ].	aStream nextPutAll: 'package: ', self name printString.	hasFile		ifTrue: [ aStream nextPutAll: ' with: ', file printString ]! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'DaleHenrichs 12/6/2010 13:14'!copySpecTo: aRepositorySpec	"Copy current mcz file to the repository named in aRepositorySpec"	self loader copySpec: self from: self repositorySpecs to: aRepositorySpec createRepository! !!MetacelloPackageSpec methodsFor: 'testing' stamp: 'dkh 3/20/2011 17:56'!currentPackageLoaded: loadedBlock comparing: comarisonOperator notLoaded: notLoadedBlock using: anMCLoader	"Use currentVersionInfoFor: because it involves the loader and returns versionInfo for a planned load 	 (atomic loaders) or currently loaded package"	| wcName vis |	vis := anMCLoader ancestorsFor: self.	vis notNil		ifTrue: [ 			| fileRef wcRef |			self getFile == nil				ifTrue: [ ^ loadedBlock value: false ].			vis				do: [ :vi | 					wcName := vi name.					fileRef := GoferResolvedReference name: self file.					wcRef := GoferResolvedReference name: wcName.					(wcRef compare: fileRef using: comarisonOperator)						ifTrue: [ ^ loadedBlock value: true ] ].			^ loadedBlock value: false ].	^ notLoadedBlock value: true! !!MetacelloPackageSpec methodsFor: 'testing' stamp: 'dkh 7/8/2011 21:40'!currentPackageLoaded: loadedBlock notLoaded: notLoadedBlock using: anMCLoader	"Use currentVersionInfoFor: because it involves the loader and returns versionInfo for a planned load 	 (atomic loaders) or currently loaded package"	| wcName vis |	vis := anMCLoader ancestorsFor: self.	vis notNil		ifTrue: [ 			self getFile == nil				ifTrue: [ ^ loadedBlock value: #() value: self file ].			^ loadedBlock value: vis value: self file ].	^ notLoadedBlock value! !!MetacelloPackageSpec methodsFor: 'gofer' stamp: 'dkh 9/25/2009 11:26'!currentVersionInfo	^self goferPackage currentVersionInfo! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'DaleHenrichs 3/5/2010 19:05'!ensureLoadedForDevelopmentUsing: mcLoader	"noop"		^true! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'dkh 11/16/2011 14:13'!explicitLoadUsing: mcLoader	| wc fetchingSpecLoader |	((wc := self workingCopy) ~~ nil and: [ wc needsSaving ]) 		ifTrue: [ 			(MetacelloSkipDirtyPackageLoad signal: self)				ifTrue:  [					Transcript cr; show: 'Skipping load of modified package: ', self file.					^self]				ifFalse: [Transcript cr; show: 'Load over modified package: ', self file] ].	"fetch and explicitly load it"	fetchingSpecLoader := mcLoader fetchingSpecLoader.	fetchingSpecLoader		explicitLoadPackageSpecs: (Array with: self) 		repositories: (fetchingSpecLoader repositoriesFrom: self repositorySpecs).! !!MetacelloPackageSpec methodsFor: 'private' stamp: 'dkh 10/7/2009 01:09'!extractNameFromFile	file == nil ifTrue: [ ^nil ].	^(self loader nameComponentsFrom: self file) first! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'DaleHenrichs 3/7/2010 09:36'!fetch	self fetchUsing: self loader! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'DaleHenrichs 4/12/2010 13:57'!fetchPackage: aLoaderPolicy	self fetchUsing: 		(self loader			loaderPolicy: aLoaderPolicy;			yourself)! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'DaleHenrichs 3/7/2010 09:38'!fetchUsing: mcLoader	| fetchingSpecLoader |	fetchingSpecLoader := mcLoader fetchingSpecLoader.	fetchingSpecLoader		linearLoadPackageSpecs: (Array with: self) 		repositories: (fetchingSpecLoader repositoriesFrom: self repositorySpecs).! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 10/6/2009 15:12'!file	file == nil ifTrue: [ ^self name ].	^file! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'dkh 06/03/2009 12:11'!file: aString	file := aString! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'DaleHenrichs 11/12/2010 06:33'!forceUpdatePackageSpec: updatedSpecs using: anMCLoader		self updatePackageSpec: updatedSpecs force: true using: anMCLoader! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'dkh 10/30/2009 10:37'!getFile	"raw access to iv"		^file! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'DaleHenrichs 12/21/2010 13:44'!getPostLoadDoIt	^postLoadDoIt! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'DaleHenrichs 12/21/2010 13:44'!getPreLoadDoIt	^preLoadDoIt! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'dkh 4/17/2011 14:41'!goferBranchPackage: branchName message: commitMessage	"uses gofer to do commit ... non-interactive"	| latestFile pkgSpec   |	(file notNil and: [ (self name, '.', branchName) = self file ])		ifTrue: [ 			latestFile := self loader latestPackage: self file fromRepository: self repositorySpecs.			pkgSpec := self copy.			latestFile ~~ nil				ifTrue: [ 					pkgSpec file: latestFile.					pkgSpec goferCommitPackage: commitMessage.					^ self ] ].	self loader goferCommitBranchPackage: branchName using: self repositorySpecs commitMessage: commitMessage! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'DaleHenrichs 3/15/2010 11:38'!goferCommitPackage: commitMessage	"uses gofer to do commit ... non-interactive"		| latestFile pkgSpec |	^(file notNil and: [ self name = self file ])		ifTrue: [			latestFile := self loader latestPackage: self name fromRepository: self repositorySpecs.			pkgSpec := self copy.			pkgSpec file: latestFile.			pkgSpec goferCommitPackage: commitMessage ]		ifFalse: [ self loader goferCommitPackageUsing: self repositorySpecs commitMessage: commitMessage ]! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'dkh 1/13/2010 17:04'!goferLoaderReference	^file == nil 		ifTrue: [ GoferPackageReference name: self name ]		ifFalse: [ 			"does Monticello-style #versionInfoFromVersionNamed: matching"			MetacelloGoferPackage name: self name packageFilename: self file ]! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'dkh 12/15/2009 10:32'!goferPackage	goferPackage == nil 		ifTrue: [ goferPackage := MetacelloGoferPackage name: self name packageFilename: self file ].	^goferPackage! !!MetacelloPackageSpec methodsFor: 'private' stamp: 'dkh 10/10/2009 11:00'!includesForPackageOrdering	^self includes! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'dkh 1/6/2010 17:58'!info	"test compatibility method"	^self! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 5/14/2010 15:50'!isPackageLoaded	^self isPackageLoaded: self loader! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 5/14/2010 15:50'!isPackageLoaded: aLoader	^(self workingCopyNameFor: aLoader) ~~ nil! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'DaleHenrichs 3/6/2010 10:28'!load	self explicitLoadUsing: self loader! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'DaleHenrichs 3/10/2010 12:32'!loadUsing: mcLoader	self loader doingLoads: [ self explicitLoadUsing: mcLoader ]! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'DaleHenrichs 4/9/2010 12:29'!loadUsing: aLoader gofer: gofer	^aLoader linearLoadPackageSpec: self gofer: gofer! !!MetacelloPackageSpec methodsFor: 'merging' stamp: 'DaleHenrichs 1/21/2010 20:37'!mergeMap	| map |	map := super mergeMap.	map at: #file put: file.	map at: #repositories put: self repositories.	map at: #preLoadDoIt put: preLoadDoIt.	map at: #postLoadDoIt put: postLoadDoIt.	^map! !!MetacelloPackageSpec methodsFor: 'merging' stamp: 'Dalehenrichs 02/10/2010 10:54'!mergeSpec: anotherSpec	| newSpec map anotherPackages anotherRepositories |	newSpec := super mergeSpec: anotherSpec.	map := anotherSpec mergeMap.	(anotherRepositories := map at: #repositories) notEmpty		ifTrue: [ 			newSpec 				repositories: (self repositories isEmpty					ifTrue: [ anotherRepositories ]					ifFalse: [ self repositories mergeSpec: anotherRepositories ]) ].	^newSpec! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 06/03/2009 12:13'!name	name == nil ifTrue: [ name := self extractNameFromFile ].	^name! !!MetacelloPackageSpec methodsFor: 'merging' stamp: 'dkh 1/2/2010 16:29'!nonOverridable	^super nonOverridable, #( repositories)! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 1/2/2010 15:35'!packageRepository		self repositorySpecs isEmpty ifTrue: [ ^nil ].	^self repositorySpecs first! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'dkh 6/8/2009 16:16'!packageSpecsInLoadOrder	^{ self. }! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'dkh 12/22/2009 10:17'!packagesNeedSavingVisited: visitedProjects using: repos into: aCollection	^self loader packagesNeedSavingUsing: repos into: aCollection! !!MetacelloPackageSpec methodsFor: 'copying' stamp: 'dkh 1/2/2010 15:46'!postCopy	super postCopy.	goferPackage := nil.	repositories := repositories copy.! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'DaleHenrichs 1/21/2010 20:40'!postLoadDoIt	^postLoadDoIt! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 12/21/2010 13:57'!postLoadDoIt: anObject	anObject setPostLoadDoItInMetacelloSpec: self! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'DaleHenrichs 1/21/2010 20:40'!preLoadDoIt	^preLoadDoIt! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 12/21/2010 13:57'!preLoadDoIt: anObject	anObject setPreLoadDoItInMetacelloSpec: self! !!MetacelloPackageSpec methodsFor: 'visiting' stamp: 'dkh 10/5/2009 09:39'!projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	packageBlock value: self! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 1/2/2010 15:41'!repositories	repositories == nil ifTrue: [ repositories := self project repositoriesSpec ].	^ repositories! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 1/2/2010 15:41'!repositories: anObject	repositories := anObject! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 1/2/2010 15:46'!repository	self deprecated: 'Use repositories or repositorySpecs'.	^self packageRepository! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'dkh 1/2/2010 15:44'!repository: aStringOrMetacelloRepositorySpec	self repositories repository: aStringOrMetacelloRepositorySpec! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'dkh 1/2/2010 15:47'!repository: aString username: username password: password	self repositories repository: aString username: username password: password! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'dkh 1/2/2010 15:43'!repositorySpecs	^self repositories map values ! !!MetacelloPackageSpec methodsFor: 'private' stamp: 'dkh 10/21/2009 15:22'!resolveToPackagesIn: aVersionSpec visited: visited	^{ self }! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'DaleHenrichs 3/15/2010 11:35'!savePackage	"Interactive save ... prompted for commit message and package name unless MCVersionNameAndMessageRequest handled"	| latestFile pkgSpec |	^(file notNil and: [ self name = self file ])		ifTrue: [			latestFile := self loader latestPackage: self name fromRepository: self repositorySpecs.			pkgSpec := self copy.			pkgSpec file: latestFile.			pkgSpec savePackage ]		ifFalse: [ self loader savePackageUsing: self repositorySpecs ]! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 12/21/2010 13:53'!setPostLoadDoIt: aSymbol	postLoadDoIt := aSymbol! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 12/21/2010 13:53'!setPreLoadDoIt: aSymbol	preLoadDoIt := aSymbol! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'DaleHenrichs 11/16/2010 16:31'!updateForSpawnMethod: sourceSpec    "This means that this spec was used in a baseline and will be used in a version .... drop all information that isn't useful"    | nm fl |    nm := name.    fl := file.    fl == nil        ifTrue: [             "if only name has been set, then force the file to be non-nil, if any attribute besides file is set, then leave file nil"            {answers.            requires.            includes.            repositories.            preLoadDoIt.            postLoadDoIt} detect: [ :each | each ~~ nil ] ifNone: [ fl := name ] ].    super updateForSpawnMethod: sourceSpec.    file := repositories := goferPackage := preLoadDoIt := postLoadDoIt := nil.    name := nm.    file := fl.    ^ file == nil! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'dkh 01/14/2010 12:57'!updatePackageRepositories: repositorySpecs	| resolvedPackageRef |	Transcript cr; show: '  Looking up version -> ', self file.	resolvedPackageRef := self loader resolveSpec: self from: repositorySpecs.	Transcript cr; show: 'Update repositoryGroup -> ', resolvedPackageRef name, ' ' , resolvedPackageRef repository description.	resolvedPackageRef version workingCopy repositoryGroup addRepository: resolvedPackageRef repository! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'dkh 11/01/2009 11:15'!updatePackageRepositoriesFor: aVersionSpec	"Don't update the repository unless the package is loaded in the image"		self workingCopy == nil ifTrue: [ ^self ].	self updatePackageRepositories: self repositorySpecs, aVersionSpec repositorySpecs.	! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'DaleHenrichs 11/12/2010 14:56'!updatePackageSpec: updatedSpecs force: force using: anMCLoader	"Add pkg copy to updatedSpecs if the file in current image is different from the receiver's file"	| viName |	(force not and: [ self getFile == nil ])		ifTrue: [ ^ self ].	"no file explicitly specified in this spec"	(viName := self workingCopyNameFor: anMCLoader) == nil		ifTrue: [ ^ self ].	"no working copy"	viName ~= self file		ifTrue: [ 			| spec |			spec := self copy.			spec file: viName.			updatedSpecs at: spec name put: spec ]		ifFalse: [ updatedSpecs at: self name put: #uptodate ]! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'DaleHenrichs 11/12/2010 06:33'!updatePackageSpec: updatedSpecs using: anMCLoader	"Add pkg copy to updatedSpecs if the file in current image is different from the receiver's file"		self updatePackageSpec: updatedSpecs force: false using: anMCLoader! !!MetacelloPackageSpec methodsFor: 'visiting' stamp: 'dkh 10/21/2009 15:51'!visitingWithPackages: packages	packages at: self name put: self! !!MetacelloPackageSpec methodsFor: 'gofer' stamp: 'dkh 9/25/2009 10:53'!workingCopy	^self goferPackage workingCopy! !!MetacelloPackageSpec methodsFor: 'gofer' stamp: 'dkh 11/05/2009 13:58'!workingCopyName	| wc |	(wc := self workingCopy) == nil ifTrue: [ ^nil ].	wc ancestry ancestors isEmpty not		ifTrue: [ ^wc ancestry ancestors first name ].	^nil! !!MetacelloPackageSpec methodsFor: 'gofer' stamp: 'dkh 9/25/2009 10:52'!workingCopyNameFor: anMCLoader	| vi |	(vi := anMCLoader currentVersionInfoFor: self) == nil ifTrue: [ ^nil ].	^vi name! !!MetacelloMCProject methodsFor: 'repository creation' stamp: 'dkh 10/22/2009 08:53'!createRepository: aRepositorySpec	^ MetacelloPlatform current createRepository: aRepositorySpec! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'DaleHenrichs 3/6/2010 07:46'!defaultLoaderClass	^MetacelloLoadingMCSpecLoader! !!MetacelloMCProject methodsFor: 'development support' stamp: 'DaleHenrichs 3/7/2010 09:51'!fetchProject	"fetch the latest version of the configuration package"		^self fetchProject: MetacelloLoaderPolicy new! !!MetacelloMCProject methodsFor: 'development support' stamp: 'DaleHenrichs 3/7/2010 09:49'!fetchProject: aLoaderPolicy	"fetch the latest version of the configuration package"		| mcLoader |	(mcLoader := self loader) == nil		ifTrue: [ mcLoader := self project loaderClass on: nil ].	mcLoader loaderPolicy: aLoaderPolicy.	mcLoader doingLoads: [ 		MCWorkingCopy			managersForClass: self configuration class			do: [:mgr | | pkg |				pkg := self packageSpec.				mgr repositoryGroup repositories do: [:repo | pkg repositories repository: (repo asRepositorySpecFor: self) ].				pkg name: mgr packageName.				pkg fetchUsing: mcLoader.				^true ]].	^true! !!MetacelloMCProject methodsFor: 'development support' stamp: 'dkh 4/17/2011 14:37'!goferBranch: branchName project: commitMessage	| pkgSpec |	(pkgSpec := self projectPackage) == nil ifTrue: [ ^false ].	pkgSpec file: pkgSpec name, '.', branchName.	^pkgSpec goferBranchPackage: branchName message: commitMessage! !!MetacelloMCProject methodsFor: 'development support' stamp: 'DaleHenrichs 3/15/2010 11:37'!goferCommitProject: commitMessage	| pkgSpec |	(pkgSpec := self projectPackage) == nil ifTrue: [ ^false ].	^pkgSpec goferCommitPackage: commitMessage! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'dkh 06/01/2009 10:58'!packageSpec	^self packageSpecClass for: self! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'dkh 06/01/2009 10:24'!packageSpecClass	^MetacelloPackageSpec! !!MetacelloMCProject methodsFor: 'development support' stamp: 'dkh 12/22/2009 10:00'!packagesNeedSaving: aVersionString	"Answer a collection of associations (package -> repository) representing the packages 	 reachable from this project that need to be saved"	| packages |	packages := Set new.	(self version: aVersionString) spec 		packagesNeedSavingVisited: (Set with: self configuration class name asString)		into: packages.	^packages! !!MetacelloMCProject methodsFor: 'private' stamp: 'dkh 6/10/2009 10:56'!pragmaKeywords	^super pragmaKeywords, #(projectPackage:attribute: packages:attribute: repositories:attribute: )! !!MetacelloMCProject methodsFor: 'development support' stamp: 'DaleHenrichs 03/20/2010 12:48'!projectPackage	MCWorkingCopy		managersForClass: self configuration class		do: [:mgr | | pkgSpec repo |			pkgSpec := 				self packageSpec					name: mgr packageName;					yourself.			mgr ancestors notEmpty				ifTrue: [ pkgSpec file: mgr ancestors first name ].			repo := mgr repositoryGroup repositories 				detect: [:each | each ~~ MCCacheRepository default ] 				ifNone: [ 					Transcript cr; show: 'Using cache repository for ', self label, ' project package'.					MCCacheRepository default ].			pkgSpec repository: repo description.			^pkgSpec].	^nil! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'DaleHenrichs 10/27/2010 11:14'!projectSpecClass	^MetacelloMCProjectSpec! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'dkh 6/7/2009 10:11'!repositoriesSpec	^self repositoriesSpecClass for: self! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'dkh 6/7/2009 10:11'!repositoriesSpecClass	^MetacelloRepositoriesSpec! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'dkh 06/01/2009 10:59'!repositorySpec	^self repositorySpecClass for: self! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'dkh 06/01/2009 10:25'!repositorySpecClass	^MetacelloRepositorySpec! !!MetacelloMCProject methodsFor: 'development support' stamp: 'Dalehenrichs 02/10/2010 10:15'!saveProject	| pkgSpec |	(pkgSpec := self projectPackage) == nil ifTrue: [ ^false ].	^pkgSpec savePackage! !!MetacelloMCProject methodsFor: 'repository updating' stamp: 'dkh 9/2/2009 06:21'!updatePackageRepositoriesFor: versionString	| versionSpec |	(versionSpec := (self version: versionString) versionSpec) packageSpecsInLoadOrder do: [:pkgSpec |		pkgSpec updatePackageRepositoriesFor: versionSpec ].	^true! !!MetacelloMCProject methodsFor: 'development support' stamp: 'DaleHenrichs 3/24/2010 15:50'!updateProject	"load the latest version of the configuration package"	"WARNING: don't forget to refresh your project instance after doing an #updateProject, 	 otherwise your instance won't reflect the info in the freshly loaded configuration"		^self updateProject: MetacelloLoaderPolicy new! !!MetacelloMCProject methodsFor: 'development support' stamp: 'dkh 4/7/2011 23:26'!updateProject: aLoaderPolicy	"load the latest version of the configuration package"	"WARNING: don't forget to refresh your project instance after doing an #updateProject, 	 otherwise your instance won't reflect the info in the freshly loaded configuration"	| mcLoader |	(mcLoader := self loader) == nil		ifTrue: [ mcLoader := self project loaderClass on: nil ].	mcLoader loaderPolicy: aLoaderPolicy.	mcLoader		doingLoads: [ 			MCWorkingCopy				managersForClass: self configuration class				do: [ :mgr | 					| pkg ar |					pkg := self packageSpec.					mgr repositoryGroup repositories do: [ :repo | pkg repositories repository: (repo asRepositorySpecFor: self) ].					ar := mgr metacelloPackageNameWithBranch.					pkg name: (ar at: 1).					(ar at: 2) notEmpty						ifTrue: [ pkg file: (ar at: 2) ].					pkg load.					^ true ] ].	^ true! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'dkh 6/6/2009 12:19'!versionSpecClass	^MetacelloMCVersionSpec! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: 'dkh 7/20/2011 11:51'!className: aString	super className: aString.	(projectPackage ~~ nil and: [ projectPackage getFile == nil ])		ifTrue: [ projectPackage name: aString; file: aString ]! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: 'DaleHenrichs 11/5/2010 15:55'!compareCurrentVersion: anOperator targetVersionStatus: targetVersionStatus using: anMCLoader	| cv vrsn prjct |	(vrsn := self versionOrNil) == nil ifTrue: [ ^false ].	prjct := self projectClassProject.	prjct loader: anMCLoader.	(cv := prjct currentVersion) == nil ifTrue: [ ^false ].	(targetVersionStatus includes: cv versionStatus)		ifTrue: [ ^cv perform: anOperator with: vrsn ].	^false	 ! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: 'DaleHenrichs 11/5/2010 15:55'!compareRelativeCurrentVersion: anOperator targetVersionStatus: targetVersionStatus using: anMCLoader	| cv vrsn |	(vrsn := self versionOrNil) == nil ifTrue: [ ^false ].	(cv := self relativeCurrentVersion) == nil ifTrue: [ ^false ].	(targetVersionStatus includes: cv versionStatus)		ifTrue: [ ^cv perform: anOperator with: vrsn ].	^false	 ! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: 'DaleHenrichs 11/5/2010 15:56'!determineCurrentVersionForLoad	"don't use self currentVersion, because we are interested in the currentVersion of the project as loaded in image, not the current version relative to our load list"		| prjct version currentVersion packageAndProjectNames cvs |	self projectClass == nil ifTrue: [ ^nil ].	(version := self versionOrNil) == nil ifTrue: [ ^nil ].	version blessing == #baseline ifTrue: [ ^version ].	self loader ignoreImage ifTrue: [ ^version ].	prjct := self projectClass new project.	prjct loader: self loader.	(currentVersion := prjct currentVersion) == nil ifTrue: [ ^nil ].	(cvs := currentVersion versionStatus) == #somethingLoaded ifTrue: [ ^nil ].	(#(allLoadedToSpec loadedToSpec loadedMatchConstraints) includes: (cvs := currentVersion versionStatus)) 		ifTrue: [ 			(currentVersion perform: self operator with: version)				ifTrue: [ "load currentVersion" ^currentVersion ].			"load version" ^nil ].	version = currentVersion ifTrue: [ ^currentVersion ].	(MetacelloProjectSpecLoadConflict projectSpec: self) 		signal: 			'Project load conflict for', 			prjct label printString,  			' between current version ',			currentVersion printString, 			'(', 			cvs asString, 			') and specified version ', 			version printString,			'. Press resume to continue with load anyway'.	^nil! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: 'dkh 9/7/2011 14:17'!ensureLoadedForDevelopmentUsing: mcLoader	"for #development projects, always need latest version of package when contemplating a load"	| ensured |	ensured := mcLoader ensuredMap at: self name ifAbsent: [ nil ].	self projectClass ~~ nil		ifTrue: [  | vrsn |			vrsn := self versionOrNil.			(vrsn ~~ nil and: [ vrsn blessing == #development ])				ifTrue: [ 					ensured ~~ #latest						ifTrue: [							mcLoader ensureForDevelopment								ifTrue: [  | pc |									(pc := self projectClass) ~~ nil										ifTrue: [ MetacelloClearStackCacheNotification signal: #(#versionConstructor)].									self projectPackage loadUsing: mcLoader ]								ifFalse: [ self projectPackage fetchUsing: mcLoader ].							mcLoader ensuredMap at: self name put: #latest ].					^self]].	ensured == nil		ifTrue:  [			mcLoader ensureForDevelopment				ifTrue: [  | pc |					(pc := self projectClass) ~~ nil						ifTrue: [ MetacelloClearStackCacheNotification signal: #(#versionConstructor)]. 					self projectPackage loadUsing: mcLoader ]				ifFalse: [ self projectPackage fetchUsing: mcLoader ].			mcLoader ensuredMap at: self name put: #present ]! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: 'dkh 9/7/2011 14:13'!ensureProjectLoaded	"Ensure that the MetacelloProject is loaded in image. 	 projectClass == nil or requested version non-existent warrants a project package load."	(self projectClass == nil or: [ self versionOrNil == nil ])		ifTrue: [ | pc |			(pc := self projectClass) ~~ nil				ifTrue: [ MetacelloClearStackCacheNotification signal: #(#versionConstructor)].			self projectPackage load.			^ true ].	^ false! !!MetacelloMCProjectSpec methodsFor: 'querying' stamp: 'dkh 10/24/2009 20:19'!file		^self projectPackage file! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: 'dkh 7/20/2011 11:54'!file: aString	self projectPackage name ifNil: [ self projectPackage name: aString ].	self projectPackage file: aString! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: 'DaleHenrichs 12/21/2010 13:45'!hasNonVersionStringField	| hasVersionString hasOperator hasProjectPackage hasLoads hasClassName hasPreLoadDoIt hasPostLoadDoIt |	hasClassName := self className ~~ nil.	hasVersionString := self versionString ~~ nil.	hasOperator := operator ~~ nil.	hasProjectPackage := self projectPackage ~~ nil		and: [ self projectPackage name ~~ nil or: [ self projectPackage packageRepository ~~ nil ] ].	hasLoads := self loads ~~ nil.	hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.	hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.	^ hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPreLoadDoIt | hasPostLoadDoIt! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: 'DaleHenrichs 11/5/2010 15:56'!isPartiallyLoaded: aLoader	| vrsn |	(vrsn := self versionOrNil) == nil ifTrue: [ ^false ].	(self loadListForVersion: vrsn) do: [:nm |		(vrsn packagesForSpecNamed: nm ) do: [:pkg |			(pkg isPackageLoaded: aLoader) ifTrue: [ ^true ]]].	^false! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: 'DaleHenrichs 11/5/2010 15:56'!isPossibleBaseline	| vrsn |	(vrsn := self versionOrNil) == nil ifTrue: [ ^false ].	(vrsn allPackagesForSpecNamed: (self loadListForVersion: vrsn)) do: [:pkg |		pkg workingCopy == nil ifTrue: [ ^false ]].	^true! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: 'DaleHenrichs 10/25/2010 15:32'!load	| displayString |	displayString := 'Project: ', self name.	self versionString ~~ nil ifTrue: [ displayString := displayString, ' ', self versionString ].	Transcript cr; show: displayString.	self ensureProjectLoaded.	self loadVersion: self determineCurrentVersionForLoad! !!MetacelloMCProjectSpec methodsFor: 'private' stamp: 'dkh 10/21/2009 19:20'!loadListForVersion: vrsn 	^ (self loads == nil			or: [self loads isEmpty])		ifTrue: [vrsn spec defaultPackageNames]		ifFalse: [self loads]! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 11/5/2010 15:57'!loadPackageList	| vrsn pkgs |	(vrsn := self versionOrNil) == nil ifTrue: [ ^#() ].	pkgs := OrderedCollection new.	(self loadListForVersion: vrsn) do: [:nm |		pkgs addAll: ((vrsn packagesForSpecNamed: nm ) collect: [:each | each name ])].	^pkgs! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: 'DaleHenrichs 11/5/2010 15:57'!loadVersion: aVersionOrNil	"Load the correct version of the project"	| vrsn mcLoader list |	vrsn := aVersionOrNil .	vrsn == nil		ifTrue: [ 			(vrsn := self versionOrNil) == nil				ifTrue: [					 ^(MetacelloProjectSpecLoadError projectSpec: self) 						signal: 'No version found for ', 									self versionString printString, 									' of ', 									self className asString ]].	mcLoader := self loader copy.	mcLoader operator: self operator.	vrsn loader: mcLoader.	list := (mcLoader ignoreImage 		ifTrue: [ self loadListForVersion: vrsn ]		ifFalse: [ vrsn packageAndProjectNamesToLoad: (self loadListForVersion: vrsn) loader: mcLoader ]) asSet.	MetacelloPlatform current 		useStackCacheDuring: [:dict | | projectCache cachedList |			projectCache := dict 					at: self projectClass 					ifAbsent: [ dict at: self projectClass put: Dictionary new].			(cachedList := projectCache at: vrsn ifAbsent: []) == nil				ifTrue: [  projectCache at: vrsn put: list ]				ifFalse: [ 					(cachedList size = list size and: [ cachedList includesAllOf: list ]) 						ifTrue: [ 							"no need to refetch list ... recursion stoppper (Issue 95)" 							^self ]						ifFalse: [  projectCache at: vrsn put: list ]].			mcLoader preLoad: self.			vrsn fetchRequiredFromArray: list.			mcLoader postLoad: self.			] 		defaultDictionary: Dictionary new.! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: 'DaleHenrichs 11/5/2010 15:57'!loadedPackageNames: aLoader	| vrsn pkgs |	(vrsn := self versionOrNil) == nil ifTrue: [ ^#() ].	pkgs := OrderedCollection new.	(self loadListForVersion: vrsn) do: [:nm |		(vrsn packagesForSpecNamed: nm ) do: [:pkg |			(pkg isPackageLoaded: aLoader) ifTrue: [ pkgs add: pkg name ]]].	^pkgs! !!MetacelloMCProjectSpec methodsFor: 'merging' stamp: 'dkh 10/4/2009 12:05'!mergeMap	| map |	map := super mergeMap.	map at: #projectPackage put: projectPackage.	^map! !!MetacelloMCProjectSpec methodsFor: 'merging' stamp: 'dkh 10/9/2009 06:28'!mergeSpec: anotherSpec	| newSpec anotherProjectPackage map |	newSpec := super mergeSpec: anotherSpec.	map := anotherSpec mergeMap.	(anotherProjectPackage := map at: #projectPackage) ~~ nil		ifTrue: [ 			newSpec projectPackage: 				(newSpec projectPackage == nil					ifTrue: [ anotherProjectPackage ]					ifFalse: [ newSpec projectPackage mergeSpec: anotherProjectPackage ])].	^newSpec! !!MetacelloMCProjectSpec methodsFor: 'merging' stamp: 'dkh 10/8/2009 20:34'!nonOverridable	^super nonOverridable, #( projectPackage )! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: 'dkh 10/4/2009 11:44'!packageFileSpecFor: aMetacelloPackagesSpec	^(aMetacelloPackagesSpec project projectReferenceSpec)			name: self name;			projectReference: self copy;			yourself.! !!MetacelloMCProjectSpec methodsFor: 'querying' stamp: 'dkh 11/12/2009 16:56'!packageRepository		^nil! !!MetacelloMCProjectSpec methodsFor: 'copying' stamp: 'DaleHenrichs 11/17/2010 12:44'!postCopy	super postCopy.	projectPackage := projectPackage copy.! !!MetacelloMCProjectSpec methodsFor: 'querying' stamp: 'DaleHenrichs 11/11/2010 17:07'!projectClass	self className == nil ifTrue: [ ^nil ].	^Smalltalk at: self className asSymbol  ifAbsent: []! !!MetacelloMCProjectSpec methodsFor: 'querying' stamp: 'dkh 9/10/2009 13:18'!projectClassProject	"indirection needed when projectClass is _not_ a subclass of MetacelloProject"		^self projectClass new project! !!MetacelloMCProjectSpec methodsFor: 'visiting' stamp: 'dkh 10/21/2009 15:53'!projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	projectBlock value: self! !!MetacelloMCProjectSpec methodsFor: 'querying' stamp: 'dkh 6/7/2009 09:19'!projectPackage	^ projectPackage! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/7/2009 09:19'!projectPackage: anObject	projectPackage := anObject! !!MetacelloMCProjectSpec methodsFor: 'querying' stamp: 'dkh 7/8/2011 22:27'!relativeCurrentVersion	"currentVersion calculated relative to the loadList"		| vrsn expanded loadList |	(vrsn := self versionOrNil) == nil ifTrue: [ ^nil ].	expanded := [ vrsn expandToLoadableSpecNames: (loadList := self loadListForVersion: vrsn) ] 					on: Error 					do: [:ex |						vrsn blessing == #development							ifTrue: [ 								self projectPackage load.								vrsn := self versionOrNil.								ex return: (vrsn expandToLoadableSpecNames: loadList)].						ex pass].	^self projectClassProject currentVersionAgainst: expanded		! !!MetacelloMCProjectSpec methodsFor: 'querying' stamp: 'dkh 1/2/2010 15:36'!repository		^self projectPackage packageRepository! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: 'dkh 10/7/2009 01:02'!repository: aString	self projectPackage repository: aString! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: 'dkh 10/22/2009 09:39'!repository: aString username: username password: password	self projectPackage repository: aString username: username password: password! !!MetacelloMCProjectSpec methodsFor: 'private' stamp: 'DaleHenrichs 11/5/2010 15:57'!resolveToAllPackagesIn: aVersionSpec visited: visited	| vrsn |	visited		pushProject: [ 			visited				visit: self				doing: [ :spec | 					spec ensureProjectLoaded.					(vrsn := spec versionOrNil) == nil						ifTrue: [ (MetacelloVersionDoesNotExistError project: self project versionString: self versionString) signal ].					^ vrsn allPackagesForSpecNamed: (self loadListForVersion: vrsn) ifAbsent: [ self error: 'invalid loads: spec' ] ] ].	^ #()! !!MetacelloMCProjectSpec methodsFor: 'private' stamp: 'dkh 11/12/2009 10:12'!resolveToLoadableSpec	^self copy! !!MetacelloMCProjectSpec methodsFor: 'development support' stamp: 'DaleHenrichs 11/16/2010 16:31'!updateForSpawnMethod: sourceSpec	"This means that this spec was used in a baseline and will be used in a version .... drop all information that isn't useful"		className := operator := loads := projectPackage := nil.	sourceSpec ~~ nil ifTrue: [ versionString := sourceSpec versionString ].! !!MetacelloMCProjectSpec methodsFor: 'development support' stamp: 'DaleHenrichs 11/5/2010 15:57'!updatePackageSpec: updatedSpecs	"Add project copy to updatedSpecs if the current version of the project 	 is different from the receiver's version"		|  prj currentVersion spec |	self className == nil ifTrue: [ ^self ].	prj := self projectClassProject.	(currentVersion := prj currentVersion) = self versionOrNil		ifTrue: [ ^self ].	currentVersion == nil ifTrue: [ ^self ].	spec := self copy.	spec versionString: currentVersion versionString.	updatedSpecs at: spec name put: spec! !!MetacelloMCProjectSpec methodsFor: 'querying' stamp: 'DaleHenrichs 1/13/2011 12:54'!version	"Empty version string means use latestVersion or #bleedingEdge"	self projectClass == nil		ifTrue: [ ^ nil ].	^ self versionString == nil		ifTrue: [ 			| vrsn |			"Eventually it will become an error to not specify a project reference version as default: #stable is the preferred default"			"self deprecated: 'Must specify a project reference version.'."			self flag: 'deprecate after version 1.0'.			(vrsn := self projectClassProject latestVersion) == nil				ifTrue: [ self projectClassProject version: #bleedingEdge ]				ifFalse: [ vrsn ] ]		ifFalse: [ self projectClassProject version: self versionString ]! !!MetacelloMCProjectSpec methodsFor: 'querying' stamp: 'DaleHenrichs 11/5/2010 15:55'!versionOrNil	^[ self version ] on: MetacelloVersionDoesNotExistError do: [:ex | ^nil ].! !!MetacelloGoferCommit methodsFor: 'running' stamp: 'dkh 4/17/2011 14:42'!execute: aWorkingCopy	| version |	version := aWorkingCopy newVersion.	self gofer repositories		do: [ :repository | repository storeVersion: version ]! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/7/2009 10:15'!addToMetacelloRepositories: aMetacelloRepositoriesSpec	| spec |	spec := 		(aMetacelloRepositoriesSpec project repositorySpec)			description: self;			yourself.	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec addMember 			name: spec name;			spec: spec;			yourself)! !!String methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 3/7/2010 08:26'!fetchRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doFetchRequiredFromArray: (Array with: self).! !!String methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 3/7/2010 08:26'!loadRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doLoadRequiredFromArray: (Array with: self).! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/7/2009 10:20'!mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec	| spec |	spec := 		(aMetacelloRepositoriesSpec project repositorySpec)			description: self;			yourself.	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec mergeMember 			name: spec name;			spec: spec;			yourself)! !!String methodsFor: '*metacello-mc' stamp: 'dkh 9/23/2009 14:34'!packageFileSpecFor: aMetacelloPackagesSpec	^(aMetacelloPackagesSpec project packageSpec)			file: self;			yourself! !!String methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 3/11/2010 10:06'!recordRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doRecordRequiredFromArray: (Array with: self).! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/7/2009 10:23'!removeFromMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec removeMember 			name: self;			yourself)! !!String methodsFor: '*metacello-mc' stamp: 'dkh 10/21/2009 19:18'!resolvePackageSpecsNamedForMetacelloMCVersion: aMetacelloMCVersion visited: visited ifAbsent: aBlock 	^ aMetacelloMCVersion 		allPackagesForSpecs:  {aMetacelloMCVersion spec packageNamed: self ifAbsent: aBlock}		visited: visited! !!MetacelloGoferLoad methodsFor: 'private' stamp: 'DaleHenrichs 12/18/2010 13:39'!updateCategories	MetacelloPlatform current bypassGoferLoadUpdateCategories		ifFalse: [ super updateCategories ]! !!MetacelloGoferLoad methodsFor: 'private' stamp: 'DaleHenrichs 3/5/2010 10:48'!updateRepositories	"Noop for Metacello...done by loader itself"! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 3/5/2010 09:46'!loadUsing: aLoader gofer: ignored	| required |	required := self resolveToLoadableSpec.	required loader: aLoader.	^required load! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 11/5/2010 15:58'!packagesNeedSavingVisited: visitedProjects using: repos into: aCollection		| prjct clsName vrsn |	prjct := self resolveToLoadableSpec.	(visitedProjects includes: (clsName := prjct className)) ifTrue: [ ^self ].	visitedProjects add: clsName.	(vrsn := self versionOrNil) == nil ifTrue: [ ^self ].	vrsn spec 		packagesNeedSavingVisited: visitedProjects 		into: aCollection! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'dkh 9/13/2012 11:26'!repository: aStringOrMetacelloRepositorySpec    ^ self projectReference repository: aStringOrMetacelloRepositorySpec! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'dkh 10/3/2009 19:14'!resolveProjectSpec	^self projectReference! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'dkh 10/21/2009 15:48'!resolveToAllPackagesIn: aVersionSpec into: packages visited: visited	(self resolveProjectSpec resolveToAllPackagesIn: aVersionSpec visited: visited) do: [:pkg |		packages at: pkg put: pkg ]! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'dkh 11/10/2009 09:48'!resolveToLoadableSpec	^self resolveProjectSpec resolveToLoadableSpec! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'dkh 10/21/2009 15:22'!resolveToPackagesIn: aVersionSpec visited: visited	^#()! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 11/16/2010 16:31'!updateForSpawnMethod: sourceSpec	"This means that this spec was used in a baseline and will be used in a version .... drop all information that isn't useful"	| nm |	nm := name.	self projectReference updateForSpawnMethod: sourceSpec.	super updateForSpawnMethod: sourceSpec.	name := nm.! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'dkh 10/23/2009 10:20'!updatePackageSpec: updatedSpecs using: anMCLoader	"Add project copy to updatedSpecs if the current version of the project 	 is different from the receiver's version"		self projectReference updatePackageSpec: updatedSpecs! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'dkh 12/7/2009 16:24'!versionString	^self projectReference versionString! !!MCDirectoryRepository methodsFor: '*metacello-mc' stamp: 'DaleHenrichs 3/5/2010 14:44'!asRepositorySpecFor: aMetacelloMCProject	^(aMetacelloMCProject repositorySpec)		description:  directory fullName;	 	type: 'directory';		yourself! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/7/2009 18:14'!addToMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: self! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/7/2009 20:40'!addToMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: self! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/7/2009 18:31'!mergeIntoMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: self! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/7/2009 20:41'!mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: self! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/7/2009 18:18'!removeFromMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: self! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/7/2009 20:41'!removeFromMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: self! !"Metacello-MC"!SystemOrganization addCategory: #'Metacello-Platform'!MetacelloPlatform subclass: #MetacelloSqueakPlatform	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Platform'!!MetacelloSqueakPlatform class methodsFor: 'initialize-release' stamp: 'dkh 10/12/2009 13:30'!initialize	"implmented to force initialize on load"	super initialize! !!MetacelloSqueakPlatform methodsFor: 'utilities' stamp: 'dkh 10/12/2009 13:26'!authorName	^Utilities authorInitials! !!MetacelloSqueakPlatform methodsFor: 'utilities' stamp: 'dkh 1/5/2011 16:46'!authorName: aString	^Utilities setAuthorInitials: aString! !!MetacelloSqueakPlatform methodsFor: 'reflection' stamp: 'dkh 1/5/2011 16:21'!copyClass: oldClass as: newName inCategory: newCategoryName	| copysName class newDefinition |	copysName := newName asSymbol.	copysName = oldClass name		ifTrue: [ ^ oldClass ].	(Smalltalk includesKey: copysName)		ifTrue: [ ^ self error: copysName , ' already exists' ].	newDefinition := oldClass definition copyReplaceAll: '#' , oldClass name asString with: '#' , copysName asString printString.	newDefinition := newDefinition		copyReplaceAll: 'category: ' , (SystemOrganization categoryOfElement: oldClass name) asString printString		with: 'category: ' , newCategoryName printString.	class := Compiler evaluate: newDefinition logged: true.	class class instanceVariableNames: oldClass class instanceVariablesString.	class copyAllCategoriesFrom: oldClass.	class class copyAllCategoriesFrom: oldClass class.	class category: newCategoryName.	^ class! !!MetacelloSqueakPlatform methodsFor: 'repository creation' stamp: 'dkh 12/29/2009 16:12'!createRepository: aRepositorySpec 	| type |	type := aRepositorySpec type.	type = 'ftp'		ifTrue: [| description headerSize index host directory |			description := aRepositorySpec description.			headerSize := 'ftp://' size.			index := description indexOf: $/ startingAt: headerSize + 1.			host := description copyFrom: headerSize + 1 to: index - 1.			directory := description copyFrom: index + 1 to: description size.			^ MCFtpRepository				host: host				directory: directory				user: aRepositorySpec username				password: aRepositorySpec password].	^ super createRepository: aRepositorySpec! !!MetacelloSqueakPlatform methodsFor: 'attributes' stamp: 'dkh 1/5/2011 15:36'!defaultPlatformAttributes	| attributes versionString |	attributes := OrderedCollection with: #squeakCommon with: #squeak.	Smalltalk		at: #SystemVersion		ifPresent: [:cl | 			versionString := cl current version.			(versionString beginsWith: 'Squeak3.10')				ifTrue: [attributes add: #'squeak3.10.x'].			(versionString beginsWith: 'Squeak4')				ifTrue: [attributes add: #'squeak4.x'.					(versionString beginsWith: 'Squeak4.1')						ifTrue: [attributes add: #'squeak4.1.x']						ifFalse: [(versionString beginsWith: 'Squeak4.2')								ifTrue: [attributes add: #'squeak4.2.x']]]].	^ attributes! !!MetacelloSqueakPlatform methodsFor: 'repository creation' stamp: 'dkh 12/29/2009 16:11'!extractTypeFromDescription: description 	(description beginsWith: 'ftp://')		ifTrue: [^ 'ftp'].	^ super extractTypeFromDescription: description! !!MetacelloSqueakPlatform methodsFor: 'reflection' stamp: 'dkh 1/5/2011 16:06'!globalNamed: globalName	^Smalltalk at: globalName! !!MetacelloSqueakPlatform methodsFor: 'reflection' stamp: 'dkh 1/5/2011 16:06'!globalNamed: globalName ifAbsent: absentBlock	^Smalltalk at: globalName ifAbsent: absentBlock! !!MetacelloSqueakPlatform methodsFor: 'utilities' stamp: 'dkh 10/12/2009 13:27'!timestamp	^Date today mmddyyyy, ' ',			((String streamContents: [:s | Time now print24: true on: s]) copyFrom: 1 to: 5)! !!BlockContext methodsFor: '*metacello-platform' stamp: 'dkh 2/5/2010 16:39'!setAuthorInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setAuthorWithBlock: self! !!BlockContext methodsFor: '*metacello-platform' stamp: 'dkh 2/5/2010 16:39'!setBlessingInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setBlessingWithBlock: self! !!BlockContext methodsFor: '*metacello-platform' stamp: 'dkh 2/5/2010 16:39'!setDescriptionInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setDescriptionWithBlock: self! !!BlockContext methodsFor: '*metacello-platform' stamp: 'dkh 2/5/2010 16:39'!setPackage: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setPackage: aString withBlock: self! !!BlockContext methodsFor: '*metacello-platform' stamp: 'dkh 2/5/2010 16:39'!setProject: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setProject: aString withBlock: self! !!BlockContext methodsFor: '*metacello-platform' stamp: 'dkh 2/5/2010 16:40'!setTimestampInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setTimestampWithBlock: self! !!BlockContext methodsFor: '*metacello-platform' stamp: 'dkh 2/5/2010 16:40'!valueSupplyingMetacelloAnswers: aListOfPairs	"evaluate the block using a list of questions / answers that might be called upon to	automatically respond to Object>>confirm: or FillInTheBlank requests"	^ [self value] 		on: ProvideAnswerNotification		do: 			[:notify | | answer caption |						caption := notify messageText withSeparatorsCompacted. "to remove new lines"			answer := aListOfPairs				detect: 					[:each | caption = each first or:						[(caption includesSubstring: each first caseSensitive: false) or:						[(each first match: caption) or:						[(String includesSelector: #matchesRegex:) and: 						[ [ caption matchesRegex: each first ] on: Error do: [:ignored | false ]]]]]]					ifNone: [nil].			answer				ifNotNil: [notify resume: answer second]				ifNil: 					[ | outerAnswer |					outerAnswer := ProvideAnswerNotification signal: notify messageText.					outerAnswer 						ifNil: [notify resume] 						ifNotNil: [notify resume: outerAnswer]]]! !"Metacello-Platform"!SystemOrganization addCategory: #ConfigurationOfGofer!Object subclass: #ConfigurationOfGofer	instanceVariableNames: 'project'	classVariableNames: 'LastVersionLoad'	poolDictionaries: ''	category: 'ConfigurationOfGofer'!!ConfigurationOfGofer class methodsFor: 'private' stamp: 'DaleHenrichs 1/25/2010 13:14'!bootstrapPackage: aString from: aPath 	| repository version |	repository := MCHttpRepository				location: aPath				user: ''				password: ''.	repository		versionReaderForFileNamed: aString , '.mcz'		do: [:reader | 			version := reader version.			version load.			version workingCopy repositoryGroup addRepository: repository]! !!ConfigurationOfGofer class methodsFor: 'development support' stamp: 'DaleHenrichs 1/14/2011 11:50'!compareVersions	"Compare previous version to development version"	"self compareVersions"	"Note: you need 1.0-beta.28 or later for the class MetacelloToolBox"	self ensureMetacello.	((Smalltalk at: #MetacelloToolBox) compareVersionsIn: self) inspect! !!ConfigurationOfGofer class methodsFor: 'development support' stamp: 'DaleHenrichs 1/11/2011 15:01'!createNewDevelopmentVersion	"Create a new development version using the #stable version as model."	"self createNewDevelopmentVersion"		"Note: you need 1.0-beta.28 or later for the class MetacelloToolBox"	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) createNewDevelopmentVersionIn: self description: ''! !!ConfigurationOfGofer class methodsFor: 'private' stamp: 'DaleHenrichs 1/25/2010 13:14'!ensureMetacello	"Bootstrap Gofer (if necessary), bootstrap ConfigurationOfMetacello (using old Gofer API), then load the latest 	version of Metacello itself."	Smalltalk at: #MetacelloProject ifAbsent: [		Smalltalk at: #Gofer ifAbsent: [			"Current version of Gofer from which to bootstrap - as of 1.0-beta.21"			self bootstrapPackage: 'Gofer-Core-lr.115' from: 'http://seaside.gemstone.com/ss/metacello' ].		Smalltalk at: #Gofer ifPresent: [:goferClass | | gofer |			gofer := goferClass new				url: 'http://seaside.gemstone.com/ss/metacello';				yourself.			[ gofer addPackage: 'ConfigurationOfMetacello' ] on: Warning do: [:ex | ex resume ].			gofer load ].		"load 'default' group of Metacello"		(Smalltalk at: #ConfigurationOfMetacello) perform: #load ]! !!ConfigurationOfGofer class methodsFor: 'metacello tool support' stamp: 'DaleHenrichs 1/25/2010 13:14'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfGofer class methodsFor: 'metacello tool support' stamp: 'DaleHenrichs 1/25/2010 13:14'!lastMetacelloVersionLoad	"Answer the last version loaded and the list of packages loaded for that version."	LastVersionLoad == nil ifTrue: [ LastVersionLoad := nil -> 'default' ].	^LastVersionLoad! !!ConfigurationOfGofer class methodsFor: 'loading' stamp: 'DaleHenrichs 1/25/2010 13:14'!load	"self load"	^self project latestVersion load! !!ConfigurationOfGofer class methodsFor: 'metacello tool support' stamp: 'DaleHenrichs 1/25/2010 13:14'!metacelloVersion: versionString loads: anArrayOrString	"Stash the last version loaded and the list of packages loaded for that version. The list	 of packages will be used by the tools when doing 'Load Package Version'"	LastVersionLoad := versionString -> anArrayOrString! !!ConfigurationOfGofer class methodsFor: 'accessing' stamp: 'DaleHenrichs 1/25/2010 13:14'!project	^self new project! !!ConfigurationOfGofer class methodsFor: 'development support' stamp: 'DaleHenrichs 12/06/2010 11:26'!updateToLatestPackageVersions: descriptionString	"Updates mcz file versions in current version"	"self updateToLatestPackageVersions: '- fixed a bug'"	"Note: you need 1.0-beta.28 or later for the class MetacelloToolBox"	self ensureMetacello.	((Smalltalk at: #MetacelloToolBox) updateToLatestPackageVersionsIn: self description: descriptionString) isEmpty		ifTrue: [ self inform: 'All specs up to date' ]! !!ConfigurationOfGofer methodsFor: 'baselines' stamp: 'DaleHenrichs 02/11/2010 10:21'!baseline100: spec 	<version: '1.0-baseline'>		spec for: #common do: [		spec blessing: #baseline.		spec 			package: 'Gofer-Core';			package: 'Gofer-Tests' with: [ spec requires: 'Gofer-Core' ].		spec			group: 'default' with: #('Core');			group: 'Core' with: #('Gofer-Core');			group: 'Tests' with: #('Gofer-Tests'). ].	spec for: #pharo do: [		spec 			repository: 'http://www.squeaksource.com/Pharo';			repository: 'http://seaside.gemstone.com/ss/metacello'. ].	spec for: #squeak do: [		spec repository: 'http://seaside.gemstone.com/ss/metacello'. ].	spec for: #gemstone do: [		spec repository: 'http://seaside.gemstone.com/ss/metacello'. ].! !!ConfigurationOfGofer methodsFor: 'baselines' stamp: 'DaleHenrichs 6/15/2010 10:47'!baseline1021: spec 	<version: '1.0.2.1-baseline'>		spec for: #common do: [		spec blessing: #baseline.		spec			repository: 'http://www.squeaksource.com/metacello';			repository: 'http://seaside.gemstone.com/ss/metacello'.		spec 			package: 'Gofer-Core';			package: 'Gofer-Tests' with: [ spec requires: 'Gofer-Core' ].		spec			group: 'default' with: #('Core');			group: 'Core' with: #('Gofer-Core');			group: 'Tests' with: #('Gofer-Tests'). ].! !!ConfigurationOfGofer methodsFor: 'baselines' stamp: 'dkh 06/15/2014 12:08'!baseline1051: spec  <version: '1.0.5.1-baseline'>  spec    for: #'common'    do: [       spec blessing: #'baseline'.      spec        package: 'Gofer-Core';        package: 'Gofer-Tests' with: [ spec requires: 'Gofer-Core' ].      spec        group: 'default' with: #('Core');        group: 'Core' with: #('Gofer-Core');        group: 'Tests' with: #('Gofer-Tests') ].  spec    for: #'pharo'    do: [ spec repository: 'http://www.squeaksource.com/Pharo' ].  spec    for: #'pharo1.0.x'    do: [       spec repository: 'http://seaside.gemtalksystems.com/ss/metacello'.      spec        package: 'Gofer-Core' with: 'Gofer-Core.pharo10';        package: 'Gofer-Tests' with: 'Gofer-Tests.pharo10' ].  spec    for: #'pharo1.1.x'    do: [       spec repository: 'http://seaside.gemtalksystems.com/ss/metacello'.      spec        package: 'Gofer-Core' with: 'Gofer-Core.pharo10';        package: 'Gofer-Tests' with: 'Gofer-Tests.pharo10' ].  spec    for: #'squeak'    do: [       spec        repository: 'http://smalltalkhub.com/mc/dkh/metacello/main';        repository: 'http://seaside.gemtalksystems.com/ss/metacello'.      spec        package: 'Gofer-Core' with: 'Gofer-Core.squeak';        package: 'Gofer-Tests' with: 'Gofer-Tests.squeak' ].  spec    for: #'gemstone'    do: [       spec repository: 'http://seaside.gemtalksystems.com/ss/metacello'.      spec        package: 'Gofer-Core' with: 'Gofer-Core.gemstone';        package: 'Gofer-Tests' with: 'Gofer-Tests.gemstone' ]! !!ConfigurationOfGofer methodsFor: 'baselines' stamp: 'dkh 06/30/2014 11:42'!baseline1052: spec  <version: '1.0.5.2-baseline'>  spec    for: #'common'    do: [       spec blessing: #'baseline'.      spec        package: 'Gofer-Core';        package: 'Gofer-Tests' with: [ spec requires: 'Gofer-Core' ].      spec        group: 'default' with: #('Core');        group: 'Core' with: #('Gofer-Core');        group: 'Tests' with: #('Gofer-Tests') ].  spec    for: #'pharo'    do: [ spec repository: 'http://www.squeaksource.com/Pharo' ].  spec    for: #'pharo1.0.x'    do: [       spec repository: 'http://seaside.gemtalksystems.com/ss/metacello'.      spec        package: 'Gofer-Core' with: 'Gofer-Core.pharo10';        package: 'Gofer-Tests' with: 'Gofer-Tests.pharo10' ].  spec    for: #'pharo1.1.x'    do: [       spec repository: 'http://seaside.gemstone.com/ss/metacello'.      spec        package: 'Gofer-Core' with: 'Gofer-Core.pharo10';        package: 'Gofer-Tests' with: 'Gofer-Tests.pharo10' ].  spec    for: #'squeak'    do: [       spec        repository: 'http://smalltalkhub.com/mc/dkh/metacello/main';        repository: 'http://seaside.gemtalksystems.com/ss/metacello'.      spec        package: 'Gofer-Core' with: 'Gofer-Core.squeak';        package: 'Gofer-Tests' with: 'Gofer-Tests.squeak' ].  spec    for: #'gemstone'    do: [       spec repository: 'http://seaside.gemtalksystems.com/ss/metacello'.      spec        package: 'Gofer-Core' with: 'Gofer-Core.gemstone';        package: 'Gofer-Tests' with: 'Gofer-Tests.gemstone' ]! !!ConfigurationOfGofer methodsFor: 'baselines' stamp: 'dkh 06/15/2014 12:07'!baseline105: spec  <version: '1.0.5-baseline'>  spec    for: #'common'    do: [       spec blessing: #'baseline'.      spec        package: 'Gofer-Core';        package: 'Gofer-Tests' with: [ spec requires: 'Gofer-Core' ].      spec        group: 'default' with: #('Core');        group: 'Core' with: #('Gofer-Core');        group: 'Tests' with: #('Gofer-Tests') ].  spec    for: #'pharo'    do: [ spec repository: 'http://www.squeaksource.com/Pharo' ].  spec    for: #'pharo1.0.x'    do: [       spec repository: 'http://seaside.gemtalksystems.com/ss/metacello'.      spec        package: 'Gofer-Core' with: 'Gofer-Core.pharo10';        package: 'Gofer-Tests' with: 'Gofer-Tests.pharo10' ].  spec    for: #'pharo1.1.x'    do: [       spec repository: 'http://seaside.gemtalksystems.com/ss/metacello'.      spec        package: 'Gofer-Core' with: 'Gofer-Core.pharo10';        package: 'Gofer-Tests' with: 'Gofer-Tests.pharo10' ].  spec    for: #'squeak'    do: [       spec repository: 'http://seaside.gemtalksystems.com/ss/metacello'.      spec        package: 'Gofer-Core' with: 'Gofer-Core.squeak';        package: 'Gofer-Tests' with: 'Gofer-Tests.squeak' ].  spec    for: #'gemstone'    do: [       spec repository: 'http://seaside.gemtalksystems.com/ss/metacello'.      spec package: 'Gofer-Tests' with: 'Gofer-Tests.gemstone' ]! !!ConfigurationOfGofer methodsFor: 'symbolic versions' stamp: 'dkh 6/7/2011 16:45'!development: spec	<symbolicVersion: #'development'>	spec for: #'common' version: #'notDefined'.! !!ConfigurationOfGofer methodsFor: 'accessing' stamp: 'DaleHenrichs 02/19/2010 12:41'!project	^ project ifNil: [ | constructor |		"Bootstrap Metacello if it is not already loaded"		self class ensureMetacello.		"Construct Metacello project"		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.		project := constructor project.		project loadType: #linear.		"use atomic load on GemStone to resolve some loading issues"		Smalltalk at: #SystemVersion ifAbsent: [ project loadType: #atomic ]. 		project ]! !!ConfigurationOfGofer methodsFor: 'symbolic versions' stamp: 'dkh 12/03/2014 14:18'!stable: spec  <symbolicVersion: #'stable'>  spec for: #'common' version: '1.0.5'.  spec for: #'gemstone' version: '1.0.5.4'.  spec for: #'squeak' version: '1.0.5.1'! !!ConfigurationOfGofer methodsFor: 'versions' stamp: 'DaleHenrichs 1/26/2010 09:58'!version100: spec 	<version: '1.0' imports: #('1.0-baseline') >		spec for: #common do: [		spec blessing: #release.		spec author: 'DaleHenrichs'.		spec timestamp: '1/25/2010 14:19'.		spec 			package: 'Gofer-Core' with: 'Gofer-Core-lr.116';			package: 'Gofer-Tests' with: 'Gofer-Tests-lr.115' ].	spec for: #pharo do: [].! !!ConfigurationOfGofer methodsFor: 'versions' stamp: 'DaleHenrichs 2/19/2010 11:48'!version101: spec	<version: '1.0.1' imports: #('1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- use MethodReference>>methodSymbol for portability'.		spec author: 'DaleHenrichs'.		spec timestamp: '02/11/10 10:22:48'.		spec 			package: 'Gofer-Core' with: 'Gofer-Core-DaleHenrichs.117';			package: 'Gofer-Tests' with: 'Gofer-Tests-lr.115'.].! !!ConfigurationOfGofer methodsFor: 'versions' stamp: 'DaleHenrichs 6/15/2010 12:05'!version1021: spec	<version: '1.0.2.1' imports: #('1.0.2.1-baseline' )>	spec for: #common do: [		spec blessing: #release.		spec description: '- add secondary repository'.		spec author: 'DaleHenrichs'.		spec timestamp: '6/15/2010 10:47'.		spec 			package: 'Gofer-Core' with: 'Gofer-Core-dkh.121';			package: 'Gofer-Tests' with: 'Gofer-Tests-lr.116'.].! !!ConfigurationOfGofer methodsFor: 'versions' stamp: 'DaleHenrichs 12/13/2010 18:10'!version1022: spec	<version: '1.0.2.2' imports: #('1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- fix a bug that prevented gofer from resolving packages in http://www.squeaksource.com/Swazoo'.		spec author: 'DaleHenrichs'.		spec timestamp: '12/13/2010 16:42'.		spec 			package: 'Gofer-Core' with: 'Gofer-Core-DaleHenrichs.122';			package: 'Gofer-Tests' with: 'Gofer-Tests-DaleHenrichs.117'.].! !!ConfigurationOfGofer methodsFor: 'versions' stamp: 'DaleHenrichs 3/23/2010 14:47'!version102: spec	<version: '1.0.2' imports: #('1.0-baseline' )>	spec for: #common do: [		spec blessing: #release.		spec description: '- pick up most recent gofer code  - updated class comments  - another comment fix  - added http://squeaksource.blueplane.jp/ as a well known repository  - repository priorities were used in the wrong order (thanks to Dale Henrichs)'.		spec author: 'DaleHenrichs'.		spec timestamp: '3/5/2010 09:32'.		spec 			package: 'Gofer-Core' with: 'Gofer-Core-dkh.121';			package: 'Gofer-Tests' with: 'Gofer-Tests-lr.116'.].! !!ConfigurationOfGofer methodsFor: 'versions' stamp: 'DaleHenrichs 5/14/2010 14:03'!version103: spec	<version: '1.0.3' imports: #('1.0-baseline' )>	spec for: #common do: [		spec blessing: #release.		spec description: '- pick up most recent gofer (5/14/2010 13:54)  - improved the method comments  - made parser more robust  - made tests run faster'.		spec author: 'DaleHenrichs'.		spec timestamp: '5/14/2010 14:03'.		spec 			package: 'Gofer-Core' with: 'Gofer-Core-StephaneDucasse.125';			package: 'Gofer-Tests' with: 'Gofer-Tests-MarcusDenker.124'.].	spec for: #gemstone do: [		spec blessing: #development.		spec description: 'not ported to GemStone, yet' ].! !!ConfigurationOfGofer methodsFor: 'versions' stamp: 'DaleHenrichs 11/19/2010 17:37'!version104: spec	<version: '1.0.4' imports: #('1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: 'match the package versions shipped in Pharo1.2a-12241'.		spec author: 'DaleHenrichs'.		spec timestamp: '11/19/2010 17:26'.		spec 			package: 'Gofer-Core' with: 'Gofer-Core-MarcusDenker.129';			package: 'Gofer-Tests' with: 'Gofer-Tests-StephaneDucasse.125'.].	spec for: #'gemstone' do: [		spec blessing: #'development'.		spec description: 'not ported to GemStone, yet'.].! !!ConfigurationOfGofer methodsFor: 'versions' stamp: 'dkh 10/20/2011 14:30'!version1051: spec	<version: '1.0.5.1' imports: #('1.0.5.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '1.0.5.1 (dkh.35) [GemStone]:- fix minor GemStone issues'.		spec author: 'dkh'.		spec timestamp: '10/11/2011 15:16'.		spec 			package: 'Gofer-Core' with: 'Gofer-Core-StephaneDucasse.133';			package: 'Gofer-Tests' with: 'Gofer-Tests-StephaneDucasse.129'. ].	spec for: #'pharo1.0.x' do: [		spec 			package: 'Gofer-Core' with: 'Gofer-Core.pharo10-dkh.135';			package: 'Gofer-Tests' with: 'Gofer-Tests.pharo10-dkh.131' ].	spec for: #'pharo1.1.x' do: [		spec 			package: 'Gofer-Core' with: 'Gofer-Core.pharo10-dkh.135';			package: 'Gofer-Tests' with: 'Gofer-Tests.pharo10-dkh.131' ].	spec for: #'squeak' do: [		spec 			package: 'Gofer-Core' with: 'Gofer-Core.squeak-dkh.135';			package: 'Gofer-Tests' with: 'Gofer-Tests.squeak-dkh.131'. ].	spec for: #'gemstone' do: [		spec  			package: 'Gofer-Core' with: 'Gofer-Core.gemstone-dkh.135';			package: 'Gofer-Tests' with: 'Gofer-Tests.gemstone-dkh.131'. ].! !!ConfigurationOfGofer methodsFor: 'versions' stamp: 'dkh 09/28/2014 13:47'!version1052: spec  <version: '1.0.5.2' imports: #('1.0.5.2-baseline')>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec        description:          '1.0.5.2 (dkh.40) [GemStone]:- change gemsource: to point to http://seaside.gemtalksystems.com/ss'.      spec author: 'dkh'.      spec timestamp: '6/30/2014 11:40'.      spec        package: 'Gofer-Core' with: 'Gofer-Core-StephaneDucasse.133';        package: 'Gofer-Tests' with: 'Gofer-Tests-StephaneDucasse.129' ].  spec    for: #'pharo1.0.x'    do: [       spec        package: 'Gofer-Core' with: 'Gofer-Core.pharo10-dkh.135';        package: 'Gofer-Tests' with: 'Gofer-Tests.pharo10-dkh.131' ].  spec    for: #'pharo1.1.x'    do: [       spec        package: 'Gofer-Core' with: 'Gofer-Core.pharo10-dkh.135';        package: 'Gofer-Tests' with: 'Gofer-Tests.pharo10-dkh.131' ].  spec    for: #'squeak'    do: [       spec        package: 'Gofer-Core' with: 'Gofer-Core.squeak-dkh.135';        package: 'Gofer-Tests' with: 'Gofer-Tests.squeak-dkh.131' ].  spec    for: #'gemstone'    do: [       spec        package: 'Gofer-Core' with: 'Gofer-Core.gemstone-dkh.136';        package: 'Gofer-Tests' with: 'Gofer-Tests.gemstone-dkh.131' ]! !!ConfigurationOfGofer methodsFor: 'versions' stamp: 'dkh 09/28/2014 13:50'!version1053: spec  <version: '1.0.5.3' imports: #('1.0.5.2-baseline')>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec        description:          'Gofer 1.0.5.3 (dkh.43)- fix Metacello Issue #227: Retry error reporting in MetacelloCommonMCSpecLoader>>retryingResolvePackageSpecReferences:gofer: should be improved  https://github.com/dalehenrich/metacello-work/issues/227'.      spec author: 'dkh'.      spec timestamp: '9/28/2014 13:45'.      spec        package: 'Gofer-Core' with: 'Gofer-Core-StephaneDucasse.133';        package: 'Gofer-Tests' with: 'Gofer-Tests-StephaneDucasse.129' ].  spec    for: #'pharo1.0.x'    do: [       spec        package: 'Gofer-Core' with: 'Gofer-Core.pharo10-dkh.135';        package: 'Gofer-Tests' with: 'Gofer-Tests.pharo10-dkh.131' ].  spec    for: #'pharo1.1.x'    do: [       spec        package: 'Gofer-Core' with: 'Gofer-Core.pharo10-dkh.135';        package: 'Gofer-Tests' with: 'Gofer-Tests.pharo10-dkh.131' ].  spec    for: #'squeak'    do: [       spec        package: 'Gofer-Core' with: 'Gofer-Core.squeak-dkh.135';        package: 'Gofer-Tests' with: 'Gofer-Tests.squeak-dkh.131' ].  spec    for: #'gemstone'    do: [       spec        package: 'Gofer-Core' with: 'Gofer-Core.gemstone-dkh.137';        package: 'Gofer-Tests' with: 'Gofer-Tests.gemstone-dkh.131' ]! !!ConfigurationOfGofer methodsFor: 'versions' stamp: 'dkh 12/03/2014 14:19'!version1054: spec  <version: '1.0.5.4' imports: #('1.0.5.2-baseline')>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec        description:          'Gofer 1.0.5.4 (dkh.45)- .mcz in repository can cripple Gofers ability to read files from a repo'.      spec author: 'dkh'.      spec timestamp: '12/3/2014 14:17'.      spec        package: 'Gofer-Core' with: 'Gofer-Core-StephaneDucasse.133';        package: 'Gofer-Tests' with: 'Gofer-Tests-StephaneDucasse.129' ].  spec    for: #'pharo1.0.x'    do: [       spec        package: 'Gofer-Core' with: 'Gofer-Core.pharo10-dkh.135';        package: 'Gofer-Tests' with: 'Gofer-Tests.pharo10-dkh.131' ].  spec    for: #'pharo1.1.x'    do: [       spec        package: 'Gofer-Core' with: 'Gofer-Core.pharo10-dkh.135';        package: 'Gofer-Tests' with: 'Gofer-Tests.pharo10-dkh.131' ].  spec    for: #'squeak'    do: [       spec        package: 'Gofer-Core' with: 'Gofer-Core.squeak-dkh.135';        package: 'Gofer-Tests' with: 'Gofer-Tests.squeak-dkh.131' ].  spec    for: #'gemstone'    do: [       spec        package: 'Gofer-Core' with: 'Gofer-Core.gemstone-dkh.138';        package: 'Gofer-Tests' with: 'Gofer-Tests.gemstone-dkh.131' ]! !!ConfigurationOfGofer methodsFor: 'versions' stamp: 'dkh 6/7/2011 16:45'!version105: spec	<version: '1.0.5' imports: #('1.0.5-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: 'match Pharo1.2.1 update: #12345- align branch naming conventions with rest of the world  Package { "." Branch } "-" Author "." Version- Issue 3682:	multiple undo/redo is broken in 1.2 because of Ocompletion. Part two. Thanks Alain Plantec.-  Issue 3660:	Revert incorrect Monticello branch naming support. Thanks lukas, julian and dale.1.0.5 (dkh.27):- add SystemOrganizer>>environment (Squeak only)- tweak tests to see errors plus add expectedFailure for revert ... Monticello bug in Squeak1.0.5 (dkh.29)- ported to GemStone ... tests green1.0.5 (dkh.32):- ported to Pharo1.0'.		spec author: 'DaleHenrichs'.		spec timestamp: '6/7/2011 15:27'.		spec 			package: 'Gofer-Core' with: 'Gofer-Core-StephaneDucasse.133';			package: 'Gofer-Tests' with: 'Gofer-Tests-StephaneDucasse.129'. ].	spec for: #'pharo1.0.x' do: [		spec 			package: 'Gofer-Core' with: 'Gofer-Core.pharo10-dkh.135';			package: 'Gofer-Tests' with: 'Gofer-Tests.pharo10-dkh.131' ].	spec for: #'pharo1.1.x' do: [		spec 			package: 'Gofer-Core' with: 'Gofer-Core.pharo10-dkh.135';			package: 'Gofer-Tests' with: 'Gofer-Tests.pharo10-dkh.131' ].	spec for: #'squeak' do: [		spec 			package: 'Gofer-Core' with: 'Gofer-Core.squeak-dkh.135';			package: 'Gofer-Tests' with: 'Gofer-Tests.squeak-dkh.131'. ].	spec for: #'gemstone' do: [		spec package: 'Gofer-Tests' with: 'Gofer-Tests.gemstone-DaleHenrichs.130'. ].! !"ConfigurationOfGofer"!GoferPackageReference subclass: #GoferConstraintReference	instanceVariableNames: 'constraintBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!!GoferConstraintReference commentStamp: 'lr 1/30/2010 14:37' prior: 33640544!A GoferPackageReference refers to the latest version of a Monticello package satisfying an additional constraint.!Object subclass: #Gofer	instanceVariableNames: 'references repositories errorBlock packageCacheRepository resolvedReferencesCache'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!!Gofer commentStamp: 'lr 1/30/2010 14:42' prior: 33633137!: Gofer, a person who runs errands. Origin 1960s: from go for, i.e. go and fetch.: ''The New Oxford American Dictionary''!! SynopsisGofer is a small tool on top of Monticello that loads, updates, merges, diffs, reverts, commits, recompiles and unloads groups of Monticello packages. Contrary to existing tools Gofer makes sure that these operations are performed as clean as possible:- Gofer treats packages from one or more repository in one operation.- Gofer works with fixed versions or tries to find the "latest" version using a given package name.- Gofer automatically assigns repositories to all packages, so that the other tools are ready to be used on individual packages.- Gofer makes sure that there is only one repository instance registered for a single physical location.- Gofer works with Monticello dependencies and uniformly treats them like the primary package.- Gofer prefers to work with faster repositories if there is a choice.- Gofer cleans up after Monticello, no empty class categories and no empty method protocols are to be expected.- Gofer supports operations to sync remote and local repositories with each other.!! InstallationGofer is included with the latest Pharo and GemStone distributions. To update to the latest version you can use Gofer itself:== Gofer upgradeIn case you are missing Gofer in your image, grab it from *http://source.lukas-renggli.ch/gofer.html*.!! DescriptionGofer is very simple by design, the basic useage scenario is always the same and consists of three steps:# You specify one or more Monticello repository URLs. You can do this using the methods ==url:==, ==url:username:password:== (HTTP, FTP), ==directory:==, or ==repository:== if you need full control. You might also use the convenience methods like ==squeaksource:==, ==wiresong:==, or ==gemsource:== for well known repositories. Additionally the following settings are available:#- Gofer implicitly declares the local package cache as a repository. To disable the local package cache use the method ==disablePackageCache==, to re-enable use ==enablePackageCache==.#- Gofer throws an error if a repository is not reachable. To silently ignore repository erros use the message ==disableRepositoryErrors==, to re-enable use ==enableRepositoryErrors==.# You specify one or more Monticello packages you want to work with, by adding them to the Gofer instance. Use ==version:== to add a specific version, or use ==package:== to add the "latest" version in the given repository. Furthermore there is ==package:constraint:== that allows you to further constraint the version to be loaded in a block passed in as the second argument.# You specify one or more actions to be performed on the specified packages:| ==load==	| Load the specified packages.| ==update==	| Update the specified packages.| ==merge==	| Merge the specified packages into their working copies.| ==localChanges==	| Answer the changes between the base version and the working copy.| ==browseLocalChanges==	| Browse the changes between the base version and the working copy.| ==remoteChanges==	| Answer the changes between the working copy and the remote changes.| ==browseRemoteChanges==	| Browse the changes between the working copy and the remote changes.| ==cleanup==	| Cleans the specified packages.| ==commit==	| Commit the modified specified packages.| ==commit:==	| Commit the modified specified packages with the given commit message.| ==revert==	| Revert the specified packages to the currently loaded version.| ==recompile==	| Recompile the specified packages.| ==reinitialize==	| Call the class side initializers on the specified packages.| ==unload==	| Unload the specified packages.| ==fetch==     | Download versions from remote repositories into the local cache.| ==push==      | Upload local versions from local cache into remote repositories.!! ExampleTo use Gofer to update to exact versions of the Kom Server, the 'latest' code of Seaside 2.8 and the 'latest' code of the Scriptaculous package that is committed by the author with the initials 'lr' one could evaluate:== Gofer new==     squeaksource: 'KomHttpServer';==     version: 'DynamicBindings-gc.7';==     version: 'KomServices-gc.19';==     version: 'KomHttpServer-gc.32';==     update.== Gofer new==     squeaksource: 'Seaside';==     package: 'Seaside2.8a';==     package: 'Scriptaculous' constraint: [ :version | version author = 'lr' ];==     load!Object subclass: #GoferReference	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!!GoferReference commentStamp: 'lr 1/30/2010 14:38' prior: 0!A GoferReference is an abstract superclass for various kinds of references to Monticello packages and versions.!GoferVersionReference subclass: #GoferResolvedReference	instanceVariableNames: 'repository'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!!GoferResolvedReference commentStamp: 'lr 1/30/2010 14:38' prior: 33641229!A GoferVersionReference refers to a specific version of a Monticello package in a particular repository. This class is the only one that can actually load the version, because it is the only one knowing where to find it.!Error subclass: #GoferRepositoryError	instanceVariableNames: 'repository'	classVariableNames: ''	poolDictionaries: ''	category: 'Gofer-Core'!!GoferRepositoryError commentStamp: 'lr 1/30/2010 14:39' prior: 0!A GoferRepositoryError is the error thrown when a repository cannot be accessed.!!GoferReinitialize methodsFor: 'running' stamp: 'DaleHenrichs 3/5/2010 09:25' prior: 33663606!execute: aWorkingCopy	aWorkingCopy packageInfo methods do: [ :each |		(each classIsMeta and: [ each methodSymbol = #initialize ])			ifTrue: [ each actualClass theNonMetaClass initialize ] ]! !!GoferConstraintReference methodsFor: 'private' stamp: 'lr 1/21/2010 00:17' prior: 33668438!matches: aResolvedReference	^ (super matches: aResolvedReference) and: [ constraintBlock value: aResolvedReference ]! !!GoferPackageReference methodsFor: 'private' stamp: 'lr 1/21/2010 00:16' prior: 33668634!matches: aResolvedReference	^ self packageName = aResolvedReference packageName! !!Gofer methodsFor: 'repositories-places' stamp: 'lr 2/7/2010 15:11'!blueplane: aString	self url: 'http://squeaksource.blueplane.jp/' , aString! !!Gofer methodsFor: 'repositories' stamp: 'lr 3/14/2010 21:13' prior: 33646164!directory: aDirectoryOrString	"Add a file-system repository at aDirectoryOrString."	| repository |	repository := (aDirectoryOrString isString and: [ aDirectoryOrString endsWith: '*' ])		ifTrue: [ 			((Smalltalk globals				at: #MCSubDirectoryRepository				ifAbsent: [ self error: aDirectoryOrString printString , ' is an unsupported repository type' ]) new)				directory: (FileDirectory on: aDirectoryOrString allButLast);				yourself ]		ifFalse: [ 			(MCDirectoryRepository new)				directory:						(aDirectoryOrString isString								ifTrue: [ FileDirectory on: aDirectoryOrString ]								ifFalse: [ aDirectoryOrString ]);				yourself ].	self repository: repository! !!Gofer methodsFor: 'references' stamp: 'lr 4/3/2010 09:56' prior: 33649178!package: aString	"Add the package aString to the receiver. aString is a package name as it appears in the Monticello Browser, something like 'Magritte-Seaside'. Gofer will try to resolve this name to an actual version in one of the configured repositories before doing something with the package. Gofer sorts all the versions in all the repositories according to branch name (versions without a branch are preferred), version number, author name and repository priority. The top hit of this sorted list is eventually going to be loaded and used."	references addLast: (GoferPackageReference name: aString)! !!Gofer methodsFor: 'references' stamp: 'lr 4/3/2010 09:56' prior: 33649364!package: aString constraint: aOneArgumentBlock	"Add the package aString to the receiver, but constraint the resulting versions further with aOneArgumentBlock. For details on the package, see #package:. The following example defines various constraints: 			aGofer package: 'Magritte-Seaside' constraint: [ :version |			version author = 'lr'				and: [ version branch = 'trial'				and: [ version versionNumber > 120 ] ] ]"	references addLast: (GoferConstraintReference name: aString constraint: aOneArgumentBlock)! !!Gofer methodsFor: 'repositories' stamp: 'lr 3/14/2010 21:13' prior: 33652832!url: anUrlString username: aUsernameString password: aPasswordString	"Add anUrlString as a repository for the following package operations."	| repository |	repository := (anUrlString beginsWith: 'ftp://')		ifTrue: [ 			(Smalltalk globals				at: #MCFtpRepository				ifAbsent: [ self error: anUrlString printString , ' is an unsupported repository type' ])				host: ((anUrlString allButFirst: 6) copyUpTo: $/)				directory: ((anUrlString allButFirst: 6) copyAfter: $/)				user: aUsernameString				password: aPasswordString ]		ifFalse: [ MCHttpRepository location: anUrlString user: aUsernameString password: aPasswordString ].	self repository: repository! !!Gofer methodsFor: 'references' stamp: 'lr 4/3/2010 09:52' prior: 33653578!version: aString	"Add the version aString to the receiver. aString is a version name as it appears in the Monticello Repository Browser, something like 'Magritte-Seaside-lr.334'. Gofer will try to resolve this name to one of the configured repositories before loading the code."	references addLast: (GoferVersionReference name: aString)! !!GoferReference methodsFor: 'private' stamp: 'lr 1/21/2010 00:16' prior: 33669541!matches: aResolvedReference	"Answer true if the receiver matches aResolvedReference."	self subclassResponsibility! !!GoferResolvedReference methodsFor: 'comparing' stamp: 'lr 3/5/2010 07:19' prior: 33671279!<= aResolvedReference	"Sort versions according to:		1. package name		2. branch name, list versions without branch last		3. version number		4. author name		5. repository priority"		self packageName = aResolvedReference packageName		ifFalse: [ ^ self packageName <= aResolvedReference packageName ].	self branch = aResolvedReference branch ifFalse: [ 		^ (self branch isEmpty or: [ aResolvedReference branch isEmpty ])			ifTrue: [ self branch size > aResolvedReference branch size ]			ifFalse: [ self branch <= aResolvedReference branch ] ].	self versionNumber = aResolvedReference versionNumber		ifFalse: [ ^ self versionNumber <= aResolvedReference versionNumber ].	self author = aResolvedReference author		ifFalse: [ ^ self author <= aResolvedReference author ].	self repository goferPriority = aResolvedReference repository goferPriority		ifFalse: [ ^ self repository goferPriority <= aResolvedReference repository goferPriority ].	^ true! !!GoferVersionReference methodsFor: 'private' stamp: 'lr 1/21/2010 00:17' prior: 33673279!matches: aResolvedReference	^ self name = aResolvedReference name! !!GoferVersionReference methodsFor: 'initialization' stamp: 'lr 2/6/2011 18:01' prior: 33673574!parseName: aString	| basicName |	basicName := aString last isDigit		ifTrue: [ aString ]		ifFalse: [ (aString copyUpToLast: $.) copyUpTo: $( ].	package := basicName copyUpToLast: $-.	(package includes: $.)		ifFalse: [ branch := '' ]		ifTrue: [			branch := package copyAfter: $..			package := package copyUpTo: $. ].	author := (basicName copyAfterLast: $-) copyUpToLast: $..	versionNumber := (basicName copyAfterLast: $-) copyAfterLast: $..	(versionNumber notEmpty and: [ versionNumber allSatisfy: [ :each | each isDigit ] ])		ifTrue: [ versionNumber := versionNumber asInteger ]		ifFalse: [ versionNumber := 0 ]! !!SystemOrganizer methodsFor: '*Gofer-Core-Accessing' stamp: 'dkh 4/18/2011 13:41'!environment	^Smalltalk! !!SystemOrganizer methodsFor: '*Gofer-Core-Accessing' stamp: 'sd 9/12/2010 19:12' prior: 33674477!goferClassesInCategory: category	^ (self listAtCategoryNamed: category) collect: [ :className | self environment at: className ]! !!GoferUnload methodsFor: 'private' stamp: 'lr 3/14/2010 21:13' prior: 33663864!defaultModel	^ (Smalltalk globals at: #MCMultiPackageLoader ifAbsent: [ MCPackageLoader ]) new! !!GoferUnload methodsFor: 'unloading' stamp: 'DaleHenrichs 3/5/2010 09:25' prior: 33664415!unloadClasses: aWorkingCopy	aWorkingCopy packageInfo methods do: [ :each |		(each classIsMeta and: [ each methodSymbol = #unload ])			ifTrue: [ each actualClass theNonMetaClass unload ] ]! !"Gofer-Core"!!MetacelloVersion methodsFor: 'printing' stamp: 'dkh 7/23/2013 07:28' prior: 34008047!printOn: aStream	| label vs |	 (#(structural broken) includes: self blessing) not		ifTrue: [ 			(vs := self versionStatus) == #somethingLoaded				ifTrue: [ aStream nextPutAll: '<>' ].			vs == #loadedMatchConstraints				ifTrue: [ aStream nextPutAll: '>=' ].			vs == #loadedToSpec				ifTrue: [ aStream nextPut: $~ ] ].	self versionNumber printOn: aStream.	self spec ~~ nil		ifTrue: [ 			(label := self spec projectLabel) isEmpty				ifFalse: [ aStream nextPutAll: ' [' , label , ']' ] ]! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 7/23/2013 14:57' prior: 34113656!excludeFromLatestVersion	^#( structural development broken baseline)! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 7/23/2013 14:25' prior: 34120812!sortedAndFilteredVersions		^(self map values asArray sort: [:a :b | a >= b ]) select: [:vrsn | (#( structural broken baseline) includes: vrsn blessing) not ].! !"Metacello-Core"!!MetacelloSqueakPlatform class methodsFor: 'initialize-release' stamp: 'dkh 6/12/2012 10:18:46.076' prior: 34400456!initialize	"implmented to force initialize on load"	super initialize! !!MetacelloSqueakPlatform methodsFor: 'utilities' stamp: 'dkh 6/12/2012 10:18:46.076' prior: 34400611!authorName	^Utilities authorInitials! !!MetacelloSqueakPlatform methodsFor: 'utilities' stamp: 'dkh 6/12/2012 10:18:46.076' prior: 34400731!authorName: aString	^Utilities setAuthorInitials: aString! !!MetacelloSqueakPlatform methodsFor: 'notification' stamp: 'dkh 6/12/2012 10:18:46.076'!collection: aCollection do: aBlock displaying: aString	self bypassProgressBars ifTrue: [ ^super collection: aCollection do: aBlock displaying: aString ].	aCollection 		do: aBlock		displayingProgress: aString! !!MetacelloSqueakPlatform methodsFor: 'reflection' stamp: 'dkh 6/12/2012 10:18:46.076' prior: 34400873!copyClass: oldClass as: newName inCategory: newCategoryName	| copysName class newDefinition |	copysName := newName asSymbol.	copysName = oldClass name		ifTrue: [ ^ oldClass ].	(Smalltalk includesKey: copysName)		ifTrue: [ ^ self error: copysName , ' already exists' ].	newDefinition := oldClass definition copyReplaceAll: '#' , oldClass name asString with: '#' , copysName asString printString.	newDefinition := newDefinition		copyReplaceAll: 'category: ' , (SystemOrganization categoryOfElement: oldClass name) asString printString		with: 'category: ' , newCategoryName printString.	class := Compiler evaluate: newDefinition logged: true.	class class instanceVariableNames: oldClass class instanceVariablesString.	class copyAllCategoriesFrom: oldClass.	class class copyAllCategoriesFrom: oldClass class.	class category: newCategoryName.	^ class! !!MetacelloSqueakPlatform methodsFor: 'repository creation' stamp: 'dkh 6/12/2012 10:18:46.076' prior: 34401828!createRepository: aRepositorySpec 	| type |	type := aRepositorySpec type.	type = 'ftp'		ifTrue: [| description headerSize index host directory |			description := aRepositorySpec description.			headerSize := 'ftp://' size.			index := description indexOf: $/ startingAt: headerSize + 1.			host := description copyFrom: headerSize + 1 to: index - 1.			directory := description copyFrom: index + 1 to: description size.			^ MCFtpRepository				host: host				directory: directory				user: aRepositorySpec username				password: aRepositorySpec password].	^ super createRepository: aRepositorySpec! !!MetacelloSqueakPlatform methodsFor: 'attributes' stamp: 'dkh 3/21/2013 14:01' prior: 34402515!defaultPlatformAttributes	| attributes versionString |	attributes := OrderedCollection with: #squeakCommon with: #squeak.	Smalltalk		at: #SystemVersion		ifPresent: [:cl | 			versionString := cl current version.			(versionString beginsWith: 'Squeak3.10')				ifTrue: [attributes add: #'squeak3.10.x'].			(versionString beginsWith: 'Squeak4')				ifTrue: [attributes add: #'squeak4.x'.					(versionString beginsWith: 'Squeak4.1')						ifTrue: [attributes add: #'squeak4.1.x']						ifFalse: [(versionString beginsWith: 'Squeak4.2')								ifTrue: [attributes add: #'squeak4.2.x']								ifFalse: [(versionString beginsWith: 'Squeak4.3')									ifTrue: [attributes add: #'squeak4.3.x']									ifFalse: [(versionString beginsWith: 'Squeak4.4')										ifTrue: [attributes add: #'squeak4.4.x']											ifFalse: [(versionString beginsWith: 'Squeak4.5')												ifTrue: [attributes add: #'squeak4.5.x']]]]]]].	^ attributes! !!MetacelloSqueakPlatform methodsFor: 'notification' stamp: 'dkh 6/12/2012 10:18:46.076'!do: aBlock displaying: aString	self bypassProgressBars ifTrue: [ ^super do: aBlock displaying: aString ].	aString		displayProgressAt: Sensor cursorPoint		from: 0 to: 2		during: [:bar |			bar value: 1.			aBlock value.			bar value: 2 ]! !!MetacelloSqueakPlatform methodsFor: 'github support' stamp: 'dkh 6/12/2012 10:18:46.076'!downloadFile: url to: outputFileName    "download from <url> into <outputFileName>"    | in out err proc archive zipfile |    in := (' -L ' , url) readStream.    out := FileStream forceNewFileNamed: outputFileName.    err := FileStream forceNewFileNamed: '/tmp/curl.err'.    proc := OSProcess thisOSProcess        forkJob: '/usr/bin/curl'        arguments:            {'-L'.            url}        environment: nil        descriptors: (Array with: nil with: out with: err).    proc ifNil: [ OSProcess noAccessorAvailable ].    [ proc isRunning ] whileTrue: [ (Delay forMilliseconds: 100) wait ].    out close.    err close.    archive := ZipArchive new.    zipfile := FileDirectory on: outputFileName.    zipfile containingDirectory readOnlyFileNamed: zipfile localName do: [ :fileStream | archive readFrom: fileStream ].    ^ archive! !!MetacelloSqueakPlatform methodsFor: 'github support' stamp: 'dkh 6/12/2012 10:18:46.076'!extractRepositoryFrom: zipFile to: directory    "unzip <zipFile> into <directory>"    | out err proc errorMessage |    out := FileStream forceNewFileNamed: '/tmp/zip.out'.    err := FileStream forceNewFileNamed: '/tmp/zip.err'.    errorMessage := ''.    [     proc := OSProcess thisOSProcess        forkJob: '/usr/bin/unzip'        arguments:            {'-u'.            zipFile.            '-d'.            directory}        environment: nil        descriptors: (Array with: nil with: out with: err).    proc ifNil: [ self noAccessorAvailable ].    [ proc isRunning ] whileTrue: [ (Delay forMilliseconds: 100) wait ] ]        ensure: [             out close.            err close ].    FileStream        fileNamed: '/tmp/zip.err'        do: [ :fileStream |             (errorMessage := fileStream contentsOfEntireFile) notEmpty                ifTrue: [ self error: 'unzip failure: ' , errorMessage printString ] ]! !!MetacelloSqueakPlatform methodsFor: 'repository creation' stamp: 'dkh 6/12/2012 10:18:46.076' prior: 34403215!extractTypeFromDescription: description 	(description beginsWith: 'ftp://')		ifTrue: [^ 'ftp'].	^ super extractTypeFromDescription: description! !!MetacelloSqueakPlatform methodsFor: 'reflection' stamp: 'dkh 6/12/2012 10:18:46.076' prior: 34403444!globalNamed: globalName	^Smalltalk at: globalName! !!MetacelloSqueakPlatform methodsFor: 'reflection' stamp: 'dkh 6/12/2012 10:18:46.076' prior: 34403578!globalNamed: globalName ifAbsent: absentBlock	^Smalltalk at: globalName ifAbsent: absentBlock! !!MetacelloSqueakPlatform methodsFor: 'utilities' stamp: 'dkh 6/12/2012 10:18:46.076' prior: 34403757!timestamp	^Date today mmddyyyy, ' ',			((String streamContents: [:s | Time now print24: true on: s]) copyFrom: 1 to: 5)! !!BlockContext methodsFor: '*metacello-platform' stamp: 'dkh 6/12/2012 10:18:46.076' prior: 34403959!setAuthorInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setAuthorWithBlock: self! !!BlockContext methodsFor: '*metacello-platform' stamp: 'dkh 6/12/2012 10:18:46.076' prior: 34404128!setBlessingInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setBlessingWithBlock: self! !!BlockContext methodsFor: '*metacello-platform' stamp: 'dkh 6/12/2012 10:18:46.076' prior: 34404301!setDescriptionInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setDescriptionWithBlock: self! !!BlockContext methodsFor: '*metacello-platform' stamp: 'dkh 6/12/2012 10:18:46.076' prior: 34404480!setPackage: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setPackage: aString withBlock: self! !!BlockContext methodsFor: '*metacello-platform' stamp: 'dkh 6/12/2012 10:18:46.076' prior: 34404675!setProject: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setProject: aString withBlock: self! !!BlockContext methodsFor: '*metacello-platform' stamp: 'dkh 6/12/2012 10:18:46.076' prior: 34404870!setTimestampInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setTimestampWithBlock: self! !!BlockContext methodsFor: '*metacello-platform' stamp: 'dkh 6/12/2012 10:18:46.076' prior: 34405045!valueSupplyingMetacelloAnswers: aListOfPairs	"evaluate the block using a list of questions / answers that might be called upon to	automatically respond to Object>>confirm: or FillInTheBlank requests"	^ [self value] 		on: ProvideAnswerNotification		do: 			[:notify | | answer caption |						caption := notify messageText withSeparatorsCompacted. "to remove new lines"			answer := aListOfPairs				detect: 					[:each | caption = each first or:						[(caption includesSubstring: each first caseSensitive: false) or:						[(each first match: caption) or:						[(String includesSelector: #matchesRegex:) and: 						[ [ caption matchesRegex: each first ] on: Error do: [:ignored | false ]]]]]]					ifNone: [nil].			answer				ifNotNil: [notify resume: answer second]				ifNil: 					[ | outerAnswer |					outerAnswer := ProvideAnswerNotification signal: notify messageText.					outerAnswer 						ifNil: [notify resume] 						ifNotNil: [notify resume: outerAnswer]]]! !!MCFtpRepository methodsFor: '*metacello-platform' stamp: 'dkh 6/12/2012 10:18:46.076'!asRepositorySpecFor: aMetacelloMCProject	| dir |	dir := directory.	(directory at: 1) = $/		ifFalse: [ dir := '/', dir ].	^(aMetacelloMCProject repositorySpec)		description:  'ftp://', host, dir;	 	type: 'ftp';		username: user;		password: password;		yourself! !!MCDictionaryRepository methodsFor: '*metacello-platform' stamp: 'dkh 6/12/2012 10:18:46.076'!possiblyNewerVersionsOfAnyOf: versionNames 	^#()! !"Metacello-Platform"!SystemOrganization addCategory: #'MonticelloFileTree-Core'!MCWriter subclass: #MCFileTreeAbstractStWriter	instanceVariableNames: 'stWriter initializers orderedClassNames orderedTraitNames'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!MCFileTreeAbstractStWriter subclass: #MCFileTreeStSnapshotWriter	instanceVariableNames: 'classDefinitions traitDefinitions classTraitDefinitions methodDefinitions'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!MCFileTreeStSnapshotWriter subclass: #MCFileTreeStCypressWriter	instanceVariableNames: 'fileStream'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!MCFileTreeStCypressWriter class	instanceVariableNames: 'specials'!MCFileTreeAbstractStWriter subclass: #MCFileTreeStWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!MCDirectoryRepository subclass: #MCFileTreeRepository	instanceVariableNames: 'readonly repositoryProperties versionNameToFileNameMap'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!MCFileTreeRepository class	instanceVariableNames: 'defaultPackageExtension defaultPropertyFileExtension'!MCMczReader subclass: #MCFileTreeAbstractReader	instanceVariableNames: 'packageDirectory packageProperties'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!MCFileTreeAbstractReader subclass: #MCFileTreeStReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!MCFileTreeAbstractReader subclass: #MCFileTreeStSnapshotReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!MCFileTreeStSnapshotReader subclass: #MCFileTreeStCypressReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!MCStWriter subclass: #MCFileTreePackageStructureStWriter	instanceVariableNames: 'initializers'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!Object subclass: #MCFileTreeFileUtils	instanceVariableNames: ''	classVariableNames: 'Current'	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!Object subclass: #MCFileTreeJsonParser	instanceVariableNames: 'stream'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!MCMczWriter subclass: #MCFileTreeWriter	instanceVariableNames: 'directory packageFileDirectory cachedPackageFileDirectoryEntries'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!!MCFileTreeAbstractStWriter class methodsFor: 'accessing' stamp: 'dkh 4/5/2012 11:15:15'!monticelloMetaDirName    ^ '.'! !!MCFileTreeAbstractStWriter class methodsFor: 'writing' stamp: 'dkh 4/5/2012 11:15:15'!on: aStream    MCFileTreePackageStructureStWriter useCypressWriter        ifTrue: [ ^ MCFileTreeStCypressWriter new stream: aStream ].    ^ (MCFileTreePackageStructureStWriter useSnapShotWriter        ifTrue: [ MCFileTreeStSnapshotWriter ]        ifFalse: [ MCFileTreeStWriter ]) new stream: aStream! !!MCFileTreeAbstractStWriter class methodsFor: 'accessing' stamp: 'dkh 4/5/2012 11:15:15'!readerClass	^ MCStReader! !!MCFileTreeAbstractStWriter methodsFor: 'private' stamp: 'dkh 4/5/2012 11:15:15'!directoryForDirectoryNamed: directoryNameOrPath    ^ directoryNameOrPath = '.'        ifTrue: [ stream packageFileDirectory ]        ifFalse: [ stream subPackageFileDirectoryFor: directoryNameOrPath ]! !!MCFileTreeAbstractStWriter methodsFor: 'private' stamp: 'dkh 4/5/2012 11:15:15'!fileNameForSelector: selector    ^ (selector == #'/'        ifTrue: [ 'encoded slash' ]        ifFalse: [             (selector includes: $/)                ifTrue: [ 'encoded' , selector copyReplaceAll: '/' with: ' slash ' ]                ifFalse: [ selector ] ]) asString! !!MCFileTreeAbstractStWriter methodsFor: 'accessing' stamp: 'dkh 08/10/2012 02:55:31'!fileUtils    ^ MCFileTreeFileUtils current! !!MCFileTreeAbstractStWriter methodsFor: 'initialize-release' stamp: 'topa 7/22/2013 00:13'!initialize    stWriter := MCFileTreePackageStructureStWriter new        initializers: (initializers := Set new);        yourself.    orderedClassNames := OrderedCollection new.    orderedTraitNames := OrderedCollection new.! !!MCFileTreeAbstractStWriter methodsFor: 'private' stamp: 'dkh 4/5/2012 11:15:15'!monticelloMetaDirName    ^ self class monticelloMetaDirName! !!MCFileTreeAbstractStWriter methodsFor: 'private' stamp: 'dkh 07/07/2013 22:12'!repository  ^ stream repository! !!MCFileTreeAbstractStWriter methodsFor: 'private' stamp: 'dkh 4/5/2012 11:15:15'!setFileStream: file    stWriter stream: file! !!MCFileTreeAbstractStWriter methodsFor: 'visiting' stamp: 'dkh 4/5/2012 11:15:15'!visitClassDefinition: definition    self subclassResponsibility! !!MCFileTreeAbstractStWriter methodsFor: 'visiting' stamp: 'topa 7/22/2013 14:35'!visitClassTraitDefinition: definition    self subclassResponsibility! !!MCFileTreeAbstractStWriter methodsFor: 'visiting' stamp: 'dkh 4/5/2012 11:15:15'!visitMetaclassDefinition: definition    "handled by class definition"! !!MCFileTreeAbstractStWriter methodsFor: 'visiting' stamp: 'dkh 4/5/2012 11:15:15'!visitMethodDefinition: definition    self subclassResponsibility! !!MCFileTreeAbstractStWriter methodsFor: 'visiting' stamp: 'dkh 4/5/2012 11:15:15'!visitOrganizationDefinition: defintion    self        writeInDirectoryName: self monticelloMetaDirName        fileName: 'categories'        extension: '.st'        visit: [ defintion categories do: [ :cat | stWriter writeCategory: cat ] ]! !!MCFileTreeAbstractStWriter methodsFor: 'visiting' stamp: 'topa 8/29/2013 21:09'!visitScriptDefinition: definition    self        writeInDirectoryName: self monticelloMetaDirName        fileName: definition scriptSelector asString        extension: '.st'        visit: [ stWriter writeScriptDefinition: definition ]! !!MCFileTreeAbstractStWriter methodsFor: 'visiting' stamp: 'topa 7/22/2013 00:05'!visitTraitDefinition: definition    self subclassResponsibility! !!MCFileTreeAbstractStWriter methodsFor: 'initialize-release' stamp: 'dkh 4/5/2012 11:15:15'!writeBasicDefinitions: aCollection    "the correct initialization order is unknown if some classes are missing in the image"    self writePropertiesFile.    stWriter acceptVisitor: self forDefinitions: aCollection.    self writeInitializers! !!MCFileTreeAbstractStWriter methodsFor: 'writing' stamp: 'topa 7/22/2013 13:55'!writeClassDefinition: definition    stWriter writeClassDefinition: definition.    (definition hasClassInstanceVariables or: [definition hasClassTraitComposition])        ifTrue: [ stWriter writeMetaclassDefinition: definition ].    definition hasComment        ifTrue: [ stWriter writeClassComment: definition ]! !!MCFileTreeAbstractStWriter methodsFor: 'writing' stamp: 'topa 7/22/2013 13:26'!writeClassTraitDefinition: definition    stWriter visitClassTraitDefinition: definition.! !!MCFileTreeAbstractStWriter methodsFor: 'initialize-release' stamp: 'dkh 4/5/2012 11:15:15'!writeDefinitions: aCollection    "the correct initialization order is unknown if some classes are missing in the image"    self writeBasicDefinitions: aCollection! !!MCFileTreeAbstractStWriter methodsFor: 'visiting' stamp: 'dkh 04/07/2012 10:32'!writeInDirectoryName: directoryNameOrPath fileName: fileName extension: ext visit: visitBlock    | directory |    directory := self directoryForDirectoryNamed: directoryNameOrPath.    self fileUtils        writeStreamFor: fileName , ext        in: directory        do: [ :fileStream |             fileStream lineEndConvention: #'lf'.            self setFileStream: fileStream.            visitBlock value ]! !!MCFileTreeAbstractStWriter methodsFor: 'initialize-release' stamp: 'dkh 4/5/2012 11:15:15'!writeInitializers    self        writeInDirectoryName: self monticelloMetaDirName        fileName: 'initializers'        extension: '.st'        visit: [             stWriter                writePresentInitializers;                writeAbsentInitializers ]! !!MCFileTreeAbstractStWriter methodsFor: 'writing' stamp: 'dkh 4/5/2012 11:15:15'!writeMethodDefinition: definition    stWriter visitMethodDefinition: definition! !!MCFileTreeAbstractStWriter methodsFor: 'initialize-release' stamp: 'dkh 4/5/2012 11:15:15'!writePropertiesFile    self        writeInDirectoryName: '.'        fileName: ''        extension: '.filetree'        visit: [ stWriter writeProperties ]! !!MCFileTreeAbstractStWriter methodsFor: 'writing' stamp: 'topa 7/22/2013 00:16'!writeTraitDefinition: definition    stWriter writeClassDefinition: definition.    definition hasComment         ifTrue: [stWriter writeClassComment: definition].! !!MCFileTreeStCypressWriter class methodsFor: 'accessing' stamp: 'dkh 9/8/2013 07:16:04'!fileNameForSelector: selector  ^ (selector includes: $:)    ifTrue: [       selector        collect: [ :each |           each = $:            ifTrue: [ $. ]            ifFalse: [ each ] ] ]    ifFalse: [       (self specials includes: selector first)        ifFalse: [ selector ]        ifTrue: [           | output specials |          specials := self specials.          output := String new writeStream.          output nextPut: $^.          selector            do: [ :each |               output                nextPutAll:                  ((specials includes: each)                    ifTrue: [ specials at: each ]                    ifFalse: [ each asString ]) ]            separatedBy: [ output nextPut: $. ].          output contents ] ]! !!MCFileTreeStCypressWriter class methodsFor: 'private' stamp: 'PeterMcLain 10/02/2012 14:47'!initializeSpecials    | map |    map := Dictionary new.    map        at: $+ put: 'plus';        at: $- put: 'minus';        at: $= put: 'equals';        at: $< put: 'less';        at: $> put: 'more';        at: $% put: 'percent';        at: $& put: 'and';        at: $| put: 'pipe';        at: $* put: 'star';        at: $/ put: 'slash';        at: $\ put: 'backslash';        at: $~ put: 'tilde';        at: $? put: 'wat';        at: $, put: 'comma';        at: $@ put: 'at'.    map keys do: [ :key | map at: (map at: key) put: key ].    ^ map! !!MCFileTreeStCypressWriter class methodsFor: 'accessing' stamp: 'dkh 4/4/2012 15:05'!monticelloMetaDirName    ^ 'monticello.meta'! !!MCFileTreeStCypressWriter class methodsFor: 'accessing' stamp: 'dkh 4/4/2012 11:27'!specials    ^ specials ifNil: [ specials := self initializeSpecials ]! !!MCFileTreeStCypressWriter methodsFor: 'private' stamp: 'dkh 02/13/2013 17:04'!fileNameForSelector: selector  ^ self class fileNameForSelector: selector! !!MCFileTreeStCypressWriter methodsFor: 'private' stamp: 'dkh 08/08/2013 18:37'!fileNameMapFor: aMethodDefinitionCollection  "https://github.com/dalehenrich/filetree/issues/92"  "answer a dictionary that maps each definition selector to a filename that is guaranteed unique on case insensitive file systems.  Segregate instance and class side methods. Key is true for class method map, false for instance method map"  | map filenameMetaMap |  map := Dictionary new.  aMethodDefinitionCollection    do: [ :mDef |       | sel col metaKey methMap |      "sort into bins by lowercase selector. "      metaKey := mDef classIsMeta.      methMap := map        at: metaKey        ifAbsent: [ map at: metaKey put: Dictionary new ].      sel := mDef selector asLowercase.      col := methMap        at: sel        ifAbsent: [ methMap at: sel put: OrderedCollection new ].      col add: mDef ].  filenameMetaMap := Dictionary new.  map    keysAndValuesDo: [ :metaKey :methMap |       | filenameMap |      filenameMap := filenameMetaMap        at: metaKey        ifAbsent: [ filenameMetaMap at: metaKey put: Dictionary new ].      methMap values        do: [ :col |           | selector sortedCol |          col size = 1            ifTrue: [               | def |              "no need to distinguish filename"              def := col at: 1.              filenameMap                at: def selector                put: (self fileNameForSelector: def selector) ]            ifFalse: [               "tack on postfix to guarantee  file names are uniique on case insensitive file systems"              sortedCol := col sorted: [ :a :b | a name <= b name ].              1 to: sortedCol size do: [ :index |                 | def filename |                def := sortedCol at: index.                filename := self fileNameForSelector: def selector.                filename := filename , '..' , index printString.                filenameMap at: def selector put: filename ] ] ] ].  ^ filenameMetaMap! !!MCFileTreeStCypressWriter methodsFor: 'initialize-release' stamp: 'dkh 07/07/2013 22:15'!propertyFileExtension  ^ self repository propertyFileExtension! !!MCFileTreeStCypressWriter methodsFor: 'private' stamp: 'dkh 4/4/2012 14:01'!setFileStream: aStream    super setFileStream: aStream.    fileStream := aStream! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'dkh 03/22/2013 11:30'!writeClassComment: definition    fileStream nextPutAll: definition comment withUnixLineEndings! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'dkh 03/22/2013 13:51'!writeClassDefinition: definition    | properties |    properties := Dictionary new.    properties at: 'name' put: definition className.    properties at: 'super' put: definition superclassName.    definition traitCompositionString        ifNotNil: [ :property |             "Issue #48: https://github.com/dalehenrich/filetree/issues/48"            property ~= '{}'                ifTrue: [ properties at: 'traitcomposition' put: property ] ].    definition classTraitCompositionString        ifNotNil: [ :property |             "Issue #48: https://github.com/dalehenrich/filetree/issues/48"            property ~= '{}'                ifTrue: [ properties at: 'classtraitcomposition' put: property ] ].    properties at: 'category' put: definition category.    properties at: 'instvars' put: definition instVarNames asArray.    properties at: 'classvars' put: definition classVarNames asArray.    properties at: 'pools' put: definition poolDictionaries asArray.    properties at: 'classinstvars' put: definition classInstVarNames asArray.    properties at: 'type' put: definition type asString.    properties at: 'commentStamp' put: definition commentStamp.    properties writeCypressJsonOn: fileStream! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'dkh 07/07/2013 22:13'!writeClassDefinition: definition to: classPath  self    writeInDirectoryName: classPath    fileName: 'README'    extension: '.md'    visit: [ self writeClassComment: definition ].  self    writeInDirectoryName: classPath    fileName: 'properties'    extension: self propertyFileExtension    visit: [ self writeClassDefinition: definition ].  self    writeInDirectoryName: classPath    fileName: 'methodProperties'    extension: self propertyFileExtension    visit: [       self        writeMethodProperties:          (self methodDefinitions at: definition className ifAbsent: [ #() ]) ]! !!MCFileTreeStCypressWriter methodsFor: 'initialize-release' stamp: '08/08/2013 16:08'!writeDefinitions: aCollection  | classDirExtension extensionClasses extensionMethodDefinitions extensionMethodMap methodHolders |  self writeBasicDefinitions: aCollection.  extensionClasses := OrderedCollection new.  extensionMethodDefinitions := OrderedCollection new.  methodHolders := self classDefinitions, self traitDefinitions.  self methodDefinitions    keysAndValuesDo: [ :className :extensionMethods |       methodHolders        at: className        ifAbsent: [           extensionClasses add: className.          extensionMethodDefinitions addAll: extensionMethods ] ].  extensionClasses    do: [ :className | self methodDefinitions removeKey: className ].    self writeMethodHolderDefinitions: self traitDefinitions extension: '.trait' to: '' do: [ :definition :classPath |	self writeTraitDefinition: definition to: classPath. ].  self    writeMethodHolderDefinitions: self classDefinitions    extension: '.class'    to: ''    do: [ :definition :classPath | self writeClassDefinition: definition to: classPath ].  classDirExtension := '.extension'.  extensionMethodMap := Dictionary new.  extensionMethodDefinitions    do: [ :methodDefinition |       | classPath methodPath |      (extensionMethodMap        at: methodDefinition className        ifAbsent: [ extensionMethodMap at: methodDefinition className put: OrderedCollection new ])        add: methodDefinition.      classPath := methodDefinition className , classDirExtension        , self fileUtils pathNameDelimiter asString.      self writeExtensionClassDefinition: methodDefinition to: classPath ].  extensionMethodMap    keysAndValuesDo: [ :className :classMethodDefinitions |       | classPath filenameMetaMap |      filenameMetaMap := self fileNameMapFor: classMethodDefinitions.      classMethodDefinitions        do: [ :methodDefinition |           | filename methodPath |          filename := (filenameMetaMap at: methodDefinition classIsMeta)            at: methodDefinition selector.          classPath := methodDefinition className , classDirExtension            , self fileUtils pathNameDelimiter asString.          methodPath := classPath            ,              (methodDefinition classIsMeta                ifTrue: [ 'class' ]                ifFalse: [ 'instance' ])            , self fileUtils pathNameDelimiter asString.          self            writeMethodDefinition: methodDefinition            to: methodPath            filename: filename ].      classPath := className , classDirExtension        , self fileUtils pathNameDelimiter asString.      self        writeInDirectoryName: classPath        fileName: 'methodProperties'        extension: self propertyFileExtension        visit: [ self writeMethodProperties: classMethodDefinitions ] ]! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'dkh 4/4/2012 17:52'!writeExtensionClassDefinition: definition    | properties |    properties := Dictionary new.    properties at: 'name' put: definition className.    properties writeCypressJsonOn: fileStream! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'dkh 07/07/2013 22:14'!writeExtensionClassDefinition: definition to: classPath  self    writeInDirectoryName: classPath    fileName: 'properties'    extension: self propertyFileExtension    visit: [ self writeExtensionClassDefinition: definition ]! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'dkh 03/22/2013 11:30'!writeMethodDefinition: definition    fileStream        nextPutAll: definition category;        lf;        nextPutAll: definition source withUnixLineEndings! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'dkh 07/18/2013 17:01'!writeMethodDefinition: methodDefinition to: methodPath  self shouldNotImplement! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'dkh 07/18/2013 16:34'!writeMethodDefinition: methodDefinition to: methodPath filename: filename  self    writeInDirectoryName: methodPath    fileName: filename    extension: '.st'    visit: [ self writeMethodDefinition: methodDefinition ]! !!MCFileTreeStCypressWriter methodsFor: 'initialize-release' stamp: 'dkh 6/12/2012 17:33:23'!writeMethodProperties: classMethodDefinitions    "Issue 33: https://github.com/dalehenrich/filetree/issues/33"    | properties classMethodsMap instanceMethodMap |    properties := Dictionary new.    properties at: 'class' put: (classMethodsMap := Dictionary new).    properties at: 'instance' put: (instanceMethodMap := Dictionary new).    classMethodDefinitions        do: [ :methodDefinition |             (methodDefinition classIsMeta                ifTrue: [ classMethodsMap ]                ifFalse: [ instanceMethodMap ]) at: methodDefinition selector asString put: methodDefinition timeStamp ].    properties writeCypressJsonOn: fileStream! !!MCFileTreeStCypressWriter methodsFor: 'initialize-release' stamp: 'dkh 07/07/2013 22:14'!writePropertiesFile  | properties |  properties := Dictionary new.  properties at: 'noMethodMetaData' put: true.  properties at: 'separateMethodMetaAndSource' put: false.  properties at: 'useCypressPropertiesFile' put: true.  self    writeInDirectoryName: '.'    fileName: ''    extension: '.filetree'    visit: [ properties writeCypressJsonOn: fileStream ].  self    writeInDirectoryName: '.'    fileName: 'properties'    extension: self propertyFileExtension    visit: [ Dictionary new writeCypressJsonOn: fileStream ]! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'topa 7/22/2013 14:54'!writeTraitDefinition: definition    | properties compositionString |    properties := Dictionary new.    properties at: 'name' put: definition className.    definition traitCompositionString        ifNotNil: [ :property |             property ~= '{}'                ifTrue: [ properties at: 'traitcomposition' put: property ] ].    " handle the classTrait case "    compositionString := self classTraitDefinitions at: definition className ifPresent: [:classTraitDefinition |	classTraitDefinition classTraitCompositionString ].    compositionString ifNil: [ compositionString := definition classTraitCompositionString ].    compositionString~= '{}'                ifTrue: [ properties at: 'classtraitcomposition' put: compositionString ] .    properties at: 'category' put: definition category.    properties at: 'commentStamp' put: definition commentStamp.    properties writeCypressJsonOn: fileStream! !!MCFileTreeStCypressWriter methodsFor: 'writing' stamp: 'topa 7/22/2013 14:47'!writeTraitDefinition: definition to: classPath  self    writeInDirectoryName: classPath    fileName: 'README'    extension: '.md'    visit: [ self writeClassComment: definition ].  self    writeInDirectoryName: classPath    fileName: 'properties'    extension: self propertyFileExtension    visit: [ self writeTraitDefinition: definition ].  self    writeInDirectoryName: classPath    fileName: 'methodProperties'    extension: self propertyFileExtension    visit: [       self        writeMethodProperties:          (self methodDefinitions at: definition className ifAbsent: [ #() ]) ]! !!MCFileTreeStSnapshotWriter methodsFor: 'accessing' stamp: 'dkh 4/5/2012 11:15:15'!classDefinitions    classDefinitions ifNil: [ classDefinitions := Dictionary new ].    ^ classDefinitions! !!MCFileTreeStSnapshotWriter methodsFor: 'accessing' stamp: 'dkh 08/08/2013 19:02:56'!classTraitDefinitions    classTraitDefinitions ifNil: [ classTraitDefinitions := Dictionary new ].    ^ classTraitDefinitions! !!MCFileTreeStSnapshotWriter methodsFor: 'accessing' stamp: 'dkh 4/5/2012 11:15:15'!methodDefinitions    methodDefinitions ifNil: [ methodDefinitions := Dictionary new ].    ^ methodDefinitions! !!MCFileTreeStSnapshotWriter methodsFor: 'accessing' stamp: 'dkh 08/08/2013 19:02:56'!traitDefinitions    traitDefinitions ifNil: [ traitDefinitions := Dictionary new ].    ^ traitDefinitions! !!MCFileTreeStSnapshotWriter methodsFor: 'visiting' stamp: 'dkh 4/5/2012 11:15:15'!visitClassDefinition: definition    orderedClassNames add: definition className.    self classDefinitions at: definition className put: definition! !!MCFileTreeStSnapshotWriter methodsFor: 'visiting' stamp: 'dkh 08/08/2013 19:02:56'!visitClassTraitDefinition: definition    orderedTraitNames add: definition className, ' classTrait'.    self classTraitDefinitions at: definition className put: definition! !!MCFileTreeStSnapshotWriter methodsFor: 'visiting' stamp: 'dkh 4/5/2012 11:15:15'!visitMethodDefinition: definition    (self methodDefinitions        at: definition className        ifAbsent: [ self methodDefinitions at: definition className put: OrderedCollection new ]) add: definition! !!MCFileTreeStSnapshotWriter methodsFor: 'visiting' stamp: 'dkh 08/08/2013 19:02:56'!visitTraitDefinition: definition    orderedTraitNames add: definition className.    self traitDefinitions at: definition className put: definition! !!MCFileTreeStSnapshotWriter methodsFor: 'writing' stamp: 'dkh 4/5/2012 11:15:15'!writeClassDefinition: definition to: classPath    self        writeInDirectoryName: classPath        fileName: definition className        extension: '.st'        visit: [ self writeClassDefinition: definition ]! !!MCFileTreeStSnapshotWriter methodsFor: 'writing' stamp: 'dkh 08/08/2013 19:02:56'!writeClassTraitDefinition: definition to: traitPath    self        writeInDirectoryName: traitPath        fileName: definition className, '_classTrait'        extension: '.st'        visit: [ self writeClassTraitDefinition: definition ]! !!MCFileTreeStSnapshotWriter methodsFor: 'initialize-release' stamp: 'dkh 08/08/2013 18:34'!writeDefinitions: aCollection  | basePath extensionClasses extensionMethodDefinitions methodHolders |  self writeBasicDefinitions: aCollection.  basePath := 'snapshot' , self fileUtils pathNameDelimiter asString , 'classes'    , self fileUtils pathNameDelimiter asString.  extensionClasses := OrderedCollection new.  extensionMethodDefinitions := OrderedCollection new.  methodHolders := self classDefinitions, self traitDefinitions..  self methodDefinitions    keysAndValuesDo: [ :className :extensionMethods |       methodHolders        at: className        ifAbsent: [           extensionClasses add: className.          extensionMethodDefinitions addAll: extensionMethods ] ].  extensionClasses    do: [ :className | self methodDefinitions removeKey: className ].    self writeMethodHolderDefinitions: self traitDefinitions extension: '.trait' to: basePath do: [ :definition :classPath |	self writeTraitDefinition: definition to: classPath.	self classTraitDefinitions at: definition className ifPresent: [:classTraitDefinition |		self writeClassTraitDefinition: classTraitDefinition to: classPath ] ].  self    writeMethodHolderDefinitions: self classDefinitions    extension: '.class'    to: basePath    do: [ :definition :classPath | self writeClassDefinition: definition to: classPath ].  basePath := 'snapshot' , self fileUtils pathNameDelimiter asString    , 'extensions' , self fileUtils pathNameDelimiter asString.  extensionMethodDefinitions    do: [ :methodDefinition |       | methodPath |      methodPath := basePath , methodDefinition className , '.class'        , self fileUtils pathNameDelimiter asString        ,          (methodDefinition classIsMeta            ifTrue: [ 'class' ]            ifFalse: [ 'instance' ])        , self fileUtils pathNameDelimiter asString.      self writeMethodDefinition: methodDefinition to: methodPath ]! !!MCFileTreeStSnapshotWriter methodsFor: 'writing' stamp: 'dkh 4/5/2012 11:15:15'!writeMethodDefinition: methodDefinition to: methodPath    | filename |    filename := self fileNameForSelector: methodDefinition selector.    self        writeInDirectoryName: methodPath        fileName: filename        extension: '.st'        visit: [ self writeMethodDefinition: methodDefinition ]! !!MCFileTreeStSnapshotWriter methodsFor: 'writing' stamp: '08/08/2013 15:40'!writeMethodHolderDefinitions: aCollection extension: extension to: basePath do: aBlock  aCollection    keysAndValuesDo: [ :className :definition |       | classPath instanceMethodPath classMethodPath filenameMetaMap theMethodDefinitions |      classPath := basePath , definition className , extension        , self fileUtils pathNameDelimiter asString.      aBlock value: definition value: classPath.      instanceMethodPath := classPath , 'instance'        , self fileUtils pathNameDelimiter asString.      classMethodPath := classPath , 'class'        , self fileUtils pathNameDelimiter asString.      theMethodDefinitions := self methodDefinitions        at: className        ifAbsent: [ #() ].      filenameMetaMap := self fileNameMapFor: theMethodDefinitions.      theMethodDefinitions        do: [ :methodDefinition |           | filename |          filename := (filenameMetaMap at: methodDefinition classIsMeta)            at: methodDefinition selector.          methodDefinition classIsMeta            ifTrue: [               self                writeMethodDefinition: methodDefinition                to: classMethodPath                filename: filename ]            ifFalse: [               self                writeMethodDefinition: methodDefinition                to: instanceMethodPath                filename: filename ] ] ]! !!MCFileTreeStSnapshotWriter methodsFor: 'writing' stamp: 'dkh 08/08/2013 19:02:56'!writeTraitDefinition: definition to: traitPath    self        writeInDirectoryName: traitPath        fileName: definition className        extension: '.st'        visit: [ self writeTraitDefinition: definition ]! !!MCFileTreeStWriter methodsFor: 'visiting' stamp: 'dkh 2/29/2012 14:52'!visitClassDefinition: definition    orderedClassNames add: definition className.    self        writeInDirectoryName: definition className        fileName: definition className        extension: '.st'        visit: [ self writeClassDefinition: definition ]! !!MCFileTreeStWriter methodsFor: 'visiting' stamp: 'topa 7/22/2013 13:36'!visitClassTraitDefinition: definition    orderedTraitNames add: definition className, ' classTrait'.    self        writeInDirectoryName: definition className        fileName: definition className, '_classTrait'        extension: '.st'        visit: [ self writeClassTraitDefinition: definition ]! !!MCFileTreeStWriter methodsFor: 'visiting' stamp: 'dkh 2/29/2012 14:55'!visitMethodDefinition: definition    | filename directoryname |    directoryname := definition classIsMeta        ifTrue: [ definition className , '_class' ]        ifFalse: [ definition className ].    filename := self fileNameForSelector: definition selector.    self        writeInDirectoryName: directoryname        fileName: filename        extension: '.st'        visit: [ self writeMethodDefinition: definition ]! !!MCFileTreeStWriter methodsFor: 'visiting' stamp: 'topa 7/22/2013 01:12'!visitTraitDefinition: definition    orderedTraitNames add: definition className.    self        writeInDirectoryName: definition className        fileName: definition className        extension: '.st'        visit: [ self writeTraitDefinition: definition ]! !!String methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!cypressEscape    ^ self encodeForHTTP! !!String methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!cypressUnescape    ^ self unescapePercents! !!String methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonOn: aStream forHtml: forHtml indent: startIndent    "by default ignore <forHtml> ... <forHtml> is used for Dictionary and Array, i.e., container objects and String which actually encodes itself differently for HTML"    aStream        nextPutAll: '"';        nextPutAll:                (forHtml                        ifTrue: [ self cypressEscape ]                        ifFalse: [ self ]);        nextPutAll: '"'! !!MCFileTreeRepository class methodsFor: 'accessing' stamp: 'dkh 4/4/2012 14:27'!defaultPackageExtension    ".tree, .pkg, .package are the only formats supported at the moment:	.tree         - original structure	.pkg          - snapshot structure	.package - cypress structure"    defaultPackageExtension        ifNil: [             defaultPackageExtension := MCFileTreePackageStructureStWriter useCypressWriter                ifTrue: [ '.package' ]                ifFalse: [ '.pkg' ] ].    ^ defaultPackageExtension! !!MCFileTreeRepository class methodsFor: 'accessing' stamp: 'dkh 4/4/2012 14:36'!defaultPackageExtension: aString    ".tree and .pkg are the only two formats supported at the moment"    "self defaultPackageExtension:'.package'"    (#('.tree' '.pkg' '.package') includes: aString)        ifFalse: [ self error: 'Unsupported package extension: ' , aString printString ].    defaultPackageExtension := aString! !!MCFileTreeRepository class methodsFor: 'accessing' stamp: 'dkh 07/10/2013 11:43:55'!defaultPropertyFileExtension  defaultPropertyFileExtension    ifNil: [ defaultPropertyFileExtension := '.json' ].  ^ defaultPropertyFileExtension! !!MCFileTreeRepository class methodsFor: 'accessing' stamp: 'dkh 07/10/2013 11:43:55'!defaultPropertyFileExtension: aString  "self defaultPropertyFileExtension:'.ston'"  self validatePropertyFileExtension: aString.  defaultPropertyFileExtension := aString! !!MCFileTreeRepository class methodsFor: 'instance creation' stamp: 'dkh 2/16/2012 14:49:00'!description    ^ 'filetree://'! !!MCFileTreeRepository class methodsFor: 'utility' stamp: 'dkh 2/29/2012 09:40:37'!parseName: aString    ^ self parseName: aString extension: self defaultPackageExtension! !!MCFileTreeRepository class methodsFor: 'utility' stamp: 'dkh 2/16/2012 14:49:00'!parseName: aString extension: extension    "picked up from GoferVersionReference>>parseName:"    | info basicName package branch author versionNumber packageName |    basicName := aString last isDigit        ifTrue: [ aString ]        ifFalse: [ (aString copyUpToLast: $.) copyUpTo: $( ].    package := basicName copyUpToLast: $-.    (package includes: $.)        ifFalse: [ branch := '' ]        ifTrue: [             branch := '.' , (package copyAfter: $.).            package := package copyUpTo: $. ].    author := (basicName copyAfterLast: $-) copyUpToLast: $..    versionNumber := (basicName copyAfterLast: $-) copyAfterLast: $..    (versionNumber notEmpty and: [ versionNumber allSatisfy: [ :each | each isDigit ] ])        ifTrue: [ versionNumber := versionNumber asNumber ]        ifFalse: [ versionNumber := 0 ].    packageName := package , branch.    ^ {packageName.    author.    versionNumber.    (packageName , extension)}! !!MCFileTreeRepository class methodsFor: 'accessing' stamp: 'dkh 07/10/2013 11:43:55'!validatePropertyFileExtension: aString  "see Issue #90: https://github.com/dalehenrich/filetree/issues/90"  (#('.json' '.ston') includes: aString)    ifFalse: [ self error: 'Unsupported property file extension: ' , aString printString ]! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 6/16/2012 09:03'!allFileNames	versionNameToFileNameMap := Dictionary new.	^(self directory entries select: [:entry | entry isDirectory and: [self canReadFileNamed: entry name]]) collect: [:entry | | vName |		vName := self versionNameFromFileName: entry name.		versionNameToFileNameMap at: vName put: entry name.		vName asMCVersionName]! !!MCFileTreeRepository methodsFor: 'private' stamp: 'dkh 10/28/2014 11:24'!allVersionNames	"https://github.com/dalehenrich/filetree/issues/132"	^ self readableFileNames collect: [ :each | each versionName ] ! !!MCFileTreeRepository methodsFor: 'accessing' stamp: 'dkh 2/16/2012 14:49:00'!asRepositorySpecFor: aMetacelloMCProject    ^ aMetacelloMCProject repositorySpec        description: self description;        type: 'filetree';        yourself! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 4/5/2012 10:33'!basicStoreVersion: aVersion  self readonly    ifTrue: [       ^ self        error:          'The filetree repository: ' , self description printString            , ' was created read only.' ].  MCFileTreeWriter fileOut: aVersion on: self! !!MCFileTreeRepository methodsFor: 'private' stamp: 'dkh 10/28/2014 10:59'!cache	^cache := Dictionary new! !!MCFileTreeRepository methodsFor: 'private' stamp: 'dkh 10/28/2014 11:25'!cacheAllFileNamesDuring: aBlock 	"https://github.com/dalehenrich/filetree/issues/132"	allFileNamesCache := nil.	^super cacheAllFileNamesDuring: aBlock ! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 2/16/2012 14:49:00'!cachedFileNames	^ #()! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 2/29/2012 10:15'!canReadFileNamed: aString    ^ (aString endsWith: self packageExtension)        or: [             (aString endsWith: '.tree')                or: [                     "Cypress format"                    aString endsWith: '.package' ] ]! !!MCFileTreeRepository methodsFor: 'accessing' stamp: 'dkh 07/10/2013 11:43:55'!defaultRepositoryProperties  ^ Dictionary new    at: 'packageExtension' put: self class defaultPackageExtension;    at: 'propertyFileExtension' put: self propertyFileExtension;    yourself! !!MCFileTreeRepository methodsFor: 'descriptions' stamp: 'dkh 2/16/2012 14:49:00'!description    ^ self class description , super description! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 3/7/2012 17:09:47'!directory: aDirectory  super directory: aDirectory.  repositoryProperties := nil.	"force properties to be reloaded from new location"  self repositoryProperties	"NOW"! !!MCFileTreeRepository methodsFor: 'actions' stamp: 'dkh 6/16/2012 09:02'!fileDirectoryOn: directoryPath    ^ self fileUtils directoryFromPath: directoryPath relativeTo: self directory! !!MCFileTreeRepository methodsFor: 'accessing' stamp: 'dkh 8/10/2012 14:55:31.237'!fileUtils    ^ MCFileTreeFileUtils current! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 07/10/2013 11:43:55'!flushCache  "force properties to be reread ... if the directory exists, otherwise let nature   take it's course"  super flushCache.  directory    ifNotNil: [       (MCFileTreeFileUtils current directoryExists: directory)        ifTrue: [           repositoryProperties := nil.          self repositoryProperties ] ]! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 2/29/2012 12:12'!goferVersionFrom: aVersionReference    "until we no longer find .tree directories in the wild"    (((self directory entries select: [:entry | entry isDirectory and: [self canReadFileNamed: entry name]]) collect: [ :entry | self fileDirectoryOn: entry name ])        select: [ :packageDirectory | self fileUtils directoryExists:packageDirectory ])        collect: [ :packageDirectory |             (self versionInfoForPackageDirectory: packageDirectory) name = aVersionReference name                ifTrue: [ ^ self loadVersionFromFileNamed: (self fileUtils directoryName: packageDirectory) ] ].    ^ nil! !!MCFileTreeRepository methodsFor: 'actions' stamp: 'dkh 6/27/2012 20:14'!packageDescriptionFromPackageDirectory: packageDirectory    | filename info extension |    filename := self fileUtils current directoryName: packageDirectory.    extension := filename copyFrom: (filename lastIndexOf: $.) to: filename size.    ^ ((self packageExtension ~= '.package'        and: [             (self fileUtils filePathExists: 'version' relativeTo: packageDirectory)                and: [ self fileUtils filePathExists: 'package' relativeTo: packageDirectory ] ])        or: [             | dir |            dir := self fileUtils                directoryFromPath: MCFileTreeStCypressWriter monticelloMetaDirName                relativeTo: packageDirectory.            self fileUtils directoryExists: dir ])        ifTrue: [             info := self versionInfoForPackageDirectory: packageDirectory.            self parseName: info name extension: extension ]        ifFalse: [             {(filename copyFrom: 1 to: (filename lastIndexOf: $.) - 1).            'cypress'.            1.            filename} ]! !!MCFileTreeRepository methodsFor: 'actions' stamp: 'dkh 2/16/2012 14:49:00'!packageDescriptionsFromReadableFileNames    ^ ((self readableFileNames collect: [ :fileName | self fileDirectoryOn: fileName ])        select: [ :packageDirectory | self fileUtils directoryExists: packageDirectory ])        collect: [ :packageDirectory | self packageDescriptionFromPackageDirectory: packageDirectory ]! !!MCFileTreeRepository methodsFor: 'private' stamp: 'dkh 2/29/2012 10:11'!packageExtension  ^ self repositoryProperties    at: 'packageExtension'    ifAbsent: [ self class defaultPackageExtension ]! !!MCFileTreeRepository methodsFor: 'private' stamp: 'dkh 2/29/2012 11:39'!parseName: aString extension: extension    ^ self class parseName: aString extension: extension! !!MCFileTreeRepository methodsFor: 'private' stamp: 'dkh 07/10/2013 11:43:55'!propertyFileExtension  ^ self repositoryProperties    at: 'propertyFileExtension'    ifAbsent: [ self class defaultPropertyFileExtension ]! !!MCFileTreeRepository methodsFor: 'private' stamp: 'dkh 07/10/2013 11:43:55'!propertyFileExtension: propertyFileExtension  self class validatePropertyFileExtension: propertyFileExtension.  self repositoryProperties    at: 'propertyFileExtension'    put: propertyFileExtension.  self writeRepositoryProperties! !!MCFileTreeRepository methodsFor: 'i/o' stamp: 'dkh 2/16/2012 14:49:00'!readStreamForFileNamed: aString do: aBlock    ^ aBlock value: self directory! !!MCFileTreeRepository methodsFor: 'private' stamp: 'dkh 10/28/2014 11:28'!readableFileNames	"https://github.com/dalehenrich/filetree/issues/132"	^self allFileNames asArray! !!MCFileTreeRepository methodsFor: 'accessing' stamp: 'dkh 2/16/2012 14:49:00'!readonly    readonly ifNil: [ readonly := false ].    ^ readonly! !!MCFileTreeRepository methodsFor: 'accessing' stamp: 'dkh 2/16/2012 14:49:00'!readonly: anObject	readonly := anObject! !!MCFileTreeRepository methodsFor: 'accessing' stamp: 'dkh 8/10/2012 07:54'!repositoryProperties  repositoryProperties    ifNil: [       repositoryProperties := Dictionary new.      (self fileUtils directoryExists: directory)        ifFalse: [           self            error:              'filetree:// repository '                ,                  (self fileUtils directoryPathString: self directory) printString                , ' does not exist.' ].      (self directory entries        detect: [ :entry | entry name = '.filetree' ]        ifNone: [  ])        ifNil: [           repositoryProperties := self defaultRepositoryProperties.          self writeRepositoryProperties ]        ifNotNil: [ :configEntry |           configEntry            readStreamDo: [ :fileStream | repositoryProperties := MCFileTreeJsonParser parseStream: fileStream ] ] ].  ^ repositoryProperties! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 2/16/2012 14:49:00'!versionFromFileNamed: aString	^ self loadVersionFromFileNamed: (versionNameToFileNameMap at: aString ifAbsent: [aString])! !!MCFileTreeRepository methodsFor: 'actions' stamp: 'dkh 8/10/2012 07:56'!versionInfoForPackageDirectory: packageDirectory    ^ ((MCReader readerClassForFileNamed: (self fileUtils directoryName: packageDirectory))        on: (self fileUtils parentDirectoryOf: packageDirectory)        fileName: (self fileUtils directoryName: packageDirectory))        loadVersionInfo;        info! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 2/16/2012 14:49:00'!versionInfoFromFileNamed: aString	^ self loadVersionInfoFromFileNamed: (versionNameToFileNameMap at: aString ifAbsent: [aString])! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 2/16/2012 14:49:00'!versionNameFromFileName: aString	| description |	description := self packageDescriptionFromPackageDirectory: (self fileDirectoryOn: aString).	^ description first , '-' , description second , '.' , description third printString! !!MCFileTreeRepository methodsFor: 'versions' stamp: 'dkh 6/12/2012 17:33:23'!versionNamed: aMCVersionName	^super versionNamed: (versionNameToFileNameMap at: aMCVersionName ifAbsent: [aMCVersionName])! !!MCFileTreeRepository methodsFor: 'interface' stamp: 'dkh 2/16/2012 14:49:00'!versionWithInfo: aVersionInfo ifAbsent: errorBlock	(self allFileNamesForVersionNamed: aVersionInfo versionName)		ifNotEmpty: [ :aCollection | ^ self versionFromFileNamed: aCollection first ].	^ errorBlock value! !!MCFileTreeRepository methodsFor: 'as yet unclassified' stamp: 'dkh 8/10/2012 09:44'!writeRepositoryProperties  self fileUtils    writeStreamFor: '.filetree'    in: self directory    do: [ :fileStream |       | keyCount propertyCount |      repositoryProperties        ifNil: [ repositoryProperties := self defaultRepositoryProperties ].      keyCount := repositoryProperties size.      propertyCount := 0.      fileStream lineEndConvention: #'lf'.      fileStream nextPutAll: '{'.      repositoryProperties        keysAndValuesDo: [ :propertyName :propertyValue |           propertyCount := propertyCount + 1.          fileStream            nextPut: $";            nextPutAll: propertyName asString;            nextPutAll: '" : "';            nextPutAll: propertyValue asString;            nextPut: $";            yourself.          propertyCount < keyCount            ifTrue: [               fileStream                nextPutAll: ',';                cr ] ].      fileStream nextPutAll: ' }' ]! !!MCFileTreeRepository methodsFor: 'i/o' stamp: 'dkh 2/16/2012 14:49:00'!writeStreamForFileNamed: aString replace: aBoolean do: aBlock	self error: 'we do not open a single stream, but write multiple files'! !!MCFileTreeAbstractReader class methodsFor: 'accessing' stamp: 'dkh 4/4/2012 17:43'!monticelloMetaDirName    ^ '.'! !!MCFileTreeAbstractReader class methodsFor: 'reading' stamp: 'dkh 2/16/2012 14:49:00'!on: s fileName: f	^ (self on: s)		packageDirectory: f;		yourself! !!MCFileTreeAbstractReader methodsFor: 'utilities' stamp: 'dkh 3/1/2012 12:09'!addClassAndMethodDefinitionsFromDirectory: aDirectory    self subclassResponsibility! !!MCFileTreeAbstractReader methodsFor: 'utilities' stamp: 'dkh 8/10/2012 14:00'!addClassAndMethodDefinitionsFromDirectoryEntries: entries    | timestamp |    self noMethodMetaData        ifTrue: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' ' , self info time print24 ].    entries        do: [ :element |             element isDirectory                ifTrue: [                     | directory |                    directory := self fileUtils directoryFromEntry: element.                    ((self separateMethodMetaAndSource or: [ self noMethodMetaData ])                        ifTrue: [ directory entries select: [ :entry | entry name endsWith: '.st' ] ]                        ifFalse: [ directory entries ])                        do: [ :file |                             | definition |                            (definition := self definitionFromFile: file inDirectory: directory)                                ifNotNil: [                                     definition isMethodDefinition                                        ifTrue: [                                             self separateMethodMetaAndSource                                                ifTrue: [                                                     directory                                                        fileNamed: definition selector asString , '.meta'                                                        do: [ :fileStream | definition setTimeStamp: (Utilities fixStamp: fileStream contents) ] ].                                            self noMethodMetaData                                                ifTrue: [ definition setTimeStamp: timestamp ] ].                                    definitions add: definition ] ] ] ]! !!MCFileTreeAbstractReader methodsFor: 'utilities' stamp: 'dkh 2/16/2012 14:49:00'!addDefinitionFromFile: directoryEntry inDirectory: aDirectory    (self definitionFromFile: directoryEntry inDirectory: aDirectory) ifNotNil: [ :def | definitions add: def ]! !!MCFileTreeAbstractReader methodsFor: 'accessing' stamp: 'dkh 2/16/2012 14:49:00'!basicVersion	^ (MCVersion new)		setPackage: self package			info: self info			snapshot: self snapshot			dependencies: self dependencies;		yourself! !!MCFileTreeAbstractReader methodsFor: 'utilities' stamp: 'dkh 8/10/2012 07:39'!definitionFromFile: directoryEntry inDirectory: aDirectory    | defs reader |    directoryEntry ifNil: [ ^ nil ].    self fileUtils        readStreamFor: directoryEntry name        in: aDirectory        do: [ :fileStream |             | methodDefinition |            reader := MCStReader on: fileStream.            (defs := reader definitions) size <= 1                ifFalse: [ self error: 'we should be writing exactly 1 definition per file' ] ].    defs size = 0        ifTrue: [ ^ nil ].    ^ defs first! !!MCFileTreeAbstractReader methodsFor: 'accessing' stamp: 'dkh 8/10/2012 05:39'!fileUtils    ^ MCFileTreeFileUtils current! !!MCFileTreeAbstractReader methodsFor: 'testing' stamp: 'dkh 8/10/2012 05:44'!hasMonticelloMetadata    ^ (self fileUtils        directoryExists:            (self fileUtils directoryFromPath: MCFileTreeStCypressWriter monticelloMetaDirName relativeTo: packageDirectory))        or: [             (self fileUtils filePathExists: 'version' relativeTo: packageDirectory)                and: [ self fileUtils filePathExists: 'package' relativeTo: packageDirectory ] ]! !!MCFileTreeAbstractReader methodsFor: 'utilities' stamp: 'topa 8/29/2013 00:58'!loadDefinitions    | entries |    definitions := OrderedCollection new.    entries := packageDirectory entries.    self        addDefinitionFromFile: (entries detect: [ :entry | entry name beginsWith: 'categories' ] ifNone: [  ])            inDirectory: packageDirectory;        addClassAndMethodDefinitionsFromDirectory: packageDirectory;        addDefinitionFromFile: (entries detect: [ :entry | entry name beginsWith: 'initializers' ] ifNone: [  ])            inDirectory: packageDirectory;        addDefinitionFromFile: (entries detect: [ :entry |               (entry name beginsWith: 'preamble') and: [	        (entry name includesSubstring: 'OfRemoval' caseSensitive: true) not] ] ifNone: [  ])            inDirectory: packageDirectory;        addDefinitionFromFile: (entries detect: [ :entry |              (entry name beginsWith: 'postscript') and: [	        (entry name includesSubstring: 'OfRemoval' caseSensitive: true) not] ] ifNone: [  ])            inDirectory: packageDirectory;        addDefinitionFromFile: (entries detect: [ :entry | entry name beginsWith: 'preambleOfRemoval' ] ifNone: [  ])            inDirectory: packageDirectory;        addDefinitionFromFile: (entries detect: [ :entry | entry name beginsWith: 'postscriptOfRemoval' ] ifNone: [  ])            inDirectory: packageDirectory.! !!MCFileTreeAbstractReader methodsFor: 'utilities' stamp: 'dkh 8/10/2012 07:18'!loadDependencies    | dependencyDir directoryPath |    directoryPath := self monticelloMetaDirName , self fileUtils pathNameDelimiter asString , 'dependencies'.    dependencyDir := self fileUtils directoryFromPath: directoryPath relativeTo: packageDirectory.    (self fileUtils directoryExists: dependencyDir)        ifFalse: [ ^ dependencies := #() ].    dependencies := OrderedCollection new.    dependencyDir entries        do: [ :entry |             dependencies                add:                    (MCVersionDependency                        package: (MCPackage named: entry name)                        info:                            (self extractInfoFrom: (self parseMember: 'dependencies' , self fileUtils pathNameDelimiter asString , entry name))) ].    dependencies := dependencies asArray! !!MCFileTreeAbstractReader methodsFor: 'accessing' stamp: 'dkh 4/4/2012 17:43'!monticelloMetaDirName    ^ self class monticelloMetaDirName! !!MCFileTreeAbstractReader methodsFor: 'testing' stamp: 'dkh 3/1/2012 10:11'!noMethodMetaData    ^ self packageProperties at: 'noMethodMetaData' ifAbsent: [ false ]! !!MCFileTreeAbstractReader methodsFor: 'accessing' stamp: 'dkh 8/10/2012 05:46'!packageDirectory: aDirectoryName    packageDirectory := self fileUtils directoryFromPath: aDirectoryName relativeTo: stream! !!MCFileTreeAbstractReader methodsFor: 'accessing' stamp: 'dkh 3/1/2012 11:56'!packageProperties    packageProperties        ifNil: [             packageProperties := Dictionary new.            (packageDirectory entries detect: [ :entry | entry name = '.filetree' ] ifNone: [  ])                ifNotNil: [ :configEntry |                     configEntry                        readStreamDo: [ :fileStream |                             | jsonObject structureVersion |                            [                             (jsonObject := MCFileTreeJsonParser parseStream: fileStream) isFloat                                ifTrue: [                                     "							0.0 - original structure							0.1 - separate files for method metaData (timestamp) and source							0.2 - no method metaData file"                                    packageProperties := Dictionary new.                                    structureVersion := jsonObject printShowingDecimalPlaces: 1.                                    packageProperties at: 'noMethodMetaData' put: structureVersion = '0.2'.                                    packageProperties at: 'separateMethodMetaAndSource' put: structureVersion = '0.1' ]                                ifFalse: [                                     packageProperties := jsonObject.                                    ((packageProperties at: 'noMethodMetaData' ifAbsent: [ false ])                                        and: [ packageProperties at: 'separateMethodMetaAndSource' ifAbsent: [ false ] ])                                        ifTrue: [ self error: 'noMethodMetaData and separateMethodMetaAndSource cannot both be true' ] ] ]                                on: Error                                do: [ :ex |                                     Transcript                                        cr;                                        show:                                                'Error reading package properties (.filetree): ' , packageDirectory pathName , ' :: ' , ex description ] ] ] ].    ^ packageProperties! !!MCFileTreeAbstractReader methodsFor: 'utilities' stamp: 'dkh 8/10/2012 07:43'!parseMember: fileName    | directory tokens |    directory := self fileUtils directoryFromPath: self monticelloMetaDirName relativeTo: packageDirectory.    self fileUtils readStreamFor: fileName in: directory do: [ :fileStream | tokens := self scanner scan: fileStream ].    ^ self associate: tokens! !!MCFileTreeAbstractReader methodsFor: 'testing' stamp: 'dkh 3/1/2012 10:10'!separateMethodMetaAndSource    ^ self packageProperties at: 'separateMethodMetaAndSource' ifAbsent: [ false ]! !!MCFileTreeStReader class methodsFor: 'accessing' stamp: 'dkh 3/1/2012 12:04'!extension	^ 'tree'! !!MCFileTreeStReader methodsFor: 'utilities' stamp: 'dkh 3/1/2012 12:18'!addClassAndMethodDefinitionsFromDirectory: aDirectory    self addClassAndMethodDefinitionsFromDirectoryEntries: aDirectory entries! !!MCFileTreeStCypressReader class methodsFor: 'accessing' stamp: 'dkh 4/4/2012 14:19'!extension    ^ 'package'! !!MCFileTreeStCypressReader class methodsFor: 'accessing' stamp: 'dkh 4/4/2012 17:44'!monticelloMetaDirName    ^ MCFileTreeStCypressWriter monticelloMetaDirName! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'topa 7/22/2013 01:41'!addClassAndMethodDefinitionsFromDirectory: aDirectory    aDirectory entries        do: [ :entry |             (entry name endsWith: '.trait')                ifTrue: [ self addTraitAndMethodDefinitionsFromEntry: entry ].            (entry name endsWith: '.class')                ifTrue: [ self addClassAndMethodDefinitionsFromEntry: entry ].            (entry name endsWith: '.extension')                ifTrue: [ self addExtensionClassAndMethodDefinitionsFromEntry: entry ] ]! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'dkh 8/10/2012 13:48'!addClassAndMethodDefinitionsFromEntry: classEntry    | classDirectory classPropertiesDict classComment entries methodPropertiesDict |    classDirectory := self fileUtils directoryFromEntry: classEntry.    ((entries := classDirectory entries) detect: [:entry | self isPropertyFile: entry] ifNone: [  ])        ifNotNil: [ :propertyEntry | propertyEntry readStreamDo: [ :fileStream | classPropertiesDict := MCFileTreeJsonParser parseStream: fileStream ] ].    (entries detect: [ :entry | entry name = 'README.md' ] ifNone: [  ])        ifNotNil: [ :commentEntry | commentEntry readStreamDo: [ :fileStream | classComment := fileStream contents ] ].    methodPropertiesDict := Dictionary new.    (entries detect: [ :entry | self isMethodPropertyFile: entry] ifNone: [  ])        ifNotNil: [ :propertyEntry |             propertyEntry                readStreamDo: [ :fileStream |                     "Issue 33: https://github.com/dalehenrich/filetree/issues/33"                    methodPropertiesDict := MCFileTreeJsonParser parseStream: fileStream ] ].    self addClassDefinitionFrom: classPropertiesDict comment: classComment withSqueakLineEndings.    self        addMethodDefinitionsForClass: (classPropertiesDict at: 'name')        methodProperties: methodPropertiesDict        in: entries! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'dkh 6/27/2012 14:18'!addClassDefinitionFrom: classPropertiesDict comment: classComment    definitions        add:            (MCClassDefinition                name: (classPropertiesDict at: 'name')                superclassName: (classPropertiesDict at: 'super')                traitComposition: (classPropertiesDict at: 'traitcomposition' ifAbsent: [ '{}' ])                classTraitComposition: (classPropertiesDict at: 'classtraitcomposition' ifAbsent: [ '{}' ])                category: (classPropertiesDict at: 'category' ifAbsent: [ self packageNameFromPackageDirectory ])                instVarNames: (classPropertiesDict at: 'instvars' ifAbsent: [ #() ])                classVarNames: (classPropertiesDict at: 'classvars' ifAbsent: [ #() ])                poolDictionaryNames: (classPropertiesDict at: 'pools' ifAbsent: [ #() ])                classInstVarNames: (classPropertiesDict at: 'classinstvars' ifAbsent: [ #() ])                type: (classPropertiesDict at: 'type' ifAbsent: [ 'normal' ]) asSymbol                comment: classComment                commentStamp: (classPropertiesDict at: 'commentStamp' ifAbsent: [ '' ]))! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'dkh 8/10/2012 14:00'!addExtensionClassAndMethodDefinitionsFromEntry: classEntry    | classDirectory classPropertiesDict methodPropertiesDict entries |    classDirectory := self fileUtils directoryFromEntry: classEntry.    ((entries := classDirectory entries) detect: [ :entry | self isPropertyFile: entry] ifNone: [  ])        ifNotNil: [ :propertyEntry | propertyEntry readStreamDo: [ :fileStream | classPropertiesDict := MCFileTreeJsonParser parseStream: fileStream ] ].    methodPropertiesDict := Dictionary new.    (entries detect: [ :entry | self isMethodPropertyFile: entry] ifNone: [  ])        ifNotNil: [ :propertyEntry |             propertyEntry                readStreamDo: [ :fileStream |                     "Issue 33: https://github.com/dalehenrich/filetree/issues/33"                    methodPropertiesDict := MCFileTreeJsonParser parseStream: fileStream ] ].    self        addMethodDefinitionsForClass: (classPropertiesDict at: 'name')        methodProperties: methodPropertiesDict        in: entries! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'dkh 8/10/2012 14:01'!addMethodDefinitionsForClass: className methodProperties: methodProperties in: entries    entries        do: [ :entry |             | classIsMeta |            classIsMeta := false.            entry name = 'class'                ifTrue: [ classIsMeta := true ].            (entry name = 'instance' or: [ entry name = 'class' ])                ifTrue: [                     ((self fileUtils directoryFromEntry: entry) entries select: [ :each | each name endsWith: '.st' ])                        do: [ :methodEntry |                             methodEntry                                readStreamDo: [ :fileStream |                                     | category source timestamp selector |                                    category := fileStream nextLine.                                    source := fileStream upToEnd.                                    selector := self methodSelectorFor: source.                                    timestamp := methodProperties                                        at:                                            (classIsMeta                                                ifTrue: [ 'class' ]                                                ifFalse: [ 'instance' ])                                        ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"                                    timestamp                                        ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' ' , self info time print24 ].                                    definitions                                        add:                                            (MCMethodDefinition                                                className: className                                                classIsMeta: classIsMeta                                                selector: selector                                                category: category                                                timeStamp: timestamp                                                source: source) ] ] ] ]! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'topa 7/22/2013 14:41'!addTraitAndMethodDefinitionsFromEntry: classEntry    | classDirectory classPropertiesDict classComment entries methodPropertiesDict |    classDirectory := self fileUtils directoryFromEntry: classEntry.    ((entries := classDirectory entries) detect: [:entry | self isPropertyFile: entry] ifNone: [  ])        ifNotNil: [ :propertyEntry | propertyEntry readStreamDo: [ :fileStream | classPropertiesDict := MCFileTreeJsonParser parseStream: fileStream ] ].    (entries detect: [ :entry | entry name = 'README.md' ] ifNone: [  ])        ifNotNil: [ :commentEntry | commentEntry readStreamDo: [ :fileStream | classComment := fileStream contents ] ]        ifNil: [ classComment := '' ].    methodPropertiesDict := Dictionary new.    (entries detect: [ :entry | self isMethodPropertyFile: entry] ifNone: [  ])        ifNotNil: [ :propertyEntry |             propertyEntry                readStreamDo: [ :fileStream |                     "Issue 33: https://github.com/dalehenrich/filetree/issues/33"                    methodPropertiesDict := MCFileTreeJsonParser parseStream: fileStream ] ].    self addTraitDefinitionFrom: classPropertiesDict comment: classComment withSqueakLineEndings.    self        addMethodDefinitionsForClass: (classPropertiesDict at: 'name')        methodProperties: methodPropertiesDict        in: entries! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'topa 7/22/2013 15:15'!addTraitDefinitionFrom: traitPropertiesDict comment: traitComment    definitions        add:            (MCTraitDefinition                name: (traitPropertiesDict at: 'name')                traitComposition: (traitPropertiesDict at: 'traitcomposition' ifAbsent: [ '{}' ])                category: (traitPropertiesDict at: 'category' ifAbsent: [ self packageNameFromPackageDirectory ])                comment: traitComment                commentStamp: (traitPropertiesDict at: 'commentStamp' ifAbsent: [ '' ])).    traitPropertiesDict at: 'classtraitcomposition' ifPresent: [:classTraitComposition |        definitions             add:                (MCClassTraitDefinition                    baseTraitName: (traitPropertiesDict at: 'name')                    classTraitComposition: classTraitComposition)].! !!MCFileTreeStCypressReader methodsFor: 'accessing' stamp: 'dkh 6/27/2012 20:19'!basicVersion    self hasMonticelloMetadata        ifTrue: [ ^ super basicVersion ].    ^ MCVersion new        setPackage: self package            info: self info            snapshot: self snapshot            dependencies: #();        yourself! !!MCFileTreeStCypressReader methodsFor: 'private' stamp: 'dkh 6/16/2013 12:47:20'!isMethodPropertyFile: entry	^ entry name = 'methodProperties.ston' or: [ entry name = 'methodProperties.json']! !!MCFileTreeStCypressReader methodsFor: 'private' stamp: 'dkh 6/16/2013 12:47:20'!isPropertyFile: entry	^ entry name = 'properties.ston' or: [ entry name = 'properties.json']! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'topa 8/29/2013 00:57'!loadDefinitions    | entries directory |    definitions := OrderedCollection new.    directory := self fileUtils directoryFromPath: self monticelloMetaDirName relativeTo: packageDirectory.    (self fileUtils directoryExists: directory)        ifTrue: [             entries := directory entries.            self                addDefinitionFromFile: (entries detect: [ :entry | entry name beginsWith: 'categories' ] ifNone: [  ])                inDirectory: directory ].    self addClassAndMethodDefinitionsFromDirectory: packageDirectory.    (self fileUtils directoryExists: directory)        ifTrue: [             self                addDefinitionFromFile: (entries detect: [ :entry | entry name beginsWith: 'initializers' ] ifNone: [  ])                inDirectory: directory;                addDefinitionFromFile: (entries detect: [ :entry |                    (entry name beginsWith: 'preamble') and: [                   (entry name includesSubstring: 'OfRemoval' caseSensitive: true) not] ] ifNone: [  ])                inDirectory: directory;                addDefinitionFromFile: (entries detect: [ :entry |                   (entry name beginsWith: 'postscript') and: [                   (entry name includesSubstring: 'OfRemoval' caseSensitive: true) not] ] ifNone: [  ])                inDirectory: directory;                addDefinitionFromFile: (entries detect: [ :entry | entry name beginsWith: 'preambleOfRemoval' ] ifNone: [  ])                inDirectory: directory;                addDefinitionFromFile: (entries detect: [ :entry | entry name beginsWith: 'postscriptOfRemoval' ] ifNone: [  ])                inDirectory: directory. ]! !!MCFileTreeStCypressReader methodsFor: 'accessing' stamp: 'dkh 6/27/2012 20:21'!loadPackage    self hasMonticelloMetadata        ifTrue: [ ^ super loadPackage ].    package := MCPackage named: self packageNameFromPackageDirectory! !!MCFileTreeStCypressReader methodsFor: 'accessing' stamp: '08/08/2013 15:01'!loadVersionInfo  self hasMonticelloMetadata    ifTrue: [ ^ info := self extractInfoFrom: (self parseMember: 'version') ].  info := MCVersionInfo    name: self packageNameFromPackageDirectory , '-cypress.1'    id: UUID new    message: 'fabricated from a Cypress format repository'    date: Date today    time: Time now    author: ''    ancestors: #()    stepChildren: #()! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'ChristopheDemarey 5/31/2013 23:28'!methodSelectorFor: source    ^ Object parserClass new parseSelector: source! !!MCFileTreeStCypressReader methodsFor: 'accessing' stamp: 'dkh 8/10/2012 14:55'!packageNameFromPackageDirectory    | filename |    filename := self fileUtils directoryName: packageDirectory.    ^ filename copyFrom: 1 to: (filename lastIndexOf: $.) - 1! !!MCFileTreeStSnapshotReader class methodsFor: 'accessing' stamp: 'dkh 3/1/2012 12:06'!extension    ^ 'pkg'! !!MCFileTreeStSnapshotReader methodsFor: 'utilities' stamp: 'dkh 8/10/2012 14:03'!addClassAndMethodDefinitionsFromDirectory: aDirectory    | snapshot classes entries extensions |    snapshot := self fileUtils directoryFromPath: 'snapshot' relativeTo: aDirectory.    classes := self fileUtils directoryFromPath: 'classes' relativeTo: snapshot.    (self fileUtils directoryExists: classes)        ifTrue: [             self addClassAndMethodDefinitionsFromDirectoryEntries: (entries := classes entries).	"load .st files from subdirectories (*.class) of snapshot/classes ... class defintions"            entries                do: [ :classDirectoryEntry |                     | classDirectory |                    classDirectory := self fileUtils directoryFromEntry: classDirectoryEntry.                    self addClassAndMethodDefinitionsFromDirectoryEntries: classDirectory entries	"load .st files from subdirectories (class or instance) of snapshot/classes/*.class ... method definitions" ] ].    extensions := self fileUtils directoryFromPath: 'extensions' relativeTo: snapshot.    (self fileUtils directoryExists: extensions)        ifTrue: [             extensions entries                do: [ :classDirectoryEntry |                     | classDirectory |                    classDirectory := self fileUtils directoryFromEntry: classDirectoryEntry.                    self addClassAndMethodDefinitionsFromDirectoryEntries: classDirectory entries	"load .st files from subdirectories (class or instance) of snapshot/extensions/*.class ... method definitions" ] ]! !!UndefinedObject methodsFor: '*monticellofiletree-core' stamp: 'topa 7/22/2013 01:03'!writeCypressJsonOn: aStream forHtml: forHtml indent: startIndent    "by default ignore <forHtml> ... <forHtml> is used for Dictionary and Array, i.e., container objects and String which actually encodes itself differently for HTML"    aStream nextPutAll: 'null'.! !!MCMethodDefinition methodsFor: '*monticellofiletree-core' stamp: 'dkh 2/16/2012 14:49:00'!setTimeStamp: aString    ^ timeStamp := aString! !!MCFileTreePackageStructureStWriter class methodsFor: 'accessing' stamp: 'dkh 4/5/2012 10:37'!useCypressWriter    "MCFileTreeRepository defaultPackageExtension:'.package'"    "MCFileTreeRepository defaultPackageExtension:'.pkg'"    ^ true! !!MCFileTreePackageStructureStWriter class methodsFor: 'accessing' stamp: 'dkh 3/1/2012 10:30'!useSnapShotWriter    ^ MCFileTreeRepository defaultPackageExtension = '.pkg'! !!MCFileTreePackageStructureStWriter methodsFor: 'accessing' stamp: 'dkh 2/29/2012 13:46'!absentInitializers	^ initializers reject: [ :each | Smalltalk hasClassNamed: each key ]! !!MCFileTreePackageStructureStWriter methodsFor: 'visiting' stamp: 'dkh 2/29/2012 13:46'!acceptVisitor: aVisitor forDefinitions: aCollection	(MCDependencySorter sortItems: aCollection)		do: [ :ea | ea accept: aVisitor ]		displayingProgress: 'Writing definitions...'! !!MCFileTreePackageStructureStWriter methodsFor: 'accessing' stamp: 'dkh 2/29/2012 13:45'!initializers: aCollection	initializers := aCollection! !!MCFileTreePackageStructureStWriter methodsFor: 'accessing' stamp: 'dkh 2/29/2012 13:46'!presentInitializers	^ initializers select: [ :each | Smalltalk hasClassNamed: each key ]! !!MCFileTreePackageStructureStWriter methodsFor: 'writing' stamp: 'dkh 2/29/2012 13:45'!writeAbsentInitializers	(self absentInitializers asSortedCollection: [ :a :b | a key <= b key ])		do: [ :association | stream nextPutAll: association value contents ]! !!MCFileTreePackageStructureStWriter methodsFor: 'writing' stamp: 'dkh 2/29/2012 14:48'!writeClassDefinition: definition    self chunkContents: [ :s | definition printDefinitionOn: s ]! !!MCFileTreePackageStructureStWriter methodsFor: 'writing' stamp: 'dkh 2/29/2012 13:42'!writeDefinitions: aCollection	"the correct initialization order is unknown if some classes are missing in the image"	initializers := Set new.	self		acceptVisitor: self forDefinitions: aCollection;		writePresentInitializers;		writeAbsentInitializers! !!MCFileTreePackageStructureStWriter methodsFor: 'writing' stamp: 'dkh 6/12/2012 17:33:23'!writeMethodInitializer: aMethodDefinition	| initializationStream |		aMethodDefinition isInitializer 		ifTrue: [			initializationStream := String new writeStream.						initializationStream nextChunkPut: aMethodDefinition className, ' initialize'; cr.			initializers add: (aMethodDefinition className->initializationStream)].! !!MCFileTreePackageStructureStWriter methodsFor: 'writing' stamp: 'dkh 2/16/2012 14:49:00'!writeMethodPreamble: definition    stream        cr;        nextPut: $!!;        nextPutAll: definition fullClassName;        nextPutAll: ' methodsFor: ';        nextPutAll: definition category asString printString;        nextPutAll: '!!';        cr! !!MCFileTreePackageStructureStWriter methodsFor: 'writing' stamp: 'dkh 2/29/2012 13:45'!writePresentInitializers	| orderedClasses presentInitializers |	presentInitializers := self presentInitializers.	orderedClasses := (ChangeSet		superclassOrder: (presentInitializers collect: [ :each | Smalltalk classNamed: each key ]))		collect: [ :each | each name ].	orderedClasses		do: [ :className | stream nextPutAll: (presentInitializers detect: [ :each | each key = className ]) value contents ]! !!MCFileTreePackageStructureStWriter methodsFor: 'writing' stamp: 'dkh 3/1/2012 14:21'!writeProperties    stream        nextPut: ${;        cr;        nextPutAll: '    "noMethodMetaData" : true,';        cr;        nextPutAll: '    "separateMethodMetaAndSource" : false';        cr;        nextPut: $};        cr! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/9/2012 09:15'!buildPathFrom: pathCollection    ^ String        streamContents: [ :stream | pathCollection do: [ :element | stream nextPutAll: element ] separatedBy: [ stream nextPut: self pathNameDelimiter ] ]! !!MCFileTreeFileUtils class methodsFor: 'accessing' stamp: 'dkh 8/8/2012 22:36'!current    ^ Current! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:59'!default    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:59'!deleteAll: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:59'!directoryExists: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:59'!directoryFromPath: directoryPath    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:59'!directoryFromPath: directoryPath relativeTo: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:59'!directoryName: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:59'!directoryPathString: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:59'!ensureDirectoryExists: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:59'!ensureFilePathExists: fileNameOrPath relativeTo: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 10:00'!filePathExists: filePath relativeTo: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'initialization' stamp: 'dkh 8/8/2012 22:37'!install    Current := self! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 10:00'!parentDirectoryOf: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 10:00'!pathNameDelimiter    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 10:00'!readStreamFor: filePath in: aDirectory do: aBlock    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 10:00'!resolvePath: path in: aDirectory    self subclassResponsibility! !!MCFileTreeFileUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 10:00'!writeStreamFor: filePath in: aDirectory do: aBlock    self subclassResponsibility! !!MCFileTreeJsonParser class methodsFor: 'instance creation' stamp: 'dkh 2/16/2012 14:39:25'!new	self error: 'Instantiate the parser with a stream.'! !!MCFileTreeJsonParser class methodsFor: 'instance creation' stamp: 'dkh 2/16/2012 14:39:25'!on: aStream	^ self basicNew initializeOn: aStream! !!MCFileTreeJsonParser class methodsFor: 'accessing' stamp: 'dkh 2/16/2012 14:39:25'!parse: aString	^ self parseStream: aString readStream! !!MCFileTreeJsonParser class methodsFor: 'accessing' stamp: 'dkh 2/16/2012 14:39:25'!parseStream: aStream	^ (self on: aStream) parse! !!MCFileTreeJsonParser methodsFor: 'adding' stamp: 'dkh 2/16/2012 14:39:25'!addProperty: anAssociation to: anObject	"Add the property anAssociation described with key and value to anObject. Subclasses might want to refine this implementation."		^ anObject 		add: anAssociation;		yourself! !!MCFileTreeJsonParser methodsFor: 'adding' stamp: 'dkh 2/16/2012 14:39:25'!addValue: anObject to: aCollection	"Add anObject to aCollection. Subclasses might want to refine this implementation."	^ aCollection copyWith: anObject! !!MCFileTreeJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!createArray	"Create an empty collection. Subclasses might want to refine this implementation."	^ Array new! !!MCFileTreeJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!createFalse	"Create the false literal. Subclasses might want to refine this implementation."		^ false! !!MCFileTreeJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!createNull	"Create the null literal. Subclasses might want to refine this implementation."	^ nil! !!MCFileTreeJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!createNumber: aString	"Create a number literal. Subclasses might want to refine this implementation."	^ aString asNumber! !!MCFileTreeJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!createObject	"Create an empty object. Subclasses might want to refine this implementation."		^ Dictionary new! !!MCFileTreeJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!createProperty: aKey with: aValue	"Create an empty attribute value pair. Subclasses might want to refine this implementation."		^ aKey -> aValue! !!MCFileTreeJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!createString: aString	"Create a string literal. Subclasses might want to refine this implementation."	^ aString! !!MCFileTreeJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!createTrue	"Create the true literal. Subclasses might want to refine this implementation."	^ true! !!MCFileTreeJsonParser methodsFor: 'private' stamp: 'dkh 2/16/2012 14:39:25'!expect: aString	"Expects aString and consume input, throw an error otherwise."	^ (self match: aString) ifFalse: [ self error: aString , ' expected' ]! !!MCFileTreeJsonParser methodsFor: 'initialization' stamp: 'dkh 2/16/2012 14:39:25'!initializeOn: aStream	self initialize.	stream := aStream! !!MCFileTreeJsonParser methodsFor: 'private' stamp: 'dkh 2/16/2012 14:39:25'!match: aString	"Tries to match aString, consume input and answer true if successful."		| position |	position := stream position.	aString do: [ :each |		(stream atEnd or: [ stream next ~= each ]) ifTrue: [ 			stream position: position.			^ false ] ].	self whitespace.	^ true! !!MCFileTreeJsonParser methodsFor: 'parsing' stamp: 'dkh 2/16/2012 14:39:25'!parse	| result |	result := self whitespace; parseValue.	stream atEnd		ifFalse: [ self error: 'end of input expected' ].	^ result! !!MCFileTreeJsonParser methodsFor: 'parsing' stamp: 'dkh 2/16/2012 14:39:25'!parseArray	| result |	self expect: '['.	result := self createArray.	(self match: ']')		ifTrue: [ ^ result ].	[ stream atEnd ] whileFalse: [		result := self			addValue: self parseValue			to: result.		(self match: ']') 			ifTrue: [ ^ result ].		self expect: ',' ].	self error: 'end of array expected'! !!MCFileTreeJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 2/16/2012 14:39:25'!parseCharacter	| char |	(char := stream next) = $\ 		ifFalse: [ ^ char ].	(char := stream next) = $" 		ifTrue: [ ^ char ].	char = $\		ifTrue: [ ^ char ].	char = $/		ifTrue: [ ^ char ].	char = $b		ifTrue: [ ^ Character backspace ].	char = $f		ifTrue: [ ^ Character newPage ].	char = $n		ifTrue: [ ^ Character lf ].	char = $r		ifTrue: [ ^ Character cr ].	char = $t		ifTrue: [ ^ Character tab ].	char = $u		ifTrue: [ ^ self parseCharacterHex ].	self error: 'invalid escape character \' , (String with: char)! !!MCFileTreeJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 2/16/2012 14:39:25'!parseCharacterHex	| value |	value := self parseCharacterHexDigit.	3 timesRepeat: [ value := (value << 4) + self parseCharacterHexDigit ].	^ Character codePoint: value! !!MCFileTreeJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 4/6/2012 15:56:14'!parseCharacterHexDigit    | digit |    stream atEnd        ifFalse: [             digit := stream next charCode.            (digit between: 48 and: 57)                ifTrue: [ ^ digit - 48 ].	"$0"	"$9"            (digit between: 65 and: 70)                ifTrue: [ ^ digit - 55 ].	"$A"	"$F"            (digit between: 97 and: 102)                ifTrue: [ ^ digit - 87 ]	"$a"	"$f" ].    self error: 'hex-digit expected'! !!MCFileTreeJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 2/16/2012 14:39:25'!parseNumber	| negated number |	negated := stream peek = $-.	negated ifTrue: [ stream next ].	number := self parseNumberInteger.	(stream peek = $.) ifTrue: [		stream next. 		number := number + self parseNumberFraction ].	(stream peek = $e or: [ stream peek = $E ]) ifTrue: [		stream next.		number := number * self parseNumberExponent ].	negated ifTrue: [ number := number negated ].	^ self whitespace; createNumber: number! !!MCFileTreeJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 4/6/2012 15:56:14'!parseNumberExponent    | number negated |    number := 0.    negated := stream peek = $-.    (negated or: [ stream peek = $+ ])        ifTrue: [ stream next ].    [ stream atEnd not and: [ stream peek isDigit ] ] whileTrue: [ number := 10 * number + (stream next charCode - 48) ].    negated        ifTrue: [ number := number negated ].    ^ 10 raisedTo: number! !!MCFileTreeJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 4/6/2012 15:56:14'!parseNumberFraction    | number power |    number := 0.    power := 1.0.    [ stream atEnd not and: [ stream peek isDigit ] ]        whileTrue: [             number := 10 * number + (stream next charCode - 48).            power := power * 10.0 ].    ^ number / power! !!MCFileTreeJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 4/6/2012 15:56:14'!parseNumberInteger    | number |    number := 0.    [ stream atEnd not and: [ stream peek isDigit ] ] whileTrue: [ number := 10 * number + (stream next charCode - 48) ].    ^ number! !!MCFileTreeJsonParser methodsFor: 'parsing' stamp: 'dkh 2/16/2012 14:39:25'!parseObject	| result |	self expect: '{'.	result := self createObject.	(self match: '}')		ifTrue: [ ^ result ].	[ stream atEnd ] whileFalse: [		result := self			addProperty: self parseProperty			to: result.		(self match: '}')			ifTrue: [ ^ result ].		self expect: ',' ].	self error: 'end of object expected'! !!MCFileTreeJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 2/16/2012 14:39:25'!parseProperty	| name value |	name := self parseString.	self expect: ':'.	value := self parseValue.	^ self createProperty: name with: value.! !!MCFileTreeJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 2/16/2012 14:39:25'!parseString	| result |	self expect: '"'.	result := WriteStream on: String new.	[ stream atEnd or: [ stream peek = $" ] ] 		whileFalse: [ result nextPut: self parseCharacter ].	^ self expect: '"'; createString: result contents! !!MCFileTreeJsonParser methodsFor: 'parsing' stamp: 'dkh 2/16/2012 14:39:25'!parseValue	| char |	stream atEnd ifFalse: [ 		char := stream peek.		char = ${			ifTrue: [ ^ self parseObject ].		char = $[			ifTrue: [ ^ self parseArray ].		char = $"			ifTrue: [ ^ self parseString ].		(char = $- or: [ char between: $0 and: $9 ])			ifTrue: [ ^ self parseNumber ].		(self match: 'true')			ifTrue: [ ^ self createTrue ].		(self match: 'false')			ifTrue: [ ^ self createFalse ].		(self match: 'null')			ifTrue: [ ^ self createNull ] ].	self error: 'invalid input'! !!MCFileTreeJsonParser methodsFor: 'private' stamp: 'dkh 2/16/2012 14:39:25'!whitespace	"Strip whitespaces from the input stream."	[ stream atEnd not and: [ stream peek isSeparator ] ]		whileTrue: [ stream next ]! !!Object methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonForHtmlOn: aStream indent: startIndent    self writeCypressJsonOn: aStream forHtml: true indent: startIndent! !!Object methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonOn: aStream forHtml: forHtml indent: startIndent    "by default ignore <forHtml> ... <forHtml> is used for Dictionary and Array, i.e., container objects and String which actually encodes itself differently for HTML"    ^ self subclassResponsibility! !!Object methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonOn: aStream indent: startIndent    self writeCypressJsonOn: aStream forHtml: false indent: startIndent! !!Array methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonOn: aStream forHtml: forHtml indent: startIndent    "by default ignore <forHtml> ... <forHtml> is used for Dictionary and Array, i.e., container objects and String which actually encodes itself differently for HTML"    | indent |    aStream        nextPutAll: '[';        lf.    indent := startIndent + 1.    1 to: self size do: [ :index |         | item |        item := self at: index.        aStream tab: indent.        item writeCypressJsonOn: aStream forHtml: forHtml indent: indent.        index < self size            ifTrue: [                 aStream                    nextPutAll: ',';                    lf ] ].    self size = 0        ifTrue: [ aStream tab: indent ].    aStream nextPutAll: ' ]'! !!Dictionary methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonForHtmlOn: aStream    self writeCypressJsonOn: aStream forHtml: true indent: 0! !!Dictionary methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonOn: aStream    self writeCypressJsonOn: aStream forHtml: false indent: 0.    aStream lf! !!Dictionary methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonOn: aStream forHtml: forHtml indent: startIndent    "by default ignore <forHtml> ... <forHtml> is used for Dictionary and Array, i.e., container objects and String which actually encodes itself differently for HTML"    | indent keys |    indent := startIndent.    aStream        nextPutAll: '{';        lf.    indent := indent + 1.    keys := self keys sort: [ :a :b | a <= b ].    1 to: keys size do: [ :index |         | key value |        key := keys at: index.        value := self at: key.        aStream tab: indent.        key writeCypressJsonOn: aStream forHtml: forHtml indent: indent.        aStream nextPutAll: ' : '.        value writeCypressJsonOn: aStream forHtml: forHtml indent: indent.        index < self size            ifTrue: [                 aStream                    nextPutAll: ',';                    lf ] ].    self size = 0        ifTrue: [ aStream tab: indent ].    aStream nextPutAll: ' }'! !!Boolean methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonOn: aStream forHtml: forHtml indent: startIndent    "by default ignore <forHtml> ... <forHtml> is used for Dictionary and Array, i.e., container objects and String which actually encodes itself differently for HTML"    aStream nextPutAll: self printString! !!MCFileTreeWriter class methodsFor: 'accessing' stamp: 'dkh 3/1/2012 13:09'!readerClass    "don't expect this message to be sent"    self shouldNotImplement! !!MCFileTreeWriter methodsFor: 'writing' stamp: 'dkh 8/10/2012 05:26'!addString: string at: fileNameOrPath    "fileNameOrPath may have one or two elements"   self addString: string at: fileNameOrPath encodedTo: 'utf8'! !!MCFileTreeWriter methodsFor: 'writing' stamp: 'dkh 7/7/2013 15:41:32'!addString: string at: fileNameOrPath encodedTo: ignored    "fileNameOrPath may have one or two elements"    "encodeTo: arg, because FileTree uses UTF8 by default"    | utils fullPath path |    utils := MCFileTreeFileUtils current.    path := MCFileTreePackageStructureStWriter useCypressWriter        ifTrue: [             fullPath := utils                buildPathFrom:                    {(MCFileTreeStCypressWriter monticelloMetaDirName).                    fileNameOrPath}.            utils ensureFilePathExists: fullPath relativeTo: self packageFileDirectory.            fullPath ]        ifFalse: [ fileNameOrPath ].    string isEmpty        ifFalse: [ utils writeStreamFor: path in: self packageFileDirectory do: [ :file | file nextPutAll: string ] ]! !!MCFileTreeWriter methodsFor: 'visiting' stamp: 'dkh 8/10/2012 07:12'!deleteExistingPackageStructureFor: members    "destroy .tree and .pkg directory structure .. otherwise it won't be pretty"    | alternateDirName alternateDir packageDirectoryName |    (self fileUtils directoryExists: self packageFileDirectory)        ifTrue: [ self fileUtils deleteAll: self packageFileDirectory ].    packageDirectoryName := self fileUtils directoryName: self packageFileDirectory.    alternateDirName := (packageDirectoryName endsWith: '.pkg')        ifTrue: [ members first , '.tree' ]        ifFalse: [             (packageDirectoryName endsWith: '.tree')                ifTrue: [ members first , '.pkg' ]                ifFalse: [                     (packageDirectoryName endsWith: '.package')                        ifTrue: [ members first , '.pkg' ] ] ].    alternateDirName        ifNotNil: [             alternateDir := self fileUtils directoryFromPath: alternateDirName relativeTo: stream directory.            (self fileUtils directoryExists: alternateDir)                ifTrue: [ self fileUtils deleteAll: alternateDir ] ]! !!MCFileTreeWriter methodsFor: 'accessing' stamp: 'dkh 8/10/2012 07:05'!fileUtils    ^ MCFileTreeFileUtils current! !!MCFileTreeWriter methodsFor: 'writing' stamp: 'dkh 2/16/2012 14:49:00'!flush	! !!MCFileTreeWriter methodsFor: 'visiting' stamp: 'dkh 8/10/2012 14:01'!initializePackageFileDirectoryCache    cachedPackageFileDirectoryEntries := Dictionary new.    self packageFileDirectory entries        do: [ :entry |             entry isDirectory                ifTrue: [ cachedPackageFileDirectoryEntries at: entry name put: (self fileUtils directoryFromEntry: entry) ] ]! !!MCFileTreeWriter methodsFor: 'writing' stamp: 'dkh 8/10/2012 07:14'!packageFileDirectory    packageFileDirectory        ifNil: [ packageFileDirectory := self fileUtils directoryFromPath: directory relativeTo: stream directory ].    ^ packageFileDirectory! !!MCFileTreeWriter methodsFor: 'writing' stamp: 'dkh 07/07/2013 22:10'!repository  ^ stream! !!MCFileTreeWriter methodsFor: 'accessing' stamp: 'dkh 2/29/2012 13:59'!snapshotWriterClass	^ MCFileTreeAbstractStWriter! !!MCFileTreeWriter methodsFor: 'visiting' stamp: 'dkh 8/10/2012 07:16'!subPackageFileDirectoryFor: directoryNameOrPath    ^ cachedPackageFileDirectoryEntries        at: directoryNameOrPath        ifAbsentPut: [             | dir |            dir := self fileUtils directoryFromPath: directoryNameOrPath relativeTo: self packageFileDirectory.            self fileUtils ensureDirectoryExists: dir.            dir ]! !!MCFileTreeWriter methodsFor: 'visiting' stamp: 'dkh 2/16/2012 14:49:00'!writeSnapshot: aSnapshot	(self snapshotWriterClass on: self) writeDefinitions: aSnapshot definitions! !!MCFileTreeWriter methodsFor: 'visiting' stamp: 'dkh 8/10/2012 14:51'!writeVersion: aVersion    | members |    directory := (members := MCFileTreeRepository parseName: aVersion info name) last.    self deleteExistingPackageStructureFor: members.    self fileUtils ensureDirectoryExists: self packageFileDirectory.    self initializePackageFileDirectoryCache.    super writeVersion: aVersion! !!Number methodsFor: '*monticellofiletree-core' stamp: 'dkh 4/6/2012 15:56:14'!writeCypressJsonOn: aStream forHtml: forHtml indent: startIndent    "by default ignore <forHtml> ... <forHtml> is used for Dictionary and Array, i.e., container objects and String which actually encodes itself differently for HTML"    aStream nextPutAll: self printString! !"MonticelloFileTree-Core"!SystemOrganization addCategory: #'MonticelloFileTree-FileDirectory-Utilities'!MCFileTreeFileUtils subclass: #MCFileTreeFileDirectoryUtils	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-FileDirectory-Utilities'!!DirectoryEntryFile methodsFor: '*monticellofiletree-filedirectory-utilities' stamp: 'dkh 2/16/2012 14:49:00'!readStreamDo: aBlock	^ directory readOnlyFileNamed: self name do: aBlock! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/8/2012 21:25'!default    ^ FileDirectory default! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/8/2012 22:12'!deleteAll: aDirectory    ^ aDirectory recursiveDelete! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/8/2012 21:48'!directoryExists: aDirectory    ^ aDirectory exists! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 13:46'!directoryFromEntry: directoryEntry    ^ directoryEntry asFileDirectory! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 09:12'!directoryFromPath: directoryPath    ^ FileDirectory on: directoryPath! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 05:18'!directoryFromPath: directoryPath relativeTo: aDirectory    ^ aDirectory directoryNamed: directoryPath! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 06:43'!directoryName: aDirectory    ^ aDirectory localName! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 07:50'!directoryPathString: aDirectory    ^ aDirectory pathName! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 05:22'!ensureDirectoryExists: aDirectory    aDirectory assureExistence! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 05:25'!ensureFilePathExists: fileNameOrPath relativeTo: aDirectory    FileDirectory splitName: fileNameOrPath to: [ :fPath :fname | (aDirectory directoryNamed: fPath) assureExistence ]! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/9/2012 15:50'!filePathExists: filePath relativeTo: aDirectory    ^ aDirectory fileExists: (aDirectory fullNameFor: filePath)! !!MCFileTreeFileDirectoryUtils class methodsFor: 'initialization' stamp: 'dkh 8/9/2012 08:29'!initialize    "self initialize"    self install! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/9/2012 09:33'!parentDirectoryOf: aDirectory    ^ aDirectory containingDirectory! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/8/2012 19:21'!pathNameDelimiter    ^ FileDirectory pathNameDelimiter! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/10/2012 06:31'!readStreamFor: filePath in: aDirectory do: aBlock    ^ aDirectory fileNamed: filePath do: aBlock! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/9/2012 15:38'!resolvePath: path in: aDirectory    ^ aDirectory directoryNamed: path! !!MCFileTreeFileDirectoryUtils class methodsFor: 'utilities' stamp: 'dkh 8/9/2012 09:44'!writeStreamFor: filePath in: aDirectory do: aBlock    aDirectory forceNewFileNamed: filePath do: aBlock! !!FileDirectory methodsFor: '*monticellofiletree-filedirectory-utilities' stamp: 'dkh 8/10/2012 09:10'!fileTreeUtilityClass    ^ MCFileTreeFileDirectoryUtils! !"MonticelloFileTree-FileDirectory-Utilities"!Installer ss3    project: 'FileTree';    install: 'ConfigurationOfFileTree'.((Smalltalk at: #ConfigurationOfFileTree) project version: #'stable') load.!Installer gemsource    project: 'metacello';    addPackage: 'ConfigurationOfMetacello';    install.!SystemOrganization addCategory: #ConfigurationOfWebClient!Object subclass: #ConfigurationOfWebClient	instanceVariableNames: 'project'	classVariableNames: 'LastVersionLoad'	poolDictionaries: ''	category: 'ConfigurationOfWebClient'!!ConfigurationOfWebClient commentStamp: 'ar 5/5/2010 21:25' prior: 0!Metacello configuration for WebClient.	ConfigurationOfWebClient load.!!ConfigurationOfWebClient class methodsFor: 'accessing' stamp: 'PaulDeBruicker 8/2/2010 20:33'!bootstrapPackage: aString from: aPath 	| repository version |	repository := MCHttpRepository				location: aPath				user: ''				password: ''.	repository		versionReaderForFileNamed: aString , '.mcz'		do: [:reader | 			version := reader version.			version load.			version workingCopy repositoryGroup addRepository: repository]! !!ConfigurationOfWebClient class methodsFor: 'accessing' stamp: 'PaulDeBruicker 8/2/2010 20:33'!ensureMetacello	"Bootstrap Gofer (if necessary), load latest mcz file for ConfigurationOfMetacello (using old 	 Gofer API), then load the latest version of Metacello itself."	Smalltalk at: #MetacelloProject ifAbsent: [ | error |		"list of repositories to try, in case primary repository is not accessible"		(Array 			with: 'http://www.squeaksource.com/MetacelloRepository' 			with: 'http://seaside.gemstone.com/ss/metacello') do: [:repositoryUrl |				([					Smalltalk at: #Gofer ifAbsent: [					"Current version of Gofer from which to bootstrap - as of 1.0-beta.21"						self bootstrapPackage: 'Gofer-Core-lr.115' from: repositoryUrl ].					Smalltalk at: #Gofer ifPresent: [:goferClass | | gofer |						gofer := goferClass new							url: repositoryUrl;							yourself.						[ gofer addPackage: 'ConfigurationOfMetacello' ] on: Warning do: [:ex | ex resume ].						gofer load ]]							on: Error							do: [ :ex |								error := ex.								Transcript 									cr; 									show: 'failed ensureMetacello: ';									show: ex description printString;									show: '...retrying'.								"try again"								ex return: nil ]) ~~ nil					ifTrue: [						"load 'default' group of Metacello"						(Smalltalk at: #ConfigurationOfMetacello) perform: #load.						^self ]].		"shouldn't get here unless the load failed ... throw an error"		self error: 'retry with alternate repository failed: ', error description printString ]! !!ConfigurationOfWebClient class methodsFor: 'accessing' stamp: 'PaulDeBruicker 8/2/2010 20:33'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfWebClient class methodsFor: 'accessing' stamp: 'PaulDeBruicker 8/2/2010 20:33'!lastMetacelloVersionLoad	"Answer the last version loaded and the list of packages loaded for that version."	LastVersionLoad == nil ifTrue: [ LastVersionLoad := nil -> 'default' ].	^LastVersionLoad! !!ConfigurationOfWebClient class methodsFor: 'accessing' stamp: 'PaulDeBruicker 8/2/2010 20:34'!load	"self load"	^self project latestVersion load! !!ConfigurationOfWebClient class methodsFor: 'accessing' stamp: 'PaulDeBruicker 8/2/2010 20:34'!metacelloVersion: versionString loads: anArrayOrString	"Stash the last version loaded and the list of packages loaded for that version. The list	 of packages will be used by the tools when doing 'Load Package Version'"	LastVersionLoad := versionString -> anArrayOrString! !!ConfigurationOfWebClient class methodsFor: 'accessing' stamp: 'ar 5/5/2010 21:11'!project	^self new project! !!ConfigurationOfWebClient class methodsFor: 'accessing' stamp: 'PaulDeBruicker 8/2/2010 20:34'!unloadMetacello	Smalltalk at: #ConfigurationOfMetacello ifPresent: [:cls | cls unloadMetacello ]! !!ConfigurationOfWebClient methodsFor: 'baselines' stamp: 'DaleHenrichs 7/3/2010 11:31'!baseline10: spec	<version: '1.0-baseline'>	spec for: #common do:[		spec blessing: #baseline.		spec repository: 'http://www.squeaksource.com/WebClient'.		"Just the fact it exists"		spec package: 'WebClient-Core'.		"Tests require existence of Core"		spec package: 'WebClient-Tests' with:[spec requires: 'WebClient-Core'].		"Documentation doesn't require Core/Tests, but HelpSystem"		spec package: 'WebClient-Help' with:[spec requires: 'HelpSystem'].		"HTTP requires core. Except on Pharo where it also requires Pharo		(i.e., order HTTP after Core+Pharo). Expressed below via #includes:"		spec package: 'WebClient-HTTP' with:[spec requires: 'WebClient-Core'].				"Q: HelpSystem - will this always been loaded? It should only be loaded		if WebClient-Help is loaded. A: Unnecessary to be explicit since Help is		in the implicit default group already and unless loading the implicit		default group HelpSystem will only be loaded if required."		spec project: 'HelpSystem' with:[			"Copied verbatim from MetacelloReferenceConfig.			Don't understand all of it and not covered in tutorials."			spec 				className: 'ConfigurationOfHelpSystem';				repository: 'http://www.squeaksource.com/MetacelloRepository'.		].			"Just copy and pasted, not sure this is the right way."		spec project: 'Seaside' with:[			spec 				className: 'ConfigurationOfSeaside30';				repository: 'http://www.squeaksource.com/MetacelloRepository'.		].			"WebClient-Seaside requires WebClient-Core and Seaside"		spec package: 'WebClient-Seaside' with: [ 		 	spec requires: #('WebClient-Core' 'Seaside' ) ].	].	spec for: #pharo do:[		"Include WebClient-Pharo with WebClient-Core when on Pharo"		spec 			package: 'WebClient-Core' with:[spec includes: 'WebClient-Pharo'];			package: 'WebClient-Pharo' with: [ spec requires: 'WebClient-Core'].	].! !!ConfigurationOfWebClient methodsFor: 'baselines' stamp: 'JohnMcKeon 4/4/2012 23:31'!baseline11: spec 	<version: '1.1-baseline'>		spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://www.squeaksource.com/WebClient'.			spec project: 'HelpSystem' with:[			spec 				className: 'ConfigurationOfHelpSystem';				repository: 'http://www.squeaksource.com/MetacelloRepository'.		].		spec project: 'Seaside' with:[			spec 				className: 'ConfigurationOfSeaside30';				repository: 'http://www.squeaksource.com/MetacelloRepository'.		].					spec 			package: 'WebClient-Core';			package: 'WebClient-HTTP' with: [ spec requires: 'WebClient-Core' ];			package: 'WebClient-Help' with: [ spec requires: 'HelpSystem' ];			package: 'WebClient-Pharo' with: [ spec requires: 'WebClient-Core' ];			package: 'WebClient-Seaside' with: [ spec requires: 'WebClient-Core' ];			package: 'WebClient-Tests' with: [ spec requires: 'WebClient-Core' ].		spec			group: 'default' with: #('Core' 'Tests' 'Help');			group: 'Core' with: #('WebClient-Core');			group: 'Help' with: #('WebClient-Help');			group: 'HTTP' with: #('WebClient-HTTP');			group: 'Server' with: #('WebClient-Seaside');			group: 'Tests' with: #('WebClient-Tests');			group: 'Dev' with: #('default' 'HTTP' 'Server').. ].					spec for: #pharo do:[		spec 			package: 'WebClient-Core' with:[spec includes: 'WebClient-Pharo'];			package: 'WebClient-Pharo' with: [ spec requires: 'WebClient-Core'].	].! !!ConfigurationOfWebClient methodsFor: 'baselines' stamp: 'JohnMcKeon 4/4/2012 23:52'!baseline13: spec 	<version: '1.3-baseline'>		spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://www.squeaksource.com/WebClient'.			spec project: 'HelpSystem' with:[			spec 				className: 'ConfigurationOfHelpSystem';				repository: 'http://www.squeaksource.com/MetacelloRepository'.		].		spec project: 'Seaside30' with:[			spec 				className: 'ConfigurationOfSeaside30';				repository: 'http://www.squeaksource.com/MetacelloRepository'.		].					spec 			package: 'WebClient-Core';			package: 'WebClient-HTTP' with: [ spec requires: 'WebClient-Core' ];			package: 'WebClient-Help' with: [ spec requires: 'HelpSystem' ];			package: 'WebClient-Pharo' with: [ spec requires: 'WebClient-Core' ];			package: 'WebClient-Seaside' with: [ spec requires: 'WebClient-Core' ];			package: 'WebClient-Tests' with: [ spec requires: 'WebClient-Core' ].		spec			group: 'default' with: #('Core' 'Tests' 'Help');			group: 'Core' with: #('WebClient-Core');			group: 'Help' with: #('WebClient-Help');			group: 'HTTP' with: #('WebClient-HTTP');			group: 'Seaside' with: #('Seaside30' 'default' 'WebClient-Seaside');			group: 'Tests' with: #('WebClient-Tests');			group: 'Dev' with: #('default' 'HTTP' 'Seaside').. ].					spec for: #pharo do:[		spec 			package: 'WebClient-Core' with:[spec includes: 'WebClient-Pharo'];			package: 'WebClient-Pharo' with: [ spec requires: 'WebClient-Core'].	].! !!ConfigurationOfWebClient methodsFor: 'baselines' stamp: 'topa 2/26/2013 10:30'!baseline14: spec 	<version: '1.4-baseline'>		spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://www.squeaksource.com/WebClient'.			spec project: 'HelpSystem' with:[			spec 				className: 'ConfigurationOfHelpSystem';				repository: 'http://www.squeaksource.com/MetacelloRepository' ].			spec 			package: 'WebClient-Core';			package: 'WebClient-HTTP' with: [ spec requires: 'WebClient-Core' ];			package: 'WebClient-Help' with: [ spec requires: 'HelpSystem' ];			package: 'WebClient-Pharo' with: [ spec requires: 'WebClient-Core' ];			package: 'WebClient-Tests' with: [ spec requires: 'WebClient-Core' ].		spec			group: 'default' with: #('Core' 'Tests' 'Help');			group: 'Core' with: #('WebClient-Core');			group: 'Help' with: #('WebClient-Help');			group: 'HTTP' with: #('WebClient-HTTP');			group: 'Tests' with: #('WebClient-Tests');			group: 'Dev' with: #('default' 'HTTP'). ].					spec for: #pharo do:[		spec 			package: 'WebClient-Core' with:[spec includes: 'WebClient-Pharo'];			package: 'WebClient-Pharo' with: [ spec requires: 'WebClient-Core'] ].! !!ConfigurationOfWebClient methodsFor: 'baselines' stamp: 'topa 4/4/2013 19:21'!baseline15: spec 	<version: '1.5-baseline'>		spec for: #common do: [		spec blessing: #baseline.		spec description: 'Account for Repository change. HelpSystem is both in Squeak and Pharo.'.		spec repository: 'http://ss3.gemstone.com/ss/WebClient'.		spec 			package: 'WebClient-Core';			package: 'WebClient-HTTP' with: [ spec requires: 'WebClient-Core' ];			package: 'WebClient-Help';			package: 'WebClient-Pharo' with: [ spec requires: 'WebClient-Core' ];			package: 'WebClient-Tests' with: [ spec requires: 'WebClient-Core' ].		spec			group: 'default' with: #('Core' 'Tests' 'Help');			group: 'Core' with: #('WebClient-Core');			group: 'Help' with: #('WebClient-Help');			group: 'HTTP' with: #('WebClient-HTTP');			group: 'Tests' with: #('WebClient-Tests');			group: 'Dev' with: #('default' 'HTTP'). ].			spec for: #pharo do:[		spec 			package: 'WebClient-Core' with:[spec includes: 'WebClient-Pharo'];			package: 'WebClient-Pharo' with: [ spec requires: 'WebClient-Core'] ].! !!ConfigurationOfWebClient methodsFor: 'accessing' stamp: 'PaulDeBruicker 8/2/2010 20:33'!project	^ project ifNil: [ | constructor |		"Bootstrap Metacello if it is not already loaded"		self class ensureMetacello.		"Construct Metacello project"		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.		project := constructor project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!ConfigurationOfWebClient methodsFor: 'symbolic versions' stamp: 'topa 8/20/2015 16:08'!stable: spec	<symbolicVersion: #stable>	spec for: #'squeak4.1' version: '1.3'.	spec for: #'squeak4.2' version: '1.3'.	spec for: #common version: '1.5.3'.! !!ConfigurationOfWebClient methodsFor: 'version' stamp: 'DaleHenrichs 7/3/2010 11:32'!version10: spec	<version: '1.0' imports: #('1.0-baseline')>	spec for: #common do:[		spec blessing: #release.		spec			project: 'HelpSystem' with: '1.1';			project: 'Seaside' with: '3.0.0-alpha5.15'.		spec 			package: 'WebClient-Core' with: 'WebClient-Core-ar.16';			package: 'WebClient-Tests' with: 'WebClient-Tests-ar.7';			package: 'WebClient-Help' with: 'WebClient-Help-ar.5';			package: 'WebClient-HTTP' with: 'WebClient-HTTP-ar.1'.	].	spec for: #pharo do:[		spec blessing: #alpha.		spec package: 'WebClient-Pharo' with: 'WebClient-Pharo-ar.1'.	].! !!ConfigurationOfWebClient methodsFor: 'versions' stamp: 'PaulDeBruicker 8/2/2010 19:47'!version11: spec 	<version: '1.1' imports: #('1.1-baseline') >		spec for: #common do: [		spec blessing: #release.		spec			project: 'HelpSystem' with: '1.1';			project: 'Seaside' with: '3.0.0-rc1'.		spec 			package: 'WebClient-Core' with: 'WebClient-Core-ar.54';			package: 'WebClient-Tests' with: 'WebClient-Tests-ar.21';			package: 'WebClient-HTTP' with: 'WebClient-HTTP-ar.1';			package: 'WebClient-Seaside' with: 'WebClient-Seaside-ar.5';			package: 'WebClient-Help' with: 'WebClient-Tests-ar.9'.			].		spec for: #pharo do: [		spec blessing: #release.		spec 			package: 'WebClient-Pharo' with: 'WebClient-Pharo-ar.3'.]						! !!ConfigurationOfWebClient methodsFor: 'versions' stamp: 'MarcoSchmidt 10/12/2010 12:29'!version12: spec	<version: '1.2' imports: #('1.1')>	spec for: #common do: [		spec author: 'MarcoSchmidt'.		spec timestamp: '10/12/2010 12:29'.		spec blessing: #development.		spec 			project: 'HelpSystem' with: '1.1';			project: 'Seaside' with: '3.0.0-rc1'.		spec 			package: 'WebClient-Core' with: 'WebClient-Core-ar.81';			package: 'WebClient-Tests' with: 'WebClient-Tests-ar.36';			package: 'WebClient-HTTP' with: 'WebClient-HTTP-ar.1';			package: 'WebClient-Seaside' with: 'WebClient-Seaside-ar.5';			package: 'WebClient-Help' with: 'WebClient-Tests-ar.9'.].	spec for: #pharo do: [		spec blessing: #release.		spec package: 'WebClient-Pharo' with: 'WebClient-Pharo-ar.4'.].! !!ConfigurationOfWebClient methodsFor: 'versions' stamp: 'JohnMcKeon 4/5/2012 00:04'!version13: spec	<version: '1.3' imports: #('1.3-baseline')>	spec for: #common do: [		spec author: 'MarcoSchmidt'.		spec timestamp: '04/04/2012 12:29'.		spec blessing: #development.		spec 			project: 'HelpSystem' with: '1.1';			project: 'Seaside30' with: '3.0.7'.		spec 			package: 'WebClient-Core' with: 'WebClient-Core-ar.90';			package: 'WebClient-Tests' with: 'WebClient-Tests-ar.45';			package: 'WebClient-HTTP' with: 'WebClient-HTTP-ar.1';			package: 'WebClient-Seaside' with: 'WebClient-Seaside-ar.10';			package: 'WebClient-Help' with: 'WebClient-Help-ar.10'.].	spec for: #pharo do: [		spec blessing: #release.		spec package: 'WebClient-Pharo' with: 'WebClient-Pharo-ar.5'.].! !!ConfigurationOfWebClient methodsFor: 'versions' stamp: 'topa 2/26/2013 10:31'!version14: spec	<version: '1.4' imports: #('1.4-baseline')>	spec for: #common do: [		spec author: 'pmm'.  "fixed by topa on 26 February 2013 10:31:33 am"		spec timestamp: '08/27/2012 11:06'.		spec blessing: #development.		spec 			project: 'HelpSystem' with: '1.1'.		spec 			package: 'WebClient-Core' with: 'WebClient-Core-ar.90';			package: 'WebClient-Tests' with: 'WebClient-Tests-ar.45';			package: 'WebClient-HTTP' with: 'WebClient-HTTP-ar.1';			package: 'WebClient-Help' with: 'WebClient-Help-ar.10' ].	spec for: #pharo do: [		spec blessing: #release.		spec package: 'WebClient-Pharo' with: 'WebClient-Pharo-ar.5' ]! !!ConfigurationOfWebClient methodsFor: 'versions' stamp: 'topa 11/4/2014 00:17'!version151: spec	<version: '1.5.1' imports: #('1.5-baseline')>	spec for: #common do: [		spec author: 'topa'. 		spec timestamp: '11/4/2014 00:16'. "MetacelloPlatform current timestamp"		spec blessing: #release.		spec 			package: 'WebClient-Core' with: 'WebClient-Core-topa.94';			package: 'WebClient-Tests' with: 'WebClient-Tests-fbs.47';			package: 'WebClient-HTTP' with: 'WebClient-HTTP-ar.1';			package: 'WebClient-Help' with: 'WebClient-Help-ar.10' ].	spec for: #pharo do: [		spec package: 'WebClient-Pharo' with: 'WebClient-Pharo-ar.5' ]! !!ConfigurationOfWebClient methodsFor: 'versions' stamp: 'topa 4/9/2015 21:31'!version152: spec	<version: '1.5.2' imports: #('1.5-baseline')>	spec for: #common do: [		spec author: 'topa'. 		spec timestamp: '4/9/2015 21:31'. "MetacelloPlatform current timestamp"		spec blessing: #release.		spec 			package: 'WebClient-Core' with: 'WebClient-Core-topa.99';			package: 'WebClient-Tests' with: 'WebClient-Tests-fbs.47';			package: 'WebClient-HTTP' with: 'WebClient-HTTP-ar.1';			package: 'WebClient-Help' with: 'WebClient-Help-ar.10' ].	spec for: #pharo do: [		spec package: 'WebClient-Pharo' with: 'WebClient-Pharo-ar.5' ]! !!ConfigurationOfWebClient methodsFor: 'versions' stamp: 'topa 8/20/2015 16:08'!version153: spec	<version: '1.5.3' imports: #('1.5-baseline')>	spec for: #common do: [		spec author: 'topa'. 		spec timestamp: '8/20/2015 16:04'. "MetacelloPlatform current timestamp"		spec blessing: #release.		spec 			package: 'WebClient-Core' with: 'WebClient-Core-ul.100';			package: 'WebClient-Tests' with: 'WebClient-Tests-topa.48';			package: 'WebClient-HTTP' with: 'WebClient-HTTP-topa.2';			package: 'WebClient-Help' with: 'WebClient-Help-ar.10' ].	spec for: #pharo do: [		spec package: 'WebClient-Pharo' with: 'WebClient-Pharo-ar.5' ]! !!ConfigurationOfWebClient methodsFor: 'versions' stamp: 'topa 4/5/2013 07:33'!version15: spec	<version: '1.5' imports: #('1.5-baseline')>	spec for: #common do: [		spec author: 'topa'. 		spec timestamp: '4/4/2013 19:22'. "MetacelloPlatform current timestamp"		spec blessing: #release.		spec 			package: 'WebClient-Core' with: 'WebClient-Core-topa.93';			package: 'WebClient-Tests' with: 'WebClient-Tests-fbs.47';			package: 'WebClient-HTTP' with: 'WebClient-HTTP-ar.1';			package: 'WebClient-Help' with: 'WebClient-Help-ar.10' ].	spec for: #pharo do: [		spec package: 'WebClient-Pharo' with: 'WebClient-Pharo-ar.5' ]! !"ConfigurationOfWebClient"!!SqueakSSL class methodsFor: 'examples' stamp: 'ar 6/17/2012 14:56' prior: 58282152!ensureSampleCertFile	"On Unix, we can simply create a valid cert file"	| certName file |	SqueakSSL platformName = 'unix' ifFalse:[^self].	certName := self name, 'Cert.pem'.	(FileDirectory default fileExists: certName) ifFalse:[		file := FileDirectory default newFileNamed: certName.		[file nextPutAll: self exampleCertFile] ensure:[file close].	].	^FileDirectory default fullNameFor: certName.! !!SecureSocketStream methodsFor: 'initialize' stamp: 'ar 11/17/2011 17:10' prior: 50763697!sslConnect	"Perform the SSL client handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete."	| inbuf squeakSSL result |	inbuf := ''.	squeakSSL := SqueakSSL new.	"Perform the SSL handshake"	[[result := squeakSSL connect: inbuf from: 1 to: inbuf size into: sendBuf.	result = 0] whileFalse:[		"Check for errors first"		result < -1 ifTrue:[^self error: 'SSL connect failed with code: ', result].		"If a token has been produced in the handshake, send it to the remote"		result > 0 ifTrue:[			self nextPutAll: (sendBuf copyFrom: 1 to: result).			self flush.		].		"Read more input and repeat"		self receiveData.		inbuf := self nextAvailable.	].	"There should be no pending data at this point, ensure it is so.	XXXX: If you ever see this problem, please inform me."	self isInBufferEmpty ifFalse:[self error: 'Unexpected input data'].	"We are connected. From here on, encryption will take place."	ssl := squeakSSL.	] ifCurtailed:[		"Make sure we destroy the platform handle if the handshake gets interrupted"		squeakSSL destroy.	].! !!SecureSocket class methodsFor: 'examples' stamp: 'ar 6/17/2012 11:13' prior: 65019771!google: query	"An example HTTPS query to encrypted.google.com.	Example:		SecureSocket google: 'squeak'.		SecureSocket google: 'SqueakSSL'.	"	| hostName address socket |	"Change the host name to try an https request to some other host"	hostName := 'encrypted.google.com'..	address := NetNameResolver addressForName: hostName.	socket := SecureSocket newTCP.	"Connect the TCP socket"	socket connectTo: address port: 443.	socket waitForConnectionFor: 10.	["Handle the client handshake"	socket sslConnect.	"Verify that the cert is valid"	socket certState = 0 ifFalse:[		self error: 'The certificate is invalid (code: ', socket certState,')'.	].	"If the certificate is valid, make sure we're were we wanted to go"	(socket peerName match: hostName) ifFalse:[		self error: 'Host name mismatch: ', socket peerName.	].	"Send encrypted data"	socket sendData:		'GET /search?q=', query,' HTTP/1.0', String crlf,		'Host: ', hostName, String crlf,		'Connection: close', String crlf,		String crlf.	"Wait for the response"	^String streamContents:[:s|		[[true] whileTrue:[s nextPutAll: socket receiveData]]			on: ConnectionClosed, ConnectionTimedOut do:[:ex| ex return].	]] ensure:[socket destroy].! !!SecureSocket methodsFor: 'connect' stamp: 'ar 6/17/2012 11:03' prior: 65014545!sslConnect	"Perform the SSL client handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete."	| inbuf squeakSSL result |	inbuf := ''.	squeakSSL := SqueakSSL new.	"Perform the SSL handshake"	[[result := squeakSSL connect: inbuf from: 1 to: inbuf size into: sendBuf.	result = 0] whileFalse:[		"Check for errors first"		result < -1 ifTrue:[^self error: 'SSL connect failed with code: ', result].		"If a token has been produced in the handshake, send it to the remote"		result > 0 ifTrue:[self sendData: (sendBuf copyFrom: 1 to: result)].		"Read more input and repeat"		inbuf := self receiveData.	].	"We are connected. From here on, encryption will take place."	ssl := squeakSSL.	] ifCurtailed:[		"Make sure we destroy the platform handle if the handshake gets interrupted"		squeakSSL destroy.	].! !SecureSocket removeSelector: #sslConnectTo:!SecureSocket removeSelector: #accept!SecureSocketStream removeSelector: #sslConnectTo:!SqueakSSL removeSelector: #serverName:!"SqueakSSL-Core"!Object subclass: #ConfigurationOf	instanceVariableNames: 'project'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Base'!!ConfigurationOf commentStamp: 'dkh 5/30/2012 16:31' prior: 0!You must use a *configuration* when your project is stored in arepository using `.mcz` files.If you are using a source code manager (SCM) like [git][1] and havecreated a *baseline* (see the [**BaselineOf** class comment][3] for more info)you may use a *configuration* to associate a specificgit commit (SHA, branch name, tag name) with a [Metacello version][2].To create a new Metacello configuration:1. Create a subclass of the **ConfigurationOf** class. The configuration   class for your project should be names by appending the name of   your project to the string `ConfigurationOf`. The name of the   category and package should be the same as the name of the class:    ```Smalltalk    ConfigurationOf subclass: #ConfigurationOfExample      instanceVariableNames: ''      classVariableNames: ''      poolDictionaries: ''      category: 'ConfigurationOfExample'    ```2. Create a **baselineXXXX:** method where you specify the structure of your project:    ```Smalltalk    baseline0100: spec      <baseline: '1.0-baseline'>      spec for: #common do: [        spec repository: 'http://ss3.gemstone.com/ss/Example'.        spec          package: 'Example-Core';          package: 'Example-Tests' with: [            spec requires: 'Example-Core' ]].    ```3. Create a **versionXXXX:** method where you specify the specific   versions of the packages to be loaded for this version:    ```Smalltalk    version01000: spec      <version: '1.0' imports: #('1.0-baseline')>      spec for: #common do: [        spec blessing: #release.        spec          package: 'Example-Core' with: 'Example-Core';          package: 'Example-Tests' with: 'Example-Tests' ].    ```4. Create a Monticello package for your **ConfigurationOf** class and save it in the repository where your packages are stored. [1]: http://git-scm.com/[2]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md#metacello-version-numbers[3]: https://github.com/dalehenrich/metacello-work/blob/master/repository/Metacello-Base.package/BaselineOf.class/README.md!ConfigurationOf subclass: #BaselineOf	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Base'!!BaselineOf commentStamp: 'dkh 5/30/2012 16:30' prior: 0!You should use a *baseline* when you are using a disk-based sourcecode manager (SCM) like [git][1].When using a disk-based SCM it is not necessary to use the Metacello*version* method, because it is intended for use with `.mcz` files. With a disk-based SCM you only need a single `baseline:` method. Whenyou change the structure of your project you can change the baseline andsave everything in a single commit. So multiple `baseline:` methods areno longer needed.You may still need a *configuration* when using a *baseline*. The[Sample project][3] on GitHub has a good example of a configuration usedin conjunction with a *baseline*. See the [**ConfigurationOf** class comment][2] for information on creating a *configuration*.To create a new Metacello baseline:1. Create a subclass of the **BaselineOf** class. The baseline   class for your project should be named by appending the name of   your project to the string `BaselineOf`. The name of the category and   package should be the same as the name of the class:    ```Smalltalk    BaselineOf subclass: #BaselineOfExample      instanceVariableNames: ''      classVariableNames: ''      poolDictionaries: ''      category: 'BaselineOfExample'    ```2. Create a **baseline:** method where you specify the structure of your project:    ```Smalltalk    baseline: spec      <baseline>      spec for: #common do: [        spec          package: 'Example-Core';          package: 'Example-Tests' with: [            spec requires: 'Example-Core' ]].    ```3. Create a Monticello package for your **BaselineOf** class and save it in the repository where your packages are stored.[1]: http://git-scm.com/[2]: https://github.com/dalehenrich/metacello-work/blob/master/repository/Metacello-Base.package/ConfigurationOf.class/README.md[3]: https://github.com/dalehenrich/sample/tree/configuration/ConfigurationOfSample.package/ConfigurationOfSample.class!Object subclass: #Metacello	instanceVariableNames: 'executorSpec statements'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Base'!!Metacello commentStamp: 'dkh 7/28/2012 20:04' prior: 0!# Metacello User GuideIn this guide we'll take a walk through a couple of common developmentscenarios and highlight some of the features of the *Metacello ScriptingAPI*.*For installatation and more detailed documentation on the MetacelloScripting API, see the [Metcello Scripting API Documentation][1].*## IntroductionThe number one job of the *Metacello Scripting API* is to simplify thejob of loading projects into your image. As you are probably alltoo aware, today it's a two step process where you first load theconfiguration into your image using [Gofer][2] and then load yourproject using Metacello:```SmalltalkGofer new  package: 'ConfigurationOfSeaside30';  squeaksource: 'MetacelloRepository';  load.((Smalltalk at: #ConfigurationOfSeaside30) version: #stable) load.```In the early days of Metacello (and Gofer) this was a great improvementover the alternatives, but today, 3 years after the introduction ofMetacello, there should be a better way...and there is.Using the *Metacello Scripting API* the above expression reduces to thefollowing:```SmalltalkMetacello new  configuration: 'Seaside30';  load.```## LoadingIn this example of the [`load` command][5] we are leveraging a couple ofdefault values, namely the `version` of the project and the `repository` where the**ConfigurationOfSeaside** package can be found:```SmalltalkMetacello new  configuration: 'Seaside30';  load.```Here is a variantof the same expression with the (current) default values explicitly specified:```SmalltalkMetacello new  configuration: 'Seaside30';  version: #stable;  squeaksource: 'MetacelloRepository';  load.```The `version` attribute can be any legal [version number][10].`squeaksource` is a [repository shortcut][4]. You can also specify thefull [repository description][3] as follows:```SmalltalkMetacello new  configuration: 'Seaside30';  version: #stable;  repository: 'http://www.squeaksource.com/MetacelloRepository';  load.```##ListingOnce you've loaded one or more projects into your image, you may want tolist them. The following is an example of the [`list` command][6]:```SmalltalkMetacello image  configuration: [:spec | true ];  list.```The `image` message tells Metacello that you'd like to lookat only loaded configurations. The *block* argument to the`configuration:` message is used to *select* against the list of loaded[MetacelloProjectSpec][7] instances in the [registry][8].The `list` command itself returns a list of [MetacelloProjectSpec][7] instances that can be printed, inspected or otherwise manipulated.In addition to a *select block*, you can specify a *select collection*specifying the names of the projects you'd like to select:```SmalltalkMetacello registry  configuration: #('Seaside30' 'MetacelloPreview');  list.```The `registry` message tells Metacello that you'd like tolook at all projects in the [registry][8] whether or not they are loaded.The *collection* argument to the `configuration:` message is used to*select* against the list of project names in the [registry][8].The `list` command can also be used to look at configurations inMonticello repositories. For example:```SmalltalkMetacello new  configuration: [:spec | spec name beginsWith: 'Seaside'];  squeaksource: 'MetacelloRepository';  list.```lists the configurations whose names (sans the `ConfigurationOf`) beginwith `Seaside` in the `MetacelloRepositry` in the[Squeaksource](http://www.squeaksource.com) repostory.## GettingOnce you've loaded a project into your image the next logical step isupgrading your project to a new version. Let's say that a new `#stable` version of Seaside30 has been releasedand that you want to upgrade. This is a two step process: * [get a new version of the configuration][11]* [load the new version][12]### Get a new version of the configurationThe following expression gets the latest version of theconfiguration:```SmalltalkMetacello image  configuration: 'Seaside30';  get.```By using the `image` message, you can leverage the fact that the [registry][8] remembersfrom which repository you loaded the original version of the configuration.The `get` command simply downloads the latest version of theconfiguration package from the repository.You may download the configuration from a different repository:```SmalltalkMetacello image  configuration: 'Seaside30';  squeaksource: 'Seaside30;  get.```The `get` command will update the [registry][8] with the newrepository location information.You may also use the `get` command to load a configuration for a projectinto your image without actually loading the project itself:```SmalltalkMetacello image  configuration: 'SeasideRest';  squeaksource: 'Seaside30';  get.```The 'SeasideRest' project information will be registered in the [registry][8] and markedas *unloaded*.### Load the new versionOnce you've got a new copy of the Seaside30 configuration loaded into your image, you mayupgrade your image with the following expression:```SmalltalkMetacello image  configuration: 'Seaside30';  version: #stable;  load.```By using the `image` message, you are asking Metacello to look theproject up in the [registry][8] before performing theoperation, so it isn't necessary to supply all of the project details for everycommand operation.Of course, the `load` command updates the [registry][8].If you want to load a project for which you've already done a `get`(like the SeasideRest project earlier), you can do the following:```SmalltalkMetacello registry  configuration: 'SeasideRest';  version: #stable;  load.```In this case you use the `registry` message to indicate that you areinterested in both *loaded* and *unloaded* projects.##LockingLet's say that you are using an older version of Seaside30 (say 3.0.5)instead of the #stable version (3.0.7) and that your application doesn'twork with newer versions of Seaside30 (you've tried and it's more workto get you application to work with the newer version of Seaside30 thanit's worth).Let's also say that you want to try out something in theSeasideRest project, but when you try loading SeasideRest, you end uphaving Seaside 3.0.7 loaded as well. This is an unfortunate side effect of Metacello trying to *do the rightthing*, only in your case it is the wrong thing.Fortunately, the [`lock` command][9] can give you control. First youneed to `lock` the Seaside30 project:```SmalltalkMetacello image  configuration: 'Seaside30';  lock.```The `image` message tells Metacello to do a lookup in the list of loadedprojects and then to put a lock on the loaded version of the project.If you want you can specify which version of the project you wantlocked:```SmalltalkMetacello image  configuration: 'Seaside30';  version: '3.0.5';  lock.```After a project is locked an error (**MetacelloLockedProjectError**) is thrown when you attempt to load a project that has a dependency upon a different version of Seaside30. The error is thrown before any packages are actually loaded.### Bypassing locksLet's say that you want to load the SeasideRest project even though it mayrequire a version of Seaside30 that is later than the version that you havelocked. To do that you need to suppress the upgrade of the Seaside30project during the load of the SeasideRest project and you can do thatwith the use of the `onUpgrade:` message:```SmalltalkMetacello new  configuration: 'SeasideRest';  version: #stable;  onUpgrade: [:ex :existing :new |     existing baseName = 'Seaside30'      ifTrue: [ ex disallow ].    ex pass ];  load.```The `onUpgrade:` block tells Metacello to disallow the upgrade of anyproject whose `baseName` is `Seaside30` and to continue with the load.Of course if there are any explicit dependencies between SeasideRest andthe later version of Seaside30 (missing classes, etc.) then you may verywell get load errors or errors while using the SeasideRest, but that'sthe price you pay for not upgrading.### Upgrading a locked projectIf you want to explicitly upgrade a locked project, you can use the`load` command. The following command will upgrade Seaside30 to version3.0.6 even if it is locked: ```SmalltalkMetacello image  configuration: 'Seaside30';  version: '3.0.6';  lock.```The newly loaded of the project will continue to be locked.[1]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md[2]: http://www.lukas-renggli.ch/blog/gofer[3]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md#repository-descriptions[4]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md#repository-shortcuts[5]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md#loading[6]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md#listing[7]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md#metacelloprojectspec[8]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md#metacello-project-registry[9]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md#locking[10]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloScriptingAPI.md#metacello-version-numbers[11]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloUserGuide.md#get-a-new-version-of-the-configuration[12]: https://github.com/dalehenrich/metacello-work/blob/master/docs/MetacelloUserGuide.md#load-the-new-version!!BaselineOf methodsFor: 'accessing' stamp: 'dkh 5/31/2012 17:57:13'!projectClass    ^ MetacelloMCBaselineProject! !!BaselineOf methodsFor: 'accessing' stamp: 'dkh 6/22/2012 12:09'!versionNumberClass    ^ MetacelloVersionNumber! !!ConfigurationOf class methodsFor: 'private' stamp: 'dkh 05/08/2013 11:39'!bootstrapMetacelloFrom: repositoryUrl  "Corresponds to version 1.0.0-beta.32.6"  "KEEP MetacelloConfigTemplate class>>ensureMetacelloBaseConfiguration in synch!!"  | platformPkg |  self ensureGoferVersion: 'Gofer-Core-lr.115' repositoryUrl: repositoryUrl.  #('Metacello-Core-dkh.678' 'Metacello-MC-dkh.674')    do: [ :pkg | self bootstrapPackage: pkg from: repositoryUrl ].  platformPkg := Smalltalk    at: #'SystemVersion'    ifPresent: [ :cl |       | versionString |      versionString := cl current version.      (versionString beginsWith: 'Squeak')        ifTrue: [           (versionString beginsWith: 'Squeak3')            ifTrue: [ 'Metacello-Platform.squeak-dkh.5' ]            ifFalse: [ 'Metacello-Platform.squeak-dkh.22' ] ]        ifFalse: [           (versionString beginsWith: 'Pharo')            ifTrue: [               self bootstrapPackage: 'Metacello-PharoCommonPlatform-dkh.2' from: repositoryUrl.              (versionString beginsWith: 'Pharo2')                ifTrue: [ 'Metacello-Platform.pharo20-dkh.33' ]                ifFalse: [ 'Metacello-Platform.pharo-dkh.34' ] ] ] ].  self bootstrapPackage: platformPkg from: repositoryUrl! !!ConfigurationOf class methodsFor: 'private' stamp: 'dkh 9/4/2012 17:09'!bootstrapPackage: aString from: aPath    | repository version |    repository := (MCCacheRepository default includesVersionNamed: aString)        ifTrue: [ MCCacheRepository default ]        ifFalse: [ MCHttpRepository location: aPath user: '' password: '' ].    self        retry: [             repository                versionReaderForFileNamed: aString , '.mcz'                do: [ :reader |                     version := reader version.                    version load.                    version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOf class methodsFor: 'private' stamp: 'dkh 6/10/2012 22:01'!ensureGoferVersion: goferVersion repositoryUrl: repositoryUrl    "load the p=file goferVersion if Gofer isn't loaded or an earlier version of Gofer is currently loaded"    | goferVersionNumber wc pName |    (Smalltalk at: #'Gofer' ifAbsent: [  ]) == nil        ifTrue: [ ^ self bootstrapPackage: goferVersion from: repositoryUrl ].    goferVersionNumber := (goferVersion copyAfterLast: $.) asNumber.    wc := [ ((Smalltalk at: #'GoferPackageReference') name: 'Gofer') workingCopy ]        on: Error        do: [ :ex | ex return: ((Smalltalk at: #'GoferPackageReference') name: 'Gofer-Core') workingCopy ].    pName := wc ancestry ancestors first name.    (pName copyAfterLast: $.) asNumber <= goferVersionNumber        ifTrue: [ self bootstrapPackage: goferVersion from: repositoryUrl ]! !!ConfigurationOf class methodsFor: 'private' stamp: 'dkh 6/11/2012 11:05'!ensureMetacello    "Bootstrap Metacello and load the 'botstrap' group"    self ensureMetacello: #('batch')! !!ConfigurationOf class methodsFor: 'private' stamp: 'dkh 06/28/2013 16:07'!ensureMetacello: loadList  "Bootstrap Metacello, retry using alternate repository, if primary repository is not accessible"  Smalltalk    at: #'MetacelloProject'    ifAbsent: [       | version error gofer |      (Array        with: 'http://smalltalkhub.com/mc/dkh/metacello/main'        with: 'http://seaside.gemtalksystems.com/ss/metacello')        do: [ :repositoryUrl |           "bootstrap Metacello"          [           self bootstrapMetacelloFrom: repositoryUrl.          Smalltalk            at: #'ConfigurationOfMetacello'            ifAbsent: [               self                retry: [                   gofer := (Smalltalk at: #'Gofer') new.                  gofer                    perform: #'url:' with: repositoryUrl;                    perform: #'package:' with: 'ConfigurationOfMetacello';                    perform: #'load' ] ].          version := (Smalltalk at: #'ConfigurationOfMetacello') project            version: #'previewBootstrap'.          version load: loadList.          self            retry: [               gofer := (Smalltalk at: #'Gofer') new.              Smalltalk                at: #'ConfigurationOfMetacelloPreview'                ifAbsent: [                   gofer                    perform: #'url:' with: repositoryUrl;                    perform: #'package:'                      with: 'ConfigurationOfMetacelloPreview';                    perform: #'load' ] ].          version := (Smalltalk at: #'ConfigurationOfMetacelloPreview') project            version: #'stable'.	"load latest from GitHub"          version load: loadList.          ^ self ]            on: Error            do: [ :ex |               error := ex.              Transcript                cr;                show: 'failed ensureMetacello using ';                show: repositoryUrl printString;                show: ' : ';                show: ex description printString;                show: '...retrying'.	"try again"              ex return: nil ] ].	"shouldn't get here unless the load failed ... throw an error"      self        error:          'retry with alternate repository failed: ' , error description printString ]! !!ConfigurationOf class methodsFor: 'accessing' stamp: 'dkh 5/31/2012 17:57:13'!project	^self new project! !!ConfigurationOf class methodsFor: 'private' stamp: 'dkh 9/4/2012 17:09'!retry: aBlock    self retry: aBlock retryCount: 3! !!ConfigurationOf class methodsFor: 'private' stamp: 'dkh 9/4/2012 20:50'!retry: aBlock retryCount: retryCount    | count |    count := 1.    [ true ]        whileTrue: [             [             aBlock value.            ^ self ]                on: Error                do: [ :ex |                     count < retryCount                        ifTrue: [                             Transcript                                cr;                                show: 'RETRYING AFTER:';                                cr;                                show: ex description printString.                            (Delay forSeconds: 5) wait ]                        ifFalse: [                             Transcript                                cr;                                show: 'FAILED RETRYING:';                                cr;                                show: ex description printString.                            ex pass ] ].            count := count + 1 ]! !!ConfigurationOf class methodsFor: 'unloading Metacello' stamp: 'dkh 5/31/2012 17:57:13'!unloadMetacello	"Unload the classes that implement Metacello. Metacello is not needed once a project has been loaded, so it can safely be unloaded."	"self unloadMetacello"	<apiDocumentation>	| gofer |	gofer := (Smalltalk at: #Gofer) new.	MCWorkingCopy allManagers do: [:wc |		((wc packageName beginsWith: 'Metacello') or: [ wc packageName beginsWith: 'OB-Metacello' ])			ifTrue: [ gofer package: wc packageName ]].	gofer unload.! !!ConfigurationOf class methodsFor: 'accessing' stamp: 'dkh 5/31/2012 17:57:13'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOf methodsFor: 'defaults' stamp: 'dkh 5/31/2012 17:57:13'!bleedingEdge 	"override if different behavior desired.	 Use:		self versionDoesNotExistError: #bleedingEdge	 if #bleedingEdge version is disallowed."	<defaultSymbolicVersion: #bleedingEdge>		^self defaultBleedingEdgeVersion! !!ConfigurationOf methodsFor: 'accessing' stamp: 'dkh 5/31/2012 17:57:13'!customProjectAttributes    "Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttrributes "    ^ #()! !!ConfigurationOf methodsFor: 'defaults' stamp: 'dkh 5/31/2012 17:57:13'!defaultBleedingEdgeVersion	| bleedingEdgeVersion |	bleedingEdgeVersion := (self project map values select: [ :version | version blessing == #baseline ])		detectMax: [ :version | version ].	bleedingEdgeVersion ifNil: [ ^#'notDefined' ].	^ bleedingEdgeVersion versionString! !!ConfigurationOf methodsFor: 'accessing' stamp: 'dkh 6/22/2012 14:31'!project    ^ project        ifNil: [             "Bootstrap Metacello if it is not already loaded"            self class ensureMetacello.            project := self projectClass new projectAttributes: self customProjectAttributes.	"Create the Metacello project"            project versionNumberClass: self versionNumberClass.            project class versionConstructorClass on: self project: project.	"Construct the project"            project loadType: #'linear'.	"change to #atomic if desired"            project ]! !!ConfigurationOf methodsFor: 'accessing' stamp: 'dkh 5/31/2012 17:57:13'!project: aProject	project ifNil: [ self class ensureMetacello ].	project := aProject! !!ConfigurationOf methodsFor: 'accessing' stamp: 'dkh 5/31/2012 17:57:13'!projectClass    ^ MetacelloMCProject! !!ConfigurationOf methodsFor: 'private' stamp: 'dkh 5/31/2012 17:57:13'!versionDoesNotExistError: versionStringOrSymbol	((Smalltalk at: #MetacelloSymbolicVersionDoesNotExistError) project: self project versionString: versionStringOrSymbol) signal! !!ConfigurationOf methodsFor: 'accessing' stamp: 'dkh 6/22/2012 12:09'!versionNumberClass    ^ MetacelloSemanticVersionNumber! !!Metacello class methodsFor: 'instance creation' stamp: 'dkh 6/13/2012 16:09'!classic    "set the options such that the load performed will be identical to the classic ConfigurationOf load:	(ConfigurationOfExample project version: '1.0') load		#classic forces Metacello to look at image state to determine which version of a project is loaded instead of using		the registry to tell us explicitly which version of a project is loaded .. image state is not PRECISE"    "useCurrentVersion is a 'private' option for enforcing classic rules, so it's not part of scripting api"    ^ self new        onUpgrade: [ :ex | ex allow ];        onConflict: [ :ex | ex allow ];        addStatement: #'useCurrentVersion:' args: {true};        yourself! !!Metacello class methodsFor: 'instance creation' stamp: 'dkh 7/16/2012 10:12'!image    ^ self new        executorSpec: #'MetacelloScriptImageExecutor' -> 'batch';        yourself! !!Metacello class methodsFor: 'instance creation' stamp: 'dkh 7/13/2012 09:13'!registry    ^ self new        executorSpec: #'MetacelloScriptRegistryExecutor' -> 'batch';        yourself! !!Metacello class methodsFor: 'private' stamp: 'dkh 7/13/2012 09:08'!scriptExecutorClass    ^ self scriptExecutorClass: {(#'MetacelloScriptApiExecutor' -> 'batch')}! !!Metacello class methodsFor: 'private' stamp: 'dkh 7/13/2012 09:15'!scriptExecutorClass: anExecutorSpec    Smalltalk at: anExecutorSpec key ifAbsent: [ ConfigurationOf ensureMetacello: anExecutorSpec value ].    ^ Smalltalk at: anExecutorSpec key! !!Metacello methodsFor: 'private' stamp: 'dkh 5/31/2012 17:57:13'!addStatement: selector args: args    self statements add: selector -> args! !!Metacello methodsFor: 'api projectSpec' stamp: 'dkh 7/12/2012 13:45'!baseline: projectName    self addStatement: #'baselineArg:' args: {projectName}! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 7/17/2012 16:46'!blueplane: projectName    self repository: 'http://squeaksource.blueplane.jp/' , projectName! !!Metacello methodsFor: 'api options' stamp: 'dkh 7/23/2012 16:17'!cacheRepository: aRepositoryDescription    self addStatement: #'cacheRepository:' args: {aRepositoryDescription}! !!Metacello methodsFor: 'api projectSpec' stamp: 'dkh 7/12/2012 13:45'!className: className    self addStatement: #'classNameArg:' args: {className}! !!Metacello methodsFor: 'api projectSpec' stamp: 'dkh 7/12/2012 13:46'!configuration: projectName    self addStatement: #'configurationArg:' args: {projectName}! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 7/17/2012 16:48'!croquet: projectName    self repository: 'http://hedgehog.software.umn.edu:8888/' , projectName! !!Metacello methodsFor: 'private' stamp: 'dkh 7/12/2012 14:29'!execute    | script |    script := self statements.    self statements: nil.    ^ self scriptExecutor execute: script! !!Metacello methodsFor: 'accessing' stamp: 'dkh 7/13/2012 09:12'!executorSpec    executorSpec ifNil: [ executorSpec := #'MetacelloScriptApiExecutor' -> 'batch' ].    ^ executorSpec! !!Metacello methodsFor: 'accessing' stamp: 'dkh 7/13/2012 09:13'!executorSpec: anAssoc    executorSpec := anAssoc! !!Metacello methodsFor: 'api actions' stamp: 'dkh 7/23/2012 15:55'!fetch    self addStatement: #'fetch:' args: #(#()).    ^ self execute! !!Metacello methodsFor: 'api actions' stamp: 'dkh 7/23/2012 15:49'!fetch: required    self addStatement: #'fetch:' args: {required}.    ^ self execute! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 06/28/2013 16:52'!gemsource: projectName  self repository: 'http://seaside.gemtalksystems.com/ss/' , projectName! !!Metacello methodsFor: 'api actions' stamp: 'dkh 5/31/2012 17:57:13'!get    "resolve project name in given repository and return an instance of MetacelloProject resolved from a ConfigurationOf or BaselineOf"    self addStatement: #'get' args: #().    ^ self execute! !!Metacello methodsFor: 'api options' stamp: 'dkh 6/13/2012 16:05'!ignoreImage    "ignore image state"    self addStatement: #'ignoreImage:' args: {true}! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 7/17/2012 16:48'!impara: projectName    self repository: 'http://source.impara.de/' , projectName! !!Metacello methodsFor: 'api actions' stamp: 'dkh 7/13/2012 16:35'!list    "list projects in registry"    self addStatement: #'list' args: #().    ^ self execute! !!Metacello methodsFor: 'api actions' stamp: 'dkh 7/23/2012 15:56'!load    self addStatement: #'load:' args: #(#()).    ^ self execute! !!Metacello methodsFor: 'api actions' stamp: 'dkh 5/31/2012 17:57:13'!load: required    self addStatement: #'load:' args: {required}.    ^ self execute! !!Metacello methodsFor: 'api actions' stamp: 'dkh 7/17/2012 10:53'!lock    "lock projects in registry"    self addStatement: #'lock' args: #().    ^ self execute! !!Metacello methodsFor: 'api options' stamp: 'dkh 6/7/2012 15:34'!onConflict: aBlock    self addStatement: #'onConflict:' args: {aBlock}! !!Metacello methodsFor: 'api options' stamp: 'dkh 6/8/2012 14:03:46'!onDowngrade: aBlock    self addStatement: #'onDowngrade:' args: {aBlock}! !!Metacello methodsFor: 'api options' stamp: 'dkh 6/7/2012 15:33'!onUpgrade: aBlock    self addStatement: #'onUpgrade:' args: {aBlock}! !!Metacello methodsFor: 'api projectSpec' stamp: 'dkh 7/12/2012 13:46'!project: projectName    self addStatement: #'projectArg:' args: {projectName}! !!Metacello methodsFor: 'api actions' stamp: 'dkh 7/23/2012 15:56'!record    self addStatement: #'record:' args: #(#()).    ^ self execute! !!Metacello methodsFor: 'api actions' stamp: 'dkh 7/19/2012 07:40'!record: required    self addStatement: #'record:' args: {required}.    ^ self execute! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 7/17/2012 16:48'!renggli: projectName    self repository: 'http://source.lukas-renggli.ch/' , projectName! !!Metacello methodsFor: 'api projectSpec' stamp: 'dkh 7/12/2012 13:46'!repository: repositoryDescription    self addStatement: #'repositoryArg:' args: {repositoryDescription}! !!Metacello methodsFor: 'api options' stamp: 'dkh 7/23/2012 19:27'!repositoryOverrides: aRepositoryDescriptionCollection    self addStatement: #'repositoryOverrides:' args: {aRepositoryDescriptionCollection}! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 7/17/2012 16:49'!saltypickle: projectName    self repository: 'http://squeak.saltypickle.com/' , projectName! !!Metacello methodsFor: 'accessing' stamp: 'dkh 7/13/2012 09:16'!scriptExecutor    ^ (self class scriptExecutorClass: self executorSpec) new! !!Metacello methodsFor: 'api options' stamp: 'dkh 5/31/2012 17:57:13'!silently    "no progress bars"    self addStatement: #'silently:' args: {true}! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 7/17/2012 16:49'!squeakfoundation: projectName    self repository: 'http://source.squeakfoundation.org/' , projectName! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 7/17/2012 16:50'!squeaksource3: projectName    self repository: 'http://ss3.gemstone.com/ss/' , projectName! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 7/17/2012 16:50'!squeaksource: projectName    self repository: 'http://www.squeaksource.com/' , projectName! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 7/17/2012 16:46'!ss3: projectName    self squeaksource3: projectName! !!Metacello methodsFor: 'accessing' stamp: 'dkh 5/31/2012 17:57:13'!statements    statements ifNil: [ statements := OrderedCollection new ].    ^ statements! !!Metacello methodsFor: 'accessing' stamp: 'dkh 5/31/2012 17:57:13'!statements: anObject	statements := anObject! !!Metacello methodsFor: 'api actions' stamp: 'dkh 7/17/2012 12:31'!unlock    "unlock projects in registry"    self addStatement: #'unlock' args: #().    ^ self execute! !!Metacello methodsFor: 'api projectSpec' stamp: 'dkh 7/12/2012 13:46'!version: versionString    self addStatement: #'versionArg:' args: {versionString}! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 7/17/2012 16:50'!wiresong: projectName    self repository: 'http://source.wiresong.ca/' , projectName! !MetacelloBaseConfiguration removeSelector: #versionDoesNotExistError:!MetacelloBaseConfiguration removeSelector: #project:!MetacelloBaseConfiguration removeSelector: #project!MetacelloBaseConfiguration removeSelector: #defaultBleedingEdgeVersion!MetacelloBaseConfiguration removeSelector: #bleedingEdge!MetacelloBaseConfiguration class removeSelector: #validate!MetacelloBaseConfiguration class removeSelector: #updateToLatestPackageVersions:!MetacelloBaseConfiguration class removeSelector: #unloadMetacello!MetacelloBaseConfiguration class removeSelector: #saveModifiedPackagesAndConfiguration:!MetacelloBaseConfiguration class removeSelector: #saveConfiguration:!MetacelloBaseConfiguration class removeSelector: #releaseDevelopmentVersion:!MetacelloBaseConfiguration class removeSelector: #project!MetacelloBaseConfiguration class removeSelector: #loadDevelopment!MetacelloBaseConfiguration class removeSelector: #loadBleedingEdge!MetacelloBaseConfiguration class removeSelector: #load!MetacelloBaseConfiguration class removeSelector: #isMetacelloConfig!MetacelloBaseConfiguration class removeSelector: #ensureMetacello!MetacelloBaseConfiguration class removeSelector: #createNewDevelopmentVersion!MetacelloBaseConfiguration class removeSelector: #createNewBaselineVersion!MetacelloBaseConfiguration class removeSelector: #compareVersions!MetacelloBaseConfiguration class removeSelector: #bootstrapPackage:from:!MetacelloBaseConfiguration class removeSelector: #DevelopmentProcess!Smalltalk removeClassNamed: #MetacelloBaseConfiguration!"Metacello-Base"!SystemOrganization addCategory: #'Metacello-Core-Exceptions-Notifications'!SystemOrganization classify: #MetacelloCleanNotification under: #'Metacello-Core-Exceptions-Notifications'!SystemOrganization classify: #MetacelloCleanLoadAndTestsNotification under: #'Metacello-Core-Exceptions-Notifications'!SystemOrganization classify: #MetacelloCleanLoadNotification under: #'Metacello-Core-Exceptions-Notifications'!SystemOrganization classify: #MetacelloClearStackCacheNotification under: #'Metacello-Core-Exceptions-Notifications'!Notification subclass: #MetacelloErrorInProjectConstructionNotification	instanceVariableNames: 'versionString exception'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Notifications'!SystemOrganization addCategory: #'Metacello-Core-Scripts'!Notification subclass: #MetacelloScriptGitHubDownloadNotification	instanceVariableNames: 'projectPath versionString'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!Notification subclass: #MetacelloScriptNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloScriptNotification subclass: #MetacelloResolveProjectUpgrade	instanceVariableNames: 'existingProjectRegistration newProjectRegistration'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloResolveProjectUpgrade subclass: #MetacelloAllowConflictingProjectUpgrade	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloResolveProjectUpgrade subclass: #MetacelloAllowProjectDowngrade	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloResolveProjectUpgrade subclass: #MetacelloAllowProjectUpgrade	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloScriptNotification subclass: #MetacelloScriptEnsureProjectLoadedForDevelopment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloScriptNotification subclass: #MetacelloScriptProjectSpecNotification	instanceVariableNames: 'projectSpec'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloScriptProjectSpecNotification subclass: #MetacelloLookupBaselineSpecForEnsureLoad	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloScriptProjectSpecNotification subclass: #MetacelloLookupProjectSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!!MetacelloLookupProjectSpec commentStamp: 'dkh 6/1/2012 10:02' prior: 0!**MetacelloLookupProjectSpec** is signalled to allow a handler to substitute a different (equivalent) project spec for fetching or loading purposes!MetacelloScriptProjectSpecNotification subclass: #MetacelloLookupProjectSpecForLoad	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!!MetacelloLookupProjectSpecForLoad commentStamp: 'dkh 6/1/2012 10:55' prior: 0!**MetacelloLookupProjectSpecForLoad** ends up returning an instance of **MetacelloProjectSpecForLoad**!MetacelloScriptProjectSpecNotification subclass: #MetacelloProjectSpecLoadedNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!!MetacelloProjectSpecLoadedNotification commentStamp: 'dkh 6/1/2012 09:32' prior: 0!**MetacelloLoadProjectSpecVersionNotification** is signalled to indicate that the given project spec was loaded into the image.!SystemOrganization classify: #MetacelloSkipDirtyPackageLoad under: #'Metacello-Core-Exceptions-Notifications'!SystemOrganization classify: #MetacelloStackCacheNotification under: #'Metacello-Core-Exceptions-Notifications'!SystemOrganization classify: #MetacelloValidationNotification under: #'Metacello-Core-Exceptions-Notifications'!Magnitude subclass: #MetacelloSemanticVersionNumber	instanceVariableNames: 'normalVersion preReleaseVersion buildVersion'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Model'!!MetacelloSemanticVersionNumber commentStamp: 'dkh 6/24/2012 18:20' prior: 0!MetacelloSemanticVersionNumber conforms to version 2.0.0-rc.1 of  [Semantic Versioning 2.0.0-rc.1](http://semver.org/)The most important thing that you need to know is that: **A normal version number MUST take the form X.Y.Z where X, Y, and Z are non-negative integers.****Semantic Versioning Specification** extracted from [Semantic versioning 2.0.0-rc.1](https://github.com/mojombo/semver/blob/3c7f2e8df747ea0ca15208fdfc90e3275240184f/semver.md):Semantic Versioning Specification (SemVer)------------------------------------------The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD","SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to beinterpreted as described in RFC 2119.1. Software using Semantic Versioning MUST declare a public API. This APIcould be declared in the code itself or exist strictly in documentation.However it is done, it should be precise and comprehensive.1. A normal version number MUST take the form X.Y.Z where X, Y, and Z arenon-negative integers. X is the major version, Y is the minor version, and Zis the patch version. Each element MUST increase numerically by increments ofone. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.1. Once a versioned package has been released, the contents of that versionMUST NOT be modified. Any modifications must be released as a new version.1. Major version zero (0.y.z) is for initial development. Anything may changeat any time. The public API should not be considered stable.1. Version 1.0.0 defines the public API. The way in which the version numberis incremented after this release is dependent on this public API and how itchanges.1. Patch version Z (x.y.Z | x > 0) MUST be incremented if only backwardscompatible bug fixes are introduced. A bug fix is defined as an internalchange that fixes incorrect behavior.1. Minor version Y (x.Y.z | x > 0) MUST be incremented if new, backwardscompatible functionality is introduced to the public API. It MUST beincremented if any public API functionality is marked as deprecated. It MAY beincremented if substantial new functionality or improvements are introducedwithin the private code. It MAY include patch level changes. Patch versionMUST be reset to 0 when minor version is incremented.1. Major version X (X.y.z | X > 0) MUST be incremented if any backwardsincompatible changes are introduced to the public API. It MAY include minorand patch level changes. Patch and minor version MUST be reset to 0 when majorversion is incremented.1. A pre-release version MAY be denoted by appending a hyphen and a series ofdot separated identifiers immediately following the patch version. IdentifiersMUST be comprised of only ASCII alphanumerics and dash [0-9A-Za-z-].Pre-release versions satisfy but have a lower precedence than the associatednormal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,1.0.0-x.7.z.92.1. A build version MAY be denoted by appending a plus sign and a series of dotseparated identifiers immediately following the patch version or pre-releaseversion. Identifiers MUST be comprised of only ASCII alphanumerics and dash[0-9A-Za-z-]. Build versions satisfy and have a higher precedence than theassociated normal version. Examples: 1.0.0+build.1, 1.3.7+build.11.e0f985a.1. Precedence MUST be calculated by separating the version into major, minor,patch, pre-release, and build identifiers in that order. Major, minor, andpatch versions are always compared numerically. Pre-release and build versionprecedence MUST be determined by comparing each dot separated identifier asfollows: identifiers consisting of only digits are compared numerically andidentifiers with letters or dashes are compared lexically in ASCII sort order.Numeric identifiers always have lower precedence than non-numeric identifiers.Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 <1.0.0-rc.1 < 1.0.0-rc.1+build.1 < 1.0.0 < 1.0.0+0.3.7 < 1.3.7+build <1.3.7+build.2.b8f12d7 < 1.3.7+build.11.e0f985a.About-----The Semantic Versioning specification is authored by [TomPreston-Werner](http://tom.preston-werner.com), inventor of Gravatars andcofounder of GitHub.If you'd like to leave feedback, please [open an issue onGitHub](https://github.com/mojombo/semver/issues).License-------Creative Commons - CC BY 3.0http://creativecommons.org/licenses/by/3.0/!SystemOrganization addCategory: #'Metacello-Core-Exceptions-Errors'!SystemOrganization classify: #MetacelloCannotUpdateReleasedVersionError under: #'Metacello-Core-Exceptions-Errors'!Error subclass: #MetacelloPackageSpecResolutionError	instanceVariableNames: 'packageSpec repositories repositoryError'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Errors'!SystemOrganization classify: #MetacelloProjectSpecLoadError under: #'Metacello-Core-Exceptions-Errors'!SystemOrganization classify: #MetacelloProjectSpecLoadConflict under: #'Metacello-Core-Exceptions-Errors'!Error subclass: #MetacelloScriptingError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloScriptingError subclass: #MetacelloConflictingProjectError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloScriptingError subclass: #MetacelloLockedProjectError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloScriptingError subclass: #MetacelloUseUpgradeError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!Error subclass: #MetacelloValidationFailure	instanceVariableNames: 'issues'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Errors'!SystemOrganization classify: #MetacelloVersionDoesNotExistError under: #'Metacello-Core-Exceptions-Errors'!SystemOrganization classify: #MetacelloSymbolicVersionDoesNotExistError under: #'Metacello-Core-Exceptions-Errors'!SystemOrganization classify: #MetacelloSymbolicVersionNotDefinedError under: #'Metacello-Core-Exceptions-Errors'!MetacelloVersionDoesNotExistError subclass: #MetacelloVersionDefinitionError	instanceVariableNames: 'exception'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Errors'!MetacelloAbstractVersionConstructor subclass: #MetacelloBaselineConstructor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!!MetacelloBaselineConstructor commentStamp: 'dkh 5/4/2012 17:05' prior: 0!##MetacelloBaselineConstructor**MetacelloBaselineConstructor** extracts the #baseline pragma from a **BaselineOfConfiguration** and produces a **MetacelloVersion**:.```SmalltalkMetacelloBaselineConstructor on: BaselineOfExample```!MetacelloAbstractVersionConstructor subclass: #MetacelloVersionConstructor	instanceVariableNames: 'errorMap'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!MetacelloProjectSpec subclass: #MetacelloGenericProjectSpec	instanceVariableNames: 'projectPackage repositories'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!SystemOrganization addCategory: #'Metacello-Core-Deprecated'!ConfigurationOf subclass: #MetacelloBaseConfiguration	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Deprecated'!!MetacelloBaseConfiguration commentStamp: 'dkh 5/30/2012 13:50' prior: 0!You should be using ConfigurationOf instead of MetacelloBaseConfiguration. The class is being kept around because many extant Metacello configurations use MetacelloBaseConfiguration as a sentinel class to indicate whether or not Metacello is loaded..Once the Metacello scripting API becomes prevalent (the api has it's own ensureMetacello logic) this class can be removed.!Object subclass: #MetacelloProject	instanceVariableNames: 'versionMap symbolicVersionMap errorMap loader loaderClass loadType configuration projectAttributes versionNumberClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Model'!Object subclass: #MetacelloProjectRegistration	instanceVariableNames: 'projectName configurationProjectSpec baselineProjectSpec loadedInImage locked mutable'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!Object subclass: #MetacelloProjectRegistry	instanceVariableNames: 'baselineRegistry configurationRegistry'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!Object subclass: #MetacelloProjectSpecForLoad	instanceVariableNames: 'projectSpec useDetermineVersionForLoad overrideProjectSpec'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!Object subclass: #MetacelloProjectSpecGenerator	instanceVariableNames: 'target'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloProjectSpecGenerator subclass: #MetacelloBaselineSpecGenerator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloProjectSpecGenerator subclass: #MetacelloConfigurationSpecGenerator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!Object subclass: #MetacelloScriptEngine	instanceVariableNames: 'root projectSpec options'	classVariableNames: 'DefaultRepositoryDescription DefaultVersionString'	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!!MetacelloScriptEngine commentStamp: 'dkh 7/12/2012 14:48' prior: 0!MetacelloScriptEngine runs the execution of the script for one projectSpec!Object subclass: #MetacelloScriptExecutor	instanceVariableNames: 'options roots singleRoot projectSpecGenerator actionArg configurationArg baselineArg projectArg classNameArg versionArg repositoryArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!!MetacelloScriptExecutor commentStamp: 'dkh 7/12/2012 14:49' prior: 0!MetacelloScriptExecutor decodes script args and launches MetacelloScriptEngine to run for each projectSpec encounters...i,e., primarily here to handl array and block args to configuration:, baseline: or project:.!MetacelloScriptExecutor subclass: #MetacelloScriptApiExecutor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!!MetacelloScriptApiExecutor commentStamp: 'dkh 7/12/2012 14:49' prior: 0!MetacelloScriptExecutor decodes script args and launches MetacelloScriptEngine to run for each projectSpec encounters...i,e., primarily here to handl array and block args to configuration:, baseline: or project:.!MetacelloScriptExecutor subclass: #MetacelloScriptImageExecutor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloScriptExecutor subclass: #MetacelloScriptRegistryExecutor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!Object subclass: #MetacelloSpec	instanceVariableNames: 'project loader mutable'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!MetacelloSpec subclass: #MetacelloVersionSpec	instanceVariableNames: 'versionString blessing description author timestamp preLoadDoIt postLoadDoIt packageList importName'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!Object subclass: #MetacelloVersionDiffReport	instanceVariableNames: 'additions configuration modifications removals from to'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Model'!!Integer methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34000000!metacelloIntegerLessThanSelf: anInteger	^anInteger < self! !!Integer methodsFor: '*metacello-core' stamp: 'dkh 6/21/2012 20:44'!metacelloSemanticIntegerLessThanSelf: anInteger    ^ anInteger < self! !!Integer methodsFor: '*metacello-core' stamp: 'dkh 6/21/2012 20:44'!metacelloSemanticStringLessThanSelf: aString    "string version components are always '<' integer component"    ^ true! !!Integer methodsFor: '*metacello-core' stamp: 'dkh 6/21/2012 20:47'!metacelloSemanticVersionComponentLessThan: aMetacelloVersonComponent    ^ aMetacelloVersonComponent metacelloSemanticIntegerLessThanSelf: self! !!Integer methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34000132!metacelloStringLessThanSelf: aString	"string version components are always '<' integer component"		^true! !!Integer methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34000312!metacelloVersionComponentLessThan: aMetacelloVersonComponent	^aMetacelloVersonComponent metacelloIntegerLessThanSelf: self! !!MetacelloMergeMemberSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34151119!applyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock	mergeBlock value: self! !!MetacelloMergeMemberSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34151298!applyToList: aListSpec	aListSpec merge: self! !!MetacelloMergeMemberSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34151428!methodUpdateSelector	^#with:! !!MetacelloCopyMemberSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34149007!applyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock    copyBlock value: self! !!MetacelloCopyMemberSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34149185!applyToList: aListSpec	aListSpec copy: self! !!MetacelloCopyMemberSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34149313!methodUpdateSelector	^#copy:! !!MetacelloCopyMemberSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34149426!sourceName	^sourceName! !!MetacelloCopyMemberSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34149533!sourceName: aString	sourceName := aString! !!MCRepository methodsFor: '*metacello-core' stamp: 'dkh 7/24/2012 21:46'!flushForScriptGet    "noop"! !!MetacelloValueHolderSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34165838!configMethodOn: aStream indent: indent	aStream tab: indent; nextPutAll: 'spec value: ', self value printString! !!MetacelloValueHolderSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24' prior: 34166031!mergeMap	| map |	map := super mergeMap.	map at: #value put: value.	^map! !!MetacelloValueHolderSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34166189!setAuthorInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setAuthor: self! !!MetacelloValueHolderSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34166360!setBlessingInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setBlessing: self! !!MetacelloValueHolderSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34166535!setDescriptionInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setDescription: self! !!MetacelloValueHolderSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34166727!setPostLoadDoItInMetacelloSpec: aMetacelloSpec	aMetacelloSpec setPostLoadDoIt: self! !!MetacelloValueHolderSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34166904!setPreLoadDoItInMetacelloSpec: aMetacelloSpec	aMetacelloSpec setPreLoadDoIt: self! !!MetacelloValueHolderSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34167069!setTimestampInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setTimestamp: self! !!MetacelloValueHolderSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34167247!value	^ value! !!MetacelloValueHolderSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34167344!value: anObject	value := anObject! !!MetacelloValueHolderSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!value: anObject constructor: aVersionConstructor    aVersionConstructor valueForValueHolder: anObject! !!MetacelloValidationIssue class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34176938!configurationClass: aClass reasonCode: aSymbol callSite: aCallSite explanation: aString	^(self new)		configurationClass: aClass;		reasonCode: aSymbol;		callSite: aCallSite;		explanation: aString;		yourself! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34177244!callSite	^ callSite! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34177358!callSite: anObject	callSite := anObject! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34177491!configurationClass	^ configurationClass! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34177624!configurationClass: aClass	configurationClass := aClass! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34177773!explanation	^ explanation! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34177892!explanation: aString	explanation := aString! !!MetacelloValidationIssue methodsFor: 'testing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34178027!isCritical	^self isError or: [ self isCriticalWarning ]! !!MetacelloValidationIssue methodsFor: 'testing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34178175!isCriticalWarning	^false! !!MetacelloValidationIssue methodsFor: 'testing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34178292!isError	^false! !!MetacelloValidationIssue methodsFor: 'testing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34178399!isWarning	^false! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34178510!label	^''! !!MetacelloValidationIssue methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34178613!printOn: aStream	aStream		nextPutAll: self label;		nextPut: $:;		space;		nextPutAll: self explanation.	self reasonCode ~~ #none		ifTrue: [ 			aStream				space;				nextPut: ${;				space;				nextPutAll: self reasonCode asString;				space;				nextPut: $} ].	(self configurationClass ~~ nil or: [ self callSite ~~ nil ])		ifTrue: [ 			aStream				space;				nextPut: $[;				space.			self configurationClass ~~ nil				ifTrue: [ 					aStream						nextPutAll: self configurationClass name asString;						space ].			self callSite ~~ nil				ifTrue: [ 					aStream						nextPutAll: self callSite name asString;						space ].			aStream nextPut: $] ]! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34179373!reasonCode	reasonCode == nil ifTrue: [ reasonCode := #none ].	^ reasonCode! !!MetacelloValidationIssue methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34179543!reasonCode: anObject	reasonCode := anObject! !!MetacelloCleanNotification class methodsFor: 'exceptioninstantiator' stamp: 'dkh 6/5/2012 19:01:24' prior: 34180980!signal: aMetacelloVersion	^ self new signal: aMetacelloVersion! !!MetacelloCleanNotification methodsFor: 'signaling' stamp: 'dkh 6/5/2012 19:01:24' prior: 34181140!signal: aMetacelloVersion	self version: aMetacelloVersion.	^ self signal! !!MetacelloCleanNotification methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34181311!version	^ version! !!MetacelloCleanNotification methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34181425!version: anObject	version := anObject! !!MetacelloClearStackCacheNotification methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34181558!cacheNames	^ cacheNames! !!MetacelloClearStackCacheNotification methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34181677!cacheNames: anArray	cacheNames := anArray! !!MetacelloClearStackCacheNotification methodsFor: 'signaling' stamp: 'dkh 6/5/2012 19:01:24' prior: 34181814!signal: anArray	"Signal the occurrence of an exceptional condition with a specified cacheName."	self cacheNames: anArray.	^ self signal! !!MetacelloErrorInProjectConstructionNotification class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24'!versionString: aString exception: anException    ^ self new        versionString: aString;        exception: anException;        signal! !!MetacelloErrorInProjectConstructionNotification methodsFor: 'exception description' stamp: 'dkh 6/5/2012 19:01:24'!defaultAction    "Answer false if you want the version recorded in the errorMap.	Answer true if you want to go ahead and throw the error"    ^ false! !!MetacelloErrorInProjectConstructionNotification methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!exception	^ exception! !!MetacelloErrorInProjectConstructionNotification methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!exception: anObject	exception := anObject! !!MetacelloErrorInProjectConstructionNotification methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!versionString	^ versionString! !!MetacelloErrorInProjectConstructionNotification methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!versionString: anObject	versionString := anObject! !!MetacelloScriptGitHubDownloadNotification methodsFor: 'accessing' stamp: 'dkh 7/24/2012 22:11'!projectPath	^ projectPath! !!MetacelloScriptGitHubDownloadNotification methodsFor: 'accessing' stamp: 'dkh 7/24/2012 22:11'!projectPath: anObject	projectPath := anObject! !!MetacelloScriptGitHubDownloadNotification methodsFor: 'accessing' stamp: 'dkh 7/24/2012 22:11'!versionString	^ versionString! !!MetacelloScriptGitHubDownloadNotification methodsFor: 'accessing' stamp: 'dkh 7/24/2012 22:11'!versionString: anObject	versionString := anObject! !!MetacelloAllowConflictingProjectUpgrade methodsFor: 'exception handling' stamp: 'dkh 7/18/2012 11:06'!defaultAction    ^ MetacelloConflictingProjectError        signal:            'Load Conflict between existing ' , self existingProjectRegistration printString , ' and '                , self newProjectRegistration printString! !!MetacelloAllowConflictingProjectUpgrade methodsFor: 'handlers' stamp: 'dkh 6/7/2012 15:50'!handleResolutionFor: aScriptEngine    ^ aScriptEngine handleConflict: self! !!MetacelloAllowConflictingProjectUpgrade methodsFor: 'accessing' stamp: 'dkh 7/18/2012 17:08'!operationString    ^ 'conflict'! !!MetacelloAllowProjectDowngrade methodsFor: 'handlers' stamp: 'dkh 7/18/2012 16:46'!handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock    ^ onDownGradeBlock cull: self cull: self existingProjectRegistration cull: self newProjectRegistration! !!MetacelloAllowProjectDowngrade methodsFor: 'handlers' stamp: 'dkh 6/8/2012 10:41'!handleResolutionFor: aScriptEngine    ^ aScriptEngine handleDowngrade: self! !!MetacelloAllowProjectDowngrade methodsFor: 'accessing' stamp: 'dkh 7/18/2012 17:09'!operationString    ^ 'downgrade'! !!MetacelloAllowProjectUpgrade methodsFor: 'exception handling' stamp: 'dkh 7/18/2012 16:43'!defaultAction    "Default for Upgrade is to allow"    self checkAllowed.    ^ self newProjectRegistration! !!MetacelloAllowProjectUpgrade methodsFor: 'handlers' stamp: 'dkh 7/18/2012 16:46'!handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock    ^ onUpgradeBlock cull: self cull: self existingProjectRegistration cull: self newProjectRegistration! !!MetacelloAllowProjectUpgrade methodsFor: 'handlers' stamp: 'dkh 6/7/2012 15:50'!handleResolutionFor: aScriptEngine    ^ aScriptEngine handleUpgrade: self! !!MetacelloAllowProjectUpgrade methodsFor: 'accessing' stamp: 'dkh 7/18/2012 17:09'!operationString    ^ 'upgrade'! !!MetacelloResolveProjectUpgrade methodsFor: 'exception handling' stamp: 'dkh 7/18/2012 16:40'!allow    self checkAllowed.    self resume: self newProjectRegistration! !!MetacelloResolveProjectUpgrade methodsFor: 'exception handling' stamp: 'dkh 7/18/2012 16:42'!allowEvenIfLocked    self resume: self newProjectRegistration! !!MetacelloResolveProjectUpgrade methodsFor: 'private' stamp: 'dkh 7/18/2012 17:09'!checkAllowed    self existingProjectRegistration locked        ifTrue: [             MetacelloLockedProjectError                signal:                    'Attempt to perform' , self operationString printString , ' a locked project: '                        , self existingProjectRegistration printString ]! !!MetacelloResolveProjectUpgrade methodsFor: 'exception handling' stamp: 'dkh 7/18/2012 16:42'!defaultAction    "Result of signal should be the projectRegistration to be used to perform the load ... default is to disallow"    ^ self existingProjectRegistration! !!MetacelloResolveProjectUpgrade methodsFor: 'exception handling' stamp: 'dkh 6/7/2012 15:25'!disallow    "default action"    self resume: self existingProjectRegistration! !!MetacelloResolveProjectUpgrade methodsFor: 'accessing' stamp: 'dkh 5/29/2012 16:30'!existingProjectRegistration	^ existingProjectRegistration! !!MetacelloResolveProjectUpgrade methodsFor: 'accessing' stamp: 'dkh 5/29/2012 16:30'!existingProjectRegistration: anObject	existingProjectRegistration := anObject! !!MetacelloResolveProjectUpgrade methodsFor: 'handlers' stamp: 'dkh 7/24/2012 11:37'!handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock    self subclassResponsibility! !!MetacelloResolveProjectUpgrade methodsFor: 'accessing' stamp: 'dkh 5/29/2012 16:30'!newProjectRegistration	^ newProjectRegistration! !!MetacelloResolveProjectUpgrade methodsFor: 'accessing' stamp: 'dkh 5/29/2012 16:30'!newProjectRegistration: anObject	newProjectRegistration := anObject! !!MetacelloResolveProjectUpgrade methodsFor: 'accessing' stamp: 'dkh 7/18/2012 17:08'!operationString    self subclassResponsibility! !!MetacelloScriptEnsureProjectLoadedForDevelopment methodsFor: 'exception handling' stamp: 'dkh 7/24/2012 11:40'!defaultAction    "Go ahead and download a new copy of configuration because blessing is #development"    ^ true! !!MetacelloScriptEnsureProjectLoadedForDevelopment methodsFor: 'handlers' stamp: 'dkh 7/24/2012 11:42'!handleResolutionFor: aScriptEngine    ^ aScriptEngine handleEnsureProjectLoadedForDevelopment: self! !!MetacelloScriptNotification methodsFor: 'handlers' stamp: 'dkh 6/7/2012 16:07'!handleResolutionFor: aScriptEngine    self subclassResponsibility! !!MetacelloLookupBaselineSpecForEnsureLoad methodsFor: 'exception description' stamp: 'dkh 7/27/2012 00:36'!defaultAction	"Answer <true> if you want to ensure the load of the baseline ... default is to load the baseline"	^ true! !!MetacelloLookupBaselineSpecForEnsureLoad methodsFor: 'handlers' stamp: 'dkh 7/27/2012 00:30'!handleResolutionFor: aScriptEngine	^ aScriptEngine handleLookupBaselineSpecForEnsureLoad: self! !!MetacelloLookupProjectSpec methodsFor: 'handlers' stamp: 'dkh 6/7/2012 16:21'!handleResolutionFor: aScriptEngine    ^ aScriptEngine handleLookupProjectSpec: self! !!MetacelloLookupProjectSpecForLoad methodsFor: 'exception description' stamp: 'dkh 6/5/2012 19:01:24'!defaultAction    "Result of signal should be the MetacelloProjectSpecForLoad to be used to perform the load. 	Create a MetacelloProjectSpecForLoad and use the overrideProjectSpec: if you want to supply a different projectSpec"    ^ MetacelloProjectSpecForLoad new        projectSpec: self projectSpec;        yourself! !!MetacelloLookupProjectSpecForLoad methodsFor: 'handlers' stamp: 'dkh 6/7/2012 16:23'!handleResolutionFor: aScriptEngine    ^ aScriptEngine handleLookupProjectSpecForLoad: self! !!MetacelloProjectSpecLoadedNotification methodsFor: 'exception description' stamp: 'dkh 6/5/2012 19:01:24'!defaultAction    ^ nil! !!MetacelloProjectSpecLoadedNotification methodsFor: 'handlers' stamp: 'dkh 6/7/2012 16:19'!handleResolutionFor: aScriptEngine    ^ aScriptEngine handleProjectSpecLoaded: self! !!MetacelloScriptProjectSpecNotification methodsFor: 'exception description' stamp: 'dkh 6/5/2012 19:01:24'!defaultAction    "Result of signal should be the projectSpec to be used to perform the load"    ^ self projectSpec! !!MetacelloScriptProjectSpecNotification methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!projectSpec    ^ projectSpec! !!MetacelloScriptProjectSpecNotification methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!projectSpec: anObject    projectSpec := anObject! !!MetacelloSkipDirtyPackageLoad class methodsFor: 'signalling' stamp: 'dkh 6/5/2012 19:01:24' prior: 34182050!signal: aMetacelloPackageSpec	^(self new packageSpec: aMetacelloPackageSpec) signal! !!MetacelloSkipDirtyPackageLoad methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34182225!defaultAction	"Default action is to skip the load of a dirty package"	^true! !!MetacelloSkipDirtyPackageLoad methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34182393!packageSpec	^packageSpec! !!MetacelloSkipDirtyPackageLoad methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34182509!packageSpec: aMetacelloPackageSpec	packageSpec := aMetacelloPackageSpec! !!MetacelloValidationNotification class methodsFor: 'exceptioninstantiator' stamp: 'dkh 6/5/2012 19:01:24' prior: 34182700!signal: aMetacelloValidationIssue	^ self new signal: aMetacelloValidationIssue! !!MetacelloValidationNotification methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34182880!issue	^ issue! !!MetacelloValidationNotification methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34182994!issue: anObject	issue := anObject! !!MetacelloValidationNotification methodsFor: 'signaling' stamp: 'dkh 6/5/2012 19:01:24' prior: 34183128!signal: aMetacelloValidationIssue	self issue: aMetacelloValidationIssue.	^ self signal! !!MetacelloVersionValidator class methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34068896!descriptionForReasonCode: reasonCode	^ self reasonCodeDescriptions at: reasonCode ifAbsent: [ self error: 'Unknown reasonCode: ' , reasonCode printString ]! !!MetacelloVersionValidator class methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34069150!populateReasonCodeDescriptions    "update MetacelloMCVersionValidator class comment to include any changes to descriptions"    | dict |    dict := Dictionary new.    dict        at: #'onlyBaselineVersion'        put: 'one or more baseline versions have been defined, but no non-baseline versions are defined.'.    dict        at: #'duplicateVersionDefinitions' put: 'there are multiple pragma methods specifying the same version.';        at: #'packageNameMismatch' put: 'the name in the packageSpec does not match the name of the mcz file.';        at: #'projectClassNameFileMismatch'            put: 'the class name of the configuration does not match the mcz file containing the configuration.';        at: #'cannotResolveVersion'            put: 'the version (project reference or symbolic version) was not found in the specified configuration.'.    dict        at: #'duplicateNames'            put: 'multiple independent definitions for an entity with same name (project, package, or group).';        at: #'incompleteProjectSpec' put: 'missing required fields in project reference (repository, className).';        at: #'incorrectVersionString' put: 'the version declared in pragma doesn''t match version in versionSpec.';        at: #'invalidDoItSelector' put: 'doit select must be a Symbol.';        at: #'invalidVersionString' put: 'versionString must be a String.';        at: #'missingVersionImport' put: 'version specified in import pragma not defined in configuration.';        at: #'noVersionsDefined'            put: 'no usable baseline or version defined in configuration ... configuration cannot be loaded.';        at: #'projectCreationError' put: 'error occured while resolving project reference.';        at: #'versionCreationError'            put:                'error occured while resolving version specification, error will be thrown if an attempt is made to use the version.';        at: #'shadowedNames' put: 'name duplication between packages and projects.';        at: #'versionCompositionError' put: 'error while creating versionSpec from pragmas.'.    ^ dict! !!MetacelloVersionValidator class methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34070984!reasonCodeDescriptions	reasonCodeDescriptions ifNil: [ reasonCodeDescriptions := self populateReasonCodeDescriptions ].	^reasonCodeDescriptions! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34071238!validateConfiguration: configurationClass	^self validateConfiguration: configurationClass debug: #() recurse: false! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34071464!validateConfiguration: configurationClass debug: debugList recurse: aBool	^ ((self new)		configurationClass: configurationClass;		debug: debugList;		recurse: aBool;		yourself) validate! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34071761!validateConfiguration: configurationClass recurse: aBool	^self validateConfiguration: configurationClass debug: #() recurse: aBool! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34072001!validateProject: aMetacelloProject	^self validateProject: aMetacelloProject debug: #() recurse: false! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34072213!validateProject: aMetacelloProject debug: debugList recurse: aBool	^ ((self new)		recurse: aBool;		debug: debugList;		configurationClass: aMetacelloProject configuration class;		yourself) validateProject: aMetacelloProject! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34072548!validateProject: aMetacelloProject recurse: aBool	^self validateProject: aMetacelloProject debug: #() recurse: aBool! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34072774!validateProject: aMetacelloProject version: versionString	^self validateProject: aMetacelloProject version: versionString debug: #() recurse: false! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34073032!validateProject: aMetacelloProject version: versionString debug: debugList	^self validateProject: aMetacelloProject version: versionString debug: debugList recurse: false! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34073313!validateProject: aMetacelloProject version: versionString debug: debugList recurse: aBool	^ ((self new)		configurationClass: aMetacelloProject configuration class;		debug: debugList;		recurse: aBool;		yourself) validateProject: aMetacelloProject version: versionString! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34073695!validateProject: aMetacelloProject version: versionString debug: debugList recurse: aBool visited: visitied	^(self new		configurationClass: aMetacelloProject configuration class;		debug: debugList;		recurse: aBool;		visited: visitied;		yourself) validateProject: aMetacelloProject version: versionString! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34074099!configurationClass	^ configurationClass! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34074233!configurationClass: anObject	configurationClass := anObject! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34074386!criticalWarningReasonCodes    ^ #(#'packageNameMismatch' #'projectClassNameFileMismatch' #'duplicateVersionDefinitions')! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34074593!debug	debug == nil ifTrue: [ debug := #() ].	^ debug! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34074743!debug: aCollection	"Any combination of: #error, #criticalWarning, #warning"	debug := aCollection! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34074935!errorReasonCodes    ^ #(#'duplicateNames' #'shadowedNames' #'invalidDoItSelector' #'invalidVersionString' #'missingVersionImport' #'projectCreationError' #'noVersionsDefined' #'cannotResolveVersion' #'incompleteProjectSpec' #'incorrectVersionString' #'versionCompositionError' #'versionCreationError')! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34075283!exludededValidations	exludededValidations == nil ifTrue: [ exludededValidations := self extractExcludedValidations ].	^exludededValidations! !!MetacelloVersionValidator methodsFor: 'pragma extraction' stamp: 'dkh 6/5/2012 19:01:24' prior: 34075528!extractExcludedValidations	| exclusionDict |	exclusionDict := Dictionary new.	(Pragma 		allNamed: #excludedValidationIssues:		in: self configurationClass) do: [:pragma | | exclusions |			exclusions := pragma argumentAt: 1.			1 to: exclusions size by: 2 do: [:index |			exclusionDict 				at: (exclusions at: index) 				put: (exclusions at: index + 1) ]].	^exclusionDict! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34076003!recordValidationCriticalWarning: aString callSite: callSite reasonCode: aSymbol	^self recordValidationCriticalWarning: aString versionString: nil callSite: callSite reasonCode: aSymbol! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34076285!recordValidationCriticalWarning: aString versionString: versionString callSite: callSite reasonCode: aSymbol	"reasonCodes:		#packageNameMismatch		#projectClassNameFileMismatch		#duplicateVersionDefinitions		#duplicateAttributeBlocks	"	(self criticalWarningReasonCodes includes: aSymbol)		ifFalse: [ self error: 'Unknown critical warning reason code' ].	((self exludededValidations at: versionString ifAbsent: [ #() ]) includes: aSymbol)		ifTrue: [ ^self ].	(self debug includes: #criticalWarning) ifTrue: [ self halt: 'Debug triggered for critical warning: ', aString ].	self validationReport		add:			(MetacelloValidationCriticalWarning				configurationClass:					(self recurse						ifTrue: [ self configurationClass ]						ifFalse: [ nil ])				reasonCode: aSymbol				callSite: callSite				explanation: aString)! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34077212!recordValidationError: aString callSite: callSite reasonCode: aSymbol	^self recordValidationError: aString versionString: nil callSite: callSite reasonCode: aSymbol! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34077474!recordValidationError: aString versionString: versionString callSite: callSite reasonCode: aSymbol	"reasonCodes:		#noVersionForSymbolicVersion		#duplicateNames		#shadowedNames		#invalidDoItSelector		#invalidVersionString		#missingVersionImport		#projectCreationError		#noVersionsDefined		#cannotResolveVersion		#incompleteProjectSpec		#incorrectVersionString	"	(self errorReasonCodes includes: aSymbol)		ifFalse: [ self error: 'Unknown error reason code' ].	((self exludededValidations at: versionString ifAbsent: [ #() ]) includes: aSymbol)		ifTrue: [ ^self ].	(self debug includes: #error) ifTrue: [ self halt: 'Debug triggered for error: ', aString ].	self validationReport		add:			(MetacelloValidationError				configurationClass:					(self recurse						ifTrue: [ self configurationClass ]						ifFalse: [ nil ])				reasonCode: aSymbol				callSite: callSite				explanation: aString)! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34078483!recordValidationWarning: aString callSite: callSite reasonCode: aSymbol					^self recordValidationWarning: aString versionString: nil callSite: callSite reasonCode: aSymbol! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34078754!recordValidationWarning: aString versionString: versionString callSite: callSite reasonCode: aSymbol	"reasonCodes:		#onlyBaselineVersion		#noVersionSpecified	"	(self warningReasonCodes includes: aSymbol)		ifFalse: [ self error: 'Unknown warning reason code' ].	((self exludededValidations at: versionString ifAbsent: [ #() ]) includes: aSymbol)		ifTrue: [ ^self ].	(self debug includes: #warning) ifTrue: [ self halt: 'Debug triggered for critical warning: ', aString ].	self validationReport		add:			(MetacelloValidationWarning				configurationClass:					(self recurse						ifTrue: [ self configurationClass ]						ifFalse: [ nil ])				reasonCode: aSymbol				callSite: callSite				explanation: aString)! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34079571!recurse	recurse == nil ifTrue: [ recurse := false ].	^ recurse! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34079729!recurse: anObject	recurse := anObject! !!MetacelloVersionValidator methodsFor: 'validation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34079862!validate	"Issue 5: 		[]no shadowing of names across project/package/group boundaries	 Issue 6: 		[]package version supplied for each package		[]no released (stable/bleedingEdge) versions (only development version)		package spec used instead of project spec in baseline (ConfigurationOfPharo-DaleHenrichs.50)	Issue 20:		[]pre and post load doits must be symbols, not blocks	Others:		[]symbolic versions can be resolved.		[]Ensure that versions are Strings and symbolic versions are symbols.	 	[]Ensure that imported versions are defined."	self validatePragmas.	^self validateProject! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34080550!validateBaselineVersionSpec: versionSpec	self subclassResponsibility! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34080713!validateDoIts: aSpec versionString: versionString errorMessage: errorMessage	| ar |	ar := {		#preLoadDoIt.	'preLoadDoIt selector for '.		#postLoadDoIt.	'postLoadDoIt selector for '.	}.	1 to: ar size by: 2 do: [ :i | 		| selector |		selector := (aSpec perform: (ar at: i)) value.		selector ~~ nil			ifTrue: [ 				selector isSymbol					ifFalse: [ 						self							recordValidationError: (ar at: i + 1) , errorMessage , ' is not a symbol'							versionString: versionString							callSite: #validateDoIts:versionString:errorMessage:							reasonCode: #invalidDoItSelector ] ] ]! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34081397!validatePragmas    "Ensure that versions are Strings and symbolic versions are symbols.	 Ensure that imported versions are defined"    | versionPragmas versionImportPragmas symbolicVersionPragmas versionStrings |    versionPragmas := self extractVersionPragmas.    versionImportPragmas := self extractVersionImportPragmas.    symbolicVersionPragmas := self extractSymbolicVersionPragmas.    versionStrings := Set new.    versionPragmas keys , versionImportPragmas keys , symbolicVersionPragmas keys        do: [ :versionString |             (versionStrings includes: versionString)                ifTrue: [                     self                        recordValidationCriticalWarning:                            'version ' , versionString printString , ' is defined multiple times.'                        versionString: versionString                        callSite: #'validatePragmas'                        reasonCode: #'duplicateVersionDefinitions' ]                ifFalse: [ versionStrings add: versionString ] ].    versionPragmas        keysAndValuesDo: [ :versionString :pragmaList |             versionString isString                ifFalse: [                     self                        recordValidationError: 'version ' , versionString printString , ' is not a String.'                        versionString: versionString                        callSite: #'validatePragmas'                        reasonCode: #'invalidVersionString' ].            pragmaList size > 1                ifTrue: [                     self                        recordValidationCriticalWarning:                            'version ' , versionString printString , ' is defined multiple times.'                        versionString: versionString                        callSite: #'validatePragmas'                        reasonCode: #'duplicateVersionDefinitions' ] ].    symbolicVersionPragmas        keysAndValuesDo: [ :versionString :pragmaList |             versionString isSymbol                ifFalse: [                     self                        recordValidationError: 'symbolic version ' , versionString printString , ' is not a Symbol.'                        versionString: versionString                        callSite: #'validatePragmas'                        reasonCode: #'invalidVersionString' ].            pragmaList size > 1                ifTrue: [                     self                        recordValidationCriticalWarning:                            'version ' , versionString printString , ' is defined multiple times.'                        versionString: versionString                        callSite: #'validatePragmas'                        reasonCode: #'duplicateVersionDefinitions' ] ].    versionImportPragmas        keysAndValuesDo: [ :versionString :pragmaList |             versionString isString                ifFalse: [                     self                        recordValidationError: 'version ' , versionString printString , ' is not a String.'                        versionString: versionString                        callSite: #'validatePragmas'                        reasonCode: #'invalidVersionString' ].            pragmaList size > 1                ifTrue: [                     self                        recordValidationCriticalWarning:                            'version ' , versionString printString , ' is defined multiple times.'                        versionString: versionString                        callSite: #'validatePragmas'                        reasonCode: #'duplicateVersionDefinitions' ].            pragmaList                do: [ :versionImportPragma |                     (versionImportPragma arguments at: 2)                        do: [ :importedVersionString |                             (versionStrings includes: importedVersionString)                                ifFalse: [                                     self                                        recordValidationError:                                            'version ' , importedVersionString printString , ' referenced in import list of version ' , versionString printString                                                , ' has not been defined.'                                        versionString: versionString                                        callSite: #'validatePragmas'                                        reasonCode: #'missingVersionImport' ] ] ] ]! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34084715!validateProject	| project |	project := self		validateProjectCreationFrom: self configurationClass		onError: [ :ex | 			self				recordValidationError:					'Error creating project: ' , ex description , ' to reproduce evalutate the following: '''						, self configurationClass name asString , ' project'''				callSite: #validateProject				reasonCode: #projectCreationError.			^ self validationReport ].	^ self validateProject: project! !!MetacelloVersionValidator methodsFor: 'validation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34085255!validateProject: project	| hasNoBaseline hasNoVersion |	(self visited includes: project configuration class)		ifTrue: [ ^ self validationReport ].	self visited add: project configuration class.	hasNoBaseline := hasNoVersion := true.	project versions		do: [ :version | 			| spec |			spec := version spec.			[ 			spec blessing value == #baseline				ifTrue: [ 					hasNoBaseline := false.					self validateBaselineVersionSpec: spec ]				ifFalse: [ 					hasNoVersion := false.					self validateVersionSpec: spec ] ]				on: Error				do: [ :ex | 					self						recordValidationError: 'Error composing version ' , version versionString printString , ': ' , ex description						versionString: version versionString						callSite: #validateProject:						reasonCode: #versionCompositionError ] ].	project symbolicVersionMap keys		do: [ :symbolicVersion | 			| version |			version := [ project version: symbolicVersion ]				on: Error , MetacelloSymbolicVersionNotDefinedError				do: [ :ex | 					"MetacelloSymbolicVersionNotDefinedError are explicitly not defined, so are not validation errors"					(ex isKindOf: MetacelloSymbolicVersionNotDefinedError)						ifFalse: [ 							self								recordValidationError:									'symbolic version ' , symbolicVersion printString , ' does not resolve to a literal version.'								callSite: #validatePragmas								reasonCode: #cannotResolveVersion ].					ex return: nil ].			version ~~ nil				ifTrue: [ self validateVersionSpecForSymbolicVersion: version spec symbolicVersion: symbolicVersion ] ].	hasNoVersion		ifTrue: [ 			hasNoBaseline				ifTrue: [ 					self						recordValidationError: 'No usable baseline or versions defined.'						callSite: #validatePragmas						reasonCode: #noVersionsDefined ]				ifFalse: [ 					self						recordValidationWarning: 'Only baseline defined (no version defined).'						callSite: #validatePragmas						reasonCode: #onlyBaselineVersion ] ].	^ self validationReport! !!MetacelloVersionValidator methodsFor: 'validation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34087336!validateProject: project version: versionString	| version spec |	(self visited includes: project configuration class)		ifTrue: [ ^ self validationReport ].	self visited add: project configuration class.	[ version := project version: versionString ]		on: Error		do: [ :ex | 			self				recordValidationError: 'Could not resolve version ' , versionString printString , ' due to error: ' , ex description				versionString: versionString				callSite: #validateProject:version:				reasonCode: #cannotResolveVersion.			^ self validationReport ].	spec := version spec.	[ 	spec blessing value == #baseline		ifTrue: [ self validateBaselineVersionSpec: spec ]		ifFalse: [ self validateVersionSpec: spec ] ]		on: Error		do: [ :ex | 			self				recordValidationError: 'Error composing version ' , version versionString printString , ': ' , ex description				versionString: version versionString				callSite: #validateProject:version:				reasonCode: #versionCompositionError ].	^ self validationReport! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34088440!validateProjectCreationFrom: aConfigurationClass onError: aBlock    [ ^ aConfigurationClass project ]        on: Error , MetacelloValidationNotification , MetacelloErrorInProjectConstructionNotification        do: [ :ex |             (ex isKindOf: MetacelloValidationNotification)                ifTrue: [                     self validationReport add: ex issue.                    ex resume ].            (ex isKindOf: MetacelloErrorInProjectConstructionNotification)                ifTrue: [                     self                        recordValidationError:                            'Error creating version: ' , ex versionString , ' error: ' , ex exception description                                , ' to reproduce evalutate the following: ''[' , self configurationClass name asString                                ,                                    ' project ] on: MetacelloErrorInProjectConstructionNotification do: [:ex | ex resume: true ]'''                        callSite: #'validateProjectCreationFrom:onError:'                        reasonCode: #'versionCreationError'.                    ex resume: false ].            ^ aBlock value: ex ]! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34088841!validateProjectVersion: versionString	| project |	project := self		validateProjectCreationFrom: self configurationClass		onError: [ :ex | 			self				recordValidationError:					'Error creating project: ' , ex description , ' to reproduce evalutate the following: '''						, self configurationClass name asString , ' project'''				callSite: #validateProject				reasonCode: #projectCreationError.			^ self validationReport ].	^ self validateProject: project version: versionString! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34089423!validateVersionSpec: versionSpec	self subclassResponsibility! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34089578!validateVersionSpecForSymbolicVersion: versionSpec symbolicVersion: symbolicVersionString	self subclassResponsibility! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34089791!validationReport		validationReport == nil ifTrue: [ validationReport := OrderedCollection new ].	^ validationReport! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34090003!validationReport: anObject	validationReport := anObject! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34090154!visited	visited == nil ifTrue: [ visited := IdentitySet new ].	^visited! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34090323!visited: anIdentitySet	visited := anIdentitySet! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34090465!warningReasonCodes	^ #(#onlyBaselineVersion )! !!MetacelloValidationWarning methodsFor: 'testing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34179680!isWarning	^true! !!MetacelloValidationWarning methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34179792!label	^'Warning'! !!Symbol methodsFor: '*metacello-core' stamp: 'dkh 9/7/2012 13:11' prior: 34186144!asMetacelloAttributeList    ^ {self}! !!Symbol methodsFor: '*metacello-core' stamp: 'dkh 9/7/2012 13:44' prior: 34186255!asMetacelloAttributePath    ^ MetacelloMethodSectionPath with: {self}! !!Symbol methodsFor: '*metacello-core' stamp: 'DaleHenrichs 12/21/2010 13:54' prior: 34186805!setPostLoadDoItInMetacelloSpec: aMetacelloSpec    self precedence == 0        ifTrue: [ self error: 'Invalid selector' ].    aMetacelloSpec        setPostLoadDoIt:            (aMetacelloSpec project valueHolderSpec                value: self;                yourself)! !!Symbol methodsFor: '*metacello-core' stamp: 'DaleHenrichs 12/21/2010 13:55' prior: 34187039!setPreLoadDoItInMetacelloSpec: aMetacelloSpec    self precedence == 0        ifTrue: [ self error: 'Invalid selector' ].    aMetacelloSpec        setPreLoadDoIt:            (aMetacelloSpec project valueHolderSpec                value: self;                yourself)! !!MetacelloSpecLoader class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34175574!on: aMetacelloPackagesSpec	^(self new) 		spec: aMetacelloPackagesSpec;		yourself! !!MetacelloSpecLoader methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34175736!load	self subclassResponsibility! !!MetacelloSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34175849!loadType	"#atomic or #linear"		^self project loadType! !!MetacelloSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34175984!project	^self spec project! !!MetacelloSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34176092!spec	^spec! !!MetacelloSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34176184!spec: aMetacelloPackagesSpec	spec := aMetacelloPackagesSpec! !!MetacelloSpecLoader methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34176323!unload	self subclassResponsibility! !!MetacelloToolBoxConstructor methodsFor: 'api callbacks' stamp: 'dkh 9/7/2012 13:12' prior: 34046969!setFor: attributeList do: aBlock    "conditional version support"    | methodSection |    methodSection := MetacelloVersionMethodSection new        attributes: attributeList asMetacelloAttributeList;        block: aBlock;        yourself.    currentSection ~~ nil        ifTrue: [ currentSection addMethodSection: methodSection ]        ifFalse: [ self methodSections add: methodSection ]! !!MetacelloToolBoxConstructor methodsFor: 'api callbacks' stamp: 'dkh 9/7/2012 13:12' prior: 34047464!setFor: attributeList version: aString    "conditional symbolicVersion support"    self methodSections        add:            (MetacelloSymbolicVersionSpec new                attributes: attributeList asMetacelloAttributeList;                versionString: aString;                yourself)! !!MetacelloAddMemberSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34148589!applyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock	addBlock value: self! !!MetacelloAddMemberSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34148765!applyToList: aListSpec	aListSpec add: self! !!MetacelloAddMemberSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34148891!methodUpdateSelector	^#overrides:! !!MetacelloAbstractConstructor methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34025709!configurationClass	^self subclassResponsibility! !!MetacelloAbstractConstructor methodsFor: 'pragma extraction' stamp: 'dkh 6/5/2012 19:01:24' prior: 34025863!extractAllVersionPragmas	| aDict |	aDict := Dictionary new.	self extractPragmas: #version: into: aDict.	self extractPragmas: #version:imports: into: aDict.	^aDict! !!MetacelloAbstractConstructor methodsFor: 'pragma extraction' stamp: 'dkh 6/5/2012 19:01:24' prior: 34026136!extractCommonDefaultSymbolicVersionPragmas	| aDict |	aDict := Dictionary new.	self extractPragmas: #defaultSymbolicVersion: for: ConfigurationOf into: aDict.	^aDict! !!MetacelloAbstractConstructor methodsFor: 'pragma extraction' stamp: 'dkh 6/5/2012 19:01:24' prior: 34026421!extractDefaultSymbolicVersionPragmas	| aDict |	aDict := Dictionary new.	self extractPragmas: #defaultSymbolicVersion: into: aDict.	^aDict! !!MetacelloAbstractConstructor methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34026658!extractPragmas: pragmaKeyword for: aClass into: versionDict	| versionString  pragmas |	(Pragma 		allNamed: pragmaKeyword		in: aClass) do: [:pragma |			versionString := pragma argumentAt: 1.			pragmas := versionDict 				at: versionString 				ifAbsent: [ | list |					list := OrderedCollection new.					versionDict at: versionString put: list.					list ].			pragmas add: pragma ].! !!MetacelloAbstractConstructor methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34027145!extractPragmas: pragmaKeyword into: versionDict	^self extractPragmas: pragmaKeyword for: self configurationClass into: versionDict! !!MetacelloAbstractConstructor methodsFor: 'pragma extraction' stamp: 'dkh 6/5/2012 19:01:24' prior: 34027383!extractSymbolicVersionPragmas	| aDict |	aDict := Dictionary new.	self extractPragmas: #symbolicVersion: into: aDict.	^aDict! !!MetacelloAbstractConstructor methodsFor: 'pragma extraction' stamp: 'dkh 6/5/2012 19:01:24' prior: 34027616!extractVersionImportPragmas	| aDict |	aDict := Dictionary new.	self extractPragmas: #version:imports: into: aDict.	^aDict! !!MetacelloAbstractConstructor methodsFor: 'pragma extraction' stamp: 'dkh 6/5/2012 19:01:24' prior: 34027847!extractVersionPragmas	| aDict |	aDict := Dictionary new.	self extractPragmas: #version: into: aDict.	^aDict! !!MetacelloMemberSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34149653!applyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock	self subclassResponsibility! !!MetacelloMemberSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34149835!applyToList: aListSpec	self subclassResponsibility! !!MetacelloMemberSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34149965!configMethodCascadeOn: aStream last: lastCascade indent: indent	self spec 		configMethodCascadeOn: aStream 		member: self 		last: lastCascade 		indent: indent! !!MetacelloMemberSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34150208!configMethodOn: aStream indent: indent	aStream nextPutAll: self class name asString, ' member: ('.	self spec configMethodOn: aStream indent: indent.	aStream nextPutAll: ')'.! !!MetacelloMemberSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34150464!methodUpdateSelector	^self subclassResponsibility! !!MetacelloMemberSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34150595!name	^name! !!MetacelloMemberSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34150687!name: aString	name := aString! !!MetacelloMemberSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34150797!sourceName	^self name! !!MetacelloMemberSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34150900!spec	^spec! !!MetacelloMemberSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34150992!spec: aMetacelloSpec	spec := aMetacelloSpec! !!MetacelloSemanticVersionNumber class methodsFor: 'private' stamp: 'dkh 6/22/2012 14:53'!extractNumericComponent: subString forPattern: forPattern    "$. separated components are integers"    | number |    forPattern        ifTrue: [ ^ subString ].    number := [ subString asNumber ]        on: Error        do: [ :ex | ex return: subString ].    ^ number asString = subString        ifTrue: [ number ]        ifFalse: [ subString ]! !!MetacelloSemanticVersionNumber class methodsFor: 'instance creation' stamp: 'dkh 6/22/2012 14:50'!fromString: aString    ^ self fromString: aString forPattern: false! !!MetacelloSemanticVersionNumber class methodsFor: 'instance creation' stamp: 'dkh 6/22/2012 16:48'!fromString: aString forPattern: forPattern    | new tokens preRelease build versionString identifierCount normalEnd preReleaseEnd normalComponents preReleaseComponents buildComponents |    normalComponents := OrderedCollection new.    preReleaseComponents := OrderedCollection new.    buildComponents := OrderedCollection new.    preRelease := aString indexOf: $- startingAt: 1.    build := aString indexOf: $+ startingAt: 1.    (build > 0 and: [ preRelease > build ])        ifTrue: [ preRelease := 0 ].    normalEnd := preRelease = 0        ifTrue: [             build = 0                ifTrue: [ aString size ]                ifFalse: [ build - 1 ] ]        ifFalse: [ preRelease - 1 ].    versionString := aString copyFrom: 1 to: normalEnd.    identifierCount := 0.    (versionString findTokens: '.')        do: [ :subString |             | integer |            forPattern                ifTrue: [ integer := subString ]                ifFalse: [                     integer := subString asInteger.                    integer < 0                        ifTrue: [ self error: 'invalid version number: normal version component must be integer ' , subString printString ] ].            normalComponents add: integer.            identifierCount := identifierCount + 1 ].    (forPattern not and: [ identifierCount ~= 3 ])        ifTrue: [ self error: 'invalid version number: normal version must have only 3 components' ].    preReleaseEnd := build = 0        ifTrue: [ aString size ]        ifFalse: [ build - 1 ].    preRelease > 0        ifTrue: [             versionString := aString copyFrom: preRelease + 1 to: preReleaseEnd.            (versionString findTokens: '.')                do: [ :subString |                     (forPattern or: [ self isSemanticIdentifier: subString ])                        ifFalse: [ self error: 'invalid version number: preRelease version component must be one of [0-9A-Za-z-]' ].                    preReleaseComponents add: (self extractNumericComponent: subString forPattern: forPattern) ] ].    build > 0        ifTrue: [             versionString := aString copyFrom: build + 1 to: aString size.            (versionString findTokens: '.')                do: [ :subString |                     (forPattern or: [ self isSemanticIdentifier: subString ])                        ifFalse: [ self error: 'invalid version number: build version component must be one of [0-9A-Za-z-]' ].                    buildComponents add: (self extractNumericComponent: subString forPattern: forPattern) ] ].    ^ self new        normalVersion: normalComponents;        preReleaseVersion: preReleaseComponents;        buildVersion: buildComponents;        yourself! !!MetacelloSemanticVersionNumber class methodsFor: 'private' stamp: 'dkh 6/21/2012 18:43'!isSemanticIdentifier: aString    "whether the receiver is composed entirely of alphanumerics"    aString        do: [ :c |             c isAlphaNumeric                ifFalse: [                     c = $-                        ifFalse: [ ^ false ] ] ].    ^ true! !!MetacelloSemanticVersionNumber methodsFor: 'comparing' stamp: 'dkh 6/21/2012 19:52'!< aMetacelloVersionNumber    aMetacelloVersionNumber species = self species        ifFalse: [ ^ false ].    ^ self compareLessThan: aMetacelloVersionNumber! !!MetacelloSemanticVersionNumber methodsFor: 'comparing' stamp: 'dkh 6/21/2012 19:53'!= aMetacelloVersionNumber    aMetacelloVersionNumber species = self species        ifFalse: [ ^ false ].    ^ self compareEqualTo: aMetacelloVersionNumber! !!MetacelloSemanticVersionNumber methodsFor: 'accessing' stamp: 'dkh 6/21/2012 17:59'!approximateBase	| base |	base := self copyFrom: 1 to: self size - 1.	base at: base size put: (base at: base size) + 1.	^base! !!MetacelloSemanticVersionNumber methodsFor: 'converting' stamp: 'dkh 6/21/2012 18:02'!asMetacelloSemanticVersionNumber    ^ self! !!MetacelloSemanticVersionNumber methodsFor: 'printing' stamp: 'dkh 07/09/2012 16:15'!asString	"Answer a string that represents the receiver."	^ self printString! !!MetacelloSemanticVersionNumber methodsFor: 'accessing' stamp: 'dkh 6/21/2012 21:06'!buildVersion    buildVersion ifNil: [ buildVersion := #() ].    ^ buildVersion! !!MetacelloSemanticVersionNumber methodsFor: 'accessing' stamp: 'dkh 6/21/2012 21:05'!buildVersion: anObject	buildVersion := anObject! !!MetacelloSemanticVersionNumber methodsFor: 'private' stamp: 'dkh 6/22/2012 11:02'!compareEqualTo: aMetacelloVersionNumber    aMetacelloVersionNumber species = self species        ifFalse: [ ^ false ].    (self compareEqualTo: self normalVersion other: aMetacelloVersionNumber normalVersion)        ifFalse: [ ^ false ].    (self compareEqualTo: self preReleaseVersion other: aMetacelloVersionNumber preReleaseVersion)        ifFalse: [ ^ false ].    ^ self compareEqualTo: self buildVersion other: aMetacelloVersionNumber buildVersion! !!MetacelloSemanticVersionNumber methodsFor: 'private' stamp: 'dkh 6/21/2012 21:26'!compareEqualTo: myComponents other: otherComponents    | mySize |    mySize := myComponents size.    mySize = otherComponents size        ifFalse: [ ^ false ].    1 to: mySize do: [ :i |         (myComponents at: i) = (otherComponents at: i)            ifFalse: [ ^ false ] ].    ^ true! !!MetacelloSemanticVersionNumber methodsFor: 'private' stamp: 'dkh 6/22/2012 15:20'!compareLessThan: aMetacelloVersionNumber    | myComponents otherComponents defaultResult |    aMetacelloVersionNumber species = self species        ifFalse: [ ^ false ].    myComponents := self normalVersion.    otherComponents := aMetacelloVersionNumber normalVersion.    defaultResult := true.    (self compareEqualTo: myComponents other: otherComponents)        ifTrue: [ defaultResult := false ]        ifFalse: [             (self compareLessThan: myComponents other: otherComponents version: #'normal')                ifFalse: [ ^ false ] ].    myComponents := self preReleaseVersion.    otherComponents := aMetacelloVersionNumber preReleaseVersion.    (self compareEqualTo: myComponents other: otherComponents)        ifTrue: [             myComponents size > 0                ifTrue: [ defaultResult := false ] ]        ifFalse: [ ^ self compareLessThan: myComponents other: otherComponents version: #'preRelease' ].    myComponents := self buildVersion.    otherComponents := aMetacelloVersionNumber buildVersion.    ^ (self compareEqualTo: myComponents other: otherComponents)        ifTrue: [ defaultResult ]        ifFalse: [ self compareLessThan: myComponents other: otherComponents version: #'build' ]! !!MetacelloSemanticVersionNumber methodsFor: 'private' stamp: 'dkh 6/22/2012 15:28'!compareLessThan: myComponents other: otherComponents version: version    | mySize aSize commonSize count more |    mySize := myComponents size.    aSize := otherComponents size.    commonSize := mySize min: aSize.    count := 0.    more := true.    [ more and: [ count < commonSize ] ]        whileTrue: [             (myComponents at: count + 1) = (otherComponents at: count + 1)                ifTrue: [ count := count + 1 ]                ifFalse: [ more := false ] ].    count < commonSize        ifTrue: [ ^ (myComponents at: count + 1) metacelloSemanticVersionComponentLessThan: (otherComponents at: count + 1) ].    mySize < aSize        ifTrue: [             mySize = 0                ifTrue: [                     #'preRelease' == version                        ifTrue: [ ^ false ].                    ^ true ].            (myComponents at: commonSize) = (otherComponents at: commonSize)                ifFalse: [ ^ true ].            ^ true ]        ifFalse: [             mySize = aSize                ifTrue: [ ^ false ].            aSize = 0                ifTrue: [                     #'build' == version                        ifTrue: [ ^ false ].                    ^ true ].            (myComponents at: commonSize) = (otherComponents at: commonSize)                ifFalse: [ ^ false ].            ^ true ]! !!MetacelloSemanticVersionNumber methodsFor: 'copying' stamp: 'dkh 6/21/2012 17:59'!copyFrom: start to: stop 	"Answer a copy of a subset of the receiver, starting from element at 	index start until element at index stop."	| newSize new j |	newSize := stop - start + 1.	new := self species new: newSize.	j := 0.	start to: stop do: [:i |		new at: j + 1 put: (self at: i).		j := j + 1 ].	^new! !!MetacelloSemanticVersionNumber methodsFor: 'operations' stamp: 'dkh 6/21/2012 17:59'!decrementMinorVersionNumber	| int |	self size to: 1 by: -1 do: [ :index | 		(int := self at: index) isString			ifFalse: [ 				int > 0					ifTrue: [ self at: index put: int - 1 ].				^ self ] ]! !!MetacelloSemanticVersionNumber methodsFor: 'enumerating' stamp: 'dkh 6/21/2012 17:59'!do: aBlock 	"Refer to the comment in Collection|do:."	1 to: self size do:		[:index | aBlock value: (self at: index)]! !!MetacelloSemanticVersionNumber methodsFor: 'enumerating' stamp: 'dkh 6/21/2012 17:59'!do: elementBlock separatedBy: separatorBlock	"Evaluate the elementBlock for all elements in the receiver,	and evaluate the separatorBlock between."	| beforeFirst | 	beforeFirst := true.	self do:		[:each |		beforeFirst			ifTrue: [beforeFirst := false]			ifFalse: [separatorBlock value].		elementBlock value: each]! !!MetacelloSemanticVersionNumber methodsFor: 'comparing' stamp: 'dkh 6/22/2012 16:10'!hash    ^ self versionComponents hash! !!MetacelloSemanticVersionNumber methodsFor: 'operations' stamp: 'dkh 6/21/2012 17:59'!incrementMinorVersionNumber	| int |	self size to: 1 by: -1 do: [:index | 		(int := self at: index) isString 			ifFalse: [ 				self at: index put: int + 1.				^self ]].! !!MetacelloSemanticVersionNumber methodsFor: 'comparing' stamp: 'dkh 6/22/2012 14:57'!match: aVersionPattern    "Answer whether the version number of the receiver matches the given pattern string.	 A Metacello version number is made up of version sequences delimited by the characters $. and $-.	 The $. introduces a numeric version sequence and $- introduces an alphanumeric version sequence.	 	 A version pattern is made up of version pattern match sequences. also delimited by the characters $. 	 and $-.. Each pattern match sequence is tested against the corresponding version sequence of the 	 receiver, using the 'standard' pattern matching rules. All sequences must answer true for a match.		 The special pattern sequence '?' is a match for the corresponding version sequence and all subsequent 	 version sequences. '?' as the version pattern matches all versions. No more version pattern 	 sequences are permitted once the '?' sequence is used. If used, it is the last version pattern	 sequence. "    | patternVersion mySize patternSize components |    patternVersion := (self class fromString: aVersionPattern forPattern: true) versionComponents.    components := self versionComponents.    mySize := components size.    patternSize := patternVersion size.    mySize = patternSize        ifFalse: [             mySize < patternSize                ifTrue: [ ^ false ].            (patternVersion at: patternSize) ~= '?'                ifTrue: [ ^ false ].            mySize := patternSize ].    1 to: mySize do: [ :i |         | pattern |        pattern := (patternVersion at: i) asString.        pattern = '?'            ifTrue: [                 i = mySize                    ifFalse: [ ^ self error: 'Invalid version match pattern: ' , aVersionPattern printString ] ]            ifFalse: [                 (pattern match: (components at: i) asString)                    ifFalse: [ ^ false ] ] ].    ^ true! !!MetacelloSemanticVersionNumber methodsFor: 'accessing' stamp: 'dkh 6/21/2012 21:06'!normalVersion    normalVersion ifNil: [ normalVersion := #() ].    ^ normalVersion! !!MetacelloSemanticVersionNumber methodsFor: 'accessing' stamp: 'dkh 6/21/2012 21:05'!normalVersion: anObject	normalVersion := anObject! !!MetacelloSemanticVersionNumber methodsFor: 'accessing' stamp: 'dkh 6/21/2012 21:06'!preReleaseVersion    preReleaseVersion ifNil: [ preReleaseVersion := #() ].    ^ preReleaseVersion! !!MetacelloSemanticVersionNumber methodsFor: 'accessing' stamp: 'dkh 6/21/2012 21:05'!preReleaseVersion: anObject	preReleaseVersion := anObject! !!MetacelloSemanticVersionNumber methodsFor: 'printing' stamp: 'dkh 6/21/2012 21:16'!print: components prefix: prefixChar on: aStream    | beforeFirst |    beforeFirst := true.    components        do: [ :component |             beforeFirst                ifTrue: [                     beforeFirst := false.                    prefixChar ifNotNil: [ aStream nextPut: prefixChar ] ]                ifFalse: [ aStream nextPut: $. ].            aStream nextPutAll: component asString ]! !!MetacelloSemanticVersionNumber methodsFor: 'printing' stamp: 'dkh 6/21/2012 21:17'!printOn: aStream    self print: self normalVersion prefix: nil on: aStream.    self print: self preReleaseVersion prefix: $- on: aStream.    self print: self buildVersion prefix: $+ on: aStream! !!MetacelloSemanticVersionNumber methodsFor: 'private' stamp: 'dkh 6/22/2012 14:44'!versionComponents    ^ self normalVersion , self preReleaseVersion , self buildVersion! !!MetacelloSemanticVersionNumber methodsFor: 'accessing' stamp: 'dkh 6/21/2012 17:59'!versionString	| strm |	strm := WriteStream on: String new.	self printOn: strm.	^strm contents! !!MetacelloSemanticVersionNumber methodsFor: 'comparing' stamp: 'dkh 6/21/2012 17:59'!~> aMetacelloVersionNumber	aMetacelloVersionNumber size == 1 ifTrue: [ ^false ].	^self >= aMetacelloVersionNumber and: [ self < aMetacelloVersionNumber approximateBase ]! !!MetacelloPlatform class methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34102990!current	Current		ifNil: [Current := MetacelloPlatform new].	^ Current! !!MetacelloPlatform class methodsFor: 'initialize-release' stamp: 'dkh 05/05/2013 13:39' prior: 34103154!initialize  "noop ... use #select"  ! !!MetacelloPlatform class methodsFor: 'initialize-release' stamp: 'dkh 05/05/2013 13:39'!select  Current := self new! !!MetacelloPlatform class methodsFor: 'initialize-release' stamp: 'dkh 05/05/2013 13:39'!unselect  MetacelloPlatform current class = self    ifTrue: [ Current := nil ]! !!MetacelloPlatform methodsFor: 'utilities' stamp: 'dkh 6/5/2012 19:01:24' prior: 34103411!authorName	Smalltalk at: #Author ifPresent: [:cl | ^cl perform: #initials ].	^'no developer initials'! !!MetacelloPlatform methodsFor: 'utilities' stamp: 'dkh 6/5/2012 19:01:24' prior: 34103591!authorName: aString	"Primarily used for testing"	self subclassResponsibility! !!MetacelloPlatform methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34103757!bypassGoferLoadUpdateCategories	bypassGoferLoadUpdateCategories == nil ifTrue: [ bypassGoferLoadUpdateCategories := false ].	^ bypassGoferLoadUpdateCategories! !!MetacelloPlatform methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34104005!bypassGoferLoadUpdateCategories: anObject	bypassGoferLoadUpdateCategories := anObject! !!MetacelloPlatform methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34104177!bypassProgressBars	bypassProgressBars == nil ifTrue: [ bypassProgressBars := false ].	^ bypassProgressBars! !!MetacelloPlatform methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34104372!bypassProgressBars: anObject	bypassProgressBars := anObject! !!MetacelloPlatform methodsFor: 'caching' stamp: 'dkh 6/5/2012 19:01:24' prior: 34104506!clearCurrentVersionCache	MetacelloClearStackCacheNotification signal: #(#currentVersion #currentVersionAgainst: #currentVersionInfo)! !!MetacelloPlatform methodsFor: 'notification' stamp: 'dkh 6/5/2012 19:01:24' prior: 34104728!collection: aCollection do: aBlock displaying: aString	aCollection do: aBlock! !!MetacelloPlatform methodsFor: 'user interaction' stamp: 'dkh 6/5/2012 19:01:24' prior: 34104891!confirm: aString		^(Smalltalk hasClassNamed: #UIManager)		ifTrue: [ (Smalltalk classNamed: #UIManager) default perform: #confirm: with: aString ]		ifFalse: [			"throw warning and answer true, if no way to announce"			Warning signal: aString.			true ]! !!MetacelloPlatform methodsFor: 'reflection' stamp: 'dkh 6/5/2012 19:01:24' prior: 34105236!copyClass: oldClass as: newName inCategory: newCategoryName	self subclassResponsibility! !!MetacelloPlatform methodsFor: 'repository creation' stamp: 'ChristopheDemarey 4/29/2013 13:22' prior: 34105420!createRepository: aRepositorySpec    | type |    type := aRepositorySpec type.    type = 'http'        ifTrue: [             ^ MCHttpRepository                location: aRepositorySpec description                user: aRepositorySpec username                password: aRepositorySpec password ].    type = 'directory'        ifTrue: [ ^ MCDirectoryRepository new directory:  (self fileHandleOn: aRepositorySpec description) ].    Smalltalk        at: #'MCFileTreeRepository'        ifPresent: [ :cl |             type = 'filetree'                ifTrue: [                     | description headerSize |                    description := aRepositorySpec description.                    headerSize := 'filetree://' size.                    ^ cl new                        directory:                             (self fileHandleOn: (aRepositorySpec description copyFrom: headerSize + 1 to: description size)) ] ].    Smalltalk        at: #'MCGitHubRepository'        ifPresent: [ :cl |             type = 'github'                ifTrue: [ ^ cl location: aRepositorySpec description ] ].    type = 'dictionary'        ifTrue: [             | description headerSize globalName |            description := aRepositorySpec description.            headerSize := 'dictionary://' size.            globalName := (description copyFrom: headerSize + 1 to: description size) asSymbol.            ^ Smalltalk                at: globalName                ifAbsent: [                     Smalltalk                        at: globalName                        put:                            (MCDictionaryRepository new                                description: description;                                yourself) ] ].    ^ nil! !!MetacelloPlatform methodsFor: 'file system' stamp: 'ChristopheDemarey 4/29/2013 14:17'!defaultDirectory	"Get the image default directory"		^self fileDirectoryClass default! !!MetacelloPlatform methodsFor: 'attributes' stamp: 'ChristopheDemarey 5/31/2013 14:04' prior: 34106213!defaultPlatformAttributes	| versionString |	Smalltalk at: #SystemVersion ifPresent: [:cl |		versionString := cl current version.		(versionString beginsWith: 'Pharo')			ifTrue: [ ^ #(#squeakCommon #pharo ) ].		(versionString beginsWith: 'Squeak')			ifTrue: [^ #(#squeakCommon #squeak )].		"see http://code.google.com/p/metacello/issues/detail?id=146"		(self string: versionString includesSubstring: 'Pharo')			ifTrue: [ ^ #(#squeakCommon #pharo ) ].		(versionString includesSubstring: 'Squeak')			ifTrue: [^ #(#squeakCommon #squeak )].		self error: 'Unrecognized version of Squeak/Pharo: ', versionString ].	^ #(#gemstone )! !!MetacelloPlatform methodsFor: 'scripting' stamp: 'dkh 7/23/2012 11:05'!defaultRepositoryDescription    ^ 'http://www.squeaksource.com/MetacelloRepository'! !!MetacelloPlatform methodsFor: 'tests' stamp: 'dkh 6/5/2012 19:01:24' prior: 34106908!defaultTimeout	"squeak compatability"	^60! !!MetacelloPlatform methodsFor: 'file system' stamp: 'ChristopheDemarey 4/29/2013 15:11'!directoryFromPath: adirectoryPath relativeTo: anotherDirectoryPath	"Get a handle on the following path: anotherDirectoryPath/adirectoryPath"	^ anotherDirectoryPath directoryNamed: adirectoryPath! !!MetacelloPlatform methodsFor: 'notification' stamp: 'dkh 6/5/2012 19:01:24' prior: 34107041!do: aBlock displaying: aString	aBlock value! !!MetacelloPlatform methodsFor: 'as yet unclassified' stamp: 'dkh 07/01/2013 08:49'!downloadErrorFileNameFor: zipFileName  ^ '/tmp/curl-' , (zipFileName select: [ :c | c isAlphaNumeric ]) , '.err'! !!MetacelloPlatform methodsFor: 'github support' stamp: 'dkh 7/7/2012 07:37'!downloadFile: url to: outputFileName    "download from <url> into <outputFileName>"    self subclassResponsibility! !!MetacelloPlatform methodsFor: 'file system' stamp: 'ChristopheDemarey 4/29/2013 15:17'!ensureDirectoryExists: aDirectoryHandle	"Ensure the directory exists."	^ aDirectoryHandle assureExistence ; yourself! !!MetacelloPlatform methodsFor: 'github support' stamp: 'dkh 7/7/2012 07:36'!extractRepositoryFrom: zipFile to: directory    "unzip <zipFile> into <directory>"    self subclassResponsibility! !!MetacelloPlatform methodsFor: 'repository creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34107172!extractTypeFromDescription: description    description == nil        ifTrue: [ ^ nil ].    ((description beginsWith: '/') or: [ description second = $: ])        ifTrue: [ ^ 'directory' ].    (description beginsWith: 'dictionary://')        ifTrue: [ ^ 'dictionary' ].    (description beginsWith: 'filetree://')        ifTrue: [ ^ 'filetree' ].    (description beginsWith: 'github://')        ifTrue: [ ^ 'github' ].    ^ 'http'! !!MetacelloPlatform methodsFor: 'github support' stamp: 'dkh 07/09/2012 04:45'!fileDirectoryClass	^FileDirectory! !!MetacelloPlatform methodsFor: 'file system' stamp: 'ChristopheDemarey 5/14/2013 17:41'!fileFromPath: aFileName relativeTo: aDirectoryPath	"Get a handle on the following path: anotherDirectoryPath/aFileName"	^ aDirectoryPath entryAt: aFileName! !!MetacelloPlatform methodsFor: 'file system' stamp: 'ChristopheDemarey 4/29/2013 15:37'!fileHandleOn: aPath	"Get an handle on a file."	^ self fileDirectoryClass on: aPath! !!MetacelloPlatform methodsFor: 'reflection' stamp: 'dkh 6/5/2012 19:01:24' prior: 34107497!globalNamed: globalName	^Smalltalk at: globalName! !!MetacelloPlatform methodsFor: 'reflection' stamp: 'dkh 6/5/2012 19:01:24' prior: 34107626!globalNamed: globalName ifAbsent: absentBlock	^Smalltalk at: globalName ifAbsent: absentBlock! !!MetacelloPlatform methodsFor: 'repository creation' stamp: 'dkh 05/08/2013 09:33'!packageInfoFor: aMCWorkingCopy  ^ aMCWorkingCopy packageInfo! !!MetacelloPlatform methodsFor: 'file system' stamp: 'ChristopheDemarey 5/29/2013 18:16'!parentDirectoryOf: aFileHandler	"Get the parent directory of this file."		^ aFileHandler containingDirectory! !!MetacelloPlatform methodsFor: 'caching' stamp: 'dkh 6/5/2012 19:01:24' prior: 34107805!primeStackCacheFor: cacheName doing: noArgBlock defaultDictionary: aDictionary	self deprecated: 'use #primeStackCacheWith:doing:'.	self 		useStackCacheDuring: [:dict | | cache |			cache := dict at: cacheName ifAbsent: [].			cache == nil				ifTrue: [ 					cache := Dictionary new.					dict at: cacheName put: cache ].			^noArgBlock value ] 		defaultDictionary: aDictionary! !!MetacelloPlatform methodsFor: 'caching' stamp: 'dkh 6/5/2012 19:01:24' prior: 34108271!primeStackCacheWith: aDictionary doing: noArgBlock	self 		useStackCacheDuring: [:dict | ^noArgBlock value ] 		defaultDictionary: aDictionary! !!MetacelloPlatform methodsFor: 'file system' stamp: 'ChristopheDemarey 5/14/2013 18:04'!readStreamOn: aFileHandle do: aBlock	"Get a read stream on the file handle and execute some actions on it."	| stream |	stream := aFileHandle readStream.	^ [ aBlock value: stream ] 		ensure: [ stream close ]! !!MetacelloPlatform methodsFor: 'file system' stamp: 'ChristopheDemarey 5/27/2013 17:42'!recursiveDelete: aDirectory	"delete this directory and all children of it"	^  aDirectory recursiveDelete! !!MetacelloPlatform methodsFor: 'caching' stamp: 'dkh 6/5/2012 19:01:24' prior: 34108489!stackCacheFor: cacheName at: key doing: aBlock	^self stackCacheFor: cacheName cacheClass: Dictionary at: key doing: aBlock! !!MetacelloPlatform methodsFor: 'caching' stamp: 'dkh 6/5/2012 19:01:24' prior: 34108687!stackCacheFor: cacheName cacheClass: cacheClass at: key doing: aBlock	self 		useStackCacheDuring: [:dict | | cache |			cache := dict at: cacheName ifAbsent: [].			cache ~~ nil				ifTrue: [ | value hasEntry |					hasEntry := true.					value := cache at: key ifAbsent: [ hasEntry := false ].					hasEntry ifTrue: [ ^value ]]				ifFalse: [ 					cache := cacheClass new.					dict at: cacheName put: cache ].			^aBlock value: cache ] 		defaultDictionary: nil! !!MetacelloPlatform methodsFor: 'utilities' stamp: 'ChristopheDemarey 5/31/2013 13:02'!string: aString includesSubstring: aSubstring	"abstract String>>includesSubstring: to have the same message on all supported platforms."	^aString includesSubString: aSubstring! !!MetacelloPlatform methodsFor: 'system' stamp: 'ChristopheDemarey 4/29/2013 16:17'!suspendSystemUpdateEventsDuring: aBlock	"Wraps call to the system evetn manager to tell it that we want to suspend events during execution of aBlock"	SystemChangeNotifier uniqueInstance doSilently: aBlock! !!MetacelloPlatform methodsFor: 'utilities' stamp: 'dkh 6/5/2012 19:01:24' prior: 34109231!timestamp	^DateAndTime now printString! !!MetacelloPlatform methodsFor: 'transactions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34109352!transact: aBlock	"On GemStone, we want to optionally abort before command execution and commit after 	 common execution. Other plaforms don't need to do anything special.	 Returning out of block, skips commit."		aBlock value! !!MetacelloPlatform methodsFor: 'caching' stamp: 'dkh 6/5/2012 19:01:24' prior: 34109655!useStackCacheDuring: aBlock defaultDictionary: defaultDictionary	| dict |	dict := MetacelloStackCacheNotification signal.	dict == nil		ifTrue: [ 			dict := defaultDictionary == nil				ifTrue: [ Dictionary new ]				ifFalse: [ defaultDictionary ] ].	[ ^ aBlock value: dict ]		on: MetacelloStackCacheNotification , MetacelloClearStackCacheNotification		do: [ :ex | 			(ex isKindOf: MetacelloStackCacheNotification)				ifTrue: [ ex resume: dict ].			(ex isKindOf: MetacelloClearStackCacheNotification)				ifTrue: [ 					| keys |					keys := ex cacheNames.					keys ifNil: [ keys := dict keys ].					keys						do: [ :k | 							(dict includesKey: k)								ifTrue: [ 									| c |									c := dict at: k.									c keys do: [ :ck | c removeKey: ck ].									dict removeKey: k ] ].					ex resume ] ]! !!MetacelloSymbolicVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34092335!versionString	^ versionString! !!MetacelloSymbolicVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34092463!versionString: anObject	versionString := anObject! !!DateAndTime methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setTimestampInMetacelloConfig: aMetacelloConfig    aMetacelloConfig setTimestampWithString: self printString! !!DateAndTime methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34021234!setTimestampInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setTimestamp: 		(aMetacelloVersionSpec project valueHolderSpec			value: self printString;			yourself)! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/21/2012 18:06'!asMetacelloSemanticVersionNumber    ^ MetacelloSemanticVersionNumber fromString: ''! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34021497!asMetacelloVersionNumber	^MetacelloVersionNumber fromString: ''! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!metacelloRegistrationHash    ^ self hash! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!registrationsCompareEqual: aMetacelloProjectSpec    ^ self = aMetacelloProjectSpec! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34021643!setAuthorInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setAuthor: self! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34021813!setBlessingInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setBlessing: self! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34021987!setDescriptionInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setDescription: self! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34022178!setPostLoadDoItInMetacelloSpec: aMetacelloSpec	aMetacelloSpec setPostLoadDoIt: 		(aMetacelloSpec project valueHolderSpec			value: self;			yourself)! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34022421!setPreLoadDoItInMetacelloSpec: aMetacelloSpec	aMetacelloSpec setPreLoadDoIt: 		(aMetacelloSpec project valueHolderSpec			value: self;			yourself)! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34022653!setProject: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setProject: aString withString: self! !!UndefinedObject methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34022849!setTimestampInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setTimestamp: self! !!MetacelloCannotUpdateReleasedVersionError methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34023054!isResumable	"Determine whether an exception is resumable."	^ true! !!MetacelloPackageSpecResolutionError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!description    "Return a textual description of the exception."    ^ 'Could not resolve: ' , packageSpec name , ' [' , packageSpec file , ']' , ' in' , self repositoryString        ,            (repositoryError == nil                ifTrue: [ '' ]                ifFalse: [                     "report repository error to user here, since failure here is likely to be due to earlier repository error"                    ' ERROR: ' , repositoryError description printString ])! !!MetacelloPackageSpecResolutionError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!packageSpec	^ packageSpec! !!MetacelloPackageSpecResolutionError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!packageSpec: anObject	packageSpec := anObject! !!MetacelloPackageSpecResolutionError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!repositories	^ repositories! !!MetacelloPackageSpecResolutionError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!repositories: anObject	repositories := anObject! !!MetacelloPackageSpecResolutionError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!repositoryError	^ repositoryError! !!MetacelloPackageSpecResolutionError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!repositoryError: anObject	repositoryError := anObject! !!MetacelloPackageSpecResolutionError methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24'!repositoryString    | repositoryString |    repositoryString := ''.    self repositories do: [ :repo | repositoryString := repositoryString , ' ' , repo description ].    ^ repositoryString! !!MetacelloPackageSpecResolutionError methodsFor: 'Signaling' stamp: 'dkh 09/26/2014 14:07'!signal  "GemStone needs this to print exception correctly"  self messageText: self description.  ^ super signal! !!MetacelloProjectSpecLoadConflict methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34023220!isResumable	"Determine whether an exception is resumable."	^ true! !!MetacelloProjectSpecLoadConflict methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!possibleVersions    "not applicable to a Conflict error"    self shouldNotImplement! !!MetacelloProjectSpecLoadConflict methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!versionString    "not applicable to a Conflict error"    self shouldNotImplement! !!MetacelloProjectSpecLoadError class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34023400!projectSpec: aMetacelloMCProjectSpec	^self new		projectSpec: aMetacelloMCProjectSpec;		yourself! !!MetacelloProjectSpecLoadError methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34023594!isResumable	"Determine whether an exception is resumable."	^ false! !!MetacelloProjectSpecLoadError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!possibleVersions    ^ self versionDoesNotExistException possibleVersions! !!MetacelloProjectSpecLoadError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34023761!projectSpec	^projectSpec! !!MetacelloProjectSpecLoadError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34023885!projectSpec: aMetacelloMCProjectSpec	projectSpec := aMetacelloMCProjectSpec! !!MetacelloProjectSpecLoadError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!versionDoesNotExistException	^ versionDoesNotExistException! !!MetacelloProjectSpecLoadError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!versionDoesNotExistException: anObject	versionDoesNotExistException := anObject! !!MetacelloProjectSpecLoadError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!versionString    ^ self versionDoesNotExistException versionString! !!MetacelloValidationFailure class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24'!issues: anObject message: aString    ^ self new        issues: anObject;        signal: aString! !!MetacelloValidationFailure methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!issues	^ issues! !!MetacelloValidationFailure methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!issues: anObject	issues := anObject! !!MetacelloSymbolicVersionDoesNotExistError methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34024062!description    "Return a textual description of the exception."    ^ 'The symbolic version ' , self versionString printString , ' is not defined in ' , self project label        , ' for the current platform. Possible symbolic version values include: ' , self possibleVersions printString! !!MetacelloSymbolicVersionDoesNotExistError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!possibleVersions    ^ self project symbolicVersionSymbols! !!MetacelloSymbolicVersionNotDefinedError methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34024353!description    "Return a textual description of the exception."    ^ 'The symbolic version ' , self versionString printString , ' is EXPLICITLY not defined in ' , self project label        , ' for the current platform (i.e., symbolic version defined as #notDefined).'! !!MetacelloVersionDefinitionError methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24'!description    "Return a textual description of the exception."    ^ 'The version ' , self versionString printString , ' is not defined in ' , self project label        , ' for the current platform, because an exception occurred while creating the version:. '        , self exception description , '. Evaluate the following to see the error: ''['        , self project configuration class name asString        ,            ' project ] 	on: MetacelloErrorInProjectConstructionNotification 	do: [:ex | ex resume: true ].'''        ,            'Possible versions include: ' , self possibleVersions printString! !!MetacelloVersionDefinitionError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!exception	^ exception! !!MetacelloVersionDefinitionError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!exception: anObject	exception := anObject! !!MetacelloVersionDoesNotExistError class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34024673!project: aMetacelloProject versionString: aVersionString	^(self new)		project: aMetacelloProject;		versionString: aVersionString;		yourself! !!MetacelloVersionDoesNotExistError methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34024918!description    "Return a textual description of the exception."    ^ 'Version ' , self versionString printString , ' is not defined in ' , self project label        , '. Possible versions include: ' , self possibleVersions printString! !!MetacelloVersionDoesNotExistError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!possibleVersions    ^ self project symbolicVersionSymbols , (self project versions collect: [ :each | each versionString ])! !!MetacelloVersionDoesNotExistError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34025170!project	^ project! !!MetacelloVersionDoesNotExistError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34025290!project: anObject	project := anObject! !!MetacelloVersionDoesNotExistError methodsFor: 'Signaling' stamp: 'dkh 09/26/2014 14:08'!signal  "GemStone needs this to print exception correctly"  self messageText: self description.  ^ super signal! !!MetacelloVersionDoesNotExistError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34025430!versionString	^ versionString! !!MetacelloVersionDoesNotExistError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34025562!versionString: anObject	versionString := anObject! !!MetacelloAbstractVersionConstructor class methodsFor: 'method generation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34028078!symbolicMethodSelectorAndPragma: selector symbolicVersionSymbol: symbolicVersionSymbol on: strm	strm		nextPutAll: selector asString , ' spec';		cr;		tab;		nextPutAll: '<symbolicVersion: #' , symbolicVersionSymbol asString printString;		nextPutAll: '>';		cr! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34028999!author: aBlockOrString    "Define author field of version spec (MetacelloMCVersionSpec).	 If <aBlockOrString> is a String, the version spec author is set to the String.	If <aBlockOrString> is a Block, the specifications in <aBlockOrString> are applied to the author spec (MetacelloValueHolderSpec). Not Recommended!!			spec author: 'dkh'.				spec author: [			spec value: 'dkh'. ].	 "    self root author: aBlockOrString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!authorForVersion: aBlockOrString    aBlockOrString setAuthorInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'dkh 9/5/2012 06:26:03.064'!baseline: aString    self root baseline: aString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'dkh 9/5/2012 06:26:03.064'!baseline: aString with: aBlockOrString    self root baseline: aString with: aBlockOrString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!baselineForVersion: aString    self setBaseline: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!baselineForVersion: aString with: aBlock    aBlock setBaseline: aString withInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34029170!blessing: aBlockOrString    "Define blessing field of version spec (MetacelloMCVersionSpec).	 If <aBlockOrString> is a String, the version spec blessing is set to the String. It is recommended to use a Symbol.	If <aBlockOrString> is a Block, the specifications in <aBlockOrString> are applied to the blessing spec (MetacelloValueHolderSpec). Not Recommended!!			spec blessing: #release.				spec blessing: [			spec value: #release. ].		The blessing should typically be set to one of three values:		#baseline - indicating that the version spec is specifying a baseline version		#development - indicating that the version spec is not stabilized and will change over time		#release - indicating that the version spec has stabilized and will NOT change over time	 "    self root blessing: aBlockOrString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!blessingForVersion: aBlockOrString    aBlockOrString setBlessingInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34029345!className: aString    "Define className field of a project spec (MetacelloMCProjectSpec).			spec project: 'CoolBrowser' with: [			spec className: 'ConfigurationOfCoolBrowser'. ].	The className field is OPTIONAL in the project spec. If omitted, the className will be created by prepending 'ConfigurationOf' to the project name.	 "    self root className: aString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!classNameForProject: aString    self root className: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'dkh 9/5/2012 06:26:03.064'!configuration: aString with: aBlockOrString    self root configuration: aString with: aBlockOrString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!configurationForVersion: aString with: aBlock    aBlock setConfiguration: aString withInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34029914!description: aBlockOrString    "Define description field of version spec (MetacelloMCVersionSpec).	 If <aBlockOrString> is a String, the version spec blessing is set to the String. It is recommended to use a Symbol.	If <aBlockOrString> is a Block, the specifications in <aBlockOrString> are applied to the blessing spec (MetacelloValueHolderSpec). Not Recommended!!			spec description: 'Descriptive comment'.				spec description: [			spec value: 'Descriptive comment'.	 "    self root description: aBlockOrString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!descriptionForVersion: aBlockOrString    aBlockOrString setDescriptionInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34030341!file: aString    "Define file field of a package spec (MetacelloPackageSpec) or project spec (MetacelloMCProjectSpec).	For a package spec, the file: field is optional in a baseline. In a baseline, the file field may be used to specify a package branch for the package:			spec package: 'MyPackage' with: [			spec file: 'MyPackage.gemstone'. ]'.	The file: field is required in a version. In a version, the file field defines the explicit version of the package to be loaded:			spec package: 'MyPackage' with: [			spec file: 'MyPackage.gemstone-dkh.1'. ]'.	The following may be used as a short cut for specifying the file field in a version:		spec package: 'MyPackage' with: 'MyPackage.gemstone-dkh.1'.	For a project spec, the file field specifies the name of the Monticello package that contains the configuration. If you are using the convention of 	naming the class and package usingthe  'ConfigurationOf' prefix, then there is no need to specify the file field:			spec project: 'MyProject' with: [			spec file: 'ConfigurationMyProject'.	It should only be used when the package name for the configuration is different from the name of the project:		spec project: 'MyProject' with: [			spec file: 'MyProject-Metacello'.	 "    self root file: aString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!fileForPackage: aString    self root file: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!fileForProject: aString    self root file: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 11:38' prior: 34030470!for: attributeListOrSymbol do: aBlock    "conditional version support"    attributeListOrSymbol setForDo: aBlock withInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 11:37' prior: 34030701!for: attributeListOrSymbol version: aString    "conditional symbolicVersion support"    attributeListOrSymbol setForVersion: aString withInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34030963!group: aString overrides: aStringOrCollection    self root group: aString overrides: aStringOrCollection constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34031252!group: aString with: aStringOrCollection    self root group: aString with: aStringOrCollection constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!groupForVersion: aString overrides: aStringOrCollection    | spec |    spec := self project groupSpec        name: aString;        includes: aStringOrCollection;        yourself.    self root packages add: spec! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!groupForVersion: aString with: aStringOrCollection    | spec |    spec := self project groupSpec        name: aString;        includes: aStringOrCollection;        yourself.    self root packages merge: spec! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'dkh 9/5/2012 06:26:03.064'!import: aString    "import names defined in baseline <aString> to be used when loading the version		spec baseline: 'Sample' with: [ spec repository: 'github://dalehenrich/sample:master/repository' ].		spec import: 'Sample' ]	 "    self root import: aString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!importForVersion: aString    self root import: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34031538!includes: anObject    self root includes: anObject constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!includesForPackage: anObject    self root includes: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34031686!loads: anObject    self root loads: anObject constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!loadsForProject: anObject    self root loads: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34031828!name: anObject    self root name: anObject constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!nameForProject: aString    self root name: aString! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34031968!operator: anObject    self root operator: anObject constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!operatorForProject: anObject    self root operator: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34032116!package: aString    self root package: aString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34032344!package: aString overrides: aBlock    self root package: aString overrides: aBlock constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34032622!package: packageName with: aBlockOrString    "Define specification for package <packageName>.	 If <aBlockOrString> is a String (or Symbol), the String is expected to be a version (or symbolic version).	If <aBlockOrString> is a Block, the specifications in <aBlockOrString> are applied to the project:			spec package: 'MyPackage' with: '1.0'.				spec package: 'MyPackage' with: [			spec file:'MyPackage-dkh.1'.			spec repository: '/opt/gemstone/repository'.	 "    self root package: packageName with: aBlockOrString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!packageForVersion: aString    | spec |    spec := self project packageSpec        name: aString;        yourself.    self root packages add: spec! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!packageForVersion: aString overrides: aBlock    | spec |    spec := self project packageSpec        name: aString;        yourself.    self root packages add: spec.    self with: spec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!packageForVersion: packageName with: aBlockOrString    aBlockOrString setPackage: packageName withInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34032823!postLoadDoIt: aSymbol    self root postLoadDoIt: aSymbol constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!postLoadDoItForPackage: aSymbol    self postLoadDoItForSpec: aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!postLoadDoItForProject: aSymbol    self postLoadDoItForSpec: aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!postLoadDoItForSpec: aSymbol    self validateDoItSelector: aSymbol.    self root postLoadDoIt: aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!postLoadDoItForVersion: aSymbol    self postLoadDoItForSpec: aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34033014!preLoadDoIt: aSymbol    self root preLoadDoIt: aSymbol constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!preLoadDoItForPackage: aSymbol    self preLoadDoItForSpec: aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!preLoadDoItForProject: aSymbol    self preLoadDoItForSpec: aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!preLoadDoItForSpec: aSymbol    self validateDoItSelector: aSymbol.    self root preLoadDoIt: aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!preLoadDoItForVersion: aSymbol    self preLoadDoItForSpec: aSymbol! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34347945!project    project == nil        ifTrue: [ project := self projectClass new ].    ^ project! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 03/12/2011 22:11' prior: 34033203!project: aString    self root project: aString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34033352!project: aString copyFrom: oldSpecName with: aBlock    self root        project: aString        copyFrom: oldSpecName        with: aBlock        constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34033847!project: aString overrides: aBlock    self root project: aString overrides: aBlock constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34034365!project: aString with: aBlockOrString    self root project: aString with: aBlockOrString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!projectForVersion: aString    self project: aString with: ''! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!projectForVersion: aString copyFrom: oldSpecName with: aBlock    | spec projectSpec |    projectSpec := self project projectSpec        name: aString;        yourself.    spec := self project projectReferenceSpec        name: aString;        projectReference: projectSpec;        yourself.    self root packages copy: oldSpecName to: spec.    self with: projectSpec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!projectForVersion: aString overrides: aBlock    | spec projectSpec |    projectSpec := self project projectSpec        name: aString;        yourself.    spec := self project projectReferenceSpec        name: aString;        projectReference: projectSpec;        yourself.    self root packages add: spec.    self with: projectSpec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!projectForVersion: aString with: aBlockOrString    aBlockOrString setProject: aString withInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34034567!projectPackage: aBlock    "projectPackage spec data folded into project spec"    self root projectPackage: aBlock constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!projectPackageForProject: aBlock    self with: self root during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34034861!removeGroup: aString    self root removeGroup: aString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!removeGroupForVersion: aString    | spec |    spec := self project groupSpec        name: aString;        yourself.    self root packages remove: spec! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34035094!removePackage: aString    self root removePackage: aString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!removePackageForVersion: aString    | spec |    spec := self project packageSpec        name: aString;        yourself.    self root packages remove: spec! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34035331!removeProject: aString    self root removeProject: aString constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!removeProjectForVersion: aString    | spec |    spec := self project projectReferenceSpec        name: aString;        yourself.    self root packages remove: spec! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34035577!repositories: aBlock    self root repositories: aBlock constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!repositoriesForPackage: aBlock    self repositoriesForSpec: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!repositoriesForProject: aBlock    self repositoriesForSpec: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!repositoriesForSpec: aBlock    self with: self root repositories during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!repositoriesForVersion: aBlock    self repositoriesForSpec: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34035747!repository: anObject    self root repository: anObject constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34035899!repository: description username: username password: password    self root        repository: description        username: username        password: password        constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!repositoryForPackage: anObject    self repositoryForSpec: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!repositoryForPackage: aString username: username password: password    self repositoryForSpec: aString username: username password: password! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!repositoryForProject: anObject    self repositoryForSpec: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!repositoryForProject: aString username: username password: password    self repositoryForSpec: aString username: username password: password! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!repositoryForRepositories: anObject    self repositoryForSpec: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!repositoryForRepositories: aString username: username password: password    self repositoryForVersion: aString username: username password: password! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!repositoryForSpec: anObject    self root repository: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!repositoryForSpec: aString username: username password: password    self root repository: aString username: username password: password! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!repositoryForVersion: anObject    self repositoryForSpec: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!repositoryForVersion: aString username: username password: password    self repositoryForSpec: aString username: username password: password! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34036133!requires: anObject    self root requires: anObject constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!requiresForPackage: anObject    self root requires: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'initialization' stamp: 'dkh 10/5/2009 16:42' prior: 34036282!reset    attributeMap := attributeOrder := nil! !!MetacelloAbstractVersionConstructor methodsFor: 'accessing' stamp: 'dkh 10/3/2009 16:37' prior: 34036530!root: aMetacelloSpec    root := aMetacelloSpec! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!setBaseline: aString    | spec projectSpec |    projectSpec := self project baselineOfProjectSpec        name: aString;        className: 'BaselineOf' , aString;        yourself.    spec := self project projectReferenceSpec        name: aString;        projectReference: projectSpec;        yourself.    self root packages merge: spec.    ^ projectSpec! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!setBaseline: aString withBlock: aBlock    | projectSpec |    projectSpec := self setBaseline: aString.    self with: projectSpec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!setConfiguration: aString withBlock: aBlock    | spec projectSpec |    projectSpec := self project configurationOfProjectSpec        name: aString;        yourself.    spec := self project projectReferenceSpec        name: aString;        projectReference: projectSpec;        yourself.    self root packages merge: spec.    self with: projectSpec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'dkh 9/7/2012 13:11' prior: 34038116!setFor: attributeList do: aBlock    "conditional version support"    attributeList asMetacelloAttributeList        do: [ :attribute |             | blockList |            blockList := self attributeMap                at: attribute                ifAbsent: [ self attributeMap at: attribute put: (blockList := OrderedCollection new) ].            blockList add: aBlock.            self addAttribute: attribute ]! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'dkh 9/7/2012 13:11' prior: 34038641!setFor: attributeList version: aString    "conditional symbolicVersion support"    attributeList asMetacelloAttributeList        do: [ :attribute |             self attributeMap at: attribute put: aString.            self addAttribute: attribute ]! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34039719!setProject: aString withBlock: aBlock    | spec projectSpec |    projectSpec := self project projectSpec        name: aString;        yourself.    spec := self project projectReferenceSpec        name: aString;        projectReference: projectSpec;        yourself.    self root packages merge: spec.    self with: projectSpec during: aBlock! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34041156!supplyingAnswers: aCollection    self root supplyingAnswers: aCollection constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!supplyingAnswersForPackage: anObject    self root answers: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34041612!timestamp: aBlockOrStringOrDateAndTime    "Define timestamp field of version spec (MetacelloMCVersionSpec).	 If <aBlockOrStringOrDateAndTime> is a String, the version spec timetamp is set to the String.	 If <aBlockOrStringOrDateAndTime> is a DateAndTime, the version spec timetamp is set to the printString of the DateAndTime.	If <aBlockOrStringOrDateAndTime> is a Block, the specifications in <aBlockOrStringOrDateAndTime> are applied to the timestamp spec (MetacelloValueHolderSpec). Not Recommended!!			spec timestamp: '10/7/2009 14:40'.				spec timestamp: DateAndTime now'.				spec timestamp: [			spec value: '10/7/2009 14:40'. ].    "    self root timestamp: aBlockOrStringOrDateAndTime constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!timestampForVersion: aBlockOrStringOrDateAndTime    aBlockOrStringOrDateAndTime setTimestampInMetacelloConfig: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34042069!value: anObject    self root value: anObject constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!valueForValueHolder: anObject    self root value: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34042211!version: anObject    self root version: anObject constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!versionForProject: anObject    self versionStringForProject: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!versionForVersion: anObject    self versionStringForVersion: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34042363!versionString: anObject    self root versionString: anObject constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!versionStringForProject: anObject    self root versionString: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 9/5/2012 06:26:03.064'!versionStringForVersion: anObject    self versionStringForProject: anObject! !!MetacelloAbstractVersionConstructor methodsFor: 'private' stamp: 'dkh 10/3/2009 16:31' prior: 34042515!with: aMetacelloSpec during: aBlock    | previousRoot |    previousRoot := self root.    self root: aMetacelloSpec.    aBlock        ensure: [ self root: previousRoot ]! !!MetacelloBaselineConstructor class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24'!on: aConfig    ^ self new        on: aConfig;        yourself! !!MetacelloBaselineConstructor class methodsFor: 'instance creation' stamp: 'dkh 6/18/2012 14:49'!on: aConfig project: aProject    ^ self new        on: aConfig project: aProject;        yourself! !!MetacelloBaselineConstructor methodsFor: 'private' stamp: 'dkh 6/18/2012 15:05'!calculate: aConfig project: aProject    | pragma versionMap versionSpec |    self configuration: aConfig.    pragma := self extractBaselinePragmaFor: aConfig class.    self        setProject:            (aProject                ifNil: [                     [ aConfig class project ]                        on: MessageNotUnderstood                        do: [ :ex | ex return: nil ] ]).    versionSpec := self project versionSpec.    self root: versionSpec.    self evaluatePragma: pragma.    versionMap := Dictionary new.    self project attributes        do: [ :attribute |             | blockList |            (blockList := self attributeMap at: attribute ifAbsent: [  ]) ~~ nil                ifTrue: [ blockList do: [ :block | self with: versionSpec during: block ] ] ].    versionSpec versionString: self project singletonVersionName.    versionMap at: versionSpec versionString put: versionSpec createVersion.    self project map: versionMap.    self project configuration: aConfig! !!MetacelloBaselineConstructor methodsFor: 'pragma extraction' stamp: 'dkh 6/5/2012 19:01:24'!extractBaselinePragmaFor: aClass    | pragmas |    pragmas := Pragma allNamed: #'baseline' in: aClass.    pragmas isEmpty        ifTrue: [ ^ self error: 'No #baseline pragma found' ].    ^ pragmas first! !!MetacelloBaselineConstructor methodsFor: 'initialization' stamp: 'dkh 6/5/2012 19:01:24'!on: aConfig    self calculate: aConfig project: nil! !!MetacelloBaselineConstructor methodsFor: 'initialization' stamp: 'dkh 6/5/2012 19:01:24'!on: aConfig project: aProject    self calculate: aConfig project: aProject! !!MetacelloVersionConstructor class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34047873!on: aConfig	^(self new)		on: aConfig;		yourself! !!MetacelloVersionConstructor class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34048035!on: aConfig project: aProject	^(self new)		on: aConfig project: aProject;		yourself! !!MetacelloVersionConstructor class methodsFor: 'deprecated' stamp: 'dkh 6/5/2012 19:01:24' prior: 34048226!spawnPackageMethodIn: aConfig category: methodCategory named: newSelector sourceVersion: sourceVersionString targetVersion: targetVersionString blessing: blessing	self deprecated: 'see MetacelloToolBox class>>createDevelopment:for:importFromBaseline:description: for a similar example'.	^self new		spawnPackageMethodIn: aConfig 		category: methodCategory 		named: newSelector		sourceVersion: sourceVersionString 		targetVersion: targetVersionString		blessing: blessing! !!MetacelloVersionConstructor class methodsFor: 'deprecated' stamp: 'dkh 6/5/2012 19:01:24' prior: 34048807!spawnPackageMethodIn: aConfig named: newSelector sourceVersion: sourceVersionString targetVersion: targetVersionString	self deprecated: 'see MetacelloToolBox class>>createDevelopment:for:importFromBaseline:description: for a similar example'.	^self 		spawnPackageMethodIn: aConfig 		category: 'versions'		named: newSelector 		sourceVersion: sourceVersionString 		targetVersion: targetVersionString 		blessing: #development! !!MetacelloVersionConstructor class methodsFor: 'deprecated' stamp: 'dkh 6/5/2012 19:01:24' prior: 34049342!spawnPackageMethodIn: aConfig named: newSelector sourceVersion: sourceVersionString targetVersion: targetVersionString blessing: blessing	self deprecated: 'see MetacelloToolBox class>>createDevelopment:for:importFromBaseline:description: for a similar example'.	^self new		spawnPackageMethodIn: aConfig 		category: 'versions'		named: newSelector 		sourceVersion: sourceVersionString 		targetVersion: targetVersionString		blessing: blessing! !!MetacelloVersionConstructor class methodsFor: 'deprecated' stamp: 'dkh 6/5/2012 19:01:24' prior: 34049894!updatePackageMethodIn: aConfig sourceVersion: sourceVersionString	self deprecated: 'see MetacelloToolBox class>>updateDevelopment:for:updateProjects:description: for a similar example'.	^self new		updatePackageMethodIn: aConfig 		sourceVersion: sourceVersionString! !!MetacelloVersionConstructor methodsFor: 'initialization' stamp: 'dkh 6/22/2012 12:43' prior: 34050254!calculate: aConfig project: aProject    | versionMap symbolicVersionMap executionBlock pragmaDict |    self setProject: aProject.    self configuration: aConfig.    versionMap := Dictionary new.    symbolicVersionMap := Dictionary new.    executionBlock := self specResolverBlock.    self collectAllVersionsFromVersionPragmasInto: versionMap using: executionBlock.    pragmaDict := self extractVersionImportPragmas.    self verifyVersionImportPragmas: pragmaDict definedIn: versionMap.    self collectAllVersionsFromVersionImportPragmasInto: versionMap using: executionBlock satisfiedPragmas: pragmaDict.    self collectAllSymbolicVersionsFromVersionPragmasInto: symbolicVersionMap using: self symbolicVersionResolverBlock.    self project map: versionMap.    self project errorMap: self errorMap.    self project symbolicVersionMap: symbolicVersionMap.    self project configuration: aConfig.	"now that we have a nearly complete project, we can collect the defaultSymbolicVersions, which expect the project to be fully constructed"    self        collectDefaultSymbolicVersionsFromVersionPragmasFrom: self extractDefaultSymbolicVersionPragmas        into: symbolicVersionMap        using: self defaultSymbolicVersionResolverBlock.	"Pick up defaults from MetacelloBaseConfiguration"    self        collectDefaultSymbolicVersionsFromVersionPragmasFrom: self extractCommonDefaultSymbolicVersionPragmas        into: symbolicVersionMap        using: self commonDefaultSymbolicVersionResolverBlock.	"now resolive symbolicVersions defined as symbolicVersions"    symbolicVersionMap copy        keysAndValuesDo: [ :symbolic :original |             | versionString visited |            versionString := original.            visited := Set new.            [             visited add: versionString.            versionString isSymbol and: [ versionString ~~ #'notDefined' ] ]                whileTrue: [                     versionString := symbolicVersionMap                        at: versionString                        ifAbsent: [ self error: 'Cannot resolve symbolic version ' , original printString ].                    (visited includes: versionString)                        ifTrue: [ self error: 'Loop detected resolving symbolic version ' , original printString ] ].            symbolicVersionMap at: symbolic put: versionString ]! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34052346!collectAllSymbolicVersionsFromVersionPragmasInto: symbolicVersionMap using: executionBlock	| defined versionPragmaDict versionString |	versionPragmaDict := self extractSymbolicVersionPragmas.	versionPragmaDict		keysAndValuesDo: [ :versionSymbol :pragmaColl | 			defined := false.			pragmaColl				do: [ :pragma | 					defined := true.					versionString := executionBlock value: versionSymbol value: pragma ].			defined				ifTrue: [ 					versionString == nil						ifFalse: [ symbolicVersionMap at: versionSymbol put: versionString ]].			self reset ]! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'dkh 9/6/2012 03:05' prior: 34052991!collectAllVersionsFromVersionImportPragmasInto: versionMap using: executionBlock satisfiedPragmas: pragmaDict    | defined done completed count |    done := false.    completed := IdentitySet new.    count := 0.    [     count := count + 1.    count > 10000        ifTrue: [ self error: 'Apparent loop in import expansion' ].    done ]        whileFalse: [             done := true.            pragmaDict                keysAndValuesDo: [ :versionString :pragmaColl |                     | versionSpec |                    versionSpec := nil.                    defined := false.                    [                     pragmaColl                        do: [ :pragma |                             (completed includes: pragma)                                ifFalse: [                                     | imports |                                    done := false.                                    imports := pragma argumentAt: 2.                                    imports                                        detect: [ :importedVersion | (versionMap includesKey: importedVersion) not ]                                        ifNone: [                                             imports                                                do: [ :importedVersion |                                                     | version |                                                    (version := versionMap at: importedVersion ifAbsent: [  ]) ~~ nil                                                        ifTrue: [                                                             defined := true.                                                            completed add: pragma.                                                            versionSpec == nil                                                                ifTrue: [ versionSpec := version spec copy ]                                                                ifFalse: [ versionSpec := versionSpec mergeSpec: version spec copy ].                                                            versionSpec versionString: versionString.                                                            executionBlock value: versionSpec value: pragma ] ] ] ] ] ]                        on: Error                        do: [ :ex |                             (MetacelloErrorInProjectConstructionNotification versionString: versionSpec versionString exception: ex)                                ifTrue: [ ^ ex pass ]                                ifFalse: [                                     self errorMap at: versionSpec versionString put: ex.                                    done := true.                                    defined := false ] ].                    defined                        ifTrue: [                             | version importedVersions |                            importedVersions := OrderedCollection new.                            version := versionSpec createVersion.                            pragmaColl do: [ :pragma | importedVersions addAll: (pragma argumentAt: 2) ].                            version importedVersions: importedVersions.                            self validateVersionString: versionString againstSpec: versionSpec.                            versionMap at: versionSpec versionString put: version ].                    self reset ] ]! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34055963!collectAllVersionsFromVersionPragmasInto: versionMap using: executionBlock    | defined versionPragmaDict |    versionPragmaDict := self extractVersionPragmas.    versionPragmaDict        keysAndValuesDo: [ :versionString :pragmaColl |             | versionSpec |            versionSpec := self project versionSpec.            versionSpec versionString: versionString.            defined := false.            [             pragmaColl                do: [ :pragma |                     executionBlock value: versionSpec value: pragma.                    defined := true ] ]                on: Error                do: [ :ex |                     (MetacelloErrorInProjectConstructionNotification versionString: versionSpec versionString exception: ex)                        ifTrue: [ ^ ex pass ]                        ifFalse: [                             self errorMap at: versionSpec versionString put: ex.                            defined := false ] ].            defined                ifTrue: [                     self validateVersionString: versionString againstSpec: versionSpec.                    versionMap at: versionSpec versionString put: versionSpec createVersion ].            self reset ]! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34056720!collectDefaultSymbolicVersionsFromVersionPragmasFrom: versionPragmaDict into: symbolicVersionMap using: executionBlock	| defined versionString |	versionPragmaDict		keysAndValuesDo: [ :versionSymbol :pragmaColl | 			defined := false.			symbolicVersionMap				at: versionSymbol				ifAbsent: [ 					"process the defaultSymbolicVersion only if the symbolicVersion is not defined yet"					pragmaColl						do: [ :pragma | 							defined := true.							versionString := executionBlock value: versionSymbol value: pragma ].					defined						ifTrue: [ 							versionString == nil								ifFalse: [ symbolicVersionMap at: versionSymbol put: versionString ] ].					self reset ] ]! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34057499!commonDefaultSymbolicVersionResolverBlock	^ self defaultSymbolicVersionResolverBlock: (ConfigurationOf new project: self project)! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34057736!defaultSymbolicVersionResolverBlock	^ self defaultSymbolicVersionResolverBlock: self configuration! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34057931!defaultSymbolicVersionResolverBlock: receiver	^ [ :symbolicVrsn :pragma | 	| result |	result := nil.	(pragma argumentAt: 1) = symbolicVrsn		ifTrue: [ 			self symbolicVersion: symbolicVrsn.			result := [ receiver perform: pragma selector ] on: MetacelloVersionDoesNotExistError do: [ :ex | ex return: nil ] ].	result ]! !!MetacelloVersionConstructor methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!errorMap    errorMap ifNil: [ errorMap := Dictionary new ].    ^ errorMap! !!MetacelloVersionConstructor methodsFor: 'initialization' stamp: 'dkh 6/5/2012 19:01:24' prior: 34058347!on: aConfig	| cacheKey |	cacheKey := aConfig class.	project := MetacelloPlatform current		stackCacheFor: #versionConstructor		at: cacheKey		doing: [ :cache | 			self calculate: aConfig project: nil.			cache at: cacheKey put:  self project ].	self setProject: project.! !!MetacelloVersionConstructor methodsFor: 'initialization' stamp: 'dkh 6/5/2012 19:01:24' prior: 34058715!on: aConfig project: aProject    | cacheKey cachedProject |    cacheKey := aConfig class.    cachedProject := MetacelloPlatform current        stackCacheFor: #'versionConstructor'        at: cacheKey        doing: [ :cache |             self calculate: aConfig project: aProject.            cache at: cacheKey put: self project.            ^ self ].    aProject map: cachedProject map.    aProject errorMap: cachedProject errorMap.    aProject symbolicVersionMap: cachedProject symbolicVersionMap.    aProject configuration: aConfig.    self setProject: aProject! !!MetacelloVersionConstructor methodsFor: 'deprecated' stamp: 'dkh 6/5/2012 19:01:24' prior: 34059275!prepareForMethodUpdate: aConfig sourceVersion: sourceVersionString forceUpdate: forceUpdate generating: generateBlock	| pragmaDict versionSpecs pragmaMap updatedPackageSpecs updatedPackageSpecsMap reversed pragmaColl seenUpdatedPackageSpecs |	self deprecated: 'see MetacelloToolBox for replacement methods'.	self configuration: aConfig.	versionSpecs := Dictionary new.	pragmaMap := Dictionary new.	pragmaDict := self extractAllVersionPragmas.	pragmaColl := pragmaDict at: sourceVersionString ifAbsent: [ ^ self ].	pragmaColl		do: [ :pragma | 			| specs versionSpec |			specs := Dictionary new.			self evaluatePragma: pragma.			self attributeMap				keysAndValuesDo: [ :attribute :blockList | 					versionSpec := self project versionSpec.					versionSpec versionString: sourceVersionString.					specs at: attribute put: versionSpec.					blockList do: [ :block | self with: versionSpec during: block ] ].			versionSpecs				at: pragma selector				put:					{specs.					(self attributeOrder).					nil}.			pragmaMap at: pragma selector put: pragma.			self reset ].	versionSpecs		keysAndValuesDo: [ :selector :ar | 			updatedPackageSpecsMap := Dictionary new.			seenUpdatedPackageSpecs := Dictionary new.			ar at: 3 put: updatedPackageSpecsMap.			reversed := aConfig project attributes reverse.			reversed				do: [ :attribute | 					| vs |					(vs := (ar at: 1) at: attribute ifAbsent: [  ]) ~~ nil						ifTrue: [ 							updatedPackageSpecs := forceUpdate								ifTrue: [ vs forceUpdatedPackageSpecs ]								ifFalse: [ vs updatedPackageSpecs ].							updatedPackageSpecs associations								do: [ :assoc | 									| filename |									(filename := seenUpdatedPackageSpecs at: assoc key ifAbsent: [  ]) == nil										ifTrue: [ 											assoc value == #uptodate												ifTrue: [ 													"#uptodate means that the spec is up-to-date and we mark it as										 seen so that the spec is not update for a 'later' spec"													seenUpdatedPackageSpecs at: assoc key put: #uptodate ]												ifFalse: [ seenUpdatedPackageSpecs at: assoc key put: assoc value file ] ]										ifFalse: [ 											"if the spec was already seen as up-to-date or the file is the same as 								 the one already seen don't propogate the file"											(filename == #uptodate or: [ assoc value == #uptodate or: [ filename = assoc value file ] ])												ifTrue: [ updatedPackageSpecs removeKey: assoc key ] ] ].							updatedPackageSpecsMap at: attribute put: updatedPackageSpecs ] ].	"clear out #uptodate markers"			updatedPackageSpecsMap				valuesDo: [ :d | 					d associations						do: [ :assoc | 							assoc value == #uptodate								ifTrue: [ d removeKey: assoc key ] ] ].	"remove shadowed packages"			1 to: reversed size do: [ :index | 				| attribute d |				attribute := reversed at: index.				((d := updatedPackageSpecsMap at: attribute ifAbsent: [  ]) ~~ nil and: [ d keys size > 0 ])					ifTrue: [ 						index + 1 to: reversed size do: [ :shadowIndex | 							d								keysDo: [ :key | 									| dict |									(dict := updatedPackageSpecsMap at: (reversed at: shadowIndex) ifAbsent: [  ]) ~~ nil										ifTrue: [ dict removeKey: key ifAbsent: [  ] ] ] ] ] ].			updatedPackageSpecsMap keys				do: [ :key | 					| d |					d := updatedPackageSpecsMap at: key.					d isEmpty						ifTrue: [ updatedPackageSpecsMap removeKey: key ] ].	"ready to generate source for method"			generateBlock				value: selector				value: pragmaMap				value: ar				value: updatedPackageSpecsMap ]! !!MetacelloVersionConstructor methodsFor: 'deprecated' stamp: 'dkh 6/5/2012 19:01:24' prior: 34062934!spawnPackageMethodIn: aConfig category: methodCategory named: newSelector sourceVersion: sourceVersionString targetVersion: targetVersionString blessing: blessing	self deprecated: 'see MetacelloToolBox class>>createBaseline:for:from:description: for replacement method'.	self 		prepareForMethodUpdate: aConfig 		sourceVersion: sourceVersionString 		forceUpdate: blessing ~~ #baseline		generating: [:selector :pragmaMap :ar :updatedPackageSpecsMap | | strm |			strm := WriteStream on: String new.			strm 				nextPutAll: newSelector asString, ' spec'; cr;				tab; nextPutAll: 						'<version: ', 						targetVersionString printString, 						' imports: #(', sourceVersionString printString, 						')>';cr.			(ar at: 2) do: [:attribute | | vs d |				vs := (ar at: 1) at: attribute.				(d := updatedPackageSpecsMap at: attribute ifAbsent: []) ~~ nil					ifTrue: [ 						vs packagesSpec list do: [:member | | x |							x := d at: member spec name ifAbsent: [].						 	member spec updateForSpawnMethod: x ]]					ifFalse: [						vs packagesSpec list do: [:member |							member spec updateForSpawnMethod: member spec copy ]].				strm cr; tab; nextPutAll: 'spec for: ', attribute printString, ' do: ['; cr.				attribute == #common					ifTrue: [						vs 							author: MetacelloPlatform current authorName;							timestamp: MetacelloPlatform current timestamp.						blessing ~~ nil							ifTrue: [ vs blessing: blessing ]].				vs configSpawnMethodOn: strm indent: 2.				strm nextPutAll: '].'].				(aConfig class						compile: strm contents					classified: methodCategory) == nil 						ifTrue: [ self error: 'Error compiling the method' ]].	^true! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34064705!specResolverBlock	^ [ :versionSpec :pragma | 	(pragma argumentAt: 1) = versionSpec versionString		ifTrue: [ 			self evaluatePragma: pragma.			self project attributes				do: [ :attribute | 					| blockList |					(blockList := self attributeMap at: attribute ifAbsent: [  ]) ~~ nil						ifTrue: [ blockList do: [ :block | self with: versionSpec during: block ] ] ] ] ]! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34065175!symbolicVersionResolverBlock	^ [ :symbolicVrsn :pragma | 	| result |	result := nil.	(pragma argumentAt: 1) = symbolicVrsn		ifTrue: [ 			self symbolicVersion: symbolicVrsn.			self evaluatePragma: pragma.			self project attributes				do: [ :attribute | 					| versionString |					versionString := self attributeMap at: attribute ifAbsent: [  ].					versionString ~~ nil						ifTrue: [ result := versionString ] ] ].	result ]! !!MetacelloVersionConstructor methodsFor: 'deprecated' stamp: 'dkh 6/5/2012 19:01:24' prior: 34065708!updatePackageMethodIn: aConfig sourceVersion: sourceVersionString	self deprecated: 'see MetacelloToolBox class>>updateDevelopment:for:updateProjects:description: for replacement method'.	self 		prepareForMethodUpdate: aConfig 		sourceVersion: sourceVersionString 		forceUpdate: false		generating: [:selector :pragmaMap :ar :updatedPackageSpecsMap | | strm pragma |			updatedPackageSpecsMap isEmpty ifTrue: [ ^false ].			strm := WriteStream on: String new.			strm 				nextPutAll: selector asString, ' spec'; cr;				tab; nextPutAll: '<version: ', sourceVersionString printString.			pragma := pragmaMap at: selector.			pragma numArgs = 2				ifTrue: [					strm nextPutAll: ' imports: #('.					(pragma argumentAt: 2) do: [:versionString |						strm nextPutAll: versionString printString; space ]].			strm nextPutAll: ')>';cr.			(ar at: 2) do: [:attribute | | vs d |				vs := (ar at: 1) at: attribute.				(d := updatedPackageSpecsMap at: attribute ifAbsent: []) ~~ nil					ifTrue: [ 						vs packagesSpec list do: [:member | 							member spec file ~~ nil								ifTrue: [ | x |									(((x := d at: member spec name ifAbsent: []) ~~ nil) and: [ x ~~ #uptodate ])						 				ifTrue: [ member spec file: x file ]]]].				strm cr; tab; nextPutAll: 'spec for: ', attribute printString, ' do: ['; cr.				attribute == #common					ifTrue: [ 						vs 							author: MetacelloPlatform current authorName;							timestamp: MetacelloPlatform current timestamp ].				vs configMethodOn: strm indent: 2.				strm nextPutAll: '].'].			(aConfig class						compile: strm contents					classified: (aConfig class whichCategoryIncludesSelector: pragma selector)) == nil						ifTrue: [ self error: 'Error compiling the method' ]].	^true! !!MetacelloVersionConstructor methodsFor: 'validation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34067556!validateVersionString: versionString againstSpec: versionSpec	versionString = versionSpec versionString		ifFalse: [ 			MetacelloValidationNotification				signal:					(MetacelloValidationError						configurationClass: self configurationClass						reasonCode: #incorrectVersionString						callSite: #validateVersionString:againstSpec						explanation:							'The version declared in the pragma ', versionString printString , ' does not match the version in the spec '								, versionSpec versionString printString) ].! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24'!verifyVersionImportPragmas: pragmaDict definedIn: versionMap    pragmaDict copy        keysAndValuesDo: [ :versionString :pragmaColl |             [             pragmaColl                do: [ :pragma |                     (pragma argumentAt: 2)                        do: [ :importedVersion |                             versionMap                                at: importedVersion                                ifAbsent: [                                     pragmaDict                                        at: importedVersion                                        ifAbsent: [                                             ^ self                                                error:                                                    'The imported version:' , importedVersion printString , ' for version: ' , versionString                                                        , ' referenced from the method: ' , pragma selector printString                                                        , ' in configuration ' , configuration class printString                                                        , ' has not been defined.' ] ] ] ] ]                on: Error                do: [ :ex |                     (MetacelloErrorInProjectConstructionNotification versionString: versionString exception: ex)                        ifTrue: [ ^ ex pass ]                        ifFalse: [                             pragmaDict removeKey: versionString.                            self errorMap at: versionString put: ex ] ] ]! !!MetacelloGroupSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34129923!answers: aListOfPairs	self shouldNotImplement! !!MetacelloGroupSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34130048!configMethodCascadeOn: aStream member: aMember last: lastCascade indent: indent	aMember methodUpdateSelector == #remove:		ifTrue: [ aStream nextPutAll: 'removeGroup: ', self name printString. ]		ifFalse: [			aStream 				nextPutAll: 'group: ', self name printString;				space; 				nextPutAll: aMember methodUpdateSelector asString, ' #('.			self includes do: [:str | aStream nextPutAll: str printString, ' ' ].			aStream nextPut: $) ].	lastCascade		ifTrue: [ aStream nextPut: $. ]		ifFalse: [ aStream nextPut: $;; cr ].! !!MetacelloGroupSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34130656!configMethodOn: aStream indent: indent	aStream 		tab: indent;		nextPutAll: 'spec '; cr;		tab: indent + 1;		nextPutAll: 'name: ', self name printString, ';'.	self configMethodBodyOn: aStream hasName: true cascading: false indent: indent + 1.	aStream nextPut: $.! !!MetacelloGroupSpec methodsFor: 'visiting' stamp: 'dkh 6/5/2012 19:01:24' prior: 34131002!projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	groupBlock value: self! !!MetacelloGroupSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34131172!requires: aCollection	self shouldNotImplement! !!MetacelloPackagesSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34141606!add: aSpec	aSpec addToMetacelloPackages: self! !!MetacelloPackagesSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34141743!applyIncludesTo: orderedSpecs for: pkgSpec firstTime: firstTime	| movedSpecs baseIndex includedSpec result |	movedSpecs := Set new.	baseIndex := orderedSpecs indexOf: pkgSpec.	pkgSpec includesForPackageOrdering		do: [:includedSpecName | 			includedSpec := orderedSpecs						detect: [:spec | spec name = includedSpecName ]						ifNone: [].			(self slideIn: orderedSpecs spec: includedSpec baseIndex: baseIndex seen: IdentitySet new firstTime: firstTime)				ifTrue: [ movedSpecs add: includedSpec name ]].	^ movedSpecs! !!MetacelloPackagesSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34142351!configMethodOn: aStream indent: indent	| packageSpecs |	packageSpecs := self map values.	packageSpecs size = 0 ifTrue: [ ^aStream nextPutAll: 'spec add: []' ].	packageSpecs size = 1		ifTrue: [			aStream 				tab: indent; 				nextPutAll: 'spec add: ['; cr.			packageSpecs first configMethodOn: aStream indent: indent + 1.			aStream nextPut: $]; cr ]		ifFalse: [			aStream 				tab: indent; 				nextPutAll: 'spec'.			1 to: packageSpecs size do: [:index | | packageSpec |				packageSpec := packageSpecs at: index.				aStream 					tab: indent + 1;					nextPutAll: 'add: ['; cr.				packageSpec configMethodOn: aStream indent: indent + 2.				aStream nextPut: $].				index < packageSpecs size					ifTrue: [ aStream nextPut: $; ].				aStream cr ]]! !!MetacelloPackagesSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34143192!copy: specNamed to: spec	self addMember: 		(self copyMember 			name: spec name;			sourceName: specNamed;			spec: spec;			yourself)! !!MetacelloPackagesSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34143409!merge: aSpec	aSpec mergeIntoMetacelloPackages: self! !!MetacelloPackagesSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34143543!packageNamed: aString ifAbsent: aBlock	^self map at: aString ifAbsent: aBlock! !!MetacelloPackagesSpec methodsFor: 'accessing' stamp: 'dkh 9/6/2012 03:05' prior: 34143702!packageSpecsInLoadOrder    | orderedSpecs moved lastMovedSpecs count terminationLimit map specsWithIncludes firstTime |    "specification order is the default order"    map := self map.    orderedSpecs := OrderedCollection new.    self list        do: [ :member |             | spec |            spec := map at: member name ifAbsent: [  ].            (spec == nil or: [ orderedSpecs includes: spec ])                ifFalse: [ orderedSpecs add: spec ] ].    orderedSpecs isEmpty        ifTrue: [ ^ orderedSpecs ].    moved := true.    count := 0.    terminationLimit := orderedSpecs size * 2.    [ moved ]        whileTrue: [             count := count + 1.            count > terminationLimit                ifTrue: [                     "Cheap termination hack - an APPARENT loop"                    self error: 'Apparent loop in before/after dependency definitions' ].            moved := false.            orderedSpecs                do: [ :packageSpec | moved := moved or: [ self sortPackageSpecs: orderedSpecs for: packageSpec ] ] ].    lastMovedSpecs := Set new.    moved := true.    count := 0.    specsWithIncludes := orderedSpecs select: [ :pkgSpec | pkgSpec includesForPackageOrdering isEmpty not ].    firstTime := true.    [ moved ]        whileTrue: [             | result |            count := count + 1.	"count > terminationLimit"            count > 14                ifTrue: [                     "Cheap termination hack - an APPARENT loop"                    self error: 'Apparent loop in before/after dependency definitions' ].            moved := false.            result := Set new.            specsWithIncludes                do: [ :packageSpec | result addAll: (self applyIncludesTo: orderedSpecs for: packageSpec firstTime: firstTime) ].            result size = lastMovedSpecs size                ifTrue: [                     result                        do: [ :name |                             (lastMovedSpecs includes: name)                                ifFalse: [ moved := true ] ] ]                ifFalse: [ moved := true ].            lastMovedSpecs := result.            firstTime := false ].    ^ orderedSpecs! !!MetacelloPackagesSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34145981!remove: aSpec	aSpec removeFromMetacelloPackages: self! !!MetacelloPackagesSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34146126!slideIn: orderedSpecs spec: targetSpec baseIndex: baseIndex seen: seen firstTime: firstTime	| targetIndex requires targetRequires targetRequiresIndexes minIndex baseSpec required |	(seen includes: targetSpec) ifTrue: [ ^false ].	targetIndex := orderedSpecs indexOf: targetSpec.	baseIndex >= targetIndex ifTrue: [ ^false ].	required := false.	baseSpec := orderedSpecs at: baseIndex.	baseIndex + 1 to: targetIndex - 1 do: [:index | | spec |		spec := orderedSpecs at: index.		(spec requires includes: baseSpec name) ifTrue: [ required := true ]].	firstTime ifFalse: [ required ifFalse: [ ^false ]].	requires := targetSpec requires.	targetRequires := orderedSpecs				select: [:spec | requires includes: spec name].	targetRequiresIndexes := targetRequires				collect: [:spec | orderedSpecs indexOf: spec].	targetRequiresIndexes add: baseIndex.	minIndex := targetRequiresIndexes				detectMax: [:each | each].	minIndex + 1 < targetIndex		ifTrue: [			orderedSpecs remove: targetSpec.			orderedSpecs add: targetSpec afterIndex: minIndex.			seen add: targetSpec ]		ifFalse: [ ^self slideIn: orderedSpecs spec: (orderedSpecs at: minIndex) baseIndex: 1 seen: seen firstTime: firstTime].	^true! !!MetacelloPackagesSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34147413!sortPackageSpecs: orderedSpecs for: packageSpec	| packageIndex moved movePackage targetPackage targetIndex targetPackages |	packageIndex := orderedSpecs indexOf: packageSpec.	moved := movePackage := false.	targetPackages := packageSpec requires.	targetPackages do: [:targetPackageName |		targetPackage := orderedSpecs 			detect: [:each | each name = targetPackageName ] 			ifNone: [].		targetIndex := orderedSpecs indexOf: targetPackage.		movePackage := movePackage or: [ packageIndex <= targetIndex ]].	movePackage 		ifTrue: [			moved := true.			orderedSpecs remove: packageSpec ifAbsent: [ ^self error: 'unexpected error removing package' ].			targetIndex := 0.			targetPackages do: [:targetPackageName | 				(targetPackage := orderedSpecs detect: [:each | 					each name = targetPackageName ] ifNone: []) ~~ nil						ifTrue: [ targetIndex := targetIndex max: (orderedSpecs indexOf: targetPackage) ]].			targetIndex == 0				ifTrue: [ orderedSpecs add: packageSpec beforeIndex: packageIndex ]				ifFalse: [ orderedSpecs add: packageSpec afterIndex: targetIndex ]].	^moved! !!MetacelloGenericProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/15/2012 13:37'!compareEqual: aMetacelloProjectSpec    "'projectPackage repositories'"    ^ (super compareEqual: aMetacelloProjectSpec)        and: [ self repositories compareEqual: aMetacelloProjectSpec repositories ]! !!MetacelloGenericProjectSpec methodsFor: 'loading' stamp: 'dkh 6/5/2012 19:01:24'!determineCurrentVersionForLoad    self subclassResponsibility! !!MetacelloGenericProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!getRepositories    "raw access to iv"    ^ repositories! !!MetacelloGenericProjectSpec methodsFor: 'scripting' stamp: 'dkh 04/02/2013 20:22'!hasNoLoadConflicts: aMetacelloProjectSpec  "'projectPackage repositories'"  ^ (super hasNoLoadConflicts: aMetacelloProjectSpec)    and: [       (self repositories isEmpty or: [ aMetacelloProjectSpec repositories isEmpty ])        or: [ self repositories hasNoLoadConflicts: aMetacelloProjectSpec repositories ] ]! !!MetacelloGenericProjectSpec methodsFor: 'testing' stamp: 'dkh 6/30/2012 13:18'!hasRepository    ^ self repositorySpecs notEmpty! !!MetacelloGenericProjectSpec methodsFor: 'loading' stamp: 'dkh 6/5/2012 19:01:24'!load    (MetacelloLookupProjectSpecForLoad new        projectSpec: self;        yourself) signal performLoad! !!MetacelloGenericProjectSpec methodsFor: 'loading' stamp: 'dkh 6/5/2012 19:01:24'!loadVersion: aVersionOrNil    self subclassResponsibility! !!MetacelloGenericProjectSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24'!mergeMap    | map |    map := super mergeMap.    map at: #'repositories' put: repositories.    ^ map! !!MetacelloGenericProjectSpec methodsFor: 'scripting' stamp: 'dkh 7/17/2012 07:04'!mergeScriptRepository: anotherSpec    self repositories: anotherSpec repositories! !!MetacelloGenericProjectSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24'!mergeSpec: anotherSpec    | newSpec map anotherRepositories |    newSpec := super mergeSpec: anotherSpec.    map := anotherSpec mergeMap.    (anotherRepositories := map at: #'repositories') ~~ nil        ifTrue: [             newSpec                repositories:                    (self getRepositories == nil                        ifTrue: [ anotherRepositories ]                        ifFalse: [ self repositories mergeSpec: anotherRepositories ]) ].    ^ newSpec! !!MetacelloGenericProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/5/2012 19:01:24'!metacelloRegistrationHash    "projectPackage (ignored) repositories"    ^ super metacelloRegistrationHash bitXor: self repositories metacelloRegistrationHash! !!MetacelloGenericProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!name: aString    super name: aString.    self projectPackage: nil! !!MetacelloGenericProjectSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24'!nonOverridable    ^ super nonOverridable , #(#'projectPackage' #'repositories')! !!MetacelloGenericProjectSpec methodsFor: 'copying' stamp: 'dkh 6/5/2012 19:01:24'!postCopy    super postCopy.    repositories := repositories copy.    projectPackage := nil! !!MetacelloGenericProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!projectPackage    self subclassResponsibility! !!MetacelloGenericProjectSpec methodsFor: 'accessing' stamp: 'dkh 7/19/2012 16:02'!projectPackage: aProjectPackage    self shouldBeMutable.    projectPackage := aProjectPackage! !!MetacelloGenericProjectSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!projectPackage: aBlock constructor: aVersionConstructor    aVersionConstructor projectPackageForProject: aBlock! !!MetacelloGenericProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!repositories    repositories ifNil: [ repositories := self project repositoriesSpec ].    ^ repositories! !!MetacelloGenericProjectSpec methodsFor: 'accessing' stamp: 'dkh 7/19/2012 16:02'!repositories: anObject    self shouldBeMutable.    repositories := anObject.    self projectPackage: nil! !!MetacelloGenericProjectSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!repositories: aBlock constructor: aVersionConstructor    aVersionConstructor repositoriesForProject: aBlock! !!MetacelloGenericProjectSpec methodsFor: 'querying' stamp: 'dkh 6/30/2012 12:32'!repository    | specs |    self deprecated: 'Use repositories or repositorySpecs'.    (specs := self repositorySpecs) isEmpty        ifTrue: [ ^ nil ].    ^ specs first! !!MetacelloGenericProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!repository: aStringOrMetacelloRepositorySpec    self repositories repository: aStringOrMetacelloRepositorySpec.    self projectPackage: nil! !!MetacelloGenericProjectSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!repository: anObject constructor: aVersionConstructor    aVersionConstructor repositoryForProject: anObject! !!MetacelloGenericProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!repository: aString username: username password: password    self repositories repository: aString username: username password: password.    self projectPackage: nil! !!MetacelloGenericProjectSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!repository: aString username: username password: password constructor: aVersionConstructor    aVersionConstructor repositoryForProject: aString username: username password: password! !!MetacelloGenericProjectSpec methodsFor: 'querying' stamp: 'dkh 6/30/2012 14:19'!repositoryDescriptions    ^ self repositorySpecs collect: [ :repoSpec | repoSpec description ]! !!MetacelloGenericProjectSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24'!repositorySpecs    repositories ifNil: [ ^ #() ].    ^ self repositories map values! !!MetacelloProjectSpec methodsFor: 'adding' stamp: 'dkh 6/5/2012 19:01:24' prior: 34151965!addToMetacelloPackages: aMetacelloPackagesSpec	| spec |	spec := (aMetacelloPackagesSpec project projectReferenceSpec)			name: self name;			projectReference: self copy;			yourself.	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec addMember 			name: spec name;			spec: spec;			yourself)			! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: 'dkh 7/17/2012 15:53'!canDowngradeTo: aMetacelloProjectSpec    (self className = aMetacelloProjectSpec className and: [ self operator == aMetacelloProjectSpec operator ])        ifFalse: [ ^ false ].    ^ (aMetacelloProjectSpec version perform: self operator with: self version) not! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: 'dkh 7/17/2012 15:53'!canUpgradeTo: aMetacelloProjectSpec    (self className = aMetacelloProjectSpec className and: [ self operator == aMetacelloProjectSpec operator ])        ifFalse: [ ^ false ].    ^ aMetacelloProjectSpec version perform: self operator with: self version! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34152356!className    className ifNil: [ self name ifNotNil: [ self className: self constructClassName ] ].    ^ className! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'dkh 7/19/2012 16:03' prior: 34152459!className: aString    self shouldBeMutable.    className := aString! !!MetacelloProjectSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!className: aString constructor: aVersionConstructor    aVersionConstructor classNameForProject: aString! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: 'dkh 07/13/2013 14:22'!compareEqual: aMetacelloProjectSpec  "name className versionString operator loads preLoadDoIt postLoadDoIt"  ^ self className = aMetacelloProjectSpec className    and: [       (self compareVersionsEqual: aMetacelloProjectSpec)        and: [           self operator == aMetacelloProjectSpec operator            and: [               self loads = aMetacelloProjectSpec loads                and: [                   self preLoadDoIt value == aMetacelloProjectSpec preLoadDoIt value                    and: [ self postLoadDoIt value == aMetacelloProjectSpec postLoadDoIt value ] ] ] ] ]! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: 'dkh 07/13/2013 14:21'!compareVersionsEqual: aMetacelloProjectSpec  | vrsn otherVrsn |  vrsn := self versionOrNil.  otherVrsn := aMetacelloProjectSpec versionOrNil.  vrsn ifNil: [ ^ vrsn = otherVrsn ].  otherVrsn ifNil: [ ^ false ].  ^ vrsn versionNumber = otherVrsn versionNumber! !!MetacelloProjectSpec methodsFor: 'printing' stamp: 'dkh 9/10/2012 16:17' prior: 34152589!configMethodBodyOn: aStream indent: indent    | hasVersionString hasOperator hasProjectPackage hasLoads hasClassName hasPreLoadDoIt hasPostLoadDoIt |    hasClassName := self hasClassName.    hasVersionString := self versionString ~~ nil.    hasOperator := operator ~~ nil.    hasProjectPackage := self hasRepository or: [ hasClassName & (self getFile ~~ nil) ].    hasLoads := self loads ~~ nil.    hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.    hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.    hasClassName        ifTrue: [             hasVersionString | hasOperator | hasProjectPackage | hasLoads                ifTrue: [                     aStream                        cr;                        tab: indent + 1 ]                ifFalse: [ aStream space ].            aStream nextPutAll: 'className: ' , self className printString.            hasVersionString | hasPreLoadDoIt | hasPostLoadDoIt | hasOperator | hasLoads | hasProjectPackage                ifTrue: [ aStream nextPut: $; ] ].    hasVersionString        ifTrue: [             | vs |            hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPreLoadDoIt | hasPostLoadDoIt                ifTrue: [                     aStream                        cr;                        tab: indent + 1 ]                ifFalse: [ aStream space ].            vs := self versionString.            aStream nextPutAll: 'versionString: '.            vs isSymbol                ifTrue: [ aStream nextPut: $# ].            aStream nextPutAll: vs asString printString.            hasPreLoadDoIt | hasPostLoadDoIt | hasOperator | hasProjectPackage | hasLoads                ifTrue: [ aStream nextPut: $; ] ].    hasPreLoadDoIt        ifTrue: [             hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPreLoadDoIt                ifTrue: [                     aStream                        cr;                        tab: indent + 1 ]                ifFalse: [ aStream space ].            aStream nextPutAll: 'preLoadDoIt: '.            self preLoadDoIt value isSymbol                ifTrue: [                     aStream                        nextPut: $#;                        nextPutAll: self preLoadDoIt value asString printString ]                ifFalse: [ aStream nextPutAll: self preLoadDoIt value asString ].            hasPostLoadDoIt | hasOperator | hasProjectPackage | hasLoads                ifTrue: [ aStream nextPut: $; ] ].    hasPostLoadDoIt        ifTrue: [             hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPostLoadDoIt                ifTrue: [                     aStream                        cr;                        tab: indent + 1 ]                ifFalse: [ aStream space ].            aStream nextPutAll: 'postLoadDoIt: '.            self postLoadDoIt value isSymbol                ifTrue: [                     aStream                        nextPut: $#;                        nextPutAll: self postLoadDoIt value asString printString ]                ifFalse: [ aStream nextPutAll: self postLoadDoIt value asString ].            hasOperator | hasProjectPackage | hasLoads                ifTrue: [ aStream nextPut: $; ] ].    hasOperator        ifTrue: [             hasClassName | hasVersionString | hasProjectPackage | hasLoads | hasPreLoadDoIt | hasPostLoadDoIt                ifTrue: [                     aStream                        cr;                        tab: indent + 1 ]                ifFalse: [ aStream space ].            aStream nextPutAll: 'operator: #' , self operator asString printString.            hasProjectPackage | hasLoads                ifTrue: [ aStream nextPut: $; ] ].    hasLoads        ifTrue: [             hasClassName | hasVersionString | hasOperator | hasProjectPackage | hasPreLoadDoIt | hasPostLoadDoIt                ifTrue: [                     aStream                        cr;                        tab: indent + 1 ]                ifFalse: [ aStream space ].            aStream nextPutAll: 'loads: #('.            self loads do: [ :str | aStream nextPutAll: str printString , ' ' ].            aStream nextPut: $).            hasProjectPackage                ifTrue: [ aStream nextPut: $; ] ].    hasProjectPackage        ifTrue: [             | hasName hasRepo |            hasRepo := self hasRepository.            hasName := self file ~= self className.            hasName                ifTrue: [                     hasClassName | hasVersionString | hasOperator | hasLoads | hasPreLoadDoIt | hasPostLoadDoIt                        ifTrue: [                             aStream                                cr;                                tab: indent + 1 ]                        ifFalse: [ aStream space ].                    aStream nextPutAll: 'file: ' , self file printString.                    hasRepo                        ifTrue: [ aStream nextPut: $; ] ].            hasRepo                ifTrue: [                     | repos |                    repos := self repositories map values.                    repos size = 1                        ifTrue: [                             hasClassName | hasVersionString | hasOperator | hasLoads | hasPreLoadDoIt | hasPostLoadDoIt | hasName                                ifTrue: [                                     aStream                                        cr;                                        tab: indent + 1 ]                                ifFalse: [ aStream space ].                            repos first configMethodCascadeOn: aStream lastCascade: true ]                        ifFalse: [                             aStream cr.                            self repositories configMethodCascadeOn: aStream indent: indent ] ] ]! !!MetacelloProjectSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34157127!configMethodOn: aStream indent: indent	aStream 		tab: indent;		nextPutAll: 'spec '; cr;		tab: indent + 1;		nextPutAll: 'name: ', self name printString, ';'.	self configMethodBodyOn: aStream indent: indent.	aStream nextPut: $.! !!MetacelloProjectSpec methodsFor: 'printing' stamp: 'dkh 6/30/2012 13:25' prior: 34157448!configShortCutMethodOn: aStream member: aMember indent: indent    | hasVersionString hasOperator hasProjectPackage hasLoads hasClassName hasPreLoadDoIt hasPostLoadDoIt |    hasClassName := self hasClassName.    hasVersionString := self versionString ~~ nil.    hasOperator := operator ~~ nil.    hasProjectPackage := self hasRepository or: [ hasClassName & (self getFile ~~ nil or: [ className ~= self name ]) ].    hasLoads := self loads ~~ nil.    hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.    hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.    hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPreLoadDoIt | hasPostLoadDoIt        ifTrue: [             (aMember methodUpdateSelector == #'copy:' or: [ aMember methodUpdateSelector == #'with:' ])                ifTrue: [                     aStream                        nextPutAll: 'with: [';                        cr ]                ifFalse: [                     aStream                        nextPutAll: 'overrides: [';                        cr ].            aStream                tab: indent;                nextPutAll: 'spec'.            self configMethodBodyOn: aStream indent: indent.            aStream nextPutAll: ' ]'.            ^ self ].    hasVersionString        ifTrue: [             | vs |            vs := self versionString.            aStream nextPutAll: 'with: '.            vs isSymbol                ifTrue: [ aStream nextPut: $# ].            aStream nextPutAll: vs asString printString ]! !!MetacelloProjectSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24'!constructClassName    ^ nil! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 6/24/2012 11:39'!currentlyLoadedClassesInVersion    self versionOrNil ifNotNil: [ :vrsn | ^ vrsn currentlyLoadedClassesInVersion ].    ^ #()! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'dkh 9/10/2012 16:05'!file    ^ self className! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!getClassName    "raw access to iv"    ^ className! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!getFile    "raw access to iv"    ^ nil! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!getOperator	^operator! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34158790!getPostLoadDoIt	^postLoadDoIt! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34158910!getPreLoadDoIt	^preLoadDoIt! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!getRepositories    "raw access to iv"    ^ nil! !!MetacelloProjectSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24'!hasClassName    ^ className ~~ nil! !!MetacelloProjectSpec methodsFor: 'as yet unclassified' stamp: 'dkh 04/02/2013 20:28'!hasLoadConflicts: aMetacelloProjectSpec  ^ (self hasNoLoadConflicts: aMetacelloProjectSpec) not! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: 'dkh 07/13/2013 14:22'!hasNoLoadConflicts: aMetacelloProjectSpec  "same as compareEqual:, except if versionString and/or repositories are not 	specified for either one, then there are not conflicts"  ^ self className = aMetacelloProjectSpec className    and: [       ((self versionString == nil or: [ aMetacelloProjectSpec versionString == nil ])        or: [ self compareVersionsEqual: aMetacelloProjectSpec ])        and: [ self operator == aMetacelloProjectSpec operator ] ]! !!MetacelloProjectSpec methodsFor: 'testing' stamp: 'dkh 9/11/2012 09:24'!hasNonVersionStringField    | hasVersionString hasOperator hasProjectPackage hasLoads hasClassName hasPreLoadDoIt hasPostLoadDoIt |    hasClassName := self hasClassName.    hasVersionString := self versionString ~~ nil.    hasOperator := operator ~~ nil.    hasProjectPackage := (self file ~~ nil and: [ hasClassName and: [ self className ~= self name ] ])        or: [ self hasRepository ].    hasLoads := self loads ~~ nil.    hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.    hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.    ^ hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPreLoadDoIt | hasPostLoadDoIt! !!MetacelloProjectSpec methodsFor: 'testing' stamp: 'dkh 9/10/2012 15:49'!hasRepository    ^ false! !!MetacelloProjectSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34159026!label	^self name! !!MetacelloProjectSpec methodsFor: 'loading' stamp: 'dkh 6/5/2012 19:01:24' prior: 34159121!load	self subclassResponsibility! !!MetacelloProjectSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24'!loadListForVersion: vrsn 	^ (self loads == nil			or: [self loads isEmpty])		ifTrue: [vrsn spec defaultPackageNames]		ifFalse: [self loads]! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34159234!loads	^ loads! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34159328!loads: aCollection	aCollection setLoadsInMetacelloProject: self! !!MetacelloProjectSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!loads: anObject constructor: aVersionConstructor    aVersionConstructor loadsForProject: anObject! !!MetacelloProjectSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24' prior: 34159480!mergeMap	| map |	map := super mergeMap.	map at: #name put: name.	map at: #className put: className.	map at: #versionString put: versionString.	map at: #operator put: operator.	map at: #loads put: loads.	map at: #preLoadDoIt put: preLoadDoIt.	map at: #postLoadDoIt put: postLoadDoIt.	^map! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: 'dkh 7/21/2012 14:12'!mergeScriptLoads: aSpec    self shouldBeMutable.    aSpec loads        ifNotNil: [ :otherLoads | self loads ifNil: [ loads := otherLoads ] ifNotNil: [ loads := (loads , otherLoads) asSet asArray ] ].    self loader: aSpec loader! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/5/2012 19:01:24'!metacelloRegistrationHash    "name className versionString operator loads preLoadDoIt postLoadDoIt"    | hash |    hash := String stringHash: name initialHash: 0.    hash := String stringHash: self className initialHash: hash.    hash := String stringHash: self versionString initialHash: hash.    hash := String stringHash: self operator asString initialHash: hash.    hash := String stringHash: self preLoadDoIt asString initialHash: hash.    hash := String stringHash: self postLoadDoIt asString initialHash: hash.    ^ hash bitXor: loads hash! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34159858!name	^name! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'dkh 7/19/2012 16:03' prior: 34159951!name: aString    ((aString at: 1) isSeparator or: [ (aString at: aString size) isSeparator ])        ifTrue: [ self error: 'Names are not allowed to have leading or trailing blanks: ' , aString printString ].    self shouldBeMutable.    name := aString! !!MetacelloProjectSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!name: aString constructor: aVersionConstructor    aVersionConstructor nameForProject: aString! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34160061!operator	operator == nil ifTrue: [ ^#>= ].	^ operator! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'dkh 7/19/2012 16:03' prior: 34160197!operator: anObject    " #= #~= #> #< #>= #<= #~> "    self shouldBeMutable.    operator := anObject! !!MetacelloProjectSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!operator: anObject constructor: aVersionConstructor    aVersionConstructor operatorForProject: anObject! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34160357!postLoadDoIt	^postLoadDoIt! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34160475!postLoadDoIt: anObject	anObject setPostLoadDoItInMetacelloSpec: self! !!MetacelloProjectSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!postLoadDoIt: aSymbol constructor: aVersionConstructor    aVersionConstructor postLoadDoItForProject: aSymbol! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34160634!preLoadDoIt	^preLoadDoIt! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34160750!preLoadDoIt: anObject	anObject setPreLoadDoItInMetacelloSpec: self! !!MetacelloProjectSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!preLoadDoIt: aSymbol constructor: aVersionConstructor    aVersionConstructor preLoadDoItForProject: aSymbol! !!MetacelloProjectSpec methodsFor: 'visiting' stamp: 'dkh 6/5/2012 19:01:24'!projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock    projectBlock value: self! !!MetacelloProjectSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24'!projectLabel    ^ 'project'! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34160897!projectPackage	^nil! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: 'dkh 7/17/2012 11:19'!registration    ^ MetacelloProjectRegistration        registrationForProjectSpec: self        ifAbsent: [ :ignored |  ]        ifPresent: [ :existing :new | existing ]! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/6/2012 16:05'!registrationsCompareEqual: aMetacelloProjectSpec    "name className versionString operator loads preLoadDoIt postLoadDoIt"    ^ self className = aMetacelloProjectSpec className        and: [ self versionString = aMetacelloProjectSpec versionString and: [ self operator == aMetacelloProjectSpec operator ] ]! !!MetacelloProjectSpec methodsFor: 'private' stamp: 'dkh 9/11/2012 11:50'!resolveToLoadableSpec	^self copy! !!MetacelloProjectSpec methodsFor: 'private' stamp: 'dkh 7/19/2012 16:02' prior: 34160996!setLoads: aCollection    self shouldBeMutable.    loads := aCollection! !!MetacelloProjectSpec methodsFor: 'private' stamp: 'dkh 7/19/2012 16:02'!setName: aStringOrNil    self shouldBeMutable.    name := aStringOrNil! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'dkh 7/19/2012 15:09' prior: 34161130!setPostLoadDoIt: aSymbol    self shouldBeMutable.    postLoadDoIt := aSymbol! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'dkh 7/19/2012 15:09' prior: 34161270!setPreLoadDoIt: aSymbol    self shouldBeMutable.    preLoadDoIt := aSymbol! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: 'dkh 7/19/2012 10:19'!unregisterProject    ^ MetacelloProjectRegistration        registrationForProjectSpec: self        ifAbsent: [  ]        ifPresent: [ :existing :new | existing unregisterProject ]! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24'!version    self subclassResponsibility! !!MetacelloProjectSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!version: anObject constructor: aVersionConstructor    aVersionConstructor versionForProject: anObject! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34161406!versionKey	"suitable for using as a unique key for the receiver's version in a dictionary"	^ self version versionKey! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24'!versionOrNil	^[ self version ] on: MetacelloVersionDoesNotExistError do: [:ex | ^nil ].! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34161603!versionString	^ versionString! !!MetacelloProjectSpec methodsFor: 'accessing' stamp: 'dkh 7/19/2012 15:09' prior: 34161712!versionString: anObject    self shouldBeMutable.    versionString := anObject! !!MetacelloProjectSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!versionString: anObject constructor: aVersionConstructor    aVersionConstructor versionStringForProject: anObject! !!BlockClosure methodsFor: '*metacello-core-scripting' stamp: 'dkh 7/16/2012 10:51'!execute: projectSpecBlock against: aScriptExecutor    aScriptExecutor executeBlock: self do: projectSpecBlock! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34183295!setAuthorInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setAuthorWithBlock: self! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setBaseline: aString withInMetacelloConfig: aMetacelloConfig    aMetacelloConfig setBaseline: aString withBlock: self! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34183461!setBlessingInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setBlessingWithBlock: self! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setConfiguration: aString withInMetacelloConfig: aMetacelloConfig    aMetacelloConfig setConfiguration: aString withBlock: self! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34183631!setDescriptionInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setDescriptionWithBlock: self! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34183807!setPackage: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setPackage: aString withBlock: self! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34183999!setProject: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setProject: aString withBlock: self! !!BlockClosure methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34184191!setTimestampInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setTimestampWithBlock: self! !!MetacelloValidationCriticalWarning methodsFor: 'testing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34176460!isCriticalWarning	^true! !!MetacelloValidationCriticalWarning methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34176588!label	^'Critical Warning'! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34094478!category	^ category! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34094587!category: anObject	category := anObject! !!MetacelloMethodSpec methodsFor: 'method generation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34094724!compileMethod	(project configuration class		compile: self methodSource		classified: self category) == nil		ifTrue: [ self error: 'Error compiling the method' ]! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34094977!methodSections	methodSections == nil ifTrue: [ methodSections := OrderedCollection new ].	^ methodSections! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34095175!methodSections: anObject	methodSections := anObject! !!MetacelloMethodSpec methodsFor: 'method generation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34095324!methodSource	self subclassResponsibility! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34095455!project	^ project! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34095562!project: anObject	project := anObject! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34095689!selector	^ selector! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34095798!selector: anObject	selector := anObject! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34095927!versionString	^ versionString! !!MetacelloMethodSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34096046!versionString: aStringOrSymbol	versionString := aStringOrSymbol! !!MetacelloAbstractPackageSpec methodsFor: 'adding' stamp: 'dkh 6/5/2012 19:01:24' prior: 34123366!addToMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec addMember 			name: self name;			spec: self;			yourself)! !!MetacelloAbstractPackageSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34123620!answers	answers == nil ifTrue: [ answers := #() ].	^answers! !!MetacelloAbstractPackageSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34123769!answers: aListOfPairs	self setAnswers: aListOfPairs! !!MetacelloAbstractPackageSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34123918!configMethodBodyOn: aStream hasName: hasName cascading: cascading indent: indent	| hasCascading hasRequires hasIncludes hasAnswers |	hasCascading := cascading.	hasRequires := self requires isEmpty not.	hasIncludes := self includes isEmpty not.	hasAnswers := self answers isEmpty not.	hasRequires		ifTrue: [ 			hasName | hasIncludes | hasAnswers | hasCascading				ifTrue: [ aStream cr; tab: indent ].			aStream nextPutAll: 'requires: #('.			self requires do: [:str | aStream nextPutAll: str printString, ' ' ].			hasIncludes | hasAnswers | hasCascading				ifTrue: [ aStream nextPutAll: ');' ]				ifFalse: [ aStream nextPut: $) ]].	hasIncludes		ifTrue: [ 			hasName | hasRequires | hasAnswers | hasCascading				ifTrue: [ aStream cr; tab: indent ].			aStream nextPutAll: 'includes: #('.			self includes do: [:str | aStream nextPutAll: str printString, ' ' ].			hasAnswers | hasCascading				ifTrue: [ aStream nextPutAll: ');' ]				ifFalse: [ aStream nextPut: $) ]].	hasAnswers		ifTrue: [ 			hasName | hasRequires | hasIncludes | hasCascading				ifTrue: [ aStream cr; tab: indent ].			aStream nextPutAll: 'supplyingAnswers: #( '.			self answers do: [:ar | 				aStream nextPutAll: '#( '.				ar do: [:val | 					(val isString or: [ val isNumber or: [ val isSymbol or: [ val isCharacter ]]])						ifTrue: [  aStream nextPutAll: val printString, ' ' ].					val == true						ifTrue: [  aStream nextPutAll: 'true ' ].					val == false						ifTrue: [  aStream nextPutAll: 'false ' ]].				aStream nextPutAll: ') ' ].			hasCascading				ifTrue: [ aStream nextPutAll: ');' ]				ifFalse: [ aStream nextPut: $) ]].! !!MetacelloAbstractPackageSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34125644!configMethodCascadeOn: aStream member: aMember last: lastCascade indent: indent	self subclassResponsibility! !!MetacelloAbstractPackageSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34125851!configMethodOn: aStream for: aValue selector: selector cascading: cascading cascade: cascade indent: indent	| valuePrintString |	aValue == nil ifTrue: [ ^self ].	cascading ifTrue: [ aStream cr; tab: indent ].	valuePrintString := aValue value isSymbol		ifTrue: [ '#' , aValue value asString printString ]		ifFalse: [ aValue value printString ].	aStream  nextPutAll: selector, valuePrintString.	cascade ifTrue: [ aStream nextPut: $; ]! !!MetacelloAbstractPackageSpec methodsFor: 'testing' stamp: 'dkh 6/30/2012 13:21'!hasRepository    ^ false! !!MetacelloAbstractPackageSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34126380!includes	includes == nil ifTrue: [ includes := #() ].	^includes! !!MetacelloAbstractPackageSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34126534!includes: aCollection	aCollection setIncludesInMetacelloPackage: self! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34126692!includesForPackageOrdering	^#()! !!MetacelloAbstractPackageSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34126820!label	^self name! !!MetacelloAbstractPackageSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24' prior: 34126924!mergeIntoMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec mergeMember 			name: self name;			spec: self;			yourself)! !!MetacelloAbstractPackageSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24' prior: 34127193!mergeMap	| map |	map := super mergeMap.	map at: #requires put: requires.	map at: #includes put: includes.	map at: #answers put: answers.	^map! !!MetacelloAbstractPackageSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24' prior: 34127436!mergeSpec: anotherSpec	| newSpec map anotherRequires anotherIncludes anotherAnswers |	newSpec := super mergeSpec: anotherSpec.	map := anotherSpec mergeMap.	anotherSpec name ~~ nil 		ifTrue: [ newSpec name: anotherSpec name ].	(anotherRequires := map at: #requires) ~~ nil		ifTrue: [ newSpec setRequires: self requires, anotherRequires ].	(anotherIncludes := map at: #includes) ~~ nil		ifTrue: [ newSpec setIncludes: self includes, anotherIncludes ].	(anotherAnswers := map at: #answers) ~~ nil		ifTrue: [ newSpec setAnswers: self answers, anotherAnswers ].	^newSpec	! !!MetacelloAbstractPackageSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34128103!name	^name! !!MetacelloAbstractPackageSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34128203!name: aString    ((aString at: 1) isSeparator or: [ (aString at: aString size) isSeparator ])        ifTrue: [ self error: 'Names are not allowed to have leading or trailing blanks: ' , aString printString ].    name := aString! !!MetacelloAbstractPackageSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24' prior: 34128329!nonOverridable	^#( includes requires answers )! !!MetacelloAbstractPackageSpec methodsFor: 'copying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34128462!postCopy	super postCopy.	requires := requires copy.	includes := includes copy.	answers := answers copy.! !!MetacelloAbstractPackageSpec methodsFor: 'visiting' stamp: 'dkh 6/5/2012 19:01:24' prior: 34128658!projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	self subclassResponsibility! !!MetacelloAbstractPackageSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34128844!referencedSpec	^self! !!MetacelloAbstractPackageSpec methodsFor: 'removing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34128953!removeFromMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec removeMember 			name: self name;			spec: self;			yourself)! !!MetacelloAbstractPackageSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34129216!requires	requires == nil ifTrue: [ requires := #() ].	^requires! !!MetacelloAbstractPackageSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34129370!requires: aCollection	aCollection setRequiresInMetacelloPackage: self! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34129526!setAnswers: aCollection	answers := aCollection! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34129660!setIncludes: aCollection	includes := aCollection! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34129796!setRequires: aCollection	requires := aCollection! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 9/7/2012 13:10' prior: 34184559!asMetacelloAttributeList    ^ self! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 9/8/2012 05:30' prior: 34184672!asMetacelloAttributePath    ^ MetacelloMethodSectionPath withAll: self! !!Collection methodsFor: '*metacello-core-scripting' stamp: 'dkh 9/5/2012 06:26:03.064'!execute: projectSpecBlock against: aScriptExecutor    aScriptExecutor executeCollection: self do: projectSpecBlock! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 9/5/2012 06:26:03.064' prior: 34185228!setForDo: aBlock withInMetacelloConfig: aMetacelloConstructore    aMetacelloConstructore setFor: self do: aBlock! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 9/5/2012 06:26:03.064' prior: 34185416!setForVersion: aString withInMetacelloConfig: aMetacelloConstructore    aMetacelloConstructore setFor: self version: aString! !!MetacelloRemoveMemberSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34151541!applyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock	removeBlock value: self! !!MetacelloRemoveMemberSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34151724!applyToList: aListSpec	aListSpec remove: self! !!MetacelloRemoveMemberSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34151856!methodUpdateSelector	^#remove:! !!MetacelloVersion class methodsFor: 'instance creation' stamp: 'dkh 6/22/2012 12:34' prior: 34004633!fromSpec: aMetacelloVersionSpec    ^ (self new versionNumber: aMetacelloVersionSpec versionNumber)        spec: aMetacelloVersionSpec;        yourself! !!MetacelloVersion class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34004855!fromString: aString	^self new versionNumber: aString asMetacelloVersionNumber! !!MetacelloVersion methodsFor: 'comparing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34005010!< aMetacelloVersion	aMetacelloVersion species = self species ifFalse: [ ^false ].	^self versionNumber < aMetacelloVersion versionNumber! !!MetacelloVersion methodsFor: 'comparing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34005224!= aMetacelloVersion	aMetacelloVersion species = self species ifFalse: [ ^false ].	^self versionNumber = aMetacelloVersion versionNumber! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34005438!author	^self spec author value! !!MetacelloVersion methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!basicSpec    ^ self spec! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34005544!blessing    ^ self basicSpec blessing value! !!MetacelloVersion methodsFor: 'private' stamp: 'dkh 9/10/2012 15:43' prior: 34005653!computeVersionStatus    ^ #'noStatus'! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34006167!description    ^ self basicSpec description value! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 9/11/2012 11:53'!difference: aMetacelloVersion	"Return a a dictionary of additions, removals and modifications"		^self spec difference: aMetacelloVersion spec! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 9/11/2012 12:09'!expandToLoadableSpecNames: nameList	"Just like #resolveToLoadableSpecs:, but returns list of spec names instead of specs"		^self spec expandToLoadableSpecNames: nameList! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 9/11/2012 10:16'!groups	"Answers the list of groups associated with this version"		| groups |	groups := OrderedCollection new.	self spec projectDo: [:ignored | ] packageDo: [:ignored | ] groupDo: [:grp | groups add: grp ].	^groups! !!MetacelloVersion methodsFor: 'comparing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34006285!hash	^self versionNumber hash! !!MetacelloVersion methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34006391!importedVersions	importedVersions == nil ifTrue: [ importedVersions := #() ].	^importedVersions! !!MetacelloVersion methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34006564!importedVersions: aCollection	importedVersions := aCollection! !!MetacelloVersion methodsFor: 'testing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34006709!isAllLoadedToSpec	"all projects and packages are loaded and match specification"		^self spec isAllLoadedToSpec! !!MetacelloVersion methodsFor: 'testing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34006904!isLoadedMatchConstraints	"all loaded projects and packages match constraints"		^self spec isLoadedMatchConstraints! !!MetacelloVersion methodsFor: 'testing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34007103!isLoadedToSpec	"all loaded projects and packages match specifications"		^self spec isLoadedToSpec! !!MetacelloVersion methodsFor: 'testing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34007285!isPossibleBaseline	^self spec isPossibleBaseline! !!MetacelloVersion methodsFor: 'testing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34007417!isSomethingLoaded	"at least one project or package has been loaded"		^self spec isSomethingLoaded! !!MetacelloVersion methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34007590!load	^self subclassResponsibility! !!MetacelloVersion methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34007698!load: required	^self subclassResponsibility! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34007828!loader	^self spec loader! !!MetacelloVersion methodsFor: 'testing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34007936!name	^self versionString! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 9/11/2012 10:35'!packageNamed: aString	^self packageNamed: aString ifAbsent: [ ^nil ].! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 9/11/2012 10:35'!packageNamed: aString ifAbsent: aBlock	| pkg |	(pkg := self spec packageNamed: aString ifAbsent: []) == nil		ifTrue: [ ^aBlock value ].	^pkg referencedSpec! !!MetacelloVersion methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34440958!printOn: aStream    | label vs |    self blessing ~~ #'broken'        ifTrue: [             (vs := self versionStatus) == #'somethingLoaded'                ifTrue: [ aStream nextPutAll: '<>' ].            vs == #'loadedMatchConstraints'                ifTrue: [ aStream nextPutAll: '>=' ].            vs == #'loadedToSpec'                ifTrue: [ aStream nextPut: $~ ] ].    self versionNumber printOn: aStream.    self basicSpec ~~ nil        ifTrue: [             (label := self projectLabel) isEmpty                ifFalse: [ aStream nextPutAll: ' [' , label , ']' ] ]! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34008591!project    ^ self basicSpec project! !!MetacelloVersion methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34008703!projectLabel    ^ self basicSpec projectLabel! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 9/11/2012 10:16'!projects	"Answers the list of projects associated with this version"	| projects |	projects := OrderedCollection new.	self spec projectDo: [:prj | projects add: prj projectReference ] packageDo: [:ignored | ] groupDo: [:ignored | ].	^projects! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 9/11/2012 11:40'!resolveToLoadableSpecs: nameList	"Resolves names in namelist to the  list of packages and projects in the version that would be loaded. Projects are 	not traversed during the transitive closure. The scope is that of the version itself.	   If the spec is a package, answer a list including the package and the transitive closure on 			its #requires: and #includes: fields.	   If the spec is a project, answer the project.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"	^self spec resolveToLoadableSpecs: nameList! !!MetacelloVersion methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34008818!spec	^spec! !!MetacelloVersion methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34008907!spec: aMetacellVersionSpec	spec := aMetacellVersionSpec! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34009040!timestamp    ^ self basicSpec timestamp value! !!MetacelloVersion methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34009153!unload	^self spec unload! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34009263!versionKey    "version printString, without the versionStatus decorations, suitable for using as a unique key for the 	 receiver in a dictionary"    ^ String        streamContents: [ :aStream |             | label |            self versionNumber printOn: aStream.            self basicSpec ~~ nil                ifTrue: [                     (label := self projectLabel) isEmpty                        ifFalse: [ aStream nextPutAll: ' [' , label , ']' ] ] ]! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34009698!versionNumber	^versionNumber! !!MetacelloVersion methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34009804!versionNumber: aVersionNumber	versionNumber := aVersionNumber! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 6/22/2012 12:38'!versionNumberFrom: aString    ^ self versionNumber class fromString: aString! !!MetacelloVersion methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34009943!versionSpec	^self spec! !!MetacelloVersion methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34010051!versionStatus	versionStatus == nil ifTrue: [ versionStatus := self computeVersionStatus].	^versionStatus! !!MetacelloVersion methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34010242!versionStatus: aSymbol	versionStatus := aSymbol! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34010366!versionString	^self versionNumber versionString! !!MetacelloVersion methodsFor: 'comparing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34010492!~> aMetacelloVersion	aMetacelloVersion species = self species ifFalse: [ ^false ].	^self versionNumber ~> aMetacelloVersion versionNumber! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: 'dkh 9/8/2012 06:02' prior: 34092796!attributeOrPath    ^ self parent == nil        ifTrue: [             self attributes size == 1                ifTrue: [ self attributes first ]                ifFalse: [ self attributes ] ]        ifFalse: [ self attributePath ]! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: 'dkh 9/7/2012 13:54' prior: 34093121!attributePath    | path |    path := MetacelloMethodSectionPath with: self attributes.    ^ self parent == nil        ifTrue: [ path ]        ifFalse: [ self parent attributePath , path ]! !!MetacelloVersionMethodSection methodsFor: 'accessing' stamp: 'dkh 03/12/2013 20:14'!printOn: aStream  aStream    nextPutAll: self class name asString;    nextPut: $(.  self versionSpec printOn: aStream.  aStream nextPut: $)! !!MetacelloVersionMethodSpec methodsFor: 'adding' stamp: 'dkh 9/8/2012 05:47' prior: 34098035!addMethodSection: attributePath versionSpec: versionSpec    | attributeList methodSection index sections found |    attributeList := attributePath last.    methodSection := MetacelloVersionMethodSection new        attributes: attributeList;        versionSpec: versionSpec;        yourself.    attributePath size > 1        ifTrue: [             index := 1.            sections := self methodSections.            found := true.            [ found ]                whileTrue: [                     found := false.                    sections                        do: [ :ms |                             ms attributes = (attributePath at: index)                                ifTrue: [                                     index == (attributePath size -1)                                        ifTrue: [                                             ms methodSections add: methodSection.                                            ^ self ].                                    sections := ms methodSections.                                    index := index + 1.                                    found := true ] ] ].            self error: 'Method section for attribute: ' , (attributePath at: index) printString , ' not found.' ]        ifFalse: [ self methodSections add: methodSection ]! !!MetacelloVersionMethodSpec methodsFor: 'adding' stamp: 'dkh 9/8/2012 05:10' prior: 34099436!findMethodSection: attributeOrPath sectionIndex: sectionIndex    | attributePath index sections found |    attributePath := attributeOrPath asMetacelloAttributePath.    index := 1.    sections := self methodSections.    found := true.    [ found ]        whileTrue: [             found := false.            sections                do: [ :ms |                     ms attributes = (attributePath at: index)                        ifTrue: [                             index == attributePath size                                ifTrue: [ ^ ms ].                            sections := ms methodSections.                            index := index + 1.                            found := true ] ] ].    self error: 'Method section for attribute: ' , attributePath printString , ' not found.'! !!MetacelloVersionMethodSpec methodsFor: 'method generation' stamp: 'dkh 9/7/2012 07:03' prior: 34101740!methodSource    | strm |    strm := WriteStream on: String new.    self        methodSelectorAndPragma: self selector        imports: self imports        versionString: self versionString        on: strm.    self        methodSection: self        pre: [ :methodSection :indent |             strm                cr;                tab: indent;                nextPutAll: 'spec for: ' , methodSection attributePrintString , ' do: [';                cr.            methodSection versionSpec configMethodOn: strm last: methodSection methodSections isEmpty indent: indent + 1 ]        last: false        post: [ :methodSection :indent :last |             strm nextPutAll: ' ].'.            (last or: [ indent = 1 or: [ methodSection methodSections isEmpty and: [ indent = 1 ] ] ])                ifTrue: [ strm cr ] ]        indent: 0.    ^ strm contents! !!MetacelloMemberListSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34138473!mapCopy: aMemberSpec into: map    | spec |    spec := map at: aMemberSpec sourceName ifAbsent: [  ].    spec == nil        ifTrue: [ ^ self error: 'Source spec named ' , aMemberSpec sourceName printString , ' not found' ]        ifFalse: [             spec aboutToCopy.            map at: aMemberSpec name put: (spec copy mergeSpec: aMemberSpec spec copy) ]! !!MetacelloValidationError methodsFor: 'testing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34176706!isError	^true! !!MetacelloValidationError methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34176814!label	^'Error'! !!MetacelloVersionNumber class methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34010726!extractNumericComponent: subString	"$. separated components are integers"	| number |	number := [subString asNumber] 						on: Error 						do: [:ex | ex return: subString ].	^number asString = subString		ifTrue: [ number ]		ifFalse: [ subString ]! !!MetacelloVersionNumber class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34011076!fromString: aString	| new components |	components := OrderedCollection new.	(aString findTokens: '.') do: [:subString | | strs |		strs := subString findTokens: '-'.		"first subString token could be an integer"		components add: (self extractNumericComponent: strs first).		strs size > 1			ifTrue: [				"remaining are uncoditionally Strings, because of leading $-"				components addAll: strs allButFirst ]].	new := self new: components size.	1 to: components size do: [:i | new at: i put: (components at: i) ].	^new! !!MetacelloVersionNumber methodsFor: 'comparing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34011694!< aMetacelloVersionNumber	| condensed aCondensed |	aMetacelloVersionNumber species = self species		ifFalse: [ ^ false ].	condensed := self collapseZeros.	aCondensed := aMetacelloVersionNumber collapseZeros.	(condensed ~~ self or: [ aCondensed ~~ aMetacelloVersionNumber ])		ifTrue: [ ^ condensed compareLessThan: aCondensed ].	^ self compareLessThan: aMetacelloVersionNumber! !!MetacelloVersionNumber methodsFor: 'comparing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34012168!= aMetacelloVersionNumber	| condensed aCondensed |	aMetacelloVersionNumber species = self species		ifFalse: [ ^ false ].	condensed := self collapseZeros.	aCondensed := aMetacelloVersionNumber collapseZeros.	(condensed ~~ self or: [ aCondensed ~~ aMetacelloVersionNumber ])		ifTrue: [ ^ condensed compareEqualTo: aCondensed ].	^ self compareEqualTo: aMetacelloVersionNumber! !!MetacelloVersionNumber methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34012631!approximateBase	| base |	base := self copyFrom: 1 to: self size - 1.	base at: base size put: (base at: base size) + 1.	^base! !!MetacelloVersionNumber methodsFor: 'converting' stamp: 'dkh 6/5/2012 19:01:24' prior: 34012843!asMetacelloVersionNumber	^self! !!MetacelloVersionNumber methodsFor: 'printing' stamp: 'dkh 07/09/2012 16:15'!asString	"Answer a string that represents the receiver."	^ self printString! !!MetacelloVersionNumber methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34012965!collapseZeros	"the rule must be that zeros can be collapsed as long as the series of zeros ends in a string term"	| collection newSize new j lastElementIsStringOrZero canCollapse |	(self size = 0 or: [ self at: 1 ]) == 0		ifTrue: [ ^ self ].	collection := OrderedCollection new.	lastElementIsStringOrZero := true.	canCollapse := true.	self size to: 1 by: -1 do: [ :i | 		| element |		element := self at: i.		(canCollapse and: [ element == 0 ])			ifTrue: [ 				lastElementIsStringOrZero					ifFalse: [ 						canCollapse := false.						collection addFirst: element.]]			ifFalse: [ 				collection addFirst: element.				canCollapse := lastElementIsStringOrZero := element isString ] ].	collection size = self size		ifTrue: [ ^ self ].	newSize := collection size.	new := self species new: newSize.	j := 0.	collection		do: [ :element | 			new at: j + 1 put: element.			j := j + 1 ].	^ new! !!MetacelloVersionNumber methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34013966!compareEqualTo: aMetacelloVersionNumber	| mySize |	aMetacelloVersionNumber species = self species ifFalse: [ ^false ].	mySize := self size.	mySize = aMetacelloVersionNumber size 		ifFalse: [ ^false ].	1 to: mySize do: [:i |		(self at: i) = (aMetacelloVersionNumber at: i) ifFalse: [ ^false ]].	^true! !!MetacelloVersionNumber methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34014363!compareLessThan: aMetacelloVersionNumber	| mySize aSize commonSize count more |	mySize := self size.	aSize := aMetacelloVersionNumber size.	commonSize :=  mySize min: aSize.	count := 0.	more := true.	[ more and: [ count < commonSize ]] whileTrue: [		(self at: count + 1) = (aMetacelloVersionNumber at: count + 1)			ifTrue: [ count := count + 1 ]			ifFalse: [ more := false ]].	count < commonSize		ifTrue: [ 			^(self at: count + 1) 				metacelloVersionComponentLessThan: (aMetacelloVersionNumber at: count + 1) ].	mySize < aSize		ifTrue: [ 			mySize = 0 ifTrue: [ ^true ].			"if the versions at commonSize are equal and the next version slot in aMetacelloVersionNumber 			 is a string, then it's considered that I'm > aMetacelloVersionNumber			 (i.e., '2.9.9' is greater than '2.9.9-alpha.2')"			(self at: commonSize) = (aMetacelloVersionNumber at: commonSize)				ifFalse: [ ^true ]. 			^(aMetacelloVersionNumber at: commonSize+1) isString not]		ifFalse: [ 			mySize = aSize ifTrue: [ ^false ].			aSize <= 0 ifTrue: [ ^false ].			"if the versions at commonSize are equal and the next version slot is a string, 			 then it's considered that I'm < aMetacelloVersionNumber			 (i.e., '2.9.9-alpha.2' is less than '2.9.9')"			(self at: commonSize) = (aMetacelloVersionNumber at: commonSize)				ifFalse: [ ^false ].			 ^(self at: commonSize+1) isString]! !!MetacelloVersionNumber methodsFor: 'copying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34015824!copyFrom: start to: stop 	"Answer a copy of a subset of the receiver, starting from element at 	index start until element at index stop."	| newSize new j |	newSize := stop - start + 1.	new := self species new: newSize.	j := 0.	start to: stop do: [:i |		new at: j + 1 put: (self at: i).		j := j + 1 ].	^new! !!MetacelloVersionNumber methodsFor: 'operations' stamp: 'dkh 6/5/2012 19:01:24' prior: 34016233!decrementMinorVersionNumber	| int |	self size to: 1 by: -1 do: [ :index | 		(int := self at: index) isString			ifFalse: [ 				int > 0					ifTrue: [ self at: index put: int - 1 ].				^ self ] ]! !!MetacelloVersionNumber methodsFor: 'enumerating' stamp: 'dkh 6/5/2012 19:01:24' prior: 34016516!do: aBlock 	"Refer to the comment in Collection|do:."	1 to: self size do:		[:index | aBlock value: (self at: index)]! !!MetacelloVersionNumber methodsFor: 'enumerating' stamp: 'dkh 6/5/2012 19:01:24' prior: 34016719!do: elementBlock separatedBy: separatorBlock	"Evaluate the elementBlock for all elements in the receiver,	and evaluate the separatorBlock between."	| beforeFirst | 	beforeFirst := true.	self do:		[:each |		beforeFirst			ifTrue: [beforeFirst := false]			ifFalse: [separatorBlock value].		elementBlock value: each]! !!MetacelloVersionNumber methodsFor: 'comparing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34017125!hash"Returns a numeric hash key for the receiver."| mySize interval hashValue |(mySize := self size) == 0  ifTrue: [ ^15243 ]."Choose an interval so that we sample at most 5 elements of the receiver"interval := ((mySize - 1) // 4) max: 1.hashValue := 4459.1 to: mySize by: interval do: [ :i | | anElement |  anElement := self at: i.  (anElement isKindOf: SequenceableCollection)    ifTrue: [      hashValue := (hashValue bitShift: -1) bitXor: anElement size.      ]    ifFalse: [      hashValue := (hashValue bitShift: -1) bitXor: anElement hash.      ].  ].^ hashValue abs! !!MetacelloVersionNumber methodsFor: 'operations' stamp: 'dkh 6/5/2012 19:01:24' prior: 34017806!incrementMinorVersionNumber	| int |	self size to: 1 by: -1 do: [:index | 		(int := self at: index) isString 			ifFalse: [ 				self at: index put: int + 1.				^self ]].! !!MetacelloVersionNumber methodsFor: 'comparing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34018063!match: aVersionPattern	"Answer whether the version number of the receiver matches the given pattern string.	 A Metacello version number is made up of version sequences delimited by the characters $. and $-.	 The $. introduces a numeric version sequence and $- introduces an alphanumeric version sequence.	 	 A version pattern is made up of version pattern match sequences. also delimited by the characters $. 	 and $-.. Each pattern match sequence is tested against the corresponding version sequence of the 	 receiver, using the 'standard' pattern matching rules. All sequences must answer true for a match.		 The special pattern sequence '?' is a match for the corresponding version sequence and all subsequent 	 version sequences. '?' as the version pattern matches all versions. No more version pattern 	 sequences are permitted once the '?' sequence is used. If used, it is the last version pattern	 sequence. "		| patternVersion mySize patternSize |	patternVersion := aVersionPattern asMetacelloVersionNumber.	mySize := self size.	patternSize := patternVersion size.	mySize = patternSize 		ifFalse: [ 			mySize < patternSize ifTrue: [ ^false ].			(patternVersion at: patternSize) ~= '?' ifTrue: [ ^false ].			mySize := patternSize ].	1 to: mySize do: [:i | | pattern |		pattern := (patternVersion at: i) asString.		pattern = '?'			ifTrue: [i = mySize ifFalse: [ ^self error: 'Invalid version match pattern: ', aVersionPattern printString ]]			ifFalse: [ (pattern match: (self at: i) asString)  ifFalse: [ ^false ]]].	^true"  '1.1.1' asMetacelloVersionNumber match: '*.*.*'. -> true  '1.1.1' asMetacelloVersionNumber match: '*.#.*'. -> true  '1.10.1' asMetacelloVersionNumber match: '*.#.*'. -> false  '1.1.1' asMetacelloVersionNumber match: '*.*'. -> false  '1.1.1' asMetacelloVersionNumber match: '*.?'. -> true  '1.0' asMetacelloVersionNumber match: '1.?'. -> true  '2.0' asMetacelloVersionNumber match: '1.?'. -> false  '1.1.1' asMetacelloVersionNumber match: '?'. -> true  '1' asMetacelloVersionNumber match: '*.?'. -> false  '1-alpha5.0' asMetacelloVersionNumber match: '1-alpha*.?'. -> true  '1-alpha15.0.1' asMetacelloVersionNumber match: '1-alpha*.?'. -> true  '1.1' asMetacelloVersionNumber match: '?.?'. -> ERROR: invalid version match pattern"! !!MetacelloVersionNumber methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34020448!printOn: aStream	| beforeFirst | 	beforeFirst := true.	self do:		[:each |		beforeFirst			ifTrue: [beforeFirst := false]			ifFalse: [				each isString					ifTrue: [ aStream nextPut: $- ]					ifFalse: [ aStream nextPut: $. ] ].		aStream nextPutAll: each asString ]! !!MetacelloVersionNumber methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34020805!versionString	| strm |	strm := WriteStream on: String new.	self printOn: strm.	^strm contents! !!MetacelloVersionNumber methodsFor: 'comparing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34020985!~> aMetacelloVersionNumber	aMetacelloVersionNumber size == 1 ifTrue: [ ^false ].	^self >= aMetacelloVersionNumber and: [ self < aMetacelloVersionNumber approximateBase ]! !!MetacelloProjectReferenceSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24'!aboutToCopy    self projectReference className! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34131307!answers: aListOfPairs	self shouldNotImplement! !!MetacelloProjectReferenceSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34131452!configMethodCascadeOn: aStream member: aMember last: lastCascade indent: indent    aMember methodUpdateSelector == #'remove:'        ifTrue: [ aStream nextPutAll: 'removeProject: ' , self name printString ]        ifFalse: [             self projectReference == nil                ifTrue: [ ^ self ].            aStream nextPutAll: self projectLabel , ': ' , self projectName printString , ' '.            (aMember methodUpdateSelector == #'copy:' and: [ self projectReference hasNonVersionStringField ])                ifTrue: [ aStream nextPutAll: 'copyFrom: ' , aMember sourceName printString , ' ' ].            self projectReference configShortCutMethodOn: aStream member: aMember indent: indent + 1 ].    lastCascade        ifTrue: [ aStream nextPut: $. ]        ifFalse: [             aStream                nextPut: $;;                cr ]! !!MetacelloProjectReferenceSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34132262!configMethodOn: aStream indent: indent	aStream 		tab: indent; nextPutAll: 'spec '; cr;		tab: indent + 1; nextPutAll: 'name: ', self name printString; nextPut: $;; cr;		tab: indent + 1; nextPutAll: 'projectReference: '; nextPut: $[; cr.	aStream 		tab: indent + 2; nextPutAll: 'spec'.	self projectReference ifNotNil: [ self projectReference configMethodBodyOn: aStream indent: indent + 2].	aStream nextPutAll: ' ].'! !!MetacelloProjectReferenceSpec methodsFor: 'testing' stamp: 'dkh 6/30/2012 13:22'!hasRepository    ^ self projectReference hasRepository! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34132773!includes: aCollection	self shouldNotImplement! !!MetacelloProjectReferenceSpec methodsFor: 'importing' stamp: 'dkh 6/26/2012 10:48'!mergeImportLoads: aLoadList    self projectReference mergeImportLoads: aLoadList! !!MetacelloProjectReferenceSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24' prior: 34132907!mergeMap	| map |	map := super mergeMap.	map at: #projectReference put: projectReference.	^map! !!MetacelloProjectReferenceSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24' prior: 34133101!mergeSpec: anotherSpec	| newSpec map anotherProjectReference |	newSpec := super mergeSpec: anotherSpec.	map := anotherSpec mergeMap.	(anotherProjectReference := map at: #projectReference) ~~ nil		ifTrue: [ 			newSpec projectReference: 				(newSpec projectReference == nil					ifTrue: [ anotherProjectReference ]					ifFalse: [ newSpec projectReference mergeSpec: anotherProjectReference ])].	^newSpec! !!MetacelloProjectReferenceSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24' prior: 34133599!nonOverridable	^super nonOverridable, #( projectReference )! !!MetacelloProjectReferenceSpec methodsFor: 'copying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34133757!postCopy	super postCopy.	projectReference := projectReference copy.! !!MetacelloProjectReferenceSpec methodsFor: 'visiting' stamp: 'dkh 6/5/2012 19:01:24' prior: 34133917!projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	projectBlock value: self! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!projectLabel    ^ self projectReference projectLabel! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34134100!projectName	^self projectReference name! !!MetacelloProjectReferenceSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34134228!projectReference	^ projectReference! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34134353!projectReference: anObject	projectReference := anObject! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34134499!referencedSpec	^self projectReference! !!MetacelloProjectReferenceSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34134634!relativeCurrentVersion	^self projectReference relativeCurrentVersion! !!MetacelloProjectReferenceSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24'!repositories    ^ self referencedSpec repositories! !!MetacelloProjectReferenceSpec methodsFor: 'loading' stamp: 'dkh 6/5/2012 19:01:24'!repositorySpecs	^self repositories map values! !!MetacelloProjectReferenceSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34134793!requires: aCollection	self shouldNotImplement! !!MetacelloProjectReferenceSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34134929!version	^self projectReference version! !!MetacelloProjectReferenceSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34135066!versionOrNil	^self projectReference versionOrNil! !!MetacelloProjectReferenceSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34135214!versionString: aString	^self projectReference versionString: aString! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34000509!addToMetacelloPackages: aMetacelloPackagesSpec	| spec |	spec := 		(aMetacelloPackagesSpec project packageSpec)			file: self;			yourself.	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec addMember 			name: spec name;			spec: spec;			yourself)! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/21/2012 18:06'!asMetacelloSemanticVersionNumber    ^ MetacelloSemanticVersionNumber fromString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34000844!asMetacelloVersionNumber	^MetacelloVersionNumber fromString: self! !!String methodsFor: '*metacello-core-scripting' stamp: 'dkh 7/16/2012 10:51'!execute: projectSpecBlock against: aScriptExecutor    aScriptExecutor executeString: self do: projectSpecBlock! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34000982!mergeIntoMetacelloPackages: aMetacelloPackagesSpec	| spec |	spec := 		(aMetacelloPackagesSpec project packageSpec)			file: self;			yourself.	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec mergeMember 			name: spec name;			spec: spec;			yourself)! !!String methodsFor: '*metacello-core-version comparison' stamp: 'dkh 6/5/2012 19:01:24' prior: 34001343!metacelloIntegerLessThanSelf: anInteger	"integer version components are always '>' string component"	^false! !!String methodsFor: '*metacello-core-version comparison' stamp: 'dkh 6/21/2012 20:44'!metacelloSemanticIntegerLessThanSelf: anInteger    "integer version components are always '>' string component"    ^ true! !!String methodsFor: '*metacello-core-version comparison' stamp: 'dkh 6/21/2012 20:43'!metacelloSemanticStringLessThanSelf: aString    ^ aString < self! !!String methodsFor: '*metacello-core-version comparison' stamp: 'dkh 6/21/2012 20:43'!metacelloSemanticVersionComponentLessThan: aMetacelloVersonComponent    ^ aMetacelloVersonComponent metacelloSemanticStringLessThanSelf: self! !!String methodsFor: '*metacello-core-version comparison' stamp: 'dkh 6/5/2012 19:01:24' prior: 34001544!metacelloStringLessThanSelf: aString	^aString < self! !!String methodsFor: '*metacello-core-version comparison' stamp: 'dkh 6/5/2012 19:01:24' prior: 34001689!metacelloVersionComponentLessThan: aMetacelloVersonComponent	^aMetacelloVersonComponent metacelloStringLessThanSelf: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34001883!removeFromMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec removeMember 			name: self;			yourself)! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34002111!setAuthorInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setAuthorWithString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34002272!setAuthorInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setAuthor: 		(aMetacelloVersionSpec project valueHolderSpec			value: self;			yourself)! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34002508!setBlessingInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setBlessingWithString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34002672!setBlessingInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setBlessing: 		(aMetacelloVersionSpec project valueHolderSpec			value: self;			yourself)! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34002912!setDescriptionInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setDescriptionWithString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34003082!setDescriptionInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setDescription: 		(aMetacelloVersionSpec project valueHolderSpec			value: self;			yourself)! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34003328!setIncludesInMetacelloPackage: aMetacelloPackageSpec	aMetacelloPackageSpec setIncludes: { self }.! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34003498!setLoadsInMetacelloProject: aMetacelloPackageSpec	aMetacelloPackageSpec setLoads: { self }.! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34003663!setPackage: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setPackage: aString withString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setPostLoadDoItInMetacelloSpec: aMetacelloSpec    self asSymbol setPostLoadDoItInMetacelloSpec: aMetacelloSpec! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24'!setPreLoadDoItInMetacelloSpec: aMetacelloSpec    self asSymbol setPreLoadDoItInMetacelloSpec: aMetacelloSpec! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34003850!setProject: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setProject: aString withString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34004036!setRequiresInMetacelloPackage: aMetacelloPackageSpec	aMetacelloPackageSpec setRequires: { self }.! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34004207!setTimestampInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setTimestampWithString: self! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34004374!setTimestampInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setTimestamp: 		(aMetacelloVersionSpec project valueHolderSpec			value: self;			yourself)! !!MetacelloProject class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34110566!new	| inst |	inst := self basicNew.	^inst configuration: inst; yourself! !!MetacelloProject class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34110730!on: aConfig	^self basicNew configuration: aConfig; yourself! !!MetacelloProject class methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!versionConstructorClass    ^ MetacelloVersionConstructor! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34110866!attributes	^(OrderedCollection with: #common)		addAll: self platformAttributes;		yourself! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24'!baselineOfProjectSpec    ^ self baselineOfProjectSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24'!baselineOfProjectSpecClass    ^ self subclassResponsibility! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24'!baselineOfVersionSpecClass    ^ self subclassResponsibility! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34111044!bleedingEdge	^self version: #bleedingEdge! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34111162!configuration	^ configuration! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34111267!configuration: anObject	configuration := anObject! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24'!configurationOfProjectSpec    ^ self configurationOfProjectSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24'!configurationOfProjectSpecClass    ^ self subclassResponsibility! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34111391!currentVersion	| cacheKey cv |	cacheKey := self configuration class.	^ MetacelloPlatform current		stackCacheFor: #currentVersion		at: cacheKey		doing: [ :cache | 			cv := self currentVersionAgainst: nil.			^ cache at: cacheKey put: cv ]! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34111710!currentVersionAgainst: resolvedPackageAndProjectNames	| cacheKey |	cacheKey := resolvedPackageAndProjectNames isNil		ifTrue: [ Array with: self configuration class with: nil ]		ifFalse: [ Array with: self configuration class with: (resolvedPackageAndProjectNames sort: [ :a :b | a <= b ]) ].	^ MetacelloPlatform current		stackCacheFor: #currentVersionAgainst:		at: cacheKey		doing: [ :cache | 			| cv versions latestSomethingLoaded |			cv := nil.			versions := self sortedAndFilteredVersions.			versions				do: [ :version | 					| status matchBlock |					status := resolvedPackageAndProjectNames isNil						ifTrue: [ version spec isPartiallyCurrent ]						ifFalse: [ version spec isPartiallyCurrentAgainst: resolvedPackageAndProjectNames ].					matchBlock := [ :matchStatus | 					cv := version copy.					cv versionStatus: matchStatus.					^ cache at: cacheKey put: cv ].					status isAllLoadedToSpec: matchBlock.					status isLoadedToSpec: matchBlock.					status isLoadedMatchConstraints: matchBlock.					status						isSomethingLoaded: [ :matchStatus | 							latestSomethingLoaded isNil								ifTrue: [ 									cv := version copy.									cv versionStatus: matchStatus.									latestSomethingLoaded := cv ] ] ].			latestSomethingLoaded ifNotNil: [ ^ cache at: cacheKey put: latestSomethingLoaded ].			^ cache at: cacheKey put: nil ]! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34113156!defaultBlessing	^#release! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24' prior: 34113261!defaultLoaderClass	^MetacelloSpecLoader! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34113376!defaultPlatformAttributes	^ MetacelloPlatform current defaultPlatformAttributes! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34113541!development	^self version: #development! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!errorMap	^ errorMap! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!errorMap: anObject    errorMap ifNil: [ errorMap := Dictionary new ].    errorMap := anObject! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34441545!excludeFromLatestVersion	^#(development broken baseline)! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24' prior: 34113793!groupSpec	^self groupSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24' prior: 34113914!groupSpecClass	^MetacelloGroupSpec! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34114035!hasVersion: versionString	self version: versionString ifAbsent: [ ^false ].	^true! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34114195!label	^self configuration class name! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34114318!lastVersion	| coll |	coll := (self map values asArray sort: [:a :b | a <= b ]) asOrderedCollection.	coll isEmpty ifTrue: [ ^nil ].	^coll last! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34114548!latestVersion	| excluded |"	self deprecated: 'Please use #stableVersion instead.'."	self flag: 'deprecate after version 1.0'.	excluded := self excludeFromLatestVersion.	^(self map values select: [:version |  		(excluded includes: version blessing) not ]) detectMax: [:version | version ]! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34114917!latestVersion: blessing	^(self map values select: [:version | blessing = version blessing ]) detectMax: [:version | version ]! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34115118!latestVersionMatching: versionPatternString	"Answer whether the version number of the receiver matches the given pattern string.	 A Metacello version number is made up of version sequences delimited by the characters $. and $-.	 The $. introduces a numeric version sequence and $- introduces an alphanumeric version sequence.	 	 A version pattern is made up of version pattern match sequences. also delimited by the characters $. 	 and $-.. Each pattern match sequence is tested against the corresponding version sequence of the 	 receiver, using the 'standard' pattern matching rules. All sequences must answer true for a match.		 The special pattern sequence '?' is a match for the corresponding version sequence and all subsequent 	 version sequences. '?' as the version pattern matches all versions. No more version pattern 	 sequences are permitted once the '?' sequence is used. If used, it is the last version pattern	 sequence."	^self 		latestVersionMatching: versionPatternString 		includedBlessings: #()		excludedBlessings: self excludeFromLatestVersion! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34116276!latestVersionMatching: versionPatternString excludedBlessings: excluded	^self 		latestVersionMatching: versionPatternString 		includedBlessings: #()		excludedBlessings: excluded! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34116535!latestVersionMatching: versionPatternString includedBlessings: included	^self 		latestVersionMatching: versionPatternString 		includedBlessings: included		excludedBlessings: self excludeFromLatestVersion! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34116820!latestVersionMatching: versionPatternString includedBlessings: included excludedBlessings: excludedBlessings	| excluded |	excluded := excludedBlessings asSet copy.	excluded removeAllFoundIn: included.	^(self map values select: [:version |		(included isEmpty or: [ included includes: version blessing ]) 			and: [ (excluded includes: version blessing) not 				and: [ version versionNumber match: versionPatternString ]]])		detectMax: [:version | version ]! !!MetacelloProject methodsFor: 'loading' stamp: 'dkh 6/5/2012 19:01:24' prior: 34117357!load: aVersionString	^(self version: aVersionString) load! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34117493!loadType	"#atomic or #linear"	loadType == nil ifTrue: [ ^#atomic ].	^loadType! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34117650!loadType: aSymbol	"#atomic or #linear"	loadType := aSymbol! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24' prior: 34117790!loader	^loader! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24' prior: 34117885!loader: aLoader	loader := aLoader! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24' prior: 34117998!loaderClass	loaderClass == nil ifTrue: [ loaderClass := self defaultLoaderClass ].	^loaderClass! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24' prior: 34118174!loaderClass: aMetacelloSpecLoader	loaderClass := aMetacelloSpecLoader! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24'!lookupVersion: aVersionString ifAbsent: aBlock    "please use version:...this is a private method"    ^ self map        at: aVersionString        ifAbsent: [             (MetacelloVersionDefinitionError project: self project versionString: aVersionString)                exception: (self errorMap at: aVersionString ifAbsent: [ ^ aBlock value ]);                signal ]! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34118321!map	versionMap ifNil: [ ^ Dictionary new ].	^ versionMap! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34118455!map: aDictionary	versionMap := aDictionary! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24' prior: 34118578!packagesSpec	^self packagesSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24' prior: 34118705!packagesSpecClass	^MetacelloPackagesSpec! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34118822!platformAttributes	 ^self projectPlatformAttributes! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34118949!pragmaKeywords	^#(version:attribute: blessing:attribute: description:attribute: required:attribute: groups:attribute: doits:attribute:)! !!MetacelloProject methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34119170!printOn: aStream	| label |	self configuration class printOn: aStream.	aStream nextPut: $(.	self versions		do: [ :vrsn | 			aStream nextPutAll: vrsn versionString.			vrsn spec ~~ nil				ifTrue: [ 					(label := vrsn spec projectLabel) isEmpty						ifFalse: [ aStream nextPutAll: ' [' , label , ']' ] ].			aStream				nextPut: $,;				space ].	aStream nextPut: $)! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34119618!project	^self! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34119706!projectAttributes	projectAttributes ~~ nil ifTrue: [ ^projectAttributes ].	^#()! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34119861!projectAttributes: aList	projectAttributes := aList! !!MetacelloProject methodsFor: 'scripting' stamp: 'dkh 6/5/2012 19:01:24'!projectForScriptEngine: aMetacelloScriptEngine    ^ self projectForScriptEngine: aMetacelloScriptEngine unconditionalLoad: false! !!MetacelloProject methodsFor: 'scripting' stamp: 'dkh 6/5/2012 19:01:24'!projectForScriptEngine: aMetacelloScriptEngine unconditionalLoad: aBool    ^ self subclassResponsibility! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34119987!projectPlatformAttributes	| list aBlock |	list := OrderedCollection new.	(aBlock := self projectAttributes) ~~ nil 		ifTrue: [ list addAll: aBlock value ].	^self defaultPlatformAttributes, list! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24' prior: 34120265!projectReferenceSpec	^self projectReferenceSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24' prior: 34120408!projectReferenceSpecClass	^MetacelloProjectReferenceSpec! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24' prior: 34120546!projectSpec	^self projectSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24' prior: 34120681!projectSpecClass    ^ MetacelloProjectSpec! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34441705!sortedAndFilteredVersions		^(self map values asArray sort: [:a :b | a >= b ]) select: [:vrsn | (#(broken baseline) includes: vrsn blessing) not ].! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34121045!stableVersion	^self version: #stable! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34121168!symbolicVersionMap	^symbolicVersionMap								! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34121303!symbolicVersionMap: aDictionary	symbolicVersionMap := aDictionary								! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34121465!symbolicVersionSymbols	^self symbolicVersionMap keys asArray sort: [:a :b | a <= b ]! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24' prior: 34121629!valueHolderSpec	^self valueHolderSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24' prior: 34121761!valueHolderSpecClass	^MetacelloValueHolderSpec! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34121894!version: aVersionString    | vrsn |    aVersionString isSymbol        ifTrue: [             | symbolicVersionString |            symbolicVersionString := self symbolicVersionMap                at: aVersionString                ifAbsent: [ (MetacelloSymbolicVersionDoesNotExistError project: self project versionString: aVersionString) signal ].            symbolicVersionString == #'notDefined'                ifTrue: [ (MetacelloSymbolicVersionNotDefinedError project: self project versionString: aVersionString) signal ].            ^ self                lookupVersion: symbolicVersionString                ifAbsent: [ (MetacelloSymbolicVersionDoesNotExistError project: self project versionString: symbolicVersionString) signal ] ].    ^ self        lookupVersion: aVersionString        ifAbsent: [ (MetacelloVersionDoesNotExistError project: self project versionString: aVersionString) signal ]! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34122752!version: aVersionString ifAbsent: aBlock	^[ self version: aVersionString ] on: MetacelloVersionDoesNotExistError do: [:ex | aBlock value ].! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/22/2012 12:41'!versionNumberClass    versionNumberClass ifNil: [ versionNumberClass := MetacelloVersionNumber ].    ^ versionNumberClass! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/22/2012 12:41'!versionNumberClass: aClass    versionNumberClass := aClass! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24' prior: 34122973!versionSpec	^self versionSpecClass for: self! !!MetacelloProject methodsFor: 'spec classes' stamp: 'dkh 6/5/2012 19:01:24' prior: 34123097!versionSpecClass	^MetacelloVersionSpec! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34123222!versions	^self map values asArray sort: [:a :b | a <= b ]! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: 'dkh 6/13/2012 13:18'!baselineClasses    "Return a set of the Metacello baseline classes that have been loaded into the image."    "self baselineClasses"    ^ BaselineOf allSubclasses! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: 'dkh 7/19/2012 11:18'!baselineProjectSpecs    "MetacelloProjectRegistration baselineProjectSpecs"    ^ self registry baselineProjectSpecs! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: 'dkh 6/13/2012 13:37'!configurationClasses    "Return a set of the Metacello configuration classes that have been loaded into the image."    "self configurationClasses"    | answer |    answer := IdentitySet new.    ConfigurationOf allSubclasses        do: [ :cl |             (cl == BaselineOf or: [ cl inheritsFrom: BaselineOf ])                ifFalse: [ answer add: cl ] ].    Object allSubclasses        do: [ :cl |             (answer includes: cl)                ifFalse: [                     (([ cl isMetacelloConfig ]                        on: Error                        do: [ :ex | ex return: false ]) and: [ cl name asString beginsWith: 'ConfigurationOf' ])                        ifTrue: [ answer add: cl ] ] ].    ^ answer! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: 'dkh 7/19/2012 11:47'!configurationProjectSpecs    "MetacelloProjectRegistration configurationProjectSpecs"    ^ self registry configurationProjectSpecs! !!MetacelloProjectRegistration class methodsFor: 'mutability' stamp: 'dkh 7/20/2012 11:37'!copyRegistryRestoreOnErrorWhile: aBlock    "install copy of registry for duration of <aBlock> execution."    "registrations will be copied on write during <aBlock> execution."    "if <aBlock> does not return control to this context, revert to the original	version of the registry. Otherwise leave the new copy installed."    | oldRegistry newRegistry |    oldRegistry := self registry.    newRegistry := self registry copy.    self registry: newRegistry.    aBlock        ensure: [             "install old version of registry"            self registry: oldRegistry ].    self registry: newRegistry	"if control returned, install newRegistry"! !!MetacelloProjectRegistration class methodsFor: 'mutability' stamp: 'dkh 7/20/2012 11:37'!copyRegistryWhile: aBlock    "install copy of registry for duration of <aBlock> execution."    "registrations will be copied on write during <aBlock> execution."    "Unconditionally revert to the original	version of the registry. Otherwise leave the new copy installed."    | oldRegistry newRegistry |    oldRegistry := self registry.    newRegistry := self registry copy.    self registry: newRegistry.    aBlock        ensure: [             "install old version of registry"            self registry: oldRegistry ]! !!MetacelloProjectRegistration class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24'!fromMCBaselineProjectSpec: aProjectSpec    ^ self new        projectName: aProjectSpec name;        baselineProjectSpec: aProjectSpec;        yourself! !!MetacelloProjectRegistration class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24'!fromMCConfigurationProjectSpec: aProjectSpec    ^ self new        projectName: aProjectSpec name;        configurationProjectSpec: aProjectSpec;        yourself! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: 'dkh 7/19/2012 11:51'!primeRegistryFromImage    "MetacelloProjectRegistration primeRegistryFromImage"    self registry primeRegistryFromImage! !!MetacelloProjectRegistration class methodsFor: 'querying' stamp: 'dkh 7/19/2012 11:34'!projectSpecForClassNamed: aClassName ifAbsent: absentBlock    ^ self registry projectSpecForClassNamed: aClassName ifAbsent: absentBlock! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: 'dkh 7/14/2012 07:47'!projectSpecs    "MetacelloProjectRegistration projectSpecs"    ^ self configurationProjectSpecs , self baselineProjectSpecs! !!MetacelloProjectRegistration class methodsFor: 'registration' stamp: 'dkh 7/19/2012 21:33'!registerProjectSpec: aProjectSpec ifPresent: presentBlock    | newRegistration |    newRegistration := aProjectSpec asProjectRegistration.    ^ self registry        registrationFor: newRegistration        ifPresent: [ :existing | presentBlock value: existing value: newRegistration ]        ifAbsent: [ newRegistration registerProject ]! !!MetacelloProjectRegistration class methodsFor: 'querying' stamp: 'dkh 7/19/2012 12:47'!registrationForClassNamed: aClassName ifAbsent: absentBlock    ^ self registry registrationForClassNamed: aClassName ifAbsent: absentBlock! !!MetacelloProjectRegistration class methodsFor: 'querying' stamp: 'dkh 7/19/2012 12:01'!registrationForProjectSpec: aProjectSpec ifAbsent: absentBlock ifPresent: presentBlock    | newRegistration |    newRegistration := aProjectSpec asProjectRegistration.    self registry        registrationFor: newRegistration        ifPresent: [ :existing | ^ presentBlock value: existing value: newRegistration ]        ifAbsent: [ ^ absentBlock value: newRegistration ]! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: 'dkh 7/19/2012 11:17'!registry    Registry ifNil: [ Registry := MetacelloProjectRegistry new ].    ^ Registry! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: 'dkh 7/19/2012 11:17'!registry: aMetacelloProjectRegistry    Registry := aMetacelloProjectRegistry! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: 'dkh 7/19/2012 11:52'!resetRegistry    Registry := nil! !!MetacelloProjectRegistration methodsFor: 'comparision' stamp: 'dkh 6/5/2012 19:01:24'!= aRegistration    aRegistration class == self class        ifFalse: [ ^ false ].    ^ (configurationProjectSpec registrationsCompareEqual: aRegistration configurationProjectSpec)        and: [ baselineProjectSpec registrationsCompareEqual: aRegistration baselineProjectSpec ]! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 6/7/2012 17:37'!baseName    ^ MetacelloScriptEngine baseNameOf: (configurationProjectSpec ifNil: [ baselineProjectSpec ]) className! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!baselineProjectSpec	^ baselineProjectSpec! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 7/19/2012 16:03'!baselineProjectSpec: anObject    self shouldBeMutable.    baselineProjectSpec := anObject! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!baselineProjectSpecIfAbsent: absentBlock    ^ baselineProjectSpec ifNil: absentBlock! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 07/24/2012 17:49'!baselineProjectSpecIfPresent: presentBlock ifAbsent: absentBlock     ^ baselineProjectSpec ifNotNil: [ presentBlock cull: baselineProjectSpec ]  ifNil: absentBlock! !!MetacelloProjectRegistration methodsFor: 'testing' stamp: 'dkh 7/18/2012 11:39'!canDowngradeTo: aProjectRegistration    "true if there are no load conflicts        OR       if the load conflicts involved two cofigurations ONLY and a downgrade is allowed"    (self hasLoadConflicts: aProjectRegistration)        ifFalse: [ ^ true ].    configurationProjectSpec        ifNotNil: [             aProjectRegistration configurationProjectSpec                ifNotNil: [                     configurationProjectSpec ensureProjectLoaded.                    ^ configurationProjectSpec canDowngradeTo: aProjectRegistration configurationProjectSpec ] ].    ^ false! !!MetacelloProjectRegistration methodsFor: 'testing' stamp: 'dkh 7/19/2012 21:03'!canUpgradeTo: aProjectRegistration    "true if there are no load conflicts        OR       if the load conflicts involved two cofigurations ONLY and an upgrade is allowed"    (self hasLoadConflicts: aProjectRegistration)        ifFalse: [ ^ true ].    configurationProjectSpec        ifNotNil: [             aProjectRegistration configurationProjectSpec                ifNotNil: [                     configurationProjectSpec copy ensureProjectLoaded.                    ^ configurationProjectSpec canUpgradeTo: aProjectRegistration configurationProjectSpec ] ].    ^ false! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!configurationProjectSpec	^ configurationProjectSpec! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 7/19/2012 16:03'!configurationProjectSpec: anObject    self shouldBeMutable.    configurationProjectSpec := anObject! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!configurationProjectSpecIfAbsent: absentBlock    ^ configurationProjectSpec ifNil: absentBlock! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 07/24/2012 17:38'!configurationProjectSpecIfPresent: presentBlock ifAbsent: absentBlock    ^ configurationProjectSpec ifNotNil: [ presentBlock cull: configurationProjectSpec ]  ifNil: absentBlock! !!MetacelloProjectRegistration methodsFor: 'mutability' stamp: 'dkh 7/19/2012 16:45'!copyOnWrite: aBlock    "assume that only registered projects are immutable ... otherwise you'll get an error"    | copy |    self class registry        registrationFor: self        ifPresent: [ :existing |  ]        ifAbsent: [             aBlock value: self.            ^ self ].    self unregisterProject.    copy := self copy.    aBlock value: copy.    copy registerProject.    ^ copy! !!MetacelloProjectRegistration methodsFor: 'querying' stamp: 'dkh 6/24/2012 13:57'!currentlyLoadedClassesInProject    | classes |    classes := Set new.    self        configurationProjectSpecIfPresent: [ :spec | classes addAll: spec currentlyLoadedClassesInVersion ]        ifAbsent: [  ].    self baselineProjectSpecIfPresent: [ :spec | classes addAll: spec currentlyLoadedClassesInVersion ] ifAbsent: [  ].    ^ classes! !!MetacelloProjectRegistration methodsFor: 'testing' stamp: 'dkh 05/11/2013 08:06'!hasLoadConflicts: aProjectRegistration  "5 combinations of loads with no load conflicts:        No configs and baselines =        configs = and no baselines        configs = and baselines =        configs = and no baseline loaded (self) with a baseline to load (aProjectRegistration)        config loaded (self), no config to load (aProjectRegistration) and no baseline loaded(self) with a baseline to load (aProjectRegistration) "  self isValid    ifFalse: [ self error: 'Invalid projectRegistration: ' , self printString ].  aProjectRegistration isValid    ifFalse: [ self error: 'Invalid projectRegistration: ' , aProjectRegistration printString ].  configurationProjectSpec    ifNil: [       aProjectRegistration configurationProjectSpec notNil        ifTrue: [           "a configuration MAY NOT trump a baseline"          ^ true ] ]    ifNotNil: [       aProjectRegistration configurationProjectSpec        ifNotNil: [           (aProjectRegistration configurationProjectSpec            hasLoadConflicts: configurationProjectSpec)            ifTrue: [ ^ true ] ] ].  ^ baselineProjectSpec    ifNil: [       "a baseline MAY trump a configuration"      false ]    ifNotNil: [ baselineProjectSpec hasLoadConflicts: aProjectRegistration baselineProjectSpec ]! !!MetacelloProjectRegistration methodsFor: 'comparision' stamp: 'dkh 6/5/2012 19:01:24'!hash    ^ ((String stringHash: projectName initialHash: 0) bitXor: configurationProjectSpec metacelloRegistrationHash)        bitXor: baselineProjectSpec metacelloRegistrationHash! !!MetacelloProjectRegistration methodsFor: 'mutability' stamp: 'dkh 7/19/2012 15:11'!immutable    mutable := false! !!MetacelloProjectRegistration methodsFor: 'mutability' stamp: 'dkh 7/19/2012 15:11'!isMutable    mutable ifNil: [ ^ true ].    ^ mutable! !!MetacelloProjectRegistration methodsFor: 'testing' stamp: 'dkh 6/5/2012 19:01:24'!isValid    " has a name and one or the other of the projectSpecs is non-nil"    projectName ifNil: [ ^ false ].    ^ configurationProjectSpec notNil or: [ baselineProjectSpec notNil ]! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 7/16/2012 12:23'!loadedInImage    loadedInImage ifNil: [ loadedInImage := false ].    ^ loadedInImage! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 7/19/2012 16:03'!loadedInImage: anObject    self shouldBeMutable.    loadedInImage := anObject! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 7/17/2012 12:36'!locked    locked ifNil: [ locked := false ].    ^ locked! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 7/19/2012 16:03'!locked: anObject    self shouldBeMutable.    locked := anObject! !!MetacelloProjectRegistration methodsFor: 'lookup' stamp: 'dkh 7/19/2012 20:58'!lookupBaselineSpec    baselineProjectSpec ifNotNil: [ :spec | ^ spec ].    ^ configurationProjectSpec! !!MetacelloProjectRegistration methodsFor: 'lookup' stamp: 'dkh 7/19/2012 20:58'!lookupConfigurationSpec    configurationProjectSpec ifNotNil: [ :spec | ^ spec ].    ^ baselineProjectSpec! !!MetacelloProjectRegistration methodsFor: 'lookup' stamp: 'dkh 05/10/2013 08:28'!lookupSpec: aProjectSpec  self configurationProjectSpec    ifNotNil: [ :spec |       spec className = aProjectSpec className        ifTrue: [ ^ spec ] ].  self baselineProjectSpec    ifNotNil: [ :spec |       spec className = aProjectSpec className        ifTrue: [ ^ spec ] ].  ^ nil! !!MetacelloProjectRegistration methodsFor: 'merging' stamp: 'dkh 7/19/2012 16:03'!merge: aProjectRegistration    "should only be called from MetacelloProjectRegistration class>>mergeRegistration:with: ... merge is done when a spec has been loaded into the image"    "nil specs are ignored in the merge, otherwise aProjectRegistration specs win"    "(self hasMergeConflicts: aProjectRegistration)        ifTrue: [ ^ self error: 'Attempt to merge registrations with conflicts' ]."    self shouldBeMutable.    configurationProjectSpec        ifNil: [ configurationProjectSpec := aProjectRegistration configurationProjectSpec ]        ifNotNil: [             aProjectRegistration configurationProjectSpec                ifNotNil: [ configurationProjectSpec := aProjectRegistration configurationProjectSpec ] ].    baselineProjectSpec        ifNil: [ baselineProjectSpec := aProjectRegistration baselineProjectSpec ]        ifNotNil: [ aProjectRegistration baselineProjectSpec ifNotNil: [ baselineProjectSpec := aProjectRegistration baselineProjectSpec ] ]! !!MetacelloProjectRegistration methodsFor: 'mutability' stamp: 'dkh 7/19/2012 15:11'!mutable    mutable := true! !!MetacelloProjectRegistration methodsFor: 'copying' stamp: 'dkh 7/19/2012 15:12'!postCopy    super postCopy.    mutable := nil! !!MetacelloProjectRegistration methodsFor: 'printing' stamp: 'dkh 6/30/2012 14:24'!printOn: aStream    | label versionString descriptions |    self        configurationProjectSpecIfPresent: [ :spec |             label := spec className.            versionString := spec versionString ]        ifAbsent: [             "baseline"            label := self baselineProjectSpec className.            versionString := '[baseline]' ].    aStream        nextPutAll: label;        space;        nextPutAll: versionString.    (descriptions := self repositoryDescriptions) isEmpty        ifTrue: [ ^ self ].    aStream nextPutAll: ' from '.    descriptions size = 1        ifTrue: [ aStream nextPutAll: descriptions first ]        ifFalse: [             aStream nextPut: ${.            descriptions do: [ :description | aStream nextPutAll: description ].            aStream nextPut: $} ]! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!projectName	^ projectName! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 7/19/2012 16:03'!projectName: anObject    self shouldBeMutable.    projectName := anObject! !!MetacelloProjectRegistration methodsFor: 'registration' stamp: 'dkh 7/19/2012 11:25'!registerProject    "unconditionally register <newRegistration> ... use with care"    self class registry registerProjectRegistration: self! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 6/30/2012 14:25'!repositoryDescriptions    ^ (self configurationProjectSpecIfAbsent: [ self baselineProjectSpec ]) repositoryDescriptions! !!MetacelloProjectRegistration methodsFor: 'mutability' stamp: 'dkh 7/19/2012 16:06'!shouldBeMutable    self isMutable        ifTrue: [ ^ self ].    self error: 'Not allowed to modify an immutable object'! !!MetacelloProjectRegistration methodsFor: 'registration' stamp: 'dkh 7/19/2012 11:33'!unregisterProject    self class registry unregisterProjectRegistration: self! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 6/13/2012 13:52'!version    ^ (self configurationProjectSpecIfAbsent: [ ^ MetacelloMCBaselineProject singletonVersionName ]) versionString! !!MetacelloProjectRegistry methodsFor: 'accessing' stamp: 'dkh 7/19/2012 11:09'!baselineProjectSpecs    "MetacelloProjectRegistration baselineProjectSpecs"    | projectSpecs |    projectSpecs := OrderedCollection new.    self baselineRegistry        keysAndValuesDo: [ :className :registration | projectSpecs add: (self projectSpecForClassNamed: className ifAbsent: [ self error: 'not expected' ]) ].    ^ projectSpecs asArray! !!MetacelloProjectRegistry methodsFor: 'accessing' stamp: 'dkh 7/19/2012 11:11'!baselineRegistry    baselineRegistry ifNil: [ baselineRegistry := Dictionary new ].    ^ baselineRegistry! !!MetacelloProjectRegistry methodsFor: 'accessing' stamp: 'dkh 7/19/2012 12:11'!configurationProjectSpecs    "MetacelloProjectRegistration configurationProjectSpecs"    | projectSpecs |    projectSpecs := OrderedCollection new.    self configurationRegistry        keysAndValuesDo: [ :className :registration | projectSpecs add: (self projectSpecForClassNamed: className ifAbsent: [ self error: 'not expected' ]) ].    ^ projectSpecs asArray! !!MetacelloProjectRegistry methodsFor: 'accessing' stamp: 'dkh 7/19/2012 11:13'!configurationRegistry    configurationRegistry ifNil: [ configurationRegistry := Dictionary new ].    ^ configurationRegistry! !!MetacelloProjectRegistry methodsFor: 'accessing' stamp: 'dkh 05/10/2013 16:42'!isEmpty  ^ self configurationProjectSpecs isEmpty    and: [ self baselineProjectSpecs isEmpty ]! !!MetacelloProjectRegistry methodsFor: 'copying' stamp: 'dkh 7/20/2012 11:13'!postCopy    super postCopy.    baselineRegistry := self baselineRegistry copy.    configurationRegistry := self configurationRegistry copy! !!MetacelloProjectRegistry methodsFor: 'initialization' stamp: ' 07/10/2013 22:51'!primeRegistryFromImage  "MetacelloProjectRegistration primeRegistryFromImage"  MetacelloProjectRegistration configurationClasses    do: [ :cl |       (self configurationRegistry includesKey: cl name asString)        ifFalse: [           "not registered"          cl project currentVersion            ifNotNil: [ :version |               [               | projectSpec |              projectSpec := (version project projectSpec                name: (MetacelloScriptEngine baseNameOf: cl name asString);                className: cl name asString;                versionString: version versionString;                repositories: version project projectPackage repositories copy;                yourself) asConfigurationProjectSpec.              projectSpec asProjectRegistration                loadedInImage: true;                registerProject ]                on: Error                do: [ :ex |                   Transcript                    cr;                    show:                        'ERROR registering (MetacelloProjectRegistry>>primeRegistryFromImage): '                            , cl name printString , ':' , ex description.                  ex return: nil ] ] ] ].  MetacelloProjectRegistration baselineClasses    do: [ :cl |       (self baselineRegistry includesKey: cl name asString)        ifFalse: [           "not registered"          cl project currentVersion            ifNotNil: [ :version |               | projectSpec |              projectSpec := (version project projectSpec                name: (MetacelloScriptEngine baseNameOf: cl name asString);                repositories: version project projectPackage repositories copy;                yourself) asBaselineProjectSpec.              projectSpec asProjectRegistration                loadedInImage: true;                registerProject ] ] ]! !!MetacelloProjectRegistry methodsFor: 'querying' stamp: 'dkh 7/19/2012 11:14'!projectSpecForClassNamed: aClassName ifAbsent: absentBlock    ^ (self configurationRegistry        at: aClassName        ifAbsent: [ ^ (self baselineRegistry at: aClassName ifAbsent: [^absentBlock value]) baselineProjectSpec ])        configurationProjectSpec! !!MetacelloProjectRegistry methodsFor: 'accessing' stamp: 'dkh 7/19/2012 11:13'!projectSpecs    "MetacelloProjectRegistration projectSpecs"    ^ self configurationProjectSpecs , self baselineProjectSpecs! !!MetacelloProjectRegistry methodsFor: 'registration' stamp: 'dkh 7/19/2012 15:27'!registerProjectRegistration: aMetacelloProjectRegistration    "unconditionally register <newRegistration> ... use with care"    aMetacelloProjectRegistration configurationProjectSpec        ifNotNil: [ :spec |             self configurationRegistry                at: spec className                ifPresent: [ :existing |                     (existing configurationProjectSpec registrationsCompareEqual: spec)                        ifFalse: [                             Transcript                                cr;                                show:                                        'REGISTRATION OF INCOMPATABLE PROJECTS: ' , existing printString , ' REPLACED BY '                                                , aMetacelloProjectRegistration printString ] ].            spec immutable.            self configurationRegistry at: spec className put: aMetacelloProjectRegistration ].    aMetacelloProjectRegistration baselineProjectSpec        ifNotNil: [ :spec |             self baselineRegistry                at: spec className                ifPresent: [ :existing |                     (existing baselineProjectSpec registrationsCompareEqual: spec)                        ifFalse: [                             Transcript                                cr;                                show:                                        'REGISTRATION OF INCOMPATABLE PROJECTS: ' , existing printString , ' REPLACED BY '                                                , aMetacelloProjectRegistration printString ] ].            spec immutable.            self baselineRegistry at: spec className put: aMetacelloProjectRegistration ].    aMetacelloProjectRegistration immutable! !!MetacelloProjectRegistry methodsFor: 'registration' stamp: 'dkh 7/19/2012 11:30'!registrationFor: aMetacelloProjectRegistration ifPresent: presentBlock ifAbsent: absentBlock    | baseName |    baseName := aMetacelloProjectRegistration baseName.    aMetacelloProjectRegistration configurationProjectSpec        ifNotNil: [ :spec | self configurationRegistry at: spec className ifPresent: [ :existing | ^ presentBlock value: existing ] ].    aMetacelloProjectRegistration baselineProjectSpec        ifNotNil: [ :spec | self baselineRegistry at: spec className ifPresent: [ :existing | ^ presentBlock value: existing ] ].    self configurationRegistry        at: 'ConfigurationOf' , baseName        ifPresent: [ :existing | ^ presentBlock value: existing ].    self baselineRegistry at: 'BaselineOf' , baseName ifPresent: [ :existing | ^ presentBlock value: existing ].    ^ absentBlock value! !!MetacelloProjectRegistry methodsFor: 'querying' stamp: 'dkh 7/19/2012 12:45'!registrationForClassNamed: aClassName ifAbsent: absentBlock    | baseName |    baseName := MetacelloScriptEngine baseNameOf: aClassName.    self configurationRegistry at: aClassName ifPresent: [ :registration | ^ registration ].    self baselineRegistry at: aClassName ifPresent: [ :registration | ^ registration ].    self configurationRegistry at: 'ConfigurationOf' , baseName ifPresent: [ :registration | ^ registration ].    self baselineRegistry at: 'BaselineOf' , baseName ifPresent: [ :registration | ^ registration ].    ^ absentBlock value! !!MetacelloProjectRegistry methodsFor: 'registration' stamp: 'dkh 7/19/2012 11:33'!unregisterProjectRegistration: aMetacelloProjectRegistration    aMetacelloProjectRegistration configurationProjectSpec        ifNotNil: [ :spec |             self configurationRegistry                removeKey: spec className                ifAbsent: [ self error: 'unexpectedly missing project registration' ] ].    aMetacelloProjectRegistration baselineProjectSpec        ifNotNil: [ :spec | self baselineRegistry removeKey: spec className ifAbsent: [ self error: 'unexpectedly missing project registration' ] ]! !!MetacelloProjectSpecForLoad methodsFor: 'testing' stamp: 'dkh 6/5/2012 19:01:24'!hasOverride    ^ self overrideProjectSpec ~~ nil! !!MetacelloProjectSpecForLoad methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!overrideProjectSpec	^ overrideProjectSpec! !!MetacelloProjectSpecForLoad methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!overrideProjectSpec: anObject	overrideProjectSpec := anObject! !!MetacelloProjectSpecForLoad methodsFor: 'operations' stamp: 'dkh 07/10/2013 22:36'!performCurrentVersionTestAgainst: vrsn operator: anOperator targetVersionStatus: targetVersionStatus using: anMCLoader  "answer true if the current state of image is to be left as is"  | currentVersion existing new |  vrsn ifNil: [ ^ false ].  self useDetermineVersionForLoad    ifTrue: [       | prjct cv |      self hasOverride        ifTrue: [           self            error:              'unexpected logic combination: useDeterminVersionForLoad & hasOverride' ].      prjct := self projectSpec projectClassProject.      prjct loader: anMCLoader.      (cv := prjct currentVersion) == nil        ifTrue: [ ^ false ].      (targetVersionStatus includes: cv versionStatus)        ifTrue: [ ^ cv perform: anOperator with: vrsn ].      ^ false ].  (self hasOverride not or: [ targetVersionStatus ~= #(#'allLoadedToSpec') ])    ifTrue: [ ^ false ].  (self overrideProjectSpec allPackagesLoaded: anMCLoader)    ifFalse: [       "roughly equivalent to versionStatus test above (#'allLoadedToSpec')"      ^ false ].  (self overrideProjectSpec    isPartiallyLoaded: self overrideProjectSpec copy loader)    ifFalse: [       "if the project is not loaded at all"      ^ false ].  (currentVersion := self overrideProjectSpec versionOrNil) ifNil: [ ^ false ].  currentVersion = vrsn    ifTrue: [ ^ true ].  existing := self overrideProjectSpec asProjectRegistration.  new := self projectSpec asProjectRegistration.  ^ currentVersion > vrsn    ifTrue: [       "answer false if downgrade allowed"      (MetacelloAllowProjectDowngrade new        existingProjectRegistration: existing;        newProjectRegistration: new;        signal) == existing ]    ifFalse: [       "answer false if upgrade allowed"      (MetacelloAllowProjectUpgrade new        existingProjectRegistration: existing;        newProjectRegistration: new;        signal) == existing ]! !!MetacelloProjectSpecForLoad methodsFor: 'operations' stamp: 'dkh 6/14/2012 17:39'!performLoad    | displayString spec |    spec := self projectSpec.    displayString := 'Project: ' , spec name.    spec versionString ~~ nil        ifTrue: [ displayString := displayString , ' ' , spec versionString ].    Transcript        cr;        show: displayString.    self hasOverride        ifTrue: [             | override |            override := self overrideProjectSpec copy.            override mergeScriptLoads: spec.            override loadVersion: nil ]        ifFalse: [             spec                loadVersion:                    (self useDetermineVersionForLoad                        ifTrue: [ spec determineCurrentVersionForLoad ]                        ifFalse: [ spec versionOrNil ]) ]! !!MetacelloProjectSpecForLoad methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!projectSpec	^ projectSpec! !!MetacelloProjectSpecForLoad methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24'!projectSpec: anObject	projectSpec := anObject! !!MetacelloProjectSpecForLoad methodsFor: 'accessing' stamp: 'dkh 6/13/2012 15:40'!useDetermineVersionForLoad    useDetermineVersionForLoad ifNil: [ useDetermineVersionForLoad := true ].    ^ useDetermineVersionForLoad! !!MetacelloProjectSpecForLoad methodsFor: 'accessing' stamp: 'dkh 6/13/2012 15:39'!useDetermineVersionForLoad: anObject	useDetermineVersionForLoad := anObject! !!MetacelloBaselineSpecGenerator methodsFor: 'accessing' stamp: 'dkh 7/16/2012 10:43'!projectSpecCreationBlock    ^ [ :projectName | {(MetacelloMCBaselineProject new baselineOfProjectSpec name: projectName)} ]! !!MetacelloBaselineSpecGenerator methodsFor: 'accessing' stamp: 'dkh 7/16/2012 10:44'!projectSpecListBlock    ^ [ MetacelloProjectRegistration baselineProjectSpecs ]! !!MetacelloBaselineSpecGenerator methodsFor: 'accessing' stamp: 'dkh 7/16/2012 11:28'!projectSpecLookupBlock    ^ [ :projectName |     {(MetacelloProjectRegistration        projectSpecForClassNamed: (MetacelloScriptEngine baselineNameFrom: projectName)        ifAbsent: [  ])} ]! !!MetacelloConfigurationSpecGenerator methodsFor: 'accessing' stamp: 'dkh 7/16/2012 10:43'!projectSpecCreationBlock    ^ [ :projectName | {(MetacelloMCProject new configurationOfProjectSpec name: projectName)} ]! !!MetacelloConfigurationSpecGenerator methodsFor: 'accessing' stamp: 'dkh 7/16/2012 10:45'!projectSpecListBlock    ^ [ MetacelloProjectRegistration configurationProjectSpecs ]! !!MetacelloConfigurationSpecGenerator methodsFor: 'accessing' stamp: 'dkh 7/16/2012 11:28'!projectSpecLookupBlock    ^ [ :projectName |     {(MetacelloProjectRegistration        projectSpecForClassNamed: (MetacelloScriptEngine configurationNameFrom: projectName)        ifAbsent: [  ])} ]! !!MetacelloProjectSpecGenerator methodsFor: 'accessing' stamp: 'dkh 7/16/2012 10:42'!projectSpecCreationBlock    ^ [ :projectName | {(MetacelloMCProject new projectSpec name: projectName)} ]! !!MetacelloProjectSpecGenerator methodsFor: 'accessing' stamp: 'dkh 7/16/2012 10:44'!projectSpecListBlock    ^ [ MetacelloProjectRegistration projectSpecs ]! !!MetacelloProjectSpecGenerator methodsFor: 'accessing' stamp: 'dkh 7/16/2012 11:27'!projectSpecLookupBlock    ^ [ :projectName |     {(MetacelloProjectRegistration        projectSpecForClassNamed: (MetacelloScriptEngine baselineNameFrom: projectName)        ifAbsent: [  ]).    (MetacelloProjectRegistration        projectSpecForClassNamed: (MetacelloScriptEngine configurationNameFrom: projectName)        ifAbsent: [  ])} ]! !!MetacelloProjectSpecGenerator methodsFor: 'accessing' stamp: 'dkh 7/16/2012 10:34'!target	^ target! !!MetacelloProjectSpecGenerator methodsFor: 'accessing' stamp: 'dkh 7/16/2012 10:34'!target: anObject	target := anObject! !!MetacelloScriptEngine class methodsFor: 'utility' stamp: 'dkh 07/14/2013 12:01'!baseNameOf: className  ^ (className beginsWith: 'BaselineOf')    ifTrue: [ className copyFrom: 'BaselineOf' size + 1 to: className size ]    ifFalse: [       (className beginsWith: 'ConfigurationOf')        ifTrue: [ className copyFrom: 'ConfigurationOf' size + 1 to: className size ]        ifFalse: [ className ] ]! !!MetacelloScriptEngine class methodsFor: 'utility' stamp: 'dkh 7/12/2012 15:04'!baselineNameFrom: baseName    "Return the fully-qualified configuration class name."    ^ (baseName indexOfSubCollection: 'BaselineOf') > 0        ifTrue: [ baseName ]        ifFalse: [ 'BaselineOf' , baseName ]! !!MetacelloScriptEngine class methodsFor: 'utility' stamp: 'dkh 07/14/2013 12:00'!baselineProjectNameOf: baselineClassName  ^ (baselineClassName beginsWith: 'BaselineOf')    ifTrue: [ baselineClassName copyFrom: 'BaselineOf' size + 1 to: baselineClassName size ]    ifFalse: [ baselineClassName ]! !!MetacelloScriptEngine class methodsFor: 'utility' stamp: 'dkh 7/12/2012 15:04'!configurationNameFrom: baseName    "Return the fully-qualified configuration class name."    ^ (baseName indexOfSubCollection: 'ConfigurationOf') > 0        ifTrue: [ baseName ]        ifFalse: [ 'ConfigurationOf' , baseName ]! !!MetacelloScriptEngine class methodsFor: 'utility' stamp: 'dkh 07/14/2013 12:01'!configurationProjectNameOf: configurationClassName  ^ (configurationClassName beginsWith: 'ConfigurationOf')    ifTrue: [       configurationClassName        copyFrom: 'ConfigurationOf' size + 1        to: configurationClassName size ]    ifFalse: [ configurationClassName ]! !!MetacelloScriptEngine class methodsFor: 'defaults' stamp: 'dkh 7/23/2012 11:09'!defaultRepositoryDescription    DefaultRepositoryDescription        ifNil: [ DefaultRepositoryDescription := MetacelloPlatform current defaultRepositoryDescription ].    ^ DefaultRepositoryDescription! !!MetacelloScriptEngine class methodsFor: 'defaults' stamp: 'dkh 7/23/2012 10:03'!defaultVersionString    DefaultVersionString ifNil: [ DefaultVersionString := #'stable' ].    ^ DefaultVersionString! !!MetacelloScriptEngine methodsFor: 'options' stamp: 'dkh 7/23/2012 16:30'!cacheRepository    ^ (MetacelloMCProject new repositorySpec description: (self options at: #'cacheRepository' ifAbsent: [ ^ nil ]))        createRepository! !!MetacelloScriptEngine methodsFor: 'defaults' stamp: 'dkh 7/23/2012 11:09'!defaultRepositoryDescription    ^ self class defaultRepositoryDescription! !!MetacelloScriptEngine methodsFor: 'defaults' stamp: 'dkh 7/23/2012 10:02'!defaultVersionString    ^ self class defaultVersionString! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: 'dkh 7/23/2012 15:53'!fetch: required    self        fetchRecord: [ :version |             required isEmpty                ifTrue: [ version fetch ]                ifFalse: [ version fetch: required ] ]        required: required! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: 'dkh 04/03/2013 12:30'!fetchRecord: fetchRecordBlock required: required  MetacelloProjectRegistration    copyRegistryWhile: [       self        handleNotificationsForAction: [           | version loadedSpec |          self setDefaultsAndValidateProjectSpec.          [ loadedSpec := self lookupProjectSpecFor: self projectSpec ]            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade            do: [ :notification |               notification                handleOnDownGrade: [ :ex :existing :new | ex allowEvenIfLocked ]                onUpgrade: [ :ex :existing :new | ex allowEvenIfLocked ] ].          version := loadedSpec versionForScriptEngine: self.          self root: (fetchRecordBlock value: version) loadDirective ] ]! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: 'dkh 04/03/2013 12:30'!get  " load a fresh copy from repo"  | spec projectPackage |  MetacelloProjectRegistration    copyRegistryRestoreOnErrorWhile: [       self setDefaultsAndValidateProjectSpec.      spec := self projectSpec.      projectPackage := spec projectPackage.      projectPackage repositorySpecs        do: [ :repoSpec | repoSpec createRepository flushForScriptGet ].      projectPackage load.      self root: (Smalltalk at: spec className asSymbol) project.      MetacelloProjectRegistration        registrationForProjectSpec: spec        ifAbsent: [ :new | new registerProject ]        ifPresent: [ :existing :new |           existing            copyOnWrite: [ :existingCopy |               spec                copyForRegistration: existingCopy                onWrite: [ :specCopy |                   specCopy                    ifNil: [ existingCopy merge: new ]                    ifNotNil: [ specCopy mergeScriptRepository: spec ] ] ] ] ]! !!MetacelloScriptEngine methodsFor: 'project lookup' stamp: 'dkh 7/12/2012 14:25'!getBaselineProjectUnconditionalLoad: unconditionalLoad    | project |    project := (self getBaselineUnconditionalLoad: unconditionalLoad) project.    project version spec repositories: self repositories copy.    ^ project! !!MetacelloScriptEngine methodsFor: 'project lookup' stamp: 'dkh 7/12/2012 14:25'!getBaselineUnconditionalLoad: unconditionalLoad    | spec |    spec := self projectSpec.    Smalltalk        at: spec className asSymbol        ifPresent: [ :cl |             unconditionalLoad                ifFalse: [ ^ cl ] ].    (spec := self lookupProjectSpecFor: spec) projectPackage load.    ^ Smalltalk at: spec className asSymbol! !!MetacelloScriptEngine methodsFor: 'project lookup' stamp: 'dkh 7/12/2012 14:25'!getConfigurationProjectUnconditionalLoad: unconditionalLoad    ^ (self getConfigurationUnconditionalLoad: unconditionalLoad) project! !!MetacelloScriptEngine methodsFor: 'project lookup' stamp: 'dkh 7/12/2012 14:25'!getConfigurationUnconditionalLoad: unconditionalLoad    | spec |    spec := self projectSpec.    Smalltalk        at: spec className asSymbol        ifPresent: [ :cl |             unconditionalLoad                ifFalse: [ ^ cl ] ].    (spec := self lookupProjectSpecFor: spec) projectPackage load.    ^ Smalltalk at: spec className asSymbol! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: 'dkh 7/12/2012 14:25'!handleConflict: exception    ^ (self options at: #'onConflict' ifAbsent: [ ^ exception pass ])        cull: exception        cull: exception existingProjectRegistration        cull: exception newProjectRegistration! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: 'dkh 7/12/2012 14:25'!handleDowngrade: exception    ^ (self options at: #'onDowngrade' ifAbsent: [ ^ exception pass ])        cull: exception        cull: exception existingProjectRegistration        cull: exception newProjectRegistration! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: 'dkh 7/24/2012 11:43'!handleEnsureProjectLoadedForDevelopment: exception    "if useCurrentVersion resume with true, else resume with false"    ^ exception resume: self useCurrentVersion! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: 'dkh 05/11/2013 07:53'!handleLookupBaselineSpecForEnsureLoad: exception  "if requested and registered don't compare equal, then ensure the new baseline is loaded"  | requested registered |  requested := exception projectSpec.  registered := self lookupProjectSpecFor: exception projectSpec.  ^ exception resume: (registered compareEqual: requested) not! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: 'dkh 7/12/2012 14:25'!handleLookupProjectSpec: exception    ^ exception        resume:            ((self lookupProjectSpecFor: exception projectSpec) ifNil: [ ^ exception resume: exception projectSpec ])! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: 'dkh 05/11/2013 07:51'!handleLookupProjectSpecForLoad: exception  "if overrideProjectSpec is nil, use currentVersion in image, ignoreImage is false"  | requested override |  requested := exception projectSpec.  override := self useCurrentVersion    ifTrue: [       "don't do lookup in registry if we expect to use the #currentVersion calculation"      nil ]    ifFalse: [       | registered |      registered := self lookupProjectSpecFor: exception projectSpec.      (registered compareEqual: requested)        ifFalse: [           "counts as override, only if they differ in some aspect"          override := registered ] ].  ^ exception    resume:      (MetacelloProjectSpecForLoad new        projectSpec: requested;        useDetermineVersionForLoad: self useCurrentVersion;        overrideProjectSpec: override;        yourself)! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: 'dkh 7/27/2012 00:21'!handleNotificationsForAction: actionBlock	[ 	actionBlock		on:			MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad , MetacelloProjectSpecLoadedNotification				, MetacelloScriptEnsureProjectLoadedForDevelopment , MetacelloLookupBaselineSpecForEnsureLoad		do: [ :ex | 			"lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"			ex handleResolutionFor: self ] ]		on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade , MetacelloAllowConflictingProjectUpgrade		do: [ :ex | 			"option handlers need to be outermost set of handlers ... last line of defense before users are involved"			ex handleResolutionFor: self ]! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: 'dkh 7/19/2012 20:48'!handleProjectSpecLoaded: exception    MetacelloProjectRegistration        registrationForProjectSpec: exception projectSpec        ifAbsent: [ :new |             new                loadedInImage: true;                registerProject ]        ifPresent: [ :existing :new |             "unconditionally merge new with existing (updates registration)"            existing                copyOnWrite: [ :existingCopy |                     existingCopy                        loadedInImage: true;                        merge: new ] ].    exception resume! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: 'dkh 7/12/2012 14:25'!handleUpgrade: exception    ^ (self options at: #'onUpgrade' ifAbsent: [ ^ exception pass ])        cull: exception        cull: exception existingProjectRegistration        cull: exception newProjectRegistration! !!MetacelloScriptEngine methodsFor: 'options' stamp: 'dkh 7/12/2012 14:25'!ignoreImage    ^ self options at: #'ignoreImage' ifAbsent: [ false ]! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: 'dkh 04/03/2013 12:30'!list  self setDefaultsAndValidateProjectSpec.  self root: self projectSpec! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: 'dkh 7/20/2012 16:17'!load: required    self        load: required        onProjectDownGrade: [ :ex :existing :new | ex allowEvenIfLocked ]        onProjectUpgrade: [ :ex :existing :new | ex allowEvenIfLocked ]! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: 'dkh 07/01/2013 06:09'!load: required onProjectDownGrade: onDownGradeBlock onProjectUpgrade: onUpgradeBlock  MetacelloProjectRegistration    copyRegistryRestoreOnErrorWhile: [       self        handleNotificationsForAction: [           | version loadedSpec |          self setDefaultsAndValidateProjectSpec.          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].          version := loadedSpec versionForScriptEngine: self.          self            root:              (required isEmpty                ifTrue: [ version load ]                ifFalse: [ version load: required ]) loadDirective.          loadedSpec loads: required.          MetacelloProjectRegistration            registrationForProjectSpec: loadedSpec            ifAbsent: [ :new |               new                loadedInImage: true;                registerProject ]            ifPresent: [ :existing :new |               existing                copyOnWrite: [ :existingCopy |                   existingCopy                    loadedInImage: true;                    merge: new ] ] ] ]! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: 'dkh 04/03/2013 12:31'!lock  | spec |  MetacelloProjectRegistration    copyRegistryRestoreOnErrorWhile: [       self setDefaultsAndValidate: self projectSpec copy.	"don't add defaults"      spec := self projectSpec.      MetacelloProjectRegistration        registrationForProjectSpec: spec        ifAbsent: [ :new |           new            locked: true;            registerProject ]        ifPresent: [ :existing :new |           existing            copyOnWrite: [ :existingCopy |               existingCopy locked: true.              spec                copyForRegistration: existingCopy                onWrite: [ :specCopy |                   specCopy                    ifNil: [ existingCopy merge: new ]                    ifNotNil: [                       specCopy mergeScriptRepository: spec.                      spec := specCopy ] ] ] ].      self root: spec ]! !!MetacelloScriptEngine methodsFor: 'project lookup' stamp: 'dkh 05/11/2013 07:45'!lookupProjectSpecFor: aProjectSpec  "if there is no conflict, choose new spec"  | registration loadedSpec |  registration := MetacelloProjectRegistration    registrationForProjectSpec: aProjectSpec    ifAbsent: [ :new | new ]    ifPresent: [ :existing :new |       (existing hasLoadConflicts: new)        ifTrue: [           ((existing canUpgradeTo: new)            ifTrue: [ MetacelloAllowProjectUpgrade new ]            ifFalse: [               (existing canDowngradeTo: new)                ifTrue: [ MetacelloAllowProjectDowngrade new ]                ifFalse: [ MetacelloAllowConflictingProjectUpgrade new ] ])            existingProjectRegistration: existing;            newProjectRegistration: new;            signal ]        ifFalse: [ new ] ].  ^ registration lookupSpec: aProjectSpec! !!MetacelloScriptEngine methodsFor: 'accessing' stamp: 'dkh 7/12/2012 14:25'!options    options ifNil: [ options := Dictionary new ].    ^ options! !!MetacelloScriptEngine methodsFor: 'accessing' stamp: 'dkh 7/12/2012 14:33'!options: aDictionary    options := aDictionary! !!MetacelloScriptEngine methodsFor: 'accessing' stamp: 'dkh 7/12/2012 14:25'!projectName    ^ self projectSpec name! !!MetacelloScriptEngine methodsFor: 'accessing' stamp: 'dkh 7/12/2012 14:26'!projectSpec    ^ projectSpec! !!MetacelloScriptEngine methodsFor: 'accessing' stamp: 'dkh 7/12/2012 14:26'!projectSpec: aProjectSpec    projectSpec := aProjectSpec! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: 'dkh 7/23/2012 15:53'!record: required    self        fetchRecord: [ :version |             required isEmpty                ifTrue: [ version record ]                ifFalse: [ version record: required ] ]        required: required! !!MetacelloScriptEngine methodsFor: 'accessing' stamp: 'dkh 7/12/2012 14:25'!repositories    ^ self projectSpec repositories! !!MetacelloScriptEngine methodsFor: 'options' stamp: 'dkh 7/23/2012 19:31'!repositoryOverrides    ^ (self options at: #'repositoryOverrides' ifAbsent: [ ^ nil ])        collect: [ :description | (MetacelloMCProject new repositorySpec description: description) createRepository ]! !!MetacelloScriptEngine methodsFor: 'accessing' stamp: 'dkh 7/12/2012 14:25'!root	^ root! !!MetacelloScriptEngine methodsFor: 'accessing' stamp: 'dkh 7/12/2012 14:25'!root: anObject	root := anObject! !!MetacelloScriptEngine methodsFor: 'project lookup' stamp: 'dkh 04/03/2013 12:29'!setDefaultsAndValidate: aProjectSpec  "NOTE: aProjectSpec has defaults assigned if versionString or repository missing"  | issues |  issues := aProjectSpec    validateForScriptLoad: self    withDefaultVersionString: self defaultVersionString    withDefaultRepositoryDecription: self defaultRepositoryDescription.  issues isEmpty    ifTrue: [ ^ self ].  (MetacelloValidationFailure    issues: issues    message: 'Project spec validation failure') signal! !!MetacelloScriptEngine methodsFor: 'project lookup' stamp: 'dkh 04/03/2013 12:34'!setDefaultsAndValidateProjectSpec  "NOTE: projectSpec has defaults assigned if versionString or repository missing"  self setDefaultsAndValidate: self projectSpec! !!MetacelloScriptEngine methodsFor: 'options' stamp: 'dkh 7/12/2012 14:25'!silently    ^ self options at: #'silently' ifAbsent: [ false ]! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: 'dkh 04/03/2013 12:31'!unlock  | spec |  MetacelloProjectRegistration    copyRegistryRestoreOnErrorWhile: [       self setDefaultsAndValidate: self projectSpec copy.	"don't add defaults"      spec := self projectSpec.      MetacelloProjectRegistration        registrationForProjectSpec: spec        ifAbsent: [ :ignored |  ]        ifPresent: [ :existing :new | existing copyOnWrite: [ :existingCopy | existingCopy locked: false ] ].      self root: spec ]! !!MetacelloScriptEngine methodsFor: 'options' stamp: 'dkh 7/12/2012 14:25'!useCurrentVersion    "private option used to implement the classic mode"    ^ self options at: #'useCurrentVersion' ifAbsent: [ false ]! !!MetacelloScriptApiExecutor methodsFor: 'execution callback' stamp: 'dkh 7/16/2012 15:59'!executeBlock: selectBlock do: projectSpecBlock    (self projectSpecsFromRepositoryArg select: selectBlock)        do: [ :projectSpec | projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ]! !!MetacelloScriptApiExecutor methodsFor: 'execution callback' stamp: 'dkh 7/16/2012 15:56'!executeCollection: aCollection do: projectSpecBlock    self projectSpecsFromRepositoryArg        do: [ :projectSpec |             (aCollection includes: (MetacelloScriptEngine baseNameOf: projectSpec className))                ifTrue: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ]! !!MetacelloScriptApiExecutor methodsFor: 'execution callback' stamp: 'dkh 7/16/2012 17:10'!executeString: aString do: projectSpecBlock    self singleRoot: true.    (projectSpecGenerator projectSpecCreationBlock value: aString)        do: [ :projectSpec | projectSpec ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ]! !!MetacelloScriptApiExecutor methodsFor: 'execution callback' stamp: 'dkh 7/16/2012 16:38'!projectSpecsFromRepositoryArg    | spec repo projectSpecs |    repositoryArg ifNil: [ ^ #() ].    spec := (projectSpecGenerator projectSpecCreationBlock value: 'xxx') first.    repo := spec project createRepository: (spec project repositorySpec description: repositoryArg).    projectSpecs := OrderedCollection new.    ((Gofer new disablePackageCache        repository: repo;        allResolved) collect: [ :resolvedReference | resolvedReference packageName ]) asSet        do: [ :packageName |             (projectSpecGenerator projectSpecCreationBlock value: (MetacelloScriptEngine baseNameOf: packageName))                do: [ :projectSpec |                     projectSpec className = packageName                        ifTrue: [ projectSpecs add: (self applyArgsToProjectSpec: projectSpec copy) ] ] ].    ^ projectSpecs! !!MetacelloScriptExecutor methodsFor: 'execution' stamp: 'dkh 7/13/2012 09:33'!applyArgsToProjectSpec: aProjectSpec    classNameArg ifNotNil: [ aProjectSpec className: classNameArg ].    versionArg ifNotNil: [ aProjectSpec versionString: versionArg ].    repositoryArg ifNotNil: [ aProjectSpec repository: repositoryArg ].    ^ aProjectSpec! !!MetacelloScriptExecutor methodsFor: 'args' stamp: 'dkh 7/13/2012 09:30'!baselineArg	^ baselineArg! !!MetacelloScriptExecutor methodsFor: 'args' stamp: 'dkh 7/13/2012 09:30'!baselineArg: anObject	baselineArg := anObject! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: 'dkh 7/23/2012 16:18'!cacheRepository: aRepositoryDescription    self options at: #'cacheRepository' put: aRepositoryDescription! !!MetacelloScriptExecutor methodsFor: 'args' stamp: 'dkh 7/13/2012 09:30'!classNameArg    ^ classNameArg! !!MetacelloScriptExecutor methodsFor: 'args' stamp: 'dkh 7/13/2012 09:30'!classNameArg: anObject    classNameArg := anObject! !!MetacelloScriptExecutor methodsFor: 'args' stamp: 'dkh 7/13/2012 09:30'!configurationArg    ^ configurationArg! !!MetacelloScriptExecutor methodsFor: 'args' stamp: 'dkh 7/13/2012 09:30'!configurationArg: anObject    configurationArg := anObject! !!MetacelloScriptExecutor methodsFor: 'execution' stamp: 'dkh 7/16/2012 17:10'!execute: statements    statements        do: [ :assoc | assoc value ifNil: [ self perform: assoc key ] ifNotNil: [ self perform: assoc key withArguments: assoc value ] ].    projectSpecGenerator := self projectSpecGenerator.    projectSpecGenerator target        execute: [ :projectSpec |             | engine |            engine := MetacelloScriptEngine new                options: self options copy;                projectSpec: projectSpec;                yourself.            engine perform: actionArg key withArguments: actionArg value.            engine root ifNotNil: [ :root | self roots add: root ] ]        against: self.    ^ (self singleRoot and: [ self roots size == 1 ])        ifTrue: [ self roots first ]        ifFalse: [ self roots ]! !!MetacelloScriptExecutor methodsFor: 'execution callback' stamp: 'dkh 7/16/2012 14:56'!executeBlock: selectBlock do: projectSpecBlock    ((projectSpecGenerator projectSpecListBlock value select: selectBlock) select: self projectSpecSelectBlock)        do: [ :projectSpec | projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ]! !!MetacelloScriptExecutor methodsFor: 'execution callback' stamp: 'dkh 7/16/2012 14:57'!executeCollection: aCollection do: projectSpecBlock    aCollection        do: [ :projectName |             ((projectSpecGenerator projectSpecLookupBlock value: projectName) select: self projectSpecSelectBlock)                do: [ :projectSpec | projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ]! !!MetacelloScriptExecutor methodsFor: 'execution callback' stamp: 'dkh 7/16/2012 17:09'!executeString: aString do: projectSpecBlock    self singleRoot: true.    ((projectSpecGenerator projectSpecLookupBlock value: aString) select: self projectSpecSelectBlock)        do: [ :projectSpec | projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ]! !!MetacelloScriptExecutor methodsFor: 'actions api' stamp: 'dkh 7/23/2012 15:58'!fetch: required    actionArg := #'fetch:' -> {required}! !!MetacelloScriptExecutor methodsFor: 'actions api' stamp: 'dkh 7/16/2012 10:17'!get    actionArg := #'get' -> #()! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: 'dkh 7/13/2012 09:31'!ignoreImage: aBool    self options at: #'ignoreImage' put: aBool! !!MetacelloScriptExecutor methodsFor: 'actions api' stamp: 'dkh 7/16/2012 10:17'!list    actionArg := #'list' -> #()! !!MetacelloScriptExecutor methodsFor: 'actions api' stamp: 'dkh 7/16/2012 10:17'!load: required    actionArg := #'load:' -> {required}! !!MetacelloScriptExecutor methodsFor: 'actions api' stamp: 'dkh 7/17/2012 10:53'!lock    actionArg := #'lock' -> #()! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: 'dkh 7/13/2012 09:31'!onConflict: aBlock    self options at: #'onConflict' put: aBlock! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: 'dkh 7/13/2012 09:31'!onDowngrade: aBlock    self options at: #'onDowngrade' put: aBlock! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: 'dkh 7/13/2012 09:31'!onUpgrade: aBlock    self options at: #'onUpgrade' put: aBlock! !!MetacelloScriptExecutor methodsFor: 'accessing' stamp: 'dkh 7/13/2012 09:02'!options    options ifNil: [ options := Dictionary new ].    ^ options! !!MetacelloScriptExecutor methodsFor: 'args' stamp: 'dkh 7/13/2012 09:30'!projectArg    ^ projectArg! !!MetacelloScriptExecutor methodsFor: 'args' stamp: 'dkh 7/13/2012 09:30'!projectArg: anObject    projectArg := anObject! !!MetacelloScriptExecutor methodsFor: 'execution' stamp: 'dkh 7/16/2012 11:06'!projectSpecGenerator    baselineArg        ifNotNil: [             configurationArg ifNotNil: [ self error: ' baseline: and configuration: are both be specified' ].            projectArg ifNotNil: [ self error: ' baseline: and project are both be specified' ].            ^ MetacelloBaselineSpecGenerator new                target: baselineArg;                yourself ].    configurationArg        ifNotNil: [             baselineArg ifNotNil: [ self error: ' baseline: and configuration: are both be specified' ].            projectArg ifNotNil: [ self error: ' configuration and project are both be specified' ].            ^ MetacelloConfigurationSpecGenerator new                target: configurationArg;                yourself ].    projectArg        ifNotNil: [             configurationArg ifNotNil: [ self error: ' project and configuration: are both be specified' ].            baselineArg ifNotNil: [ self error: ' baseline: and project are both be specified' ].            ^ MetacelloProjectSpecGenerator new                target: projectArg;                yourself ].    self error: 'project, baseline, or configuration not specified'! !!MetacelloScriptExecutor methodsFor: 'execution callback' stamp: 'dkh 7/16/2012 11:34'!projectSpecSelectBlock    ^ [ :projectSpec | true ]! !!MetacelloScriptExecutor methodsFor: 'actions api' stamp: 'dkh 7/19/2012 07:45'!record: required    actionArg := #'record:' -> {required}! !!MetacelloScriptExecutor methodsFor: 'args' stamp: 'dkh 7/13/2012 09:30'!repositoryArg    ^ repositoryArg! !!MetacelloScriptExecutor methodsFor: 'args' stamp: 'dkh 7/13/2012 09:30'!repositoryArg: anObject    repositoryArg := anObject! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: 'dkh 7/23/2012 19:28'!repositoryOverrides: aRepositoryDescriptionList    self options at: #'repositoryOverrides' put: aRepositoryDescriptionList! !!MetacelloScriptExecutor methodsFor: 'accessing' stamp: 'dkh 7/13/2012 09:02'!roots    roots ifNil: [ roots := OrderedCollection new ].    ^ roots! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: 'dkh 7/13/2012 09:31'!silently: aBool    self options at: #'silently' put: aBool! !!MetacelloScriptExecutor methodsFor: 'accessing' stamp: 'dkh 7/16/2012 17:09'!singleRoot    singleRoot ifNil: [ singleRoot := false ].    ^ singleRoot! !!MetacelloScriptExecutor methodsFor: 'accessing' stamp: 'dkh 7/16/2012 17:09'!singleRoot: aBool    singleRoot := aBool! !!MetacelloScriptExecutor methodsFor: 'actions api' stamp: 'dkh 7/17/2012 12:31'!unlock    actionArg := #'unlock' -> #()! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: 'dkh 7/13/2012 09:31'!useCurrentVersion: aBool    "private option used to implement the classic mode"    self options at: #'useCurrentVersion' put: aBool! !!MetacelloScriptExecutor methodsFor: 'args' stamp: 'dkh 7/13/2012 09:30'!versionArg    ^ versionArg! !!MetacelloScriptExecutor methodsFor: 'args' stamp: 'dkh 7/13/2012 09:30'!versionArg: anObject    versionArg := anObject! !!MetacelloScriptImageExecutor methodsFor: 'execution callback' stamp: 'dkh 7/16/2012 14:53'!projectSpecSelectBlock    ^ [ :projectSpec |     projectSpec        ifNil: [ false ]        ifNotNil: [             MetacelloProjectRegistration                registrationForProjectSpec: projectSpec                ifAbsent: [ false ]                ifPresent: [ :existingRegistration :newRegistration | existingRegistration loadedInImage ] ] ]! !!MetacelloScriptRegistryExecutor methodsFor: 'actions api' stamp: 'dkh 7/20/2012 12:00'!prime! !!MetacelloScriptRegistryExecutor methodsFor: 'actions api' stamp: 'dkh 7/13/2012 09:37'!remove! !!MetacelloScriptRegistryExecutor methodsFor: 'actions api' stamp: 'dkh 7/13/2012 09:36'!reset! !!MetacelloSpec class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34161850!for: aVersionMap	^(self platformClass new)		for: aVersionMap;		yourself! !!MetacelloSpec class methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34162005!platformClass	^self! !!MetacelloSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24'!aboutToCopy! !!MetacelloSpec methodsFor: 'spec creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34162104!addMember	^MetacelloAddMemberSpec for: self project! !!MetacelloSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34162237!answers	^#()! !!MetacelloSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34162323!configMethodOn: aStream	self configMethodOn: aStream indent: 0! !!MetacelloSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34162461!configMethodOn: aStream indent: indent	self subclassResponsibility! !!MetacelloSpec methodsFor: 'spec creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34162608!copyMember	^MetacelloCopyMemberSpec for: self project! !!MetacelloSpec methodsFor: 'mutability' stamp: 'dkh 7/19/2012 16:44'!copyOnWrite: aBlock    "assume that only registered projects are immutable ... otherwise you'll get an error"    | copy |    copy := self copy.    aBlock value: copy.    ^ copy! !!MetacelloSpec methodsFor: 'doits' stamp: 'dkh 6/5/2012 19:01:24' prior: 34162733!doItBlock: selector	selector == nil ifTrue: [ ^nil ].	selector numArgs = 0		ifTrue: [ ^[ self project configuration perform: selector ] ].	selector numArgs = 1		ifTrue: [ ^[:aLoader | self project configuration perform: selector with: aLoader ] ].	selector numArgs = 2		ifTrue: [ ^[:aLoader :pkgSpec | self project configuration perform: selector with: aLoader with: pkgSpec ] ].	^nil! !!MetacelloSpec methodsFor: 'initialization' stamp: 'dkh 7/19/2012 15:09' prior: 34163206!for: aProject    self shouldBeMutable.    project := aProject! !!MetacelloSpec methodsFor: 'mutability' stamp: 'dkh 7/19/2012 15:03'!immutable    mutable := false! !!MetacelloSpec methodsFor: 'mutability' stamp: 'dkh 7/19/2012 15:03'!isMutable    mutable ifNil: [ ^ true ].    ^ mutable! !!MetacelloSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34163321!label	^self printString! !!MetacelloSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34163419!loader	loader == nil 		ifTrue: [ | prjctLoader |			(prjctLoader := self project loader) == nil				ifTrue: [ self loader: (self project loaderClass on: self) ]				ifFalse: [ self loader: prjctLoader ]].	^loader! !!MetacelloSpec methodsFor: 'accessing' stamp: 'dkh 7/19/2012 15:07' prior: 34163708!loader: aLoader    "We're interested in propogating the loader state, _except_ for the spec"    self shouldBeMutable.    loader := aLoader copy.    loader spec: self! !!MetacelloSpec methodsFor: 'importing' stamp: 'dkh 6/26/2012 16:34'!mergeImportLoads: aLoadList    self error: 'import: can only be used with baseline project specs'! !!MetacelloSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24' prior: 34163915!mergeMap	^Dictionary new.! !!MetacelloSpec methodsFor: 'spec creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34164021!mergeMember	^MetacelloMergeMemberSpec for: self project! !!MetacelloSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24' prior: 34164159!mergeSpec: aSpec    | newSpec nonOverridable |    self validateMergeForSpec: aSpec.    newSpec := self copy.    nonOverridable := self nonOverridable.    aSpec mergeMap        keysAndValuesDo: [ :key :value |             (nonOverridable includes: key)                ifFalse: [                     value ~~ nil                        ifTrue: [ newSpec instVarNamed: key asString put: value ] ] ].    ^ newSpec! !!MetacelloSpec methodsFor: 'mutability' stamp: 'dkh 7/19/2012 15:03'!mutable    mutable := true! !!MetacelloSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24' prior: 34164698!nonOverridable	^#()! !!MetacelloSpec methodsFor: 'copying' stamp: 'dkh 7/19/2012 21:12' prior: 34164790!postCopy    super postCopy.    mutable := nil.    loader ~~ nil        ifTrue: [ self loader: loader ].! !!MetacelloSpec methodsFor: 'doits' stamp: 'dkh 6/5/2012 19:01:24' prior: 34164934!postLoadDoIt	"noop unless non-nil value returned"	^nil! !!MetacelloSpec methodsFor: 'doits' stamp: 'dkh 6/5/2012 19:01:24' prior: 34165070!postLoadDoItBlock	^self doItBlock: self postLoadDoIt value! !!MetacelloSpec methodsFor: 'doits' stamp: 'dkh 6/5/2012 19:01:24' prior: 34165201!preLoadDoIt	"noop unless non-nil value returned"		^nil! !!MetacelloSpec methodsFor: 'doits' stamp: 'dkh 6/5/2012 19:01:24' prior: 34165337!preLoadDoItBlock	^self doItBlock: self preLoadDoIt value! !!MetacelloSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34165468!printOn: aStream	self configMethodOn: aStream indent: 0! !!MetacelloSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34165600!project	^project! !!MetacelloSpec methodsFor: 'spec creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34165696!removeMember	^MetacelloRemoveMemberSpec for: self project! !!MetacelloSpec methodsFor: 'mutability' stamp: 'dkh 7/19/2012 15:06'!shouldBeMutable    self isMutable        ifTrue: [ ^ self ].    self error: 'Not allowed to modify an immutable object'! !!MetacelloSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24'!validateMergeForSpec: aSpec    aSpec class = self class        ifFalse: [             self                error:                    'The project spec ' , self name printString , ' in project ' , self project label , ' has incompatible specs. '                        , aSpec class name asString , ' and ' , self class name asString , ' are not compatible.' ]! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34167458!author	author == nil 		ifTrue: [			^self project valueHolderSpec				value: '';				yourself].	^ author! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34167646!author: anObject	anObject setAuthorInMetacelloVersion: self! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!author: aBlockOrString constructor: aVersionConstructor    aVersionConstructor authorForVersion: aBlockOrString! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 9/10/2012 15:23'!baseline: aString constructor: aVersionConstructor    aVersionConstructor baselineForVersion: aString! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 9/10/2012 15:23'!baseline: aString with: aBlockOrString constructor: aVersionConstructor    aVersionConstructor baselineForVersion: aString with: aBlockOrString! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34167787!blessing	blessing == nil 		ifTrue: [			^self project valueHolderSpec				value: self project defaultBlessing;				yourself].	^ blessing! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34168006!blessing: anObject	anObject setBlessingInMetacelloVersion: self! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!blessing: aBlockOrString constructor: aVersionConstructor    aVersionConstructor blessingForVersion: aBlockOrString! !!MetacelloVersionSpec methodsFor: 'printing' stamp: 'dkh 9/10/2012 15:56'!configMethodBasicOn: aStream last: last indent: indent    | values lastIndex lastBlock |    last        ifTrue: [             "need to calculate last statement with a value"            values := {(self getBlessing).            (self getDescription).            (self getPreLoadDoIt).            (self getPostLoadDoIt).            (self getAuthor).            (self getTimestamp)}.            1 to: values size do: [ :index |                 (values at: index) ~~ nil                    ifTrue: [ lastIndex := index ] ].            lastBlock := [ :arg | arg = lastIndex ] ]        ifFalse: [ lastBlock := [ :arg | false ] ].    self        configMethodValueOn: aStream        for: self getBlessing        selector: 'blessing:'        last: (lastBlock value: 1)        indent: indent.    self        configMethodValueOn: aStream        for: self getDescription        selector: 'description:'        last: (lastBlock value: 2)        indent: indent.    self        configMethodValueOn: aStream        for: self getPreLoadDoIt        selector: 'preLoadDoIt:'        last: (lastBlock value: 3)        indent: indent.    self        configMethodValueOn: aStream        for: self getPostLoadDoIt        selector: 'postLoadDoIt:'        last: (lastBlock value: 4)        indent: indent.    self        configMethodValueOn: aStream        for: self getAuthor        selector: 'author:'        last: (lastBlock value: 5)        indent: indent.    self        configMethodValueOn: aStream        for: self getTimestamp        selector: 'timestamp:'        last: (lastBlock value: 6)        indent: indent! !!MetacelloVersionSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34168160!configMethodOn: aStream for: spec selector: selector last: last indent: indent	spec == nil		ifTrue: [ ^ self ].	aStream		tab: indent;		nextPutAll: 'spec ' , selector , ' [';		cr.	spec configMethodOn: aStream indent: indent + 1.	aStream nextPutAll: ' ].'.	last		ifFalse: [ aStream cr ]! !!MetacelloVersionSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34168543!configMethodOn: aStream indent: indent	self configMethodOn: aStream last: true indent: indent! !!MetacelloVersionSpec methodsFor: 'printing' stamp: 'dkh 9/10/2012 15:58' prior: 34168727!configMethodOn: aStream last: last indent: indent    | spec hasPackageSpecs |    hasPackageSpecs := false.    self packagesSpec list        do: [ :member |             member spec                projectDo: [ :proj |                     member spec name ~~ nil                        ifTrue: [ hasPackageSpecs := true ] ]                packageDo: [ :package |                     member spec name ~~ nil                        ifTrue: [ hasPackageSpecs := true ] ]                groupDo: [ :group |                     member spec name ~~ nil                        ifTrue: [ hasPackageSpecs := true ] ] ].    self configMethodBasicOn: aStream last: hasPackageSpecs not indent: indent.    self configPackagesSpecMethodOn: aStream indent: indent.    last        ifFalse: [ aStream cr ]! !!MetacelloVersionSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34170132!configMethodValueOn: aStream for: spec selector: selector last: last indent: indent	| valuePrintString |	spec == nil		ifTrue: [ ^ self ].	valuePrintString := spec value isSymbol		ifTrue: [ '#' , spec value asString printString ]		ifFalse: [ spec value printString ].	aStream		tab: indent;		nextPutAll: 'spec ' , selector , ' ' , valuePrintString , '.'.	last		ifFalse: [ aStream cr ]! !!MetacelloVersionSpec methodsFor: 'printing' stamp: 'dkh 9/10/2012 15:58'!configPackagesSpecMethodOn: aStream indent: indent	| projectSpecs packageSpecs groupSpecs |	projectSpecs := OrderedCollection new.	packageSpecs := OrderedCollection new.	groupSpecs := OrderedCollection new.	self packagesSpec list do: [:member |		member spec 			projectDo: [:proj | member spec name ~~ nil ifTrue: [ projectSpecs add: member ]]			packageDo: [:package | member spec name ~~ nil ifTrue: [ packageSpecs add: member ]]			groupDo: [:group | member spec name ~~ nil ifTrue: [ groupSpecs add: member ]]].	projectSpecs isEmpty not		ifTrue: [			aStream tab: indent; nextPutAll: 'spec '.			projectSpecs size > 1 ifTrue: [ aStream cr; tab: indent + 1 ].			1 to: projectSpecs size  do: [:index | 				(projectSpecs at: index) configMethodCascadeOn: aStream last: index == projectSpecs size indent: indent + 1.				index ~= projectSpecs size ifTrue: [ aStream tab: indent + 1 ]]].	packageSpecs isEmpty not		ifTrue: [			projectSpecs isEmpty not ifTrue: [ aStream cr ].			aStream tab: indent; nextPutAll: 'spec '.			packageSpecs size > 1 ifTrue: [ aStream cr; tab: indent + 1 ].			1 to: packageSpecs size  do: [:index | 				(packageSpecs at: index) configMethodCascadeOn: aStream last: index == packageSpecs size indent: indent + 1.				index ~= packageSpecs size ifTrue: [ aStream tab: indent + 1 ]]].	groupSpecs isEmpty not		ifTrue: [			projectSpecs isEmpty not | packageSpecs isEmpty not ifTrue: [ aStream cr ].			aStream tab: indent; nextPutAll: 'spec '.			groupSpecs size > 1 ifTrue: [ aStream cr; tab: indent + 1 ].			1 to: groupSpecs size  do: [:index | 				(groupSpecs at: index) configMethodCascadeOn: aStream last: index == groupSpecs size indent: indent + 1.				index ~= groupSpecs size ifTrue: [ aStream tab: indent + 1 ]]].! !!MetacelloVersionSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34170614!configSpawnMethodOn: aStream indent: indent	self configMethodValueOn: aStream for: self getBlessing selector: 'blessing:' last: false indent: indent.	self configMethodValueOn: aStream for: self getAuthor selector: 'author:' last: false indent: indent.	self configMethodValueOn: aStream for: self getTimestamp selector: 'timestamp:' last: false indent: indent.! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 9/10/2012 15:23'!configuration: aString with: aBlockOrString constructor: aVersionConstructor    aVersionConstructor configurationForVersion: aString with: aBlockOrString! !!MetacelloVersionSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34171057!createVersion	^self versionClass fromSpec: self! !!MetacelloVersionSpec methodsFor: 'loading' stamp: 'dkh 9/11/2012 12:13'!defaultPackageNames	"if there is a package named 'default' (a group) then it defines the default package names,	 otherwise answer a list of all of the package names in this version"	self packages packageNamed: 'default' ifAbsent: [ ^self packageNames ].	^#('default')! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34171362!description	description == nil 		ifTrue: [			^self project valueHolderSpec				value: '';				yourself].	^ description! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34171564!description: anObject	anObject setDescriptionInMetacelloVersion: self! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!description: aBlockOrString constructor: aVersionConstructor    aVersionConstructor descriptionForVersion: aBlockOrString! !!MetacelloVersionSpec methodsFor: 'querying' stamp: 'dkh 9/11/2012 11:57'!difference: otherVersionSpec    "Return a dictionary of additions, removals and modifications"    | report myProjectSpecs otherProjectSpecs |    report := MetacelloVersionDiffReport new.    myProjectSpecs := Dictionary new.    self        projectDo: [ :projectSpec | myProjectSpecs at: projectSpec name put: projectSpec ]        packageDo: [ :ignored |  ]        groupDo: [ :ignored |  ].    otherProjectSpecs := Dictionary new.    otherVersionSpec        projectDo: [ :projectSpec | otherProjectSpecs at: projectSpec name put: projectSpec ]        packageDo: [ :ignored |  ]        groupDo: [ :ignored |  ].    myProjectSpecs        valuesDo: [ :myProjectSpec |             | otherProjectSpec |            otherProjectSpec := otherProjectSpecs at: myProjectSpec name ifAbsent: [  ].            otherProjectSpec == nil                ifTrue: [                     report removals                        at: myProjectSpec name                        put:                            {(myProjectSpec versionString).                            ''} ]                ifFalse: [                     myProjectSpec versionString = otherProjectSpec versionString                        ifFalse: [                             report modifications                                at: myProjectSpec name                                put:                                    {(myProjectSpec versionString).                                    (otherProjectSpec versionString)} ] ] ].    otherProjectSpecs        valuesDo: [ :otherProjectSpec |             (myProjectSpecs at: otherProjectSpec name ifAbsent: [  ]) == nil                ifTrue: [                     report additions                        at: otherProjectSpec name                        put:                            {''.                            (otherProjectSpec versionString)} ] ].    ^ report! !!MetacelloVersionSpec methodsFor: 'loading' stamp: 'dkh 9/11/2012 12:09'!expandToLoadableSpecNames: nameList	| cacheKey names |	cacheKey := Array with: self label with: nameList.	^MetacelloPlatform current		stackCacheFor: #loadableSpecNames		at: cacheKey		doing: [ :cache | 			names := (self resolveToLoadableSpecs: nameList) collect: [:spec | spec name ].			cache at: cacheKey put: names ].! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34171715!getAuthor	^author! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34171813!getBlessing	^blessing! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34171915!getDescription	^description! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34172024!getPostLoadDoIt	^postLoadDoIt! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34172135!getPreLoadDoIt	^preLoadDoIt! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34172243!getTimestamp	^timestamp! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 9/10/2012 15:22'!group: aString overrides: aStringOrCollection constructor: aVersionConstructor    aVersionConstructor groupForVersion: aString overrides: aStringOrCollection! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 9/10/2012 15:22'!group: aString with: aStringOrCollection constructor: aVersionConstructor    aVersionConstructor groupForVersion: aString with: aStringOrCollection! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 9/11/2012 12:13'!import    ^ importName! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 9/11/2012 10:38'!import: anObject    importName := anObject! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 9/10/2012 15:24'!import: aString constructor: aVersionConstructor    aVersionConstructor importForVersion: aString! !!MetacelloVersionSpec methodsFor: 'testing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34172346!isPartiallyCurrent: notLoadedMatters useEquality: useEquality	self subclassResponsibility! !!MetacelloVersionSpec methodsFor: 'testing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34172516!isPossibleBaseline    self subclassResponsibility! !!MetacelloVersionSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34172651!label	^self versionString, ' [', self projectLabel, ']'! !!MetacelloVersionSpec methodsFor: 'merging' stamp: 'dkh 9/11/2012 14:20' prior: 34172787!mergeMap    | map |    map := super mergeMap.    map at: #'versionString' put: versionString.    map at: #'blessing' put: blessing.    map at: #'description' put: description.    map at: #'author' put: author.    map at: #'timestamp' put: timestamp.    map at: #'preLoadDoIt' put: preLoadDoIt.    map at: #'postLoadDoIt' put: postLoadDoIt.    map at: #'packageList' put: self packages.    ^ map! !!MetacelloVersionSpec methodsFor: 'merging' stamp: 'dkh 9/11/2012 14:18'!mergeSpec: anotherSpec    | newSpec map anotherPackages |    newSpec := super mergeSpec: anotherSpec.    map := anotherSpec mergeMap.    (anotherPackages := map at: #'packageList') isEmpty not        ifTrue: [             newSpec                packages:                    (self packages isEmpty                        ifTrue: [ anotherPackages ]                        ifFalse: [ self packages mergeSpec: anotherPackages ]) ].    ^ newSpec! !!MetacelloVersionSpec methodsFor: 'merging' stamp: 'dkh 9/11/2012 12:11'!nonOverridable    ^ super nonOverridable , #(#'packageList')! !!MetacelloVersionSpec methodsFor: 'querying' stamp: 'dkh 9/11/2012 10:36'!packageNamed: aString	^self packageNamed: aString ifAbsent: [ nil ]! !!MetacelloVersionSpec methodsFor: 'querying' stamp: 'dkh 9/11/2012 10:37'!packageNamed: aString forLoad: forLoad forMap: map ifAbsent: absentBlock    | importSpec |    ^ map        at: aString        ifAbsent: [             (forLoad and: [ self import notNil ])                ifTrue: [                     "expect the 'missing' name to be satisfied within context of imported project"                    importSpec := (map at: self import ifAbsent: absentBlock) copy                        name: aString;                        mergeImportLoads: {aString};                        yourself.                    importSpec projectReference name: aString.                    importSpec ]                ifFalse: [                     (aString = 'default' or: [ aString = 'ALL' ])                        ifTrue: [                             self project groupSpec                                name: aString;                                includes: self packageNames;                                yourself ]                        ifFalse: [ absentBlock value ] ] ]! !!MetacelloVersionSpec methodsFor: 'querying' stamp: 'dkh 9/11/2012 10:36'!packageNamed: aString forMap: map ifAbsent: absentBlock    "import: only allowed to be used with baseline project specs"    ^ self        packageNamed: aString        forLoad: true        forMap: map        ifAbsent: absentBlock! !!MetacelloVersionSpec methodsFor: 'querying' stamp: 'dkh 9/11/2012 10:36'!packageNamed: aString ifAbsent: aBlock	^self packageNamed: aString forMap: self packages map ifAbsent: aBlock! !!MetacelloVersionSpec methodsFor: 'querying' stamp: 'dkh 9/10/2012 15:40'!packageNames    packageList == nil        ifTrue: [ ^ #() ].    ^ self packages map keys asSet! !!MetacelloVersionSpec methodsFor: 'querying' stamp: 'dkh 9/11/2012 10:09'!packageSpecsInLoadOrder    ^ self packages packageSpecsInLoadOrder! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 9/10/2012 15:39'!packages    packageList == nil        ifTrue: [ packageList := self project packagesSpec ].    ^ packageList! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 9/10/2012 15:39'!packages: anObject    packageList := anObject! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 9/10/2012 15:54'!packagesSpec	^self packages! !!MetacelloVersionSpec methodsFor: 'copying' stamp: 'dkh 9/10/2012 15:40' prior: 34173179!postCopy    super postCopy.    blessing := blessing copy.    description := description copy.    author := author copy.    timestamp := timestamp copy.    packageList := packageList copy! !!MetacelloVersionSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34173403!postLoadDoIt	^postLoadDoIt! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34173521!postLoadDoIt: anObject	anObject setPostLoadDoItInMetacelloSpec: self! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!postLoadDoIt: aSymbol constructor: aVersionConstructor    aVersionConstructor postLoadDoItForVersion: aSymbol! !!MetacelloVersionSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34173671!preLoadDoIt	^preLoadDoIt! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34173787!preLoadDoIt: anObject	anObject setPreLoadDoItInMetacelloSpec: self! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!preLoadDoIt: aSymbol constructor: aVersionConstructor    aVersionConstructor preLoadDoItForVersion: aSymbol! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 9/10/2012 15:23'!project: aString constructor: aVersionConstructor    aVersionConstructor projectForVersion: aString! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 9/10/2012 15:23'!project: aString copyFrom: oldSpecName with: aBlock constructor: aVersionConstructor    aVersionConstructor projectForVersion: aString copyFrom: oldSpecName with: aBlock! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 9/10/2012 15:24'!project: aString overrides: aBlock constructor: aVersionConstructor    aVersionConstructor projectForVersion: aString overrides: aBlock! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 9/10/2012 15:24'!project: aString with: aBlockOrString constructor: aVersionConstructor    aVersionConstructor projectForVersion: aString with: aBlockOrString! !!MetacelloVersionSpec methodsFor: 'enumerating' stamp: 'dkh 9/11/2012 10:08'!projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	self packageSpecsInLoadOrder do: [:pkgSpec |		pkgSpec projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock ]! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34173943!projectLabel	^self project label! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 9/10/2012 15:24'!removeGroup: aString constructor: aVersionConstructor    aVersionConstructor removeGroupForVersion: aString! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 9/10/2012 15:24'!removeProject: aString constructor: aVersionConstructor    aVersionConstructor removeProjectForVersion: aString! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!repositories: aBlock constructor: aVersionConstructor    aVersionConstructor repositoriesForVersion: aBlock! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!repository: anObject constructor: aVersionConstructor    aVersionConstructor repositoryForVersion: anObject! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!repository: aString username: username password: password constructor: aVersionConstructor    aVersionConstructor repositoryForVersion: aString username: username password: password! !!MetacelloVersionSpec methodsFor: 'loading' stamp: 'dkh 9/11/2012 11:49'!resolveToLoadableSpec: aString forLoad: forLoad forMap: map packages: packageMap    | package |    package := self        packageNamed: aString        forLoad: forLoad        forMap: map        ifAbsent: [ ^ self error: 'Name not found: ' , aString ].    packageMap at: package name put: package.    ^ {package}! !!MetacelloVersionSpec methodsFor: 'loading' stamp: 'dkh 9/11/2012 11:49'!resolveToLoadableSpecs: nameList    "Resolves names in namelist to the  list of packages and projects in the version that would be loaded. Projects are 	not traversed during the transitive closure. The scope is that of the version itself.	   If the spec is a package, answer a list including the package and the transitive closure on 			its #requires: and #includes: fields.	   If the spec is a project, answer the project.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"    | map |    map := Dictionary new.    self resolveToLoadableSpecs: nameList forLoad: false map: map.    ^ map values! !!MetacelloVersionSpec methodsFor: 'loading' stamp: 'dkh 9/11/2012 11:49'!resolveToLoadableSpecs: required forLoad: forLoad map: packageMap    | reqd allReqd map newReqd spec |    reqd := required copy.    allReqd := Set new.    map := self packages map.    [ reqd isEmpty ]        whileFalse: [             newReqd := Set new.            reqd                do: [ :req |                     (self                        resolveToLoadableSpec: req                        forLoad: forLoad                        forMap: map                        packages: packageMap)                        do: [ :loadableSpec |                             newReqd addAll: loadableSpec requires.                            newReqd addAll: loadableSpec includes ] ].            allReqd addAll: reqd.            newReqd removeAllFoundIn: allReqd.            reqd := newReqd ].    packageMap keys        do: [ :pkgName |             (spec := (packageMap at: pkgName) resolveToLoadableSpec) == nil                ifTrue: [ packageMap removeKey: pkgName ]                ifFalse: [ packageMap at: pkgName put: (packageMap at: pkgName) resolveToLoadableSpec ] ]! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34174057!setAuthor: anObject	author := anObject! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34174175!setBlessing: anObject	blessing := anObject! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34174297!setDescription: anObject	description := anObject! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34174436!setPostLoadDoIt: aSymbol	postLoadDoIt := aSymbol! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34174576!setPreLoadDoIt: aSymbol	preLoadDoIt := aSymbol! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34174704!setTimestamp: anObject	timestamp := anObject! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34174829!timestamp	timestamp == nil 		ifTrue: [			^self project valueHolderSpec				value: '';				yourself].	^ timestamp! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34175026!timestamp: anObject	anObject setTimestampInMetacelloVersion: self! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 6/5/2012 19:01:24'!timestamp: aBlockOrStringOrDateAndTime constructor: aVersionConstructor    aVersionConstructor timestampForVersion: aBlockOrStringOrDateAndTime! !!MetacelloVersionSpec methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34175171!versionClass	^MetacelloVersion! !!MetacelloVersionSpec methodsFor: 'private' stamp: 'dkh 6/22/2012 12:35'!versionNumber    ^ self project versionNumberClass fromString: self versionString! !!MetacelloVersionSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34175282!versionString	versionString == nil ifTrue: [ ^'' ].	^ versionString! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34175430!versionString: anObject	versionString := anObject! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 9/10/2012 15:24'!versionString: anObject constructor: aVersionConstructor    aVersionConstructor versionStringForVersion: anObject! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!additions	additions ifNil: [ additions := Dictionary new ].	^ additions! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!additions: anObject	additions := anObject! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!configuration	^ configuration! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!configuration: anObject	configuration := anObject! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!from	^ from! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!from: anObject	from := anObject! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!modifications	modifications ifNil: [ modifications := Dictionary new ].	^ modifications! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!modifications: anObject	modifications := anObject! !!MetacelloVersionDiffReport methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22'!printOn: aStream	| printBlock |	printBlock := [ :pkgName :ar | 	aStream		tab: 2;		nextPutAll: pkgName asString;		cr.	aStream		tab: 3;		nextPutAll: (ar at: 1) asString printString;		nextPutAll: ' to ';		nextPutAll: (ar at: 2) asString printString;		cr ].	aStream		nextPutAll: self configuration asString;		space;		nextPutAll: from asString printString;		nextPutAll: ' to ';		nextPutAll: to asString printString;		cr.	aStream		tab;		nextPutAll: 'Additions:';		cr.	self additions keysAndValuesDo: printBlock.	aStream		tab;		nextPutAll: 'Modifications:';		cr.	self modifications keysAndValuesDo: printBlock.	aStream		tab;		nextPutAll: 'Removals:';		cr.	self removals keysAndValuesDo: printBlock! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!removals	removals ifNil: [ removals := Dictionary new ].	^ removals! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!removals: anObject	removals := anObject! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!to	^ to! !!MetacelloVersionDiffReport methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!to: anObject	to := anObject! !!Object methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34179882!metacelloIntegerLessThanSelf: anInteger	^self error: 'Invalid Metacello verson component - should be String or Integer.'! !!Object methodsFor: '*metacello-core' stamp: 'dkh 6/21/2012 20:08'!metacelloSemanticIntegerLessThanSelf: anInteger    ^ self error: 'Invalid Metacello verson component - should be String or Integer.'! !!Object methodsFor: '*metacello-core' stamp: 'dkh 6/21/2012 20:09'!metacelloSemanticStringLessThanSelf: anInteger    ^ self error: 'Invalid Metacello verson component - should be String or Integer.'! !!Object methodsFor: '*metacello-core' stamp: 'dkh 6/21/2012 20:08'!metacelloSemanticVersionComponentLessThan: aMetacelloVersonComponent    ^ self error: 'Invalid Metacello verson component - should be String or Integer.'! !!Object methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34180076!metacelloStringLessThanSelf: anInteger	^self error: 'Invalid Metacello verson component - should be String or Integer.'! !!Object methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34180269!metacelloVersionComponentLessThan: aMetacelloVersonComponent	^self error: 'Invalid Metacello verson component - should be String or Integer.'! !MetacelloVersionConstructor removeSelector: #versionImportPragmasVerifiedDefinedIn:!"Metacello-Core"!MetacelloGenericProjectSpec subclass: #MetacelloMCProjectSpec	instanceVariableNames: 'file'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!MetacelloMCProjectSpec subclass: #MetacelloMCBaselineOfProjectSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!MetacelloMCProjectSpec subclass: #MetacelloMCConfigurationOfProjectSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!MetacelloFetchingMCSpecLoader subclass: #MetacelloEnsureFetchingMCSpecLoader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Loaders'!MetacelloVersionValidator subclass: #MetacelloMCVersionValidator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Validation'!!MetacelloMCVersionValidator commentStamp: 'dkh 1/26/2012 09:49' prior: 34187518!Performs configuration validation.For programmatically decoding reason codes use:  MetacellMCVersionValidator fullDescriptionForReasonCode: <reasonCode>Warning reason codes:	#notDevelopmentVersion			- the symbolic version #development refers to a non-development literal version.	#loadWarning 						- Warning signalled during load [load validation].	#onlyBaselineVersion 				- one or more baseline versions have been defined, but no non-baseline versions are defined.	#stableDevelopmentVersion		- a version whose blessing is #development has been declared as a #stable versionCritical Warning reason codes:	#duplicateVersionDefinitions 		         - there are multiple pragma methods specifying the same version	#loadDeprecation					         - deprecation warning signalled while loading configuration [load validation]	#missingRecommendedProjectSpecField - missing recommended fields in project reference (versionString). The versionString should be specified so that #bleedingEdge loads will be predictable and repeatable	#noLoadableVersions 				         - no non #baseline versions defined in configuration	#noTests 							         - no test cases defined in loaded configuration [load validation]	#noVersionSpecified 				         - no version defined for the project reference or package. The version specified in the baseline or the latest version of the project or package in the repository will be used.	#packageNameMismatch 			         - the name in the packageSpec does not match the name of the mcz file	#projectClassNameFileMismatch 	         - the class name of the configuration does not match the mcz file containing the configuration	#testDeprecation 					         - deprecation warning signalled while running configuration tests [load validation]Error reason codes:	#cannotResolveVersion 			- the version (project reference or symbolic version) was not found in the specified configuration	#duplicateNames 					- multiple independent definitions for an entity with same name (project, package, or group)	#incompleteProjectSpec 			- missing required fields in project reference (className and/or repository)	#incorrectVersionString 			- the version declared in pragma doesn't match version in versionSpec	#invalidDoItSelector 				- doit select must be a Symbol	#invalidVersionString 				- versionString must be a String	#loadError 							- error occured while loading configuration [load validation]	#missingVersionImport 			- version specified in import pragma not defined in configuration	#noVersionsDefined 				- no usable baseline or version defined in configuration ... configuration cannot be loaded	#projectCreationError 				- error occured while resolving project reference	#shadowedNames 					- name duplication between packages and projects	#testFailures						- test failures while running tests [load validation]	#versionCompositionError 			- error while creating versionSpec from pragmas!MetacelloSpecLoader subclass: #MetacelloCommonMCSpecLoader	instanceVariableNames: 'operator loaderPolicy disablePackageCache'	classVariableNames: 'RetryPackageResolution'	poolDictionaries: ''	category: 'Metacello-MC-Loaders'!MetacelloVersionSpec subclass: #MetacelloMCVersionSpec	instanceVariableNames: 'repositories packages'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!MetacelloMCProject subclass: #MetacelloMCBaselineProject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Model'!!MetacelloMCBaselineProject commentStamp: 'dkh 5/5/2012 08:47' prior: 0!The **MetacelloMCBaselineProject**  is a wrapper for the **BaselineOf** version specification for file-based repositories.There is a single version in a **MetacelloMCBaselineProject**, named *'baseline'*.A typical **BaselineOf** is specification:```Smalltalkbaseline: spec    <baseline>    spec        package: 'External-Core';        package: 'External-Tests' with: [ spec requires: 'External-Core' ];        yourself.    spec        group: 'Core' with: #('External-Core');        group: 'default' with: #('Core');        group: 'Tests' with: #('External-Tests');        yourself```The `<baseline>` pragma marks the method containing the baseline specification.!!MetacelloMCBaselineOfProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!asBaselineProjectSpec    ^ self! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!asProjectRegistration    ^ MetacelloProjectRegistration fromMCBaselineProjectSpec: self! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!asProjectSpec    ^ self copyForScriptingInto: (MetacelloMCProjectSpec for: self project asConfigurationProject)! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!canDowngradeTo: aProjectSpec    "cannot upgrade between baselines"    ^ false! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!canUpgradeTo: aProjectSpec    "cannot upgrade between baselines"    ^ false! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22'!constructClassName    ^ 'BaselineOf' , self name! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'mutability' stamp: 'dkh 7/19/2012 20:42'!copyForRegistration: aMetacelloProjectRegistration onWrite: aBlock    | copy |    aMetacelloProjectRegistration        baselineProjectSpecIfPresent: [ :spec |             copy := spec copy.            aBlock value: copy.            aMetacelloProjectRegistration baselineProjectSpec: copy ]        ifAbsent: [             aMetacelloProjectRegistration                configurationProjectSpecIfPresent: [ :spec |                     copy := spec copy.                    aBlock value: copy.                    aMetacelloProjectRegistration configurationProjectSpec: copy ]                ifAbsent: [ aBlock value: nil ] ]! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22'!determineCurrentVersionForLoad    ^ self version! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'loading' stamp: 'dkh 07/16/2013 15:06'!ensureConfigurationLoaded: vrsn ensured: ensured  "answer true if the configuration should be reloaded"  "see Issue #181 for details ... basically we always want to consider loading the baseline from a project reference, especially if the two project specs are not the same..."  "https://github.com/dalehenrich/metacello-work/issues/181"  ^ true! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22'!hasClassName    ^ className ~~ nil and: [ className ~= self constructClassName ]! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'importing' stamp: 'dkh 6/26/2012 16:34'!mergeImportLoads: aLoadList    aLoadList        ifNotNil: [ :otherLoads | self loads ifNil: [ loads := otherLoads ] ifNotNil: [ loads := loads , otherLoads ] ]! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'merging' stamp: 'dkh 6/8/2012 14:04:22'!mergeSpec: anotherSpec    ^ super mergeSpec: anotherSpec asBaselineProjectSpec! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22'!projectLabel    ^ 'baseline'! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'scripting' stamp: 'dkh 7/23/2012 14:29'!validateVersionString: issues withDefaultVersionString: ignored    self versionString        ifNotNil: [ :vs |             | prj |            prj := self project asBaselineProject.            vs ~= prj singletonVersionName                ifTrue: [                     issues                        add:                            (MetacelloValidationError                                configurationClass: self projectClass                                reasonCode: #'invalidVersionString'                                callSite:                                    #'validateForScriptLoad:withDefaultVersionString:withDefaultRepositoryDecription:'                                explanation:                                    'version field is incorrect, should be: ' , prj singletonVersionName printString) ] ]! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22'!version    self projectClass == nil        ifTrue: [ ^ nil ].    ^ self projectClassProject version! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'construction' stamp: 'dkh 6/8/2012 14:04:22'!version: anObject constructor: aVersionConstructor    self error: 'version: not allowed in a baseline project spec'! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22'!versionString    ^ versionString ifNil: [ self version ifNotNil: [:v | v versionString] ]! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'construction' stamp: 'dkh 6/8/2012 14:04:22'!versionString: anObject constructor: aVersionConstructor    self error: 'versionString: not allowed in a baseline project spec'! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!asConfigurationProjectSpec    ^ self! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!asProjectRegistration    ^ MetacelloProjectRegistration fromMCConfigurationProjectSpec: self! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!asProjectSpec    ^ self copyForScriptingInto: (MetacelloMCProjectSpec for: self project asConfigurationProject)! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22'!constructClassName    ^ 'ConfigurationOf' , self name! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'mutability' stamp: 'dkh 7/19/2012 20:42'!copyForRegistration: aMetacelloProjectRegistration onWrite: aBlock    | copy |    aMetacelloProjectRegistration        configurationProjectSpecIfPresent: [ :spec |             copy := spec copy.            aBlock value: copy.            aMetacelloProjectRegistration configurationProjectSpec: copy ]        ifAbsent: [             aMetacelloProjectRegistration                baselineProjectSpecIfPresent: [ :spec |                     copy := spec copy.                    aBlock value: copy.                    aMetacelloProjectRegistration baselineProjectSpec: copy ]                ifAbsent: [ aBlock value: nil ] ]! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22'!hasClassName    ^ className ~~ nil and: [ className ~= self constructClassName ]! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'merging' stamp: 'dkh 6/8/2012 14:04:22'!mergeSpec: anotherSpec    ^ super mergeSpec: anotherSpec asConfigurationProjectSpec! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22'!projectLabel    ^ 'configuration'! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: 'dkh 6/14/2012 15:53'!allPackagesLoaded: aLoader    "answer true if all of the packages (excluding projects) are loaded"    | vrsn pkgs |    (vrsn := self versionOrNil) == nil        ifTrue: [ ^ false ].    pkgs := OrderedCollection new.    (self loadListForVersion: vrsn)        do: [ :nm |             vrsn packages                do: [ :pkg |                     (pkg isPackageLoaded: aLoader)                        ifFalse: [ ^ false ] ] ].    ^ true! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!asBaselineProjectSpec    ^ self copyForScriptingInto: (MetacelloMCBaselineOfProjectSpec for: self project asBaselineProject)! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!asConfigurationProjectSpec    ^ self copyForScriptingInto: (MetacelloMCConfigurationOfProjectSpec for: self project asConfigurationProject)! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!asProjectRegistration    (self className beginsWith: 'BaselineOf')        ifTrue: [ ^ MetacelloProjectRegistration fromMCBaselineProjectSpec: self ].    ^ MetacelloProjectRegistration fromMCConfigurationProjectSpec: self! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!asProjectSpec    ^ self! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!canDowngradeTo: aMetacelloProjectSpec    ^ (super canDowngradeTo: aMetacelloProjectSpec) and: [ self file = aMetacelloProjectSpec file ]! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!canUpgradeTo: aMetacelloProjectSpec    ^ (super canUpgradeTo: aMetacelloProjectSpec) and: [ self file = aMetacelloProjectSpec file ]! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34379173!className: aString    super className: aString.    self projectPackage: nil! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: 'dkh 6/13/2012 16:30' prior: 34379430!compareCurrentVersion: anOperator targetVersionStatus: targetVersionStatus using: anMCLoader    ^ (MetacelloLookupProjectSpecForLoad new        projectSpec: self;        yourself) signal        performCurrentVersionTestAgainst: self versionOrNil        operator: anOperator        targetVersionStatus: targetVersionStatus        using: anMCLoader! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/15/2012 13:40'!compareEqual: aMetacelloProjectSpec    "'projectPackage repositories'"    ^ (super compareEqual: aMetacelloProjectSpec) and: [ self file = aMetacelloProjectSpec file ]! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34379919!compareRelativeCurrentVersion: anOperator targetVersionStatus: targetVersionStatus using: anMCLoader	| cv vrsn |	(vrsn := self versionOrNil) == nil ifTrue: [ ^false ].	(cv := self relativeCurrentVersion) == nil ifTrue: [ ^false ].	(targetVersionStatus includes: cv versionStatus)		ifTrue: [ ^cv perform: anOperator with: vrsn ].	^false	! !!MetacelloMCProjectSpec methodsFor: 'mutability' stamp: 'dkh 7/19/2012 20:26'!copyForRegistration: aMetacelloProjectRegistration onWrite: aBlock    self subclassResponsibility! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!copyForScriptingInto: aProjectSpec    ^aProjectSpec        setName: name;        className: className;        versionString: versionString;        operator: operator;        setLoads: loads;        preLoadDoIt: preLoadDoIt;        postLoadDoIt: postLoadDoIt;        repositories: repositories copy;        file: file! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: 'dkh 7/7/2012 07:16' prior: 34380354!determineCurrentVersionForLoad    "don't use self currentVersion, because we are interested in the currentVersion of the project as loaded in image, not the current version relative to our load list"    | prjct version currentVersion packageAndProjectNames cvs |    self projectClass == nil        ifTrue: [ ^ nil ].    (version := self versionOrNil) == nil        ifTrue: [ ^ nil ].    version blessing == #'baseline'        ifTrue: [ ^ version ].    self loader ignoreImage        ifTrue: [ ^ version ].    prjct := self projectClass new project.    prjct loader: self loader.    (currentVersion := prjct currentVersion) == nil        ifTrue: [ ^ nil ].    (cvs := currentVersion versionStatus) == #'somethingLoaded'        ifTrue: [ ^ nil ].    (#(#'allLoadedToSpec' #'loadedToSpec' #'loadedMatchConstraints') includes: (cvs := currentVersion versionStatus))        ifTrue: [             (currentVersion perform: self operator with: version)                ifTrue: [                     "load currentVersion"                    ^ currentVersion ].	"load version"            ^ nil ].    version = currentVersion        ifTrue: [ ^ currentVersion ].	"I don't believe that it is possible to reach this point in the method, so I will be interested if I run across a case that produces this error"    (MetacelloProjectSpecLoadConflict projectSpec: self)        signal:            'Project load conflict for' , prjct label printString , ' between current version ' , currentVersion printString , '('                , cvs asString , ') and specified version ' , version printString                , '. Press resume to continue with load anyway'.    ^ nil! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: 'dkh 07/16/2013 15:05'!ensureConfigurationLoaded: vrsn ensured: ensured  "answer true if the configuration should be reloaded"  vrsn blessing == #'development'    ifTrue: [       ensured ~~ #'latest'        ifTrue: [ ^ MetacelloScriptEnsureProjectLoadedForDevelopment signal ] ].  ^ false! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22'!ensureLoadUsing: aLoader    (MetacelloLookupProjectSpec new        projectSpec: self;        yourself)  signal projectPackage ensureLoadUsing: aLoader! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: 'dkh 7/27/2012 00:06' prior: 34381752!ensureLoadedForDevelopmentUsing: mcLoader	"for #development projects, always need latest version of package when contemplating a load"	| ensured |	ensured := mcLoader ensuredMap at: self name ifAbsent: [ nil ].	self projectClass ~~ nil		ifTrue: [ 			| vrsn |			vrsn := self versionOrNil.			vrsn ~~ nil				ifTrue: [ 					(self ensureConfigurationLoaded: vrsn ensured: ensured)						ifTrue: [ 							mcLoader ensureForDevelopment								ifTrue: [ 									| pc |									(pc := self projectClass) ~~ nil										ifTrue: [ 											MetacelloClearStackCacheNotification												signal:													#(#currentVersion #currentVersionAgainst: #currentVersionInfo #versionConstructor #loadableSpecNames) , {pc} ].									self ensureLoadUsing: mcLoader ]								ifFalse: [ self projectPackage fetchUsing: mcLoader ].							mcLoader ensuredMap at: self name put: #latest ].					^ self ] ].	ensured == nil		ifTrue: [ 			"projectClass == nil or version == nil"			mcLoader ensureForDevelopment				ifTrue: [ 					| pc |					(pc := self projectClass) ~~ nil						ifTrue: [ 							MetacelloClearStackCacheNotification								signal:									#(#currentVersion #currentVersionAgainst: #currentVersionInfo #versionConstructor #loadableSpecNames) , {pc} ].					self ensureLoadUsing: mcLoader ]				ifFalse: [ self fetchUsing: mcLoader ].			mcLoader ensuredMap at: self name put: #present ]! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: 'dkh 03/13/2013 15:18' prior: 34382982!ensureProjectLoaded  "Ensure that the MetacelloProject is loaded in image. 	 projectClass == nil or requested version non-existent warrants a project package load."  "answer true if the projectClass exists"  (self projectClass == nil    or: [       self versionOrNil == nil        or: [ (loader notNil or: [ self isMutable ]) and: [ self loader ignoreImage ] ] ])    ifTrue: [       | pc |      (pc := self projectClass) ~~ nil        ifTrue: [           MetacelloClearStackCacheNotification            signal:              #(#'currentVersion' #'currentVersionAgainst:' #'currentVersionInfo' #'versionConstructor' #'loadableSpecNames')                , {pc} ].      self projectPackage ifNil: [ ^ true ].      self ensureLoadUsing: self loader ].  ^ self projectClass ~~ nil! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22'!fetchUsing: aLoader    (MetacelloLookupProjectSpec new        projectSpec: self;        yourself) signal projectPackage fetchUsing: aLoader! !!MetacelloMCProjectSpec methodsFor: 'querying' stamp: 'dkh 9/10/2012 16:05' prior: 34383481!file    file ifNil: [ ^ self className ].    ^ file! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: 'dkh 7/19/2012 16:03' prior: 34383596!file: aString    self shouldBeMutable.    file := aString.    self projectPackage: nil! !!MetacelloMCProjectSpec methodsFor: 'construction' stamp: 'dkh 6/8/2012 14:04:22'!file: aString constructor: aVersionConstructor    aVersionConstructor fileForProject: aString! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!getFile    "raw access to iv"    ^ file! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: 'dkh 04/02/2013 20:23'!hasNoLoadConflicts: aMetacelloProjectSpec  "'projectPackage repositories'"  ^ (super hasNoLoadConflicts: aMetacelloProjectSpec)    and: [ self file = aMetacelloProjectSpec file ]! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34384515!isPartiallyLoaded: aLoader	| vrsn |	(vrsn := self versionOrNil) == nil ifTrue: [ ^false ].	(self loadListForVersion: vrsn) do: [:nm |		(vrsn packagesForSpecNamed: nm ) do: [:pkg |			(pkg isPackageLoaded: aLoader) ifTrue: [ ^true ]]].	^false! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34384851!isPossibleBaseline	| vrsn |	(vrsn := self versionOrNil) == nil ifTrue: [ ^false ].	(vrsn allPackagesForSpecNamed: (self loadListForVersion: vrsn)) do: [:pkg |		pkg workingCopy == nil ifTrue: [ ^false ]].	^true! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34385752!loadPackageList	| vrsn pkgs |	(vrsn := self versionOrNil) == nil ifTrue: [ ^#() ].	pkgs := OrderedCollection new.	(self loadListForVersion: vrsn) do: [:nm |		pkgs addAll: ((vrsn packagesForSpecNamed: nm ) collect: [:each | each name ])].	^pkgs! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34386091!loadVersion: aVersionOrNil    "Load the correct version of the project"    | vrsn mcLoader list |    self ensureProjectLoaded.    vrsn := aVersionOrNil.    vrsn == nil        ifTrue: [             [ vrsn := self version ]                on: MetacelloVersionDoesNotExistError                do: [ :ex |                     ^ (MetacelloProjectSpecLoadError projectSpec: self)                        versionDoesNotExistException: ex;                        signal:                                'No version found for ' , self versionString printString , ' of ' , self className asString , ' because: '                                        , ex description ] ].    mcLoader := self loader copy.    mcLoader operator: self operator.    vrsn loader: mcLoader.    list := (mcLoader ignoreImage        ifTrue: [ self loadListForVersion: vrsn ]        ifFalse: [ vrsn packageAndProjectNamesToLoad: (self loadListForVersion: vrsn) loader: mcLoader ]) asSet.    MetacelloPlatform current        useStackCacheDuring: [ :dict |             | projectCache cachedList |            projectCache := dict at: self projectClass ifAbsent: [ dict at: self projectClass put: Dictionary new ].            (cachedList := projectCache at: vrsn ifAbsent: [  ]) == nil                ifTrue: [ projectCache at: vrsn put: list ]                ifFalse: [                     (cachedList size = list size and: [ cachedList includesAllOf: list ])                        ifTrue: [                             "no need to refetch list ... recursion stoppper (Issue 95)"                            ^ self ]                        ifFalse: [ projectCache at: vrsn put: list ] ].            vrsn versionString ~= self versionString                ifTrue: [ Transcript show: ' [' , vrsn versionString , ']' ].            mcLoader preLoad: self.            vrsn fetchRequiredFromArray: list.	"do the load"            (MetacelloProjectSpecLoadedNotification new projectSpec: (self copy versionString: vrsn versionString))                signal.            mcLoader postLoad: self ]        defaultDictionary: Dictionary new! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34387547!loadedPackageNames: aLoader	| vrsn pkgs |	(vrsn := self versionOrNil) == nil ifTrue: [ ^#() ].	pkgs := OrderedCollection new.	(self loadListForVersion: vrsn) do: [:nm |		(vrsn packagesForSpecNamed: nm ) do: [:pkg |			(pkg isPackageLoaded: aLoader) ifTrue: [ pkgs add: pkg name ]]].	^pkgs! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!metacelloRegistrationHash    "file"    ^ String stringHash: self file initialHash: super metacelloRegistrationHash! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34388712!packageFileSpecFor: aMetacelloPackagesSpec	^(aMetacelloPackagesSpec project projectReferenceSpec)			name: self name;			projectReference: self copy;			yourself.! !!MetacelloMCProjectSpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34389232!projectClass    self className == nil        ifTrue: [ ^ nil ].    ^ Smalltalk at: self className asSymbol ifAbsent: [  ]! !!MetacelloMCProjectSpec methodsFor: 'querying' stamp: 'dkh 7/2/2012 16:40' prior: 34389421!projectClassProject    "indirection needed when projectClass is _not_ a subclass of MetacelloProject"    ^ self projectClass new project        setBaselineRepositoryDescription: self repositoryDescriptions;        yourself! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34389810!projectPackage    projectPackage        ifNil: [             self className ifNil: [ ^ nil ].            projectPackage := self project packageSpec.            projectPackage name: self className.            self getFile ifNotNil: [ projectPackage file: self file ].            projectPackage repositories: self getRepositories ].    ^ projectPackage! !!MetacelloMCProjectSpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34390055!relativeCurrentVersion    "currentVersion calculated relative to the loadList"    | vrsn expanded loadList |    (vrsn := self versionOrNil) == nil        ifTrue: [ ^ nil ].    expanded := [ vrsn expandToLoadableSpecNames: (loadList := self loadListForVersion: vrsn) ]        on: Error        do: [ :ex |             vrsn blessing == #'development'                ifTrue: [                     self ensureLoadUsing: self loader.                    vrsn := self versionOrNil.                    ex return: (vrsn expandToLoadableSpecNames: loadList) ].            ex pass ].    ^ self projectClassProject currentVersionAgainst: expanded! !!MetacelloMCProjectSpec methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34391190!resolveToAllPackagesIn: aVersionSpec visited: visited    | vrsn |    visited        pushProject: [             visited                visit: self                doing: [ :spec |                     spec ensureProjectLoaded.                    vrsn := spec version.                    ^ vrsn                        allPackagesForSpecNamed: (self loadListForVersion: vrsn)                        ifAbsent: [ self error: 'invalid loads: spec' ] ] ].    ^ #()! !!MetacelloMCProjectSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34391864!updateForSpawnMethod: sourceSpec	"This means that this spec was used in a baseline and will be used in a version .... drop all information that isn't useful"		repositories := className := operator := loads := projectPackage := nil.	sourceSpec ~~ nil ifTrue: [ versionString := sourceSpec versionString ].! !!MetacelloMCProjectSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34392257!updatePackageSpec: updatedSpecs    "Add project copy to updatedSpecs if the current version of the project 	 is different from the receiver's version"    | prj currentVersion spec |    className == nil        ifTrue: [ ^ self ].    prj := self projectClassProject.    (currentVersion := prj currentVersion) = self versionOrNil        ifTrue: [ ^ self ].    currentVersion == nil        ifTrue: [ ^ self ].    spec := self copy.    spec versionString: currentVersion versionString.    updatedSpecs at: spec name put: spec! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: 'dkh 7/23/2012 11:17'!validateForScriptLoad: aScriptEngine withDefaultVersionString: defaultVersionString withDefaultRepositoryDecription: defaultRepositoryDecription    | issues callSite |    issues := OrderedCollection new.    callSite := #'validateForScriptLoad:withDefaultVersionString:withDefaultRepositoryDecription:'.    self name        ifNil: [             issues                add:                    (MetacelloValidationError                        configurationClass: self projectClass                        reasonCode: #'incompleteProjectSpec'                        callSite: callSite                        explanation: 'name field required') ].    self className        ifNil: [             issues                add:                    (MetacelloValidationError                        configurationClass: self projectClass                        reasonCode: #'incompleteProjectSpec'                        callSite: callSite                        explanation: 'className field required') ].    self repositories isEmpty        ifTrue: [             defaultRepositoryDecription                ifNotNil: [ self repository: defaultRepositoryDecription ]                ifNil: [                     issues                        add:                            (MetacelloValidationError                                configurationClass: self projectClass                                reasonCode: #'incompleteProjectSpec'                                callSite: callSite                                explanation: 'repository field required') ] ].    self validateVersionString: issues withDefaultVersionString: defaultVersionString.    ^ issues! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: 'dkh 7/23/2012 11:56'!validateVersionString: issues withDefaultVersionString: defaultVersionString    self versionString        ifNil: [             defaultVersionString                ifNotNil: [ self versionString: defaultVersionString ]                ifNil: [                     issues                        add:                            (MetacelloValidationError                                configurationClass: self projectClass                                reasonCode: #'incompleteProjectSpec'                                callSite:                                    #'validateForScriptLoad:withDefaultVersionString:withDefaultRepositoryDecription:'                                explanation: 'version field required') ] ]! !!MetacelloMCProjectSpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34392836!version	"Empty version string means use latestVersion or #bleedingEdge"	self projectClass == nil		ifTrue: [ ^ nil ].	^ self versionString == nil		ifTrue: [ 			| vrsn |			"Eventually it will become an error to not specify a project reference version as default: #stable is the preferred default"			"self deprecated: 'Must specify a project reference version.'."			self flag: 'deprecate after version 1.0'.			(vrsn := self projectClassProject latestVersion) == nil				ifTrue: [ self projectClassProject version: #bleedingEdge ]				ifFalse: [ vrsn ] ]		ifFalse: [ self projectClassProject version: self versionString ]! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: 'dkh 7/27/2012 04:59'!versionForScriptEngine: aMetacelloScriptEngine    | prj |    prj := self projectClass ifNil: [ self project ] ifNotNil: [ self projectClassProject ].    ^ ((prj projectForScriptEngine: aMetacelloScriptEngine) version: self versionString)        silently: aMetacelloScriptEngine silently;        ignoreImage: aMetacelloScriptEngine ignoreImage;        cacheRepository: aMetacelloScriptEngine cacheRepository;        repositoryOverrides: aMetacelloScriptEngine repositoryOverrides! !!MetacelloEnsureFetchingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!ensureSpecLoader	^ self! !!MetacelloEnsureFetchingMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22'!scheduleFetchFor: packageSpec cachedReference: reference	"reference already in the cache during fetch ...schedule a load directive for reference, so ensured load will come from cache"	^ self		scheduleFetchFor: packageSpec		reference: reference		message:			'Fetched -> (cached) ' , reference name , ' --- ' , reference repository description , ' --- '				, reference repository description! !!MetacelloEnsureFetchingMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22'!scheduleFetchFor: packageSpec nearestReference: reference	"latest version in repository already matches the cached reference...schedule a load directive for reference, so ensured load will come from cache"	^ self		scheduleFetchFor: packageSpec		reference: reference		message:			'Fetched -> (nearest) ' , reference name , ' --- ' , reference repository description , ' --- '				, reference repository description! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34322705!actionLabel	^'Fetching '! !!MetacelloFetchingMCSpecLoader methodsFor: 'versionInfo' stamp: 'dkh 6/8/2012 14:04:22' prior: 34322822!ancestorsFor: packageSpec	^self loadData		ancestorsFor: packageSpec 		ifAbsent: [ super ancestorsFor: packageSpec ]! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34323036!atomicLoadPackageSpecs: packageSpecs repositories: repositories	self loaderPolicy 		pushAtomicLoadDirectivesDuring: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ]		for: self! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34323339!cacheRepository	^self loaderPolicy cacheRepository! !!MetacelloFetchingMCSpecLoader methodsFor: 'versionInfo' stamp: 'dkh 6/8/2012 14:04:22' prior: 34323491!currentVersionInfoFor: packageSpec	^self loadData		currentVersionInfoFor: packageSpec 		ifAbsent: [ super currentVersionInfoFor: packageSpec ]! !!MetacelloFetchingMCSpecLoader methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34323733!doLoad	self loaderPolicy copy load! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!ensureSpecLoader	^ (MetacelloEnsureFetchingMCSpecLoader on: self spec)		shouldDisablePackageCache: self shouldDisablePackageCache;		loaderPolicy: self loaderPolicy; "explicitly share the loaderPolicy"		yourself! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34323867!ensuredMap	^self loaderPolicy ensuredMap! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34324005!explicitLoadPackageSpecs: packageSpecs repositories: repositories		| directive |	directive := self loaderPolicy 		pushExplicitLoadDirectivesDuring: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ]		for: self.	directive explicitLoadWithPolicy: self loaderPolicy.! !!MetacelloFetchingMCSpecLoader methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34324383!linearLoadPackageSpec: packageSpec gofer: gofer	MetacelloPlatform current		do: [ 			| references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |			"check to see if mcz file is already in cacheRepository"			cachedReference := self resolvePackageSpec: packageSpec cachedGofer: self loaderPolicy cacheGofer.			(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])				ifTrue: [ 					cachedReference name = packageSpec file						ifTrue: [ 							"exact match between packageSpec file and cache"							^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ].	"look up mcz file"			references := self retryingResolvePackageSpecReferences: packageSpec gofer: gofer.			nearestReference := references last asMetacelloCachingResolvedReference.	"If the mcz is already in the cacheRepository, no need to copy"			(cachedReference ~~ nil and: [ cachedReference name = nearestReference name ])				ifTrue: [ 					"latest reference in repository matches cachedReference ... "					^ self scheduleFetchFor: packageSpec nearestReference: nearestReference ].	"If the mcz is already loaded into the image, no need to copy"			(self ignoreImage not and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])				ifTrue: [ 					loadedVersionInfos						do: [ :info | 							info name = nearestReference name								ifTrue: [ ^ self ] ] ].			externalReference := (references select: [ :ref | ref name = nearestReference name ]) first				asMetacelloCachingResolvedReference.			self repositoryMap at: externalReference name put: externalReference repository.			(self				resolveDependencies: externalReference				nearest: nearestReference				into: (OrderedCollection with: nearestReference))				do: [ :reference | 					| pSpec l |					mcVersion := reference version.					(l := (GoferVersionReference name: reference name) resolveAllWith: self loaderPolicy cacheGofer) isEmpty						ifTrue: [ 							self cacheRepository storeVersion: mcVersion.							reference == nearestReference								ifTrue: [ pSpec := packageSpec ]								ifFalse: [ 									pSpec := packageSpec project packageSpec.									pSpec name: mcVersion package name ].							self loadData								addVersion: mcVersion								versionInfo: mcVersion info								resolvedReference: reference								packageSpec: pSpec ] ].			self scheduleFetchFor: packageSpec externalReference: externalReference ]		displaying: 'Fetching ' , packageSpec file! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34327044!linearLoadPackageSpecs: packageSpecs repositories: repositories		self loaderPolicy 		pushLinearLoadDirectivesDuring: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ]		 for: self! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34327348!loadData	^self loaderPolicy loadData! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34327484!loadDirective	^self loaderPolicy loadDirective! !!MetacelloFetchingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34327630!loadingSpecLoader	^(MetacelloLoadingMCSpecLoader on: self spec)		shouldDisablePackageCache: self shouldDisablePackageCache;		loaderPolicy: self loaderPolicy copy;		yourself! !!MetacelloFetchingMCSpecLoader methodsFor: 'doits' stamp: 'dkh 6/8/2012 14:04:22' prior: 34327901!postLoad: packageOrVersionSpec	(MetacelloDirective postLoadSpec: packageOrVersionSpec loader: self)  addTo: self loadDirective! !!MetacelloFetchingMCSpecLoader methodsFor: 'doits' stamp: 'dkh 6/8/2012 14:04:22' prior: 34328125!preLoad: packageOrVersionSpec	(MetacelloDirective preLoadSpec: packageOrVersionSpec loader: self) addTo: self loadDirective! !!MetacelloFetchingMCSpecLoader methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34328348!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self loadDirective printOn: aStream.	aStream nextPut: $)! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34328557!resolveDependencies: aResolvedReference nearest: nearestReference into: aCollection	| block retryCount coll notDone |	self flag: 'Not used, but retained to avoid upgrade issues'.	block := [ :dependency | | reference |		reference := MetacelloCachingGoferResolvedReference			name: dependency versionInfo name			repository: aResolvedReference repository.		coll add: reference.		Transcript cr; show: 'Fetched dependency -> ', reference name, ' --- ', reference repository description.		self resolveDependencies: reference nearest: reference into: coll].	retryCount := 0.	notDone := true.	coll := OrderedCollection new.	[ notDone and: [ retryCount < 3 ]]		whileTrue: [			retryCount > 0 ifTrue: [ Transcript cr; show: '...RETRY' ].			[ 					"ensure that all resolved references have cached their version while wrapped by error handler"				aCollection do: [:each | each version ]. 				nearestReference version dependencies do: block.				notDone := false ]					on: Error 					do: [:ex | 						retryCount := retryCount + 1.						retryCount >= 3 ifTrue: [ ex pass ].						coll := OrderedCollection new ]].	aCollection addAll: coll.	^aCollection! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34329814!resolvePackageSpec: packageSpec cachedGofer: gofer	|  versionReference references |	versionReference := packageSpec goferLoaderReference.	(references := versionReference resolveAllWith: gofer) isEmpty 		ifTrue: [ ^nil ].	^references last asMetacelloCachingResolvedReference.! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22'!scheduleFetchFor: packageSpec cachedReference: reference	"reference already in the cache during fetch ...no need to schedule fetch"	^ self! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22'!scheduleFetchFor: packageSpec externalReference: reference	^ self		scheduleFetchFor: packageSpec		reference: reference		message:			'Fetched -> ' , reference name , ' --- ' , reference repository description , ' --- ' , reference repository description! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22'!scheduleFetchFor: packageSpec nearestReference: reference	"latest version in repository already matches the cached reference...no need to schedule fetch"	^ self! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22'!scheduleFetchFor: packageSpec reference: reference message: message	self loaderPolicy resetCacheGofer.	self preLoad: packageSpec.	(MetacelloDirective loadPackage: packageSpec externalReference: reference loader: self) addTo: self loadDirective.	self postLoad: packageSpec.	Transcript		cr;		show: message! !!GoferResolvedReference methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34304212!asMetacelloCachingResolvedReference	^MetacelloCachingGoferResolvedReference name: self name repository: self repository! !!GoferResolvedReference methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34304420!compare: aLoadableReference using: aComparisonOperator	"Compare versions using <aComparisonOperator>. package names #= then compare based upon version number	Branches and Author names are used in the case of a version number tie, because we need to avoid seesaw loading."			self packageName = aLoadableReference packageName		ifFalse: [ ^false ].	self versionNumber = aLoadableReference versionNumber		ifFalse: [ ^ self versionNumber perform: aComparisonOperator with: aLoadableReference versionNumber ].	self branch = aLoadableReference branch 		ifFalse: [ ^ self branch perform: aComparisonOperator with: aLoadableReference branch ].	^ self author perform: aComparisonOperator with: aLoadableReference author! !!MCRepository methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34277790!asRepositorySpecFor: aMetacelloMCProject	self subclassResponsibility! !!MCRepository methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22'!metacelloProjectClassFor: aScriptEngine    ^ MetacelloMCProject! !!MCRepository methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22'!projectVersion: aString    "noop"! !!MCWorkingCopy methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34308310!metacelloPackageNameWithBranch	"answer array with package name and package name with branch name"	ancestry ancestors isEmpty		ifTrue: [ 			^ {(package name).			(package name)} ].	^ (GoferVersionReference name: self ancestors first name) metacelloPackageNameWithBranch! !!MetacelloLoadingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34336054!actionLabel	^'Loading '! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34336176!copySpec: pkgSpec from: repositorySpecs to: repository	| gofer |	gofer := MetacelloGofer new.	(self repositoriesFrom: repositorySpecs) do: [:repo | gofer repository: repo ].	^self copySpec: pkgSpec with: gofer to: repository! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34336513!copySpec: pkgSpec with: gofer to: aRepository	| repository resolvedReference |	[resolvedReference := pkgSpec goferLoaderReference resolveWith: gofer]		on: Error		do: [:ignored | ^nil ].	repository := MCRepositoryGroup default repositories		detect: [ :each | each = aRepository ]		ifNone: [ aRepository ].	repository storeVersion: resolvedReference version.	^resolvedReference repository! !!MetacelloLoadingMCSpecLoader methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34337004!doLoad	"NOOP"! !!MetacelloLoadingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34337115!fetchingSpecLoader	^(MetacelloFetchingMCSpecLoader on: self spec)		shouldDisablePackageCache: self shouldDisablePackageCache;		loaderPolicy: self loaderPolicy copy;		yourself! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34337392!goferCommitBranchPackage: branchName using: repositorySpecs commitMessage: commitMessage	| gofer repoSpecs wc |	repoSpecs := self spec repositorySpecs notEmpty		ifTrue: [ self spec repositorySpecs ]		ifFalse: [ repositorySpecs ].	gofer := MetacelloGofer new.	gofer disablePackageCache.	wc := self spec workingCopy.	repositorySpecs		do: [ :repoSpec | 			| repo |			repo := repoSpec createRepository.			(wc possiblyNewerVersionsIn: repo) notEmpty				ifTrue: [ 					self						notify:							'There are possibly newer versions of the package ' , self spec name printString , ' in the repository '								, repo description printString								, '. Cancel and manually merge if you want to pick up the changes from the later version.' ].			gofer repository: repo ].	gofer package: self spec name.	[ gofer interactiveCommit ]		on: MCVersionNameAndMessageRequest		do: [ :ex | 			| ref |			ref := GoferVersionReference name: ex suggestedName.			ex				resume:					{(ref packageName , '.' , branchName , '-' , ref author , '.' , ref versionNumber printString).					commitMessage} ].	^ true! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34338596!goferCommitPackageUsing: repositorySpecs commitMessage: commitMessage	| gofer repoSpecs wc |	repoSpecs := self spec repositorySpecs notEmpty				ifTrue: [ self spec repositorySpecs ]				ifFalse: [ repositorySpecs ].	gofer := MetacelloGofer new.	gofer disablePackageCache.	wc := self spec workingCopy.	repositorySpecs do: [:repoSpec | | repo |		repo := repoSpec createRepository.		(wc possiblyNewerVersionsIn: repo) notEmpty			ifTrue: [ self notify: 'There are possibly newer versions of the package ', self spec name printString, ' in the repository ', repo description printString, '. Cancel and manually merge if you want to pick up the changes from the later version.' ].		gofer repository: repo ].	gofer package: self spec name.	gofer commit: commitMessage.	^true! !!MetacelloLoadingMCSpecLoader methodsFor: 'packages' stamp: 'dkh 6/8/2012 14:04:22' prior: 34339464!latestPackage: aString fromRepository: repositorySpecs	| gofer |	gofer := MetacelloGofer new.	gofer disablePackageCache.	(self repositoriesFrom: repositorySpecs) do: [:repo | gofer repository: repo ].	^([(GoferPackageReference name: aString) resolveWith: gofer]		on: Error		do: [:ignored | ^ nil ]) name! !!MetacelloLoadingMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34339861!linearLoadPackageSpec: packageSpec gofer: gofer	MetacelloPlatform current		do:  [ | loadBlock goferLoad answers resolvedReference repo |			resolvedReference := self resolvePackageSpec: packageSpec gofer: gofer.			resolvedReference isNil ifTrue: [ "Package version already loaded into image" ^self ].			loadBlock := [				self preLoad: packageSpec.				goferLoad := MetacelloGoferLoad on: MetacelloGofer new.				goferLoad addResolved: resolvedReference.				goferLoad execute.				MetacelloPlatform current clearCurrentVersionCache.				self postLoad: packageSpec ].			(answers := packageSpec answers) notEmpty				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]				ifFalse: [ loadBlock value].			repo := resolvedReference repository.			self hasRepositoryOverrides				ifTrue: [					repo := self loaderPolicy repositoryMap 								at: resolvedReference name 								ifAbsent: [ resolvedReference repository ].					resolvedReference workingCopy repositoryGroup addRepository:  repo ]				ifFalse: [ resolvedReference workingCopy repositoryGroup addRepository: resolvedReference repository ].			Transcript cr; show: 'Loaded -> ', resolvedReference name, ' --- ', repo description, ' --- ', resolvedReference repository description  ]		displaying: 'Loading ', packageSpec file! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34341270!packagesNeedSavingUsing: repositorySpecs into: aCollection	| wc repoSpecs repo |	(wc := self spec workingCopy) == nil ifTrue: [ ^self ].	(wc ancestry ancestors notEmpty and: [ wc modified not])		ifTrue: [ ^self ].	repoSpecs := self spec repositorySpecs notEmpty				ifTrue: [ self spec repositorySpecs ]				ifFalse: [ repositorySpecs ].	repo := (self spec getFile == nil or: [ wc ancestry ancestors isEmpty ])		ifTrue: [ (self repositoriesFrom: repoSpecs ignoreOverrides: true) first ]		ifFalse: [			([ self resolveSpec: self spec from: repoSpecs ] 				on: Error 				do: [:ignored | ^self ]) repository ].	aCollection add: self spec -> repo! !!MetacelloLoadingMCSpecLoader methodsFor: 'doits' stamp: 'dkh 6/8/2012 14:04:22' prior: 34342017!postLoad: packageOrVersionSpec	| block |	(block := packageOrVersionSpec postLoadDoItBlock) ~~ nil		ifTrue: [ block valueWithPossibleArgs: { self. packageOrVersionSpec. } ]! !!MetacelloLoadingMCSpecLoader methodsFor: 'doits' stamp: 'dkh 6/8/2012 14:04:22' prior: 34342285!preLoad: packageOrVersionSpec	| block |	(block := packageOrVersionSpec preLoadDoItBlock) ~~ nil		ifTrue: [ block valueWithPossibleArgs: { self. packageOrVersionSpec. } ]! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34342565!repositoryFor: pkgSpec from: repositorySpecs	^([self resolveSpec: pkgSpec from: repositorySpecs]		on: Error		do: [:ignored | ^nil ]) repository! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34342819!repositoryFor: pkgSpec with: gofer	^([self resolveSpec: pkgSpec with: gofer]		on: Error		do: [:ignored | ^nil ]) repository! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34343043!resolveSpec: pkgSpec from: repositorySpecs	| gofer |	gofer := MetacelloGofer new.	gofer disablePackageCache.	(self repositoriesFrom: repositorySpecs ignoreOverrides: true) 		do: [:repo | gofer repository: repo ].	^self resolveSpec: pkgSpec with: gofer! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34343408!resolveSpec: pkgSpec with: gofer	^pkgSpec goferLoaderReference resolveWith: gofer! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34343597!savePackageUsing: repositorySpecs	| wc repo repoSpecs newVersion |	(wc := self spec workingCopy) == nil ifTrue: [ ^false ].	(wc ancestry ancestors notEmpty and: [ wc modified not])		ifTrue: [ ^false ].	repoSpecs := self spec repositorySpecs notEmpty				ifTrue: [ self spec repositorySpecs ]				ifFalse: [ repositorySpecs ].	(self spec getFile == nil or: [ wc ancestry ancestors isEmpty ])		ifTrue: [ repo := (self repositoriesFrom: repoSpecs ignoreOverrides: true) first ]		ifFalse: [			[ 	| newer |				repo := (self resolveSpec: self spec from: repoSpecs) repository.				newer := wc possiblyNewerVersionsIn: repo.				newer isEmpty not 					ifTrue: [						(MetacelloPlatform current confirm: 'CAUTION!! These versions in the repository may be newer:', 							String cr, newer printString, String cr,							'Do you really want to save this version?') ifFalse: [ ^false ]] ] 				on: Error 				do: [:ignored | ^false ] ].	(newVersion :=  wc newVersion) == nil ifTrue: [ ^false ].	repo storeVersion: newVersion.	^true! !!MetacelloMCVersionValidator class methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34197842!populateReasonCodeDescriptions    "update MetacelloMCVersionValidator class comment to include any changes to descriptions"    | dict |    dict := super populateReasonCodeDescriptions.    dict        at: #'notDevelopmentVersion'            put: 'the symbolic version #development refers to a non-development literal version.';        at: #'loadWarning' put: 'Warning signalled during load [load validation].';        at: #'stableDevelopmentVersion'            put: 'a version whose blessing is #development has been declared as a #stable version.'.	"Warnings"    dict        at: #'loadDeprecation' put: 'deprecation warning signalled while loading configuration [load validation].';        at: #'missingRecommendedProjectSpecField'            put:                'missing recommended fields in project reference (versionString). The versionString should be specified so that #bleedingEdge loads will be predictable and repeatable.';        at: #'noLoadableVersions' put: 'no non #baseline versions defined in configuration.';        at: #'noTests' put: 'no test cases defined in loaded configuration [load validation].';        at: #'noVersionSpecified'            put:                'no version defined for the project reference or package. The version specified in the baseline or the latest version of the project or package in the repository will be used.';        at: #'testDeprecation'            put: 'deprecation warning signalled while running configuration tests [load validation].'.	"Critical Warnings"    dict        at: #'loadError' put: 'error occured while loading configuration [load validation].';        at: #'testFailures' put: 'test failures while running tests [load validation].'.	"Errors"    ^ dict! !!MetacelloMCVersionValidator class methodsFor: 'instance creation' stamp: 'dkh 6/8/2012 14:04:22' prior: 34199220!validateConfigurationLoad: configurationClass	^ ((self new)		configurationClass: configurationClass;		yourself) validateProjectLoad! !!MetacelloMCVersionValidator class methodsFor: 'instance creation' stamp: 'dkh 6/8/2012 14:04:22' prior: 34199464!validateConfigurationLoad: configurationClass version: versionString	^self validateConfigurationLoad: configurationClass version: versionString loads: #()! !!MetacelloMCVersionValidator class methodsFor: 'instance creation' stamp: 'dkh 6/8/2012 14:04:22' prior: 34199730!validateConfigurationLoad: configurationClass version: versionString loads: loadList	^ ((self new)		configurationClass: configurationClass;		yourself) validateProjectVersionLoad: versionString loads: loadList! !!MetacelloMCVersionValidator methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34200036!criticalWarningReasonCodes	^ super criticalWarningReasonCodes		, #(#noLoadableVersions #noTests #testDeprecation #loadDeprecation #noVersionSpecified #'missingRecommendedProjectSpecField' )! !!MetacelloMCVersionValidator methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34200283!errorReasonCodes	^ super errorReasonCodes, #(#loadError #testFailures )! !!MetacelloMCVersionValidator methodsFor: 'validation' stamp: 'dkh 7/2/2012 17:32' prior: 34200452!validateBaselineVersionSpec: versionSpec    | projectNames packageNames groupNames versionMessage |    self        validateDoIts: versionSpec        versionString: versionSpec versionString        errorMessage: ' version ' , versionSpec versionString printString.    projectNames := Set new.    packageNames := Set new.    groupNames := Set new.    versionMessage := ' in version ' , versionSpec versionString printString.    versionSpec        projectDo: [ :projectSpec |             projectSpec resolveProjectSpec className == nil                ifTrue: [                     self                        recordValidationError:                            'Missing required field (className:) for project reference ' , projectSpec name printString , ' in version '                                , versionSpec versionString printString                        versionString: versionSpec versionString                        callSite: #'validateBaselineVersionSpec:'                        reasonCode: #'incompleteProjectSpec' ].            projectSpec resolveProjectSpec versionString == nil                ifTrue: [                     self                        recordValidationCriticalWarning:                            'Missing recommended field (versionString:) for project reference ' , projectSpec name printString , ' in version '                                , versionSpec versionString printString                        versionString: versionSpec versionString                        callSite: #'validateBaselineVersionSpec:'                        reasonCode: #'missingRecommendedProjectSpecField' ].            projectSpec hasRepository                ifTrue: [                     (self recurse and: [ projectSpec versionString ~~ nil ])                        ifTrue: [                             | project |                            projectSpec resolveProjectSpec ensureProjectLoaded.                            project := self                                validateProjectCreationFrom: projectSpec resolveProjectSpec projectClass                                onError: [ :ex |                                     self                                        recordValidationError: 'Error creating project reference: ' , ex description                                        versionString: versionSpec versionString                                        callSite: #'validateBaselineVersionSpec:'                                        reasonCode: #'projectCreationError'.                                    nil ].                            project ~~ nil                                ifTrue: [                                     self validationReport                                        addAll:                                            (self class                                                validateProject: project                                                version: projectSpec versionString                                                debug: self debug                                                recurse: self recurse                                                visited: self visited) ] ] ]                ifFalse: [                     self                        recordValidationError:                            'Missing required field (repository:) for project reference ' , projectSpec name printString , ' in version '                                , versionSpec versionString printString                        versionString: versionSpec versionString                        callSite: #'validateBaselineVersionSpec:'                        reasonCode: #'incompleteProjectSpec' ].            self                validateDoIts: projectSpec                versionString: versionSpec versionString                errorMessage: projectSpec name printString , versionMessage.            (projectNames includes: projectSpec name)                ifTrue: [                     self                        recordValidationError:                            'Duplicate projects named' , projectSpec name printString , versionMessage                        versionString: versionSpec versionString                        callSite: #'validateBaselineVersionSpec:'                        reasonCode: #'duplicateNames' ]                ifFalse: [ projectNames add: projectSpec name ] ]        packageDo: [ :packageSpec |             self                validateDoIts: packageSpec                versionString: versionSpec versionString                errorMessage: packageSpec name printString , versionMessage.            (packageNames includes: packageSpec name)                ifTrue: [                     self                        recordValidationError:                            'Duplicate packages named' , packageSpec name printString , versionMessage                        versionString: versionSpec versionString                        callSite: #'validateBaselineVersionSpec:'                        reasonCode: #'duplicateNames' ]                ifFalse: [ projectNames add: packageSpec name ] ]        groupDo: [ :groupSpec |             (groupNames includes: groupSpec name)                ifTrue: [                     self                        recordValidationError: 'Duplicate groups named' , groupSpec name printString , versionMessage                        versionString: versionSpec versionString                        callSite: #'validateBaselineVersionSpec:'                        reasonCode: #'duplicateNames' ]                ifFalse: [ projectNames add: groupSpec name ] ].    (packageNames intersection: projectNames) notEmpty        ifTrue: [             self                recordValidationError: 'Names duplicated between packages and projects' , versionMessage                versionString: versionSpec versionString                callSite: #'validateBaselineVersionSpec:'                reasonCode: #'shadowedNames' ].    (groupNames intersection: projectNames) notEmpty        ifTrue: [             self                recordValidationError: 'Names duplicated between groups and projects' , versionMessage                versionString: versionSpec versionString                callSite: #'validateBaselineVersionSpec:'                reasonCode: #'shadowedNames' ].    (projectNames intersection: packageNames) notEmpty        ifTrue: [             self                recordValidationError: 'Names duplicated between projects and packages' , versionMessage                versionString: versionSpec versionString                callSite: #'validateBaselineVersionSpec:'                reasonCode: #'shadowedNames' ].    (groupNames intersection: packageNames) notEmpty        ifTrue: [             self                recordValidationError: 'Names duplicated between groups and packages' , versionMessage                versionString: versionSpec versionString                callSite: #'validateBaselineVersionSpec:'                reasonCode: #'shadowedNames' ].    (projectNames intersection: groupNames) notEmpty        ifTrue: [             self                recordValidationError: 'Names duplicated between projects and groups' , versionMessage                versionString: versionSpec versionString                callSite: #'validateBaselineVersionSpec:'                reasonCode: #'shadowedNames' ].    (packageNames intersection: groupNames) notEmpty        ifTrue: [             self                recordValidationError: 'Names duplicated between packages and groups' , versionMessage                versionString: versionSpec versionString                callSite: #'validateBaselineVersionSpec:'                reasonCode: #'shadowedNames' ]! !!MetacelloMCVersionValidator methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34205473!validateCleanLoadAndTestsForVersion: version loads: loadList	| cleanLoad cleanTests |	cleanTests := cleanLoad := false.	[ 	self validateVersionLoad: version loads: loadList.	cleanLoad := true ]		on: Error , Warning		do: [ :ex | 			(ex isKindOf: Error)				ifTrue: [ 					self						recordValidationError:							'Error while loading version ' , version versionString printString , ' in ' , self configurationClass name asString								, ' ' , ex description						versionString: version versionString						callSite: #validateCleanLoadAndTestsForVersion:loads:						reasonCode: #loadError ].			(ex isKindOf: Warning)				ifTrue: [ 					(ex isKindOf: Deprecation)						ifTrue: [ 							self								recordValidationCriticalWarning:									'Deprecation while loading version ' , version versionString printString , ' in '										, self configurationClass name asString , ' ' , ex description								versionString: version versionString								callSite: #validateCleanLoadAndTestsForVersion:loads:								reasonCode: #loadDeprecation ]						ifFalse: [ 							self								recordValidationWarning:									'Warning while loading version ' , version versionString printString , ' in ' , self configurationClass name asString										, ' ' , ex description								versionString: version versionString								callSite: #validateCleanLoadAndTestsForVersion:loads:								reasonCode: #loadWarning.							Smalltalk								at: #UndeclaredVariableWarning								ifPresent: [ :undeclaredWrning | 									(ex isKindOf: undeclaredWrning)										ifTrue: [ ex resume: true ] ].							ex resume ] ] ].	cleanLoad		ifTrue: [ 			cleanTests := [ self validateVersionTests: version ]				on: Deprecation				do: [ :ex | 					| message |					message := 'Deprecation warning while running tests for version ' , version versionString printString , ' in '						, self configurationClass name asString , ' ' , ex description.	"Deprecation warning for release tests is the same as a test failure"					self						recordValidationCriticalWarning: message						versionString: version versionString						callSite: #validateCleanLoadAndTestsForVersion:loads:						reasonCode: #testDeprecation.					ex return: false ].			cleanTests				ifTrue: [ MetacelloCleanLoadAndTestsNotification signal: version ]				ifFalse: [ MetacelloCleanLoadNotification signal: version ] ]! !!MetacelloMCVersionValidator methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34207952!validateProjectLoad	| issues project versions currentVersion collectedIssues |	(issues := self validateProject select: [ :issue | issue isError ]) notEmpty		ifTrue: [ ^ issues ].	project := self configurationClass project.	collectedIssues := issues.	versions := project versions		select: [ :version | 			validationReport := nil.			version blessing ~~ #broken				and: [ 					version blessing ~~ #baseline						and: [ (issues := (self validateProject: project version: version versionString) select: [ :issue | issue isCritical ]) isEmpty ] ] ].	validationReport := collectedIssues.	versions isEmpty		ifTrue: [ 			self				recordValidationCriticalWarning: 'No non #baseline versions  available  in ' , self configurationClass name asString				callSite: #validateProjectLoad				reasonCode: #noLoadableVersions.			^ self validationReport ].	(currentVersion := project currentVersion) ~~ nil		ifTrue: [ 			| index |			index := versions indexOf: currentVersion.			versions := versions copyFrom: index to: versions size ].	versions do: [ :version | self validateCleanLoadAndTestsForVersion: version loads: #('ALL') ].	^ self validationReport! !!MetacelloMCVersionValidator methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34209207!validateProjectVersionLoad: versionString loads: loadList	| issues project currentVersion version |	(issues := (self validateProjectVersion: versionString) select: [ :issue | issue isError ]) notEmpty		ifTrue: [ ^ issues ].	project := self configurationClass project.	version := project		version: versionString		ifAbsent: [ 			self				recordValidationError: 'Version ' , versionString printString , ' does not exist.'				callSite: #validateProjectVersionLoad:loads:				reasonCode: #cannotResolveVersion.			^ self validationReport ].	version blessing = #broken		ifTrue: [ self error: 'The specified version is #broken' ].	self validateCleanLoadAndTestsForVersion: version loads: loadList.	^ self validationReport! !!MetacelloMCVersionValidator methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34210028!validateVersionLoad: version loads: loadList	| list |	list := loadList asOrderedCollection.	list isEmpty		ifTrue: [ list add: 'default' ].	(version groups includes: 'Tests')		ifTrue: [ list add: 'Tests' ].	version load: list! !!MetacelloMCVersionValidator methodsFor: 'private' stamp: 'dkh 6/30/2012 13:24' prior: 34210345!validateVersionSpec: versionSpec    versionSpec blessing value == #'broken'        ifTrue: [ ^ self ].    versionSpec        projectDo: [ :projectSpec |             | referencedProjectSpec |            projectSpec versionString == nil                ifTrue: [                     self                        recordValidationCriticalWarning:                            'No version specified for the project reference ' , projectSpec name printString , ' in version '                                , versionSpec versionString printString                        versionString: versionSpec versionString                        callSite: #'validateVersionSpec:'                        reasonCode: #'noVersionSpecified' ].            referencedProjectSpec := projectSpec referencedSpec.            versionSpec blessing value == #'baseline'                ifTrue: [                     referencedProjectSpec hasRepository                        ifTrue: [                             (referencedProjectSpec file beginsWith: referencedProjectSpec className)                                ifFalse: [                                     self                                        recordValidationCriticalWarning:                                            'The class name of project ' , referencedProjectSpec className printString , ' does not match the file name '                                                , referencedProjectSpec file printString , ' in version '                                                , versionSpec versionString printString                                        versionString: versionSpec versionString                                        callSite: #'validateVersionSpec:'                                        reasonCode: #'projectClassNameFileMismatch' ] ]                        ifFalse: [                             self                                recordValidationError:                                    'The specification for the project reference ' , projectSpec name printString , ' in version '                                        , versionSpec versionString printString                                        , ' is missing the required repository field'                                versionString: versionSpec versionString                                callSite: #'validateVersionSpec:'                                reasonCode: #'incompleteProjectSpec' ] ].            referencedProjectSpec ensureProjectLoaded                ifTrue: [                     [ projectSpec version ]                        on: MetacelloVersionDoesNotExistError                        do: [ :ex |                             | explanation |                            explanation := projectSpec versionString == nil                                ifTrue: [ 'the default version' ]                                ifFalse: [ 'version ' , projectSpec versionString printString ].                            self                                recordValidationError:                                    'Cannot resolve ' , explanation , ' for the project reference ' , projectSpec name printString , ' in version '                                        , versionSpec versionString printString                                versionString: versionSpec versionString                                callSite: #'validateVersionSpec:'                                reasonCode: #'cannotResolveVersion' ] ] ]        packageDo: [ :packageSpec |             (packageSpec file beginsWith: packageSpec name)                ifFalse: [                     self                        recordValidationCriticalWarning:                            'The name of package ' , packageSpec name printString , ' does not match the file name ' , packageSpec file printString                                , ' in version ' , versionSpec versionString printString                        versionString: versionSpec versionString                        callSite: #'validateVersionSpec:'                        reasonCode: #'packageNameMismatch' ].            packageSpec file = packageSpec name                ifTrue: [                     self                        recordValidationCriticalWarning:                            'No version specified for the package ' , packageSpec name printString , ' in version '                                , versionSpec versionString printString                        versionString: versionSpec versionString                        callSite: #'validateVersionSpec:'                        reasonCode: #'noVersionSpecified' ] ]        groupDo: [ :ignored |  ].    self validateBaselineVersionSpec: versionSpec! !!MetacelloMCVersionValidator methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34213598!validateVersionSpecForSymbolicVersion: versionSpec symbolicVersion: symbolicVersionString	| blessing |	versionSpec blessing value == #broken		ifTrue: [ ^ self ].	blessing := versionSpec blessing value.	(symbolicVersionString == #development and: [ blessing ~~ #development ])		ifTrue: [ 			self				recordValidationWarning:					'Symbolic version ' , symbolicVersionString printString , ' refers to a version' , versionSpec versionString printString						, ' whose blessing ' , blessing printString , ' is not #development'				versionString: versionSpec versionString				callSite: #validateVersionSpecForSymbolicVersion:symbolicVersion:				reasonCode: #notDevelopmentVersion ]! !!MetacelloMCVersionValidator methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34214379!validateVersionTests: version	| testCases cleanTests |	testCases := IdentitySet new.	cleanTests := true.	version currentlyLoadedClassesInVersion		do: [ :class | 			((class inheritsFrom: TestCase) and: [ class isAbstract not ])				ifTrue: [ testCases add: class ] ].	testCases		do: [ :testCase | 			| testResults |			testResults := testCase suite run.			testResults defects notEmpty				ifTrue: [ 					self						recordValidationError:							'Test failures in tests ' , testCase name asString , ' for ' , version versionString printString , ' in '								, self configurationClass name asString , ' ' , testResults printString						versionString: version versionString						callSite: #validateVersionTests:						reasonCode: #testFailures.					cleanTests := false ] ].	testCases isEmpty		ifTrue: [ 			self				recordValidationCriticalWarning:					'No test cases for ' , version versionString printString , ' in ' , self configurationClass name asString				versionString: version versionString				callSite: #validateVersionTests:				reasonCode: #noTests.			cleanTests := false ].	^ cleanTests! !!MetacelloMCVersionValidator methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34215590!warningReasonCodes	^ super warningReasonCodes, #(#loadWarning #notDevelopmentVersion #stableDevelopmentVersion)! !!MetacelloRepositoriesSpec methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34305896!add: aStringOrSpec	aStringOrSpec addToMetacelloRepositories: self! !!MetacelloRepositoriesSpec methodsFor: 'scripting' stamp: 'dkh 6/15/2012 13:40'!compareEqual: aMetacelloProjectSpec    | repositorySpecs anotherRepositorySpecs |    repositorySpecs := (self map values sort: [ :a :b | a description <= b description ])        collect: [ :each | each description ].    anotherRepositorySpecs := (aMetacelloProjectSpec map values sort: [ :a :b | a description <= b description ])        collect: [ :each | each description ].    ^ repositorySpecs = anotherRepositorySpecs! !!MetacelloRepositoriesSpec methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34306361!configMethodCascadeOn: aStream indent: indent	| repositorySpecs |	repositorySpecs := self map values sort: [:a :b | a description <= b description ].	repositorySpecs size = 1		ifTrue: [ repositorySpecs first configMethodCascadeOn: aStream lastCascade: true ]		ifFalse: [			1 to: repositorySpecs size do: [:index | | repositorySpec |				aStream tab: indent + 1.				(repositorySpecs at: index)					configMethodCascadeOn: aStream 					lastCascade: index >= repositorySpecs size ]]! !!MetacelloRepositoriesSpec methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34306932!configMethodOn: aStream indent: indent	aStream 		tab: indent; 		nextPutAll: 'spec';		cr.	self configMethodCascadeOn: aStream indent: indent! !!MetacelloRepositoriesSpec methodsFor: 'scripting' stamp: 'dkh 07/16/2013 19:15'!hasNoLoadConflicts: aMetacelloProjectSpec  | repositorySpecs anotherRepositorySpecs |  repositorySpecs := self map values    sort: [ :a :b | a description <= b description ].  anotherRepositorySpecs := aMetacelloProjectSpec map values    sort: [ :a :b | a description <= b description ].  repositorySpecs size ~= anotherRepositorySpecs size    ifTrue: [ ^ false ].  1 to: repositorySpecs size do: [ :index |     | repoSpec anotherRepoSpec |    repoSpec := repositorySpecs at: index.    anotherRepoSpec := anotherRepositorySpecs at: index.    (repoSpec hasNoLoadConflicts: anotherRepoSpec)      ifFalse: [ ^ false ] ].  ^ true! !!MetacelloRepositoriesSpec methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34307159!merge: aRepositorySpec	aRepositorySpec mergeIntoMetacelloRepositories: self! !!MetacelloRepositoriesSpec methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!metacelloRegistrationHash    ^ ((self map values sort: [ :a :b | a description <= b description ]) collect: [ :each | each description ]) hash! !!MetacelloRepositoriesSpec methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34307626!remove: aRepositorySpec	aRepositorySpec removeFromMetacelloRepositories: self! !!MetacelloRepositoriesSpec methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34307788!repository: aStringOrSpec	aStringOrSpec addToMetacelloRepositories: self! !!MetacelloRepositoriesSpec methodsFor: 'construction' stamp: 'dkh 6/8/2012 14:04:22'!repository: anObject constructor: aVersionConstructor    aVersionConstructor repositoryForRepositories: anObject! !!MetacelloRepositoriesSpec methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34307946!repository: description username: username password: password	| spec |	spec := 		(self project repositorySpec)			description: description;			username: username;			password: password;			yourself.	self addMember: 		(self addMember 			name: spec name;			spec: spec;			yourself)! !!MetacelloRepositoriesSpec methodsFor: 'construction' stamp: 'dkh 6/8/2012 14:04:22'!repository: aString username: username password: password constructor: aVersionConstructor    aVersionConstructor repositoryForRepositories: aString username: username password: password! !!MCDictionaryRepository methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34277954!asRepositorySpecFor: aMetacelloMCProject	| desc |	desc := self description.	desc ifNil: [ desc := 'dictionary://Metacello_Dictionary' ].	^(aMetacelloMCProject repositorySpec)		description:  desc;	 	type: 'dictionary';		yourself! !!MCDictionaryRepository methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34278208!versionInfoFromVersionNamed: aString	| versions |	versions := self dictionary values select: [:version | version info name beginsWith: aString ].	versions isEmpty ifTrue: [ ^ nil ].	versions := versions asSortedCollection: [ :a :b |		([ (a info name copyAfterLast: $.) asNumber ] on: Error do: [:ex | ex return: 0 ]) <= 			([ (b info name copyAfterLast: $.) asNumber ] on: Error do: [:ex | ex return: 0 ]) ].	^ versions last info! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34215780!allPackagesForSpecNamed: aStringOrArray	"resolves list of packages associated with the named spec.	   If the spec is a packages, answer a list including the package and the transitive closure on 			its #requires: and #includes: fields.	   If the spec is a project, answer a list of the packages associated with the project,			following the transitive closure on packages reachable starting with the #loads: field.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"	"In essence, this query answers the list of all packages that would be loaded if the package 		named <aString> were loaded."	"If there is no spec named <aString>, answers an empty list"	^self allPackagesForSpecNamed: aStringOrArray ifAbsent: [ ^#() ]! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34216719!allPackagesForSpecNamed: aStringOrArray ifAbsent: aBlock	"resolves list of packages associated with the named spec.	   If the spec is a packages, answer a list including the package and the transitive closure on 			its #requires: and #includes: fields.	   If the spec is a project, answer a list of the packages associated with the project,			following the transitive closure on packages reachable starting with the #loads: field.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"	"In essence, this query answers the list of all packages that would be loaded if the package 		named <aString> were loaded."	"If there is no spec named <aString>, aBlock is evaluated"	^aStringOrArray 		resolvePackageSpecsNamedForMetacelloMCVersion: self 		visited: MetacelloVisitedPackages new 		ifAbsent: aBlock ! !!MetacelloMCVersion methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34217741!allPackagesForSpecs: pkgSpecs visited: visited 	| coll |	coll := Dictionary new.	pkgSpecs		do: [:pkgSpec | (pkgSpec resolveToAllPackagesIn: self spec visited: visited)				do: [:pkg | coll at: pkg name put: pkg ]].	^ coll values asOrderedCollection! !!MetacelloMCVersion methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34218084!cacheRepository: repository 	"by default cacheRepository is an MCDictionaryRepository"		self loaderPolicy cacheRepository: repository! !!MetacelloMCVersion methodsFor: 'private' stamp: 'dkh 9/10/2012 15:43'!computeVersionStatus	"		#allLoadedToSpec - all projects and packages are loaded and match specification		#loadedToSpec - all loaded projects and packages match specifications (at least one package loaded)		#loadedMatchConstraints - all loaded projects and packages match constraints (at least one package loaded)		#somethingLoaded - at least one package loaded	"	self spec computeVersionStatus: [ :status | ^ status ].	^ #noStatus! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34218308!currentlyLoadedClassesInVersion	^self spec currentlyLoadedClassesInVersion! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34218461!currentlyLoadedExtensionClassesInVersion	^self spec currentlyLoadedExtensionClassesInVersion! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 9/11/2012 11:53' prior: 34218632!defaultPackageNamesToLoad	"Answer the list of packages and projects to be loaded --> packages already loaded"		^ self defaultPackageNamesToLoad: self spec defaultPackageNames! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 9/11/2012 11:53' prior: 34218896!defaultPackageNamesToLoad: defaultList	"Answer the list of packages and projects to be loaded: packages already loaded plust defaultList"		^ self packageAndProjectNamesToLoad: defaultList loader: self loader! !!MetacelloMCVersion methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34219420!doFetchRequiredFromArray: anArray	| oldPolicy oldBypassProgress displayString |	displayString := self versionNumber printString, ' of ', self spec projectLabel.	Transcript cr; show: 'Fetching ', displayString, '...'.	oldPolicy := loaderPolicy. 	oldBypassProgress := MetacelloPlatform current bypassProgressBars.	self loaderPolicy silently ifTrue: [ MetacelloPlatform current bypassProgressBars: true ].	[ 	| ans |		ans := self fetchRequiredFromArray: anArray.		Transcript cr; show: '...finished ', self versionNumber printString.		^ans ]			ensure: [ 				MetacelloPlatform current bypassProgressBars: oldBypassProgress.				loaderPolicy := oldPolicy ]	! !!MetacelloMCVersion methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34220160!doLoadRequiredFromArray: anArray	| displayString oldPolicy oldBypassProgress |	displayString := self versionNumber printString, ' of ', self spec projectLabel.	Transcript cr; show: 'Loading ', displayString, '...'.	oldPolicy := loaderPolicy. 	oldBypassProgress := MetacelloPlatform current bypassProgressBars.	self loaderPolicy silently ifTrue: [ MetacelloPlatform current bypassProgressBars: true ].	[	| fetchLoader |		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).		MetacelloPlatform current			do:  [  fetchLoader doLoad ]			displaying: 'Loading ', displayString.		Transcript cr; show: '...finished ', self versionNumber printString.		^fetchLoader ]		ensure: [ 			MetacelloPlatform current bypassProgressBars: oldBypassProgress.			loaderPolicy := oldPolicy ]! !!MetacelloMCVersion methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34221062!doRecordRequiredFromArray: anArray	| originalLoader oldPolicy displayString oldBypassProgress |	displayString := self versionNumber printString, ' of ', self spec projectLabel.	Transcript cr; show: 'Recording ', displayString, '...'.	originalLoader := self versionSpec loader.	oldPolicy := loaderPolicy. 	oldBypassProgress := MetacelloPlatform current bypassProgressBars.	self loaderPolicy silently ifTrue: [ MetacelloPlatform current bypassProgressBars: true ].	[	MetacelloPlatform current			do:  [ | ans |				self versionSpec loader: originalLoader recordingSpecLoader.				ans := (self executeLoadFromArray: anArray) copy.				Transcript cr; show: '...finished ', self versionNumber printString.				^ans ]			displaying: 'Recording ', displayString ]				ensure: [					MetacelloPlatform current bypassProgressBars: oldBypassProgress.					self versionSpec loader: originalLoader.					loaderPolicy := oldPolicy ]! !!MetacelloMCVersion methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34222075!executeLoadFromArray: anArray	| loader mcLoader |	loader := MetacelloMCVersionSpecLoader on: self spec.	loader required: anArray.	loaderPolicy notNil ifTrue: [ loader loaderPolicy: loaderPolicy ].	^loader load! !!MetacelloMCVersion methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34222631!fetch	^self doFetchRequiredFromArray: self spec defaultPackageNames! !!MetacelloMCVersion methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34222784!fetch: required	^required fetchRequiredForMetacelloMCVersion: self! !!MetacelloMCVersion methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34222928!fetchRequiredFromArray: anArray	| originalLoader displayString newLoader |	originalLoader := self versionSpec loader.	newLoader := originalLoader fetchingSpecLoader.	displayString := newLoader actionLabel , self versionNumber printString , ' of ' , self spec projectLabel.	MetacelloPlatform current		do: [ 			[ 			self versionSpec loader: newLoader.			MetacelloPlatform current				useStackCacheDuring: [ :dict | ^ self executeLoadFromArray: anArray ]				defaultDictionary: Dictionary new ] ensure: [ self versionSpec loader: originalLoader ] ]		displaying: displayString! !!MetacelloMCVersion methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34223895!ignoreImage: aBool 	"by default ignoreImage is false"		self loaderPolicy ignoreImage: aBool! !!MetacelloMCVersion methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34224074!load	^self doLoadRequiredFromArray: self spec defaultPackageNames! !!MetacelloMCVersion methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34224217!load: required	^required loadRequiredForMetacelloMCVersion: self! !!MetacelloMCVersion methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34224369!loadRequiredFromArray: anArray	| displayString |	displayString := 'Loading ', self versionNumber printString, ' of ', self spec projectLabel.	MetacelloPlatform current		do: [ ^self executeLoadFromArray: anArray ]		displaying: displayString! !!MetacelloMCVersion methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34224690!loader: aLoader	self versionSpec loader: aLoader! !!MetacelloMCVersion methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34224826!loaderPolicy	loaderPolicy == nil ifTrue: [ loaderPolicy := MetacelloLoaderPolicy new ].	^ loaderPolicy! !!MetacelloMCVersion methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34225017!loaderPolicy: anObject	loaderPolicy := anObject! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 9/11/2012 11:53' prior: 34225152!packageAndProjectNamesToLoad: defaultList loader: aLoader	"Answer the list of packages and projects to be loaded: packages already loaded plust defaultList"		| loadedPackageNames projectMap loadedProjectNames list |	loadedPackageNames := ((self packages select: [:pkg | pkg isPackageLoaded: aLoader ]) 		collect: [:pkg | pkg name ]) asSet, 			defaultList.	projectMap := Dictionary new.	self  projects do: [:prj | 		prj className ~~ nil			ifTrue: [ | coll loaded |				coll := projectMap at: prj className ifAbsent: [					coll := OrderedCollection new.					projectMap at: prj className put: coll.					coll].				(loaded := prj loadedPackageNames: aLoader) isEmpty 					ifFalse: [  coll add: prj -> (loaded -> prj loadPackageList) ]]].	loadedProjectNames := Set new.	projectMap keysAndValuesDo: [:prjClass :coll |		coll size <= 1			ifTrue: [ coll do: [:assoc | loadedProjectNames add: assoc key name ]]			ifFalse: [ 				"multiple project references against the same configuration ... only count project as loaded				 if there is an exact match for loaded projects...				 See http://code.google.com/p/metacello/issues/detail?id=86"				coll do: [:assoc | | loaded packageList |					loaded := assoc value key. "loaded packages from project"					packageList := assoc value value. "loadlist for project"					(packageList difference: loaded) isEmpty						ifTrue: [ loadedProjectNames add: assoc key name ]]]].	list := loadedPackageNames, loadedProjectNames.	list isEmpty ifTrue: [ ^self spec defaultPackageNames].	^list! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 9/11/2012 10:16' prior: 34227159!packages	"Answers the list of packages associated with this version"	| packages |	packages := OrderedCollection new.	self spec projectDo: [:ignored | ] packageDo: [:pkg | packages add: pkg ] groupDo: [:ignored | ].	^packages! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34227468!packagesForSpecNamed: aString	"resolves list of packages associated with the named spec.	   If the spec is a packages, answer a list including only the package. #requires: and #includes:			fields in the package are ignored.	   If the spec is a project, answers an empty list.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"	"If there is no spec named <aString>, answers an empty list"	^self packagesForSpecNamed: aString ifAbsent: [ ^#() ]! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34228131!packagesForSpecNamed: aString ifAbsent: aBlock	"resolves list of packages associated with the named spec.	   If the spec is a packages, answer a list including only the package. #requires: and #includes:			fields in the package are ignored.	   If the spec is a project, answers an empty list.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"	"If there is no spec named <aString>, aBlock is evaluated"	| pkgSpec |	pkgSpec := self spec packageNamed: aString ifAbsent: aBlock.	^pkgSpec resolveToPackagesIn: self spec visited: MetacelloVisitedPackages new! !!MetacelloMCVersion methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34229240!record	^self doRecordRequiredFromArray: self spec defaultPackageNames! !!MetacelloMCVersion methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34229396!record: required	^required recordRequiredForMetacelloMCVersion: self! !!MetacelloMCVersion methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34229553!repositoryOverrides: repositoriesCollection 	self loaderPolicy overrideRepositories: repositoriesCollection! !!MetacelloMCVersion methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34230492!silently: aBool 	"by default silently is false"		self loaderPolicy silently: aBool! !!MetacelloCommonMCSpecLoader class methodsFor: 'utilities' stamp: 'dkh 6/8/2012 14:04:22' prior: 34310460!nameComponentsFrom: aVersionName	| ar |	ar := (aVersionName last isDigit and: [ (aVersionName indexOf: $.) > 0 ])ifFalse: [Array with: aVersionName with: '' with: 0 with: aVersionName with: self]		ifTrue: [ | vrsn str |			str := ((aVersionName copyAfterLast: $-) copyAfterLast: $.).			vrsn := str isEmpty				ifTrue: [0]				ifFalse: [str asInteger].			Array				with: (aVersionName copyUpToLast:  $-)								"base pkg name"				with: ((aVersionName copyAfterLast: $-) copyUpTo: $.)				"user"				with:  vrsn "version"				with: aVersionName				with: self ].	^ar! !!MetacelloCommonMCSpecLoader class methodsFor: 'accessing' stamp: 'dkh 6/17/2012 19:51'!retryPackageResolution    "if true, 		errors during #retryingResolvePackageSpecReferences:gofer: are caught and 		the resolution is retried 3 times. After the thrid time, a MetacelloPackageSpecResolutionError		is thrown	if false,		an error during #retryingResolvePackageSpecReferences:gofer: will be passed,		likely resulting in a walkback ... useful for debugging."    RetryPackageResolution ifNil: [ RetryPackageResolution := true ].    ^ RetryPackageResolution! !!MetacelloCommonMCSpecLoader class methodsFor: 'accessing' stamp: 'dkh 6/17/2012 19:48'!retryPackageResolution: aBool    RetryPackageResolution := aBool! !!MetacelloCommonMCSpecLoader methodsFor: 'versionInfo' stamp: 'dkh 6/8/2012 14:04:22' prior: 34311119!ancestorsFor: packageSpec	| cacheKey vi |	cacheKey := packageSpec file.	^MetacelloPlatform current		stackCacheFor: #ancestors		at: cacheKey		doing: [ :cache | 			vi := packageSpec ancestors.			cache at: cacheKey put: vi ].! !!MetacelloCommonMCSpecLoader methodsFor: 'versionInfo' stamp: 'dkh 6/8/2012 14:04:22' prior: 34311449!currentVersionInfoFor: packageSpec	| cacheKey vi |	cacheKey := packageSpec file.	^MetacelloPlatform current		stackCacheFor: #currentVersionInfo		at: cacheKey		doing: [ :cache | 			vi := packageSpec currentVersionInfo.			cache at: cacheKey put: vi ].! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34311802!doLoad	self subclassResponsibility! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34311931!doingLoads: aBlock	"escape mechanism for recording and null loaders to skip doing loaderlike things"		aBlock value! !!MetacelloCommonMCSpecLoader methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34312142!ensureForDevelopment	^true! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!ensureSpecLoader	^ self! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34312266!fetchingSpecLoader	^self! !!MetacelloCommonMCSpecLoader methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34312386!hasRepositoryOverrides	^self loaderPolicy hasRepositoryOverrides! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34312548!ignoreImage	^self loaderPolicy ignoreImage! !!MetacelloCommonMCSpecLoader methodsFor: 'initialize-release' stamp: 'dkh 6/8/2012 14:04:22' prior: 34312697!initialize	self loaderPolicy! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34312820!linearLoadPackageSpec: packageSpec gofer: gofer	self subclassResponsibility! !!MetacelloCommonMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34312981!linearLoadPackageSpecs: packageSpecs repositories: repositories		| gofer |	gofer := MetacelloGofer new.	repositories do: [:repo | gofer repository: repo ].	packageSpecs do: [:pkg | pkg loadUsing: self gofer: gofer ].! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34313297!load	| repos |	repos := self repositoriesFrom: self spec repositorySpecs.	^ self loadType == #atomic		ifTrue: [self atomicLoadPackageSpecs: self spec packageSpecsInLoadOrder repositories: repos]		ifFalse: ["assume #linear"			self linearLoadPackageSpecs: self spec packageSpecsInLoadOrder repositories: repos ]! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: 'dkh 7/5/2012 20:26' prior: 34313697!loadPackageDirective: aPackageLoadDirective gofer: aGofer	| packageSpec |	packageSpec := aPackageLoadDirective spec.	MetacelloPlatform current		do: [ 			| loadBlock goferLoad answers resolvedReference |			aGofer disablePackageCache.	"for good luck:)"			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.			resolvedReference isNil				ifTrue: [ 					"Package version already loaded into image"					^ self ].			loadBlock := [ 			"mcLoader preLoad: packageSpec."			goferLoad := MetacelloGoferLoad on: aGofer.			goferLoad addResolved: resolvedReference.			goferLoad execute.			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec" ].			(answers := packageSpec answers) notEmpty				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]				ifFalse: [ loadBlock value ].			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.			Transcript				cr;				show:						'Loaded -> ' , resolvedReference name , ' --- ' , aPackageLoadDirective repository description , ' --- '								, resolvedReference repository description ]		displaying: 'Loading ' , packageSpec file! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34314946!loadPackageDirectives: pkgLoads gofer: aGofer	MetacelloPlatform current		do:  [ | goferLoad loadBlock answers |			goferLoad := MetacelloGoferLoad on: aGofer.			answers := OrderedCollection new.			pkgLoads do: [:packageLoadDirective | | resolvedReference |				aGofer disablePackageCache. "for good luck:)"				(resolvedReference := self 						resolvePackageSpec: packageLoadDirective spec 						gofer: aGofer) ~~ nil					ifTrue: [ 						goferLoad addResolved: resolvedReference.						answers addAll: packageLoadDirective spec answers.						packageLoadDirective resolvedReference:  resolvedReference ]].			Transcript cr; show: 'Starting atomic load'.			loadBlock := [				"pkgLoads do: [:packageLoadDirective |  mcLoader preLoad: packageLoadDirective spec ]."				goferLoad execute.				pkgLoads do: [:packageLoadDirective |					packageLoadDirective resolvedReference == nil						ifTrue: [ Transcript cr; tab; show: 'Already Loaded -> ', packageLoadDirective file ]						ifFalse: [ Transcript cr; tab; show: 'Loaded -> ', packageLoadDirective file, ' --- ',  packageLoadDirective repository description, ' --- ', packageLoadDirective resolvedReference repository description.					packageLoadDirective resolvedReference workingCopy repositoryGroup addRepository: packageLoadDirective repository ]].				MetacelloPlatform current clearCurrentVersionCache.				"pkgLoads do: [:packageLoadDirective | 					packageLoadDirective resolvedReference ~~ nil						ifTrue: [mcLoader postLoad: packageLoadDirective spec ]]"].			answers notEmpty				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]				ifFalse: [ loadBlock value].			Transcript cr; show: 'Finished atomic load' ]		displaying: 'Atomic Load...'.! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34316774!loaderPolicy	loaderPolicy == nil ifTrue: [ loaderPolicy := MetacelloLoaderPolicy new ].	^loaderPolicy! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34316974!loaderPolicy: anObject	loaderPolicy := anObject! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34317117!loadingSpecLoader	^self! !!MetacelloCommonMCSpecLoader methodsFor: 'packages' stamp: 'dkh 6/8/2012 14:04:22' prior: 34317229!nameComponentsFrom: aVersionName	^self class nameComponentsFrom: aVersionName! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34317396!operator	operator == nil ifTrue: [ ^#= ].	^operator! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34317538!operator: aSymbol	operator := aSymbol! !!MetacelloCommonMCSpecLoader methodsFor: 'doits' stamp: 'dkh 6/8/2012 14:04:22' prior: 34317670!postLoad: packageOrVersionSpec	"subclassResponsibility, but it gets called during an upgrade, so leave it as NOOP"! !!MetacelloCommonMCSpecLoader methodsFor: 'doits' stamp: 'dkh 6/8/2012 14:04:22' prior: 34317877!preLoad: packageOrVersionSpec	self subclassResponsibility! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34318032!recordingSpecLoader	^(MetacelloNullRecordingMCSpecLoader on: self spec)		shouldDisablePackageCache: self shouldDisablePackageCache;		loaderPolicy: self loaderPolicy copy;		yourself! !!MetacelloCommonMCSpecLoader methodsFor: 'repositories' stamp: 'dkh 6/8/2012 14:04:22' prior: 34318316!repositoriesFrom: aMetacelloMVRepositorySpecs	^self repositoriesFrom: aMetacelloMVRepositorySpecs ignoreOverrides: false! !!MetacelloCommonMCSpecLoader methodsFor: 'repositories' stamp: 'dkh 6/8/2012 14:04:22' prior: 34318537!repositoriesFrom: aMetacelloMVRepositorySpecs ignoreOverrides: ignoreOverrides	| repositories repos |	(ignoreOverrides not and: [self hasRepositoryOverrides]) ifTrue: [ ^self loaderPolicy overrideRepositories ].	repositories := MCRepositoryGroup default repositories.	repos := OrderedCollection new.	aMetacelloMVRepositorySpecs do: [:aSpec | | description repo |		description := aSpec description.		(repo := repositories detect: [:rep | rep description = description ] ifNone: [ aSpec createRepository ]) ~~ nil			ifTrue: [ repos add: repo ]].	^repos! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34319194!repositoryMap	^self loaderPolicy repositoryMap! !!MetacelloCommonMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34319327!resolvePackageSpec: packageSpec gofer: gofer	|  references resolvedReference mcVersion loadedVersionInfos |	references := self retryingResolvePackageSpecReferences: packageSpec gofer: gofer.	resolvedReference := references last asMetacelloCachingResolvedReference.	mcVersion := resolvedReference version.	(loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil		ifTrue: [ 			loadedVersionInfos do: [:info | info name = mcVersion info name 				ifTrue: [ 					"package already loaded, don't load again"					^nil ]]].	^resolvedReference! !!MetacelloCommonMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34319962!resolvePackageSpecReferences: packageSpec gofer: gofer	|  versionReference references localGofer |	localGofer := gofer.	self hasRepositoryOverrides not		ifTrue: [			packageSpec repositorySpecs notEmpty				ifTrue: [ 					localGofer := MetacelloGofer new.					(self repositoriesFrom: packageSpec repositorySpecs) do: [:repo | localGofer repository: repo ]]].	(packageSpec getFile == nil or: [ self shouldDisablePackageCache ])		ifTrue: [ 			"don't use package-cache when trying to get latest version"			localGofer disablePackageCache ].	versionReference := packageSpec goferLoaderReference.	references := versionReference resolveAllWith: localGofer.	localGofer enablePackageCache.	^references! !!MetacelloCommonMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/17/2012 19:52' prior: 34320754!retryingResolvePackageSpecReferences: packageSpec gofer: gofer    | retryCount references repositoryError |    retryCount := 0.    references := #().    [ references isEmpty and: [ retryCount < 3 ] ]        whileTrue: [             retryCount > 0                ifTrue: [                     Transcript                        cr;                        show: '...RETRY->' , packageSpec file ].            references := [ self resolvePackageSpecReferences: packageSpec gofer: gofer ]                on: Error , GoferRepositoryError                do: [ :ex |                     self class retryPackageResolution                        ifFalse: [ ex pass ].                    retryCount >= 2                        ifTrue: [                             (ex isKindOf: GoferRepositoryError)                                ifTrue: [                                     "ignore repository errors at this point, in case an alternate repository is in the list "                                    Transcript                                        cr;                                        show: 'gofer repository error: ' , ex description printString , '...ignoring'.                                    repositoryError := ex.                                    ex resume: #() ]                                ifFalse: [ ex pass ] ].                    ex return: #() ].            retryCount := retryCount + 1 ].    references isEmpty        ifTrue: [             Transcript                cr;                show: '...FAILED->' , packageSpec file.            (MetacelloPackageSpecResolutionError new                packageSpec: packageSpec;                repositories: gofer repositories;                repositoryError: repositoryError;                yourself) signal ].    ^ references! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34322324!shouldDisablePackageCache	disablePackageCache == nil ifTrue: [ disablePackageCache := false ].	^ disablePackageCache! !!MetacelloCommonMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34322539!shouldDisablePackageCache: anObject	disablePackageCache := anObject! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34330198!actionLabel	^'Recording '! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34330328!afterLoads	afterLoads == nil ifTrue: [ afterLoads := OrderedCollection new ].	^afterLoads! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34330523!beforeLoads	beforeLoads == nil ifTrue: [ beforeLoads := OrderedCollection new ].	^beforeLoads! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'versionInfo' stamp: 'dkh 6/8/2012 14:04:22' prior: 34330716!currentVersionInfoFor: packageSpec	^self loadData		currentVersionInfoFor: packageSpec 		ifAbsent: [ nil ]! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34330927!doingLoads: aBlock	"escape mechanism for recording and null loaders to skip doing loaderlike things"! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34331130!ensureForDevelopment	^false! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34331262!evalDoits	evalDoits == nil ifTrue: [ evalDoits := false ].	^evalDoits! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34331438!evalDoits: aBool	evalDoits := aBool! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34331575!linearLoadPackageSpec: packageSpec gofer: gofer	MetacelloPlatform current		do:  [ | externalReference loadBlock answers fake |			externalReference := self resolveRecordingPackageSpecReference: packageSpec gofer: gofer.			loadBlock := [					self preLoad: packageSpec.					(MetacelloDirective 						loadPackage: packageSpec 						externalReference: externalReference 						loader: self) addTo: self loadDirective.					self postLoad: packageSpec ].			(answers := packageSpec answers) notEmpty				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]				ifFalse: [ loadBlock value ].			fake := packageSpec copy.			fake name: fake file.			self loadData 				addVersion: fake				versionInfo: fake				resolvedReference: externalReference 				packageSpec: packageSpec ]		displaying: 'Recording ', packageSpec file! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34332509!loadPackageDirective: aPackageLoadDirective gofer: aGofer	"Noop"! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34332674!loadPackageDirectives: pkgLoads gofer: aGofer	"Noop"! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34332830!loadedPackages	| packages |	packages := OrderedCollection new.	self loadDirective packageDirectivesDo: [:directive | packages add: directive file ].	^packages! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34333096!loadedRepositories	| repos |	repos := OrderedCollection new.	self repositoryMap values collect: [:coll | repos addAll: coll ].	^repos! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34333336!loadingSpecLoader	^self! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34333464!packages	| packages |	packages := OrderedCollection new.	self loadDirective packageDirectivesDo: [:directive | packages add: directive spec ].	^packages! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'doits' stamp: 'dkh 6/8/2012 14:04:22' prior: 34333719!postLoad: packageOrVersionSpec	self evalDoits ifFalse: [ ^self ].	packageOrVersionSpec postLoadDoItBlock ~~ nil		ifTrue: [ self afterLoads add: packageOrVersionSpec name, ' load' ].	super postLoad: packageOrVersionSpec! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'doits' stamp: 'dkh 6/8/2012 14:04:22' prior: 34334040!preLoad: packageOrVersionSpec	self evalDoits ifFalse: [ ^self ].	packageOrVersionSpec preLoadDoItBlock ~~ nil		ifTrue: [ self beforeLoads add: packageOrVersionSpec name, ' load' ].	super preLoad: packageOrVersionSpec! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34334364!recordingSpecLoader	^self! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34334482!resolvePackageSpecReferences: packageSpec gofer: gofer	|  versionReference references localGofer |	localGofer := gofer.	self hasRepositoryOverrides not		ifTrue: [			packageSpec repositorySpecs notEmpty				ifTrue: [ 					localGofer := MetacelloGofer new.					(self repositoriesFrom: packageSpec repositorySpecs) do: [:repo | localGofer repository: repo ]]].	(packageSpec getFile == nil or: [ self shouldDisablePackageCache ])		ifTrue: [ 			"don't use package-cache when trying to get latest version"			localGofer disablePackageCache ].	versionReference := packageSpec goferLoaderReference.	references := versionReference resolveAllWith: localGofer.	localGofer enablePackageCache.	^references! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34335291!resolveRecordingPackageSpecReference: packageSpec gofer: gofer	| externalPackageReference |	externalPackageReference := packageSpec file == nil				ifTrue: [ GoferPackageReference name: packageSpec name ]				ifFalse: [ GoferResolvedReference name: packageSpec file repository: nil ].	packageSpec repositorySpecs isEmpty		ifTrue: [  self repositoryMap at: externalPackageReference packageName put: (gofer repositories reject: [:repo | repo = MCCacheRepository default ]) ]		ifFalse: [  self repositoryMap at: externalPackageReference packageName put: (packageSpec repositorySpecs collect: [:repoSpec | repoSpec createRepository ]) ].	^externalPackageReference! !!MetacelloDirective class methodsFor: 'instance creation' stamp: 'dkh 6/8/2012 14:04:22' prior: 34235542!loadPackage: aPackageSpec externalReference: externalReference loader: aLoader	^MetacelloPackageLoadDirective new		spec: aPackageSpec externalReference: externalReference  loader: aLoader! !!MetacelloDirective class methodsFor: 'instance creation' stamp: 'dkh 6/8/2012 14:04:22' prior: 34235833!loader: aLoader	^self new		loader: aLoader! !!MetacelloDirective class methodsFor: 'instance creation' stamp: 'dkh 6/8/2012 14:04:22' prior: 34235978!postLoadSpec: packageOrVersionSpec loader: aLoader	^MetacelloPostLoadDirective new		spec: packageOrVersionSpec loader: aLoader! !!MetacelloDirective class methodsFor: 'instance creation' stamp: 'dkh 6/8/2012 14:04:22' prior: 34236207!preLoadSpec: packageOrVersionSpec loader: aLoader	^MetacelloPreLoadDirective new		spec: packageOrVersionSpec loader: aLoader! !!MetacelloDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34236418!addTo: aLoaderDirective	aLoaderDirective add: self! !!MetacelloDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34236559!directivesDo: aBlock	aBlock value: self! !!MetacelloDirective methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34236685!label	^self spec label! !!MetacelloDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34236793!loadUsing: aLoaderDirective gofer: aGofer	self subclassResponsibility! !!MetacelloDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34236950!loader	^loader! !!MetacelloDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34237052!loader: aLoader	loader := aLoader! !!MetacelloDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34237176!packageDirectivesDo: aBlock! !!MetacelloDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34237289!packageDo: aBlock! !!MetacelloDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34237391!postLoadDo: aBlock	! !!MetacelloDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34237496!preLoadDo: aBlock! !!MetacelloDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34237601!prepostLoadDirectivesDo: aBlock! !!MetacelloDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34237721!prepostLoadDo: aBlock! !!MetacelloDirective methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34237828!printOn: aStream	self printOn: aStream indent: 0! !!MetacelloDirective methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34237963!printOn: aStream indent: indent	indent timesRepeat: [ aStream tab ].	aStream		nextPutAll: self title;		nextPutAll: ' : ';		nextPutAll: self label.! !!MetacelloDirective methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34238202!printString	"Explicit override of superclass implementation. When you are printing a loadDirective it is annoying to have it truncated."	^String streamContents: [:s | self printOn: s]! !!MetacelloDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34238475!spec	^spec! !!MetacelloDirective methodsFor: 'initialize-release' stamp: 'dkh 6/8/2012 14:04:22' prior: 34238582!spec: packageOrVersionSpec loader: aLoader	spec := packageOrVersionSpec.	loader := aLoader! !!MetacelloDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34238761!title	self subclassResponsibility! !!MetacelloDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34238885!versionDirectivesDepthFirstDo: aBlock! !!MetacelloDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34239012!versionDirectivesDo: aBlock! !!MetacelloDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34239124!versionDo: aBlock! !!MetacelloPackageSpec methodsFor: 'gofer' stamp: 'dkh 6/8/2012 14:04:22' prior: 34352738!ancestors	^self goferPackage ancestors! !!MetacelloPackageSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34352864!compareCurrentVersion: anOperator targetVersionStatus: statusIgnored using: anMCLoader	self 		currentPackageLoaded: [:bool | ^bool ] 		comparing: anOperator 		notLoaded: [:ignored | ^false ]		using: anMCLoader! !!MetacelloPackageSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34353166!compareRelativeCurrentVersion: anOperator targetVersionStatus: statusIgnored using: anMCLoader	^self compareCurrentVersion: anOperator targetVersionStatus: statusIgnored using: anMCLoader! !!MetacelloPackageSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34353433!compareWorkingCopyNamed: wcName using: comarisonOperator	| fileRef wcRef |	fileRef := GoferResolvedReference name: self file.	wcRef := GoferResolvedReference name: wcName.	^ wcRef compare: fileRef using: comarisonOperator! !!MetacelloPackageSpec methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34353746!configMethodBodyOn: aStream hasName: hasName indent: indent	| hasFile hasRepositories hasPreLoadDoIt hasPostLoadDoIt hasRequiresOrIncludesOrAnswers |	hasFile := file ~~ nil.	hasRepositories := self repositorySpecs size > 0.	hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.	hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.	hasRequiresOrIncludesOrAnswers := (self requires isEmpty and: [ self includes isEmpty and: [self answers isEmpty ]]) not.	hasRequiresOrIncludesOrAnswers		ifTrue: [ 			self 				configMethodBodyOn: aStream 				hasName: hasName 				cascading: hasFile | hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt				indent: indent ].	self 		configMethodOn: aStream 		for: file 		selector: 'file: ' 		cascading: hasName | hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers 		cascade: hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt 		indent: indent.	hasRepositories		ifTrue: [ 			(self repositorySpecs size > 1)				ifTrue: [ 					hasName | hasFile | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers						ifTrue: [ 							aStream cr;							tab: indent. ].					aStream 						nextPutAll: 'repositories: ['; 						cr;						tab: indent + 1;						nextPutAll: 'spec'; 						cr.					self repositories configMethodCascadeOn: aStream indent: indent + 1.					aStream nextPutAll: ' ]' ]				ifFalse: [ 					hasName | hasFile | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers						ifTrue: [ aStream cr; tab: indent ].					self repositories configMethodCascadeOn: aStream indent: indent ].			hasPreLoadDoIt | hasPostLoadDoIt ifTrue: [ aStream nextPut: $; ] ].	self 		configMethodOn: aStream 		for: self getPreLoadDoIt 		selector: 'preLoadDoIt: '		cascading: hasName | hasFile | hasRepositories | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers 		cascade: hasPostLoadDoIt 		indent: indent.	self 		configMethodOn: aStream 		for: self getPostLoadDoIt 		selector: 'postLoadDoIt: ' 		cascading: hasName | hasFile | hasRepositories | hasPreLoadDoIt | hasRequiresOrIncludesOrAnswers 		cascade: false 		indent: indent.	aStream nextPut: $.! !!MetacelloPackageSpec methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34355974!configMethodCascadeOn: aStream member: aMember last: lastCascade indent: indent	aMember methodUpdateSelector  == #remove:		ifTrue: [ aStream  nextPutAll: 'removePackage: ', self name printString ]		ifFalse: [ self configShortCutMethodBodyOn: aStream member: aMember indent: indent ].	lastCascade		ifTrue: [ aStream nextPut: $. ]		ifFalse: [ aStream nextPut: $;; cr ]! !!MetacelloPackageSpec methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34356436!configMethodOn: aStream indent: indent	| hasRepositories hasPreLoadDoIt hasPostLoadDoIt hasRequiresOrIncludesOrAnswers hasFile |	hasFile := file ~~ nil.	hasRepositories := self repositorySpecs size > 0.	hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.	hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.	hasRequiresOrIncludesOrAnswers := (self requires isEmpty and: [ self includes isEmpty and: [self answers isEmpty ]]) not.	aStream tab: indent; nextPutAll: 'spec '.	hasFile | hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers		ifTrue: [			aStream cr; tab: indent + 1; nextPutAll: 'name: ', self name printString; nextPut: $;.			self configMethodBodyOn: aStream hasName: true indent: indent + 1 ]		ifFalse: [			aStream nextPutAll: 'name: ', self name printString ]! !!MetacelloPackageSpec methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34357331!configShortCutMethodBodyOn: aStream member: aMember indent: indent	| hasFile hasRepositories hasPreLoadDoIt hasPostLoadDoIt hasRequiresOrIncludesOrAnswers |	hasFile := file ~~ nil.	hasRepositories := self repositorySpecs size > 0.	hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.	hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.	hasRequiresOrIncludesOrAnswers := (self requires isEmpty and: [ self includes isEmpty and: [self answers isEmpty ]]) not.	hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers		ifTrue: [			aStream 				nextPutAll: 'package: ', self name printString, ' ';				nextPutAll: aMember methodUpdateSelector asString, ' ['; cr.			aStream tab: indent + 1; nextPutAll: 'spec '.			self configMethodBodyOn: aStream hasName: false indent: indent + 2.			aStream nextPutAll: ' ]'.			^self ].	aStream nextPutAll: 'package: ', self name printString.	hasFile		ifTrue: [ aStream nextPutAll: ' with: ', file printString ]! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34358403!copySpecTo: aRepositorySpec	"Copy current mcz file to the repository named in aRepositorySpec"	self loader copySpec: self from: self repositorySpecs to: aRepositorySpec createRepository! !!MetacelloPackageSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34358669!currentPackageLoaded: loadedBlock comparing: comarisonOperator notLoaded: notLoadedBlock using: anMCLoader	"Use currentVersionInfoFor: because it involves the loader and returns versionInfo for a planned load 	 (atomic loaders) or currently loaded package"	| wcName vis |	vis := anMCLoader ancestorsFor: self.	vis notNil		ifTrue: [ 			| fileRef wcRef |			self getFile == nil				ifTrue: [ ^ loadedBlock value: false ].			vis				do: [ :vi | 					wcName := vi name.					fileRef := GoferResolvedReference name: self file.					wcRef := GoferResolvedReference name: wcName.					(wcRef compare: fileRef using: comarisonOperator)						ifTrue: [ ^ loadedBlock value: true ] ].			^ loadedBlock value: false ].	^ notLoadedBlock value: true! !!MetacelloPackageSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34359493!currentPackageLoaded: loadedBlock notLoaded: notLoadedBlock using: anMCLoader	"Use currentVersionInfoFor: because it involves the loader and returns versionInfo for a planned load 	 (atomic loaders) or currently loaded package"	| wcName vis |	vis := anMCLoader ancestorsFor: self.	vis notNil		ifTrue: [ 			self getFile == nil				ifTrue: [ ^ loadedBlock value: #() value: self file ].			^ loadedBlock value: vis value: self file ].	^ notLoadedBlock value! !!MetacelloPackageSpec methodsFor: 'gofer' stamp: 'dkh 6/8/2012 14:04:22' prior: 34360033!currentVersionInfo	^self goferPackage currentVersionInfo! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22'!ensureLoadUsing: mcLoader	self explicitLoadUsing: mcLoader ensureSpecLoader! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34360177!ensureLoadedForDevelopmentUsing: mcLoader	"noop"		^true! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34360314!explicitLoadUsing: mcLoader	| wc fetchingSpecLoader |	((wc := self workingCopy) ~~ nil and: [ wc needsSaving ]) 		ifTrue: [ 			(MetacelloSkipDirtyPackageLoad signal: self)				ifTrue:  [					Transcript cr; show: 'Skipping load of modified package: ', self file.					^self]				ifFalse: [Transcript cr; show: 'Load over modified package: ', self file] ].	"fetch and explicitly load it"	fetchingSpecLoader := mcLoader fetchingSpecLoader.	fetchingSpecLoader		explicitLoadPackageSpecs: (Array with: self) 		repositories: (fetchingSpecLoader repositoriesFrom: self repositorySpecs).! !!MetacelloPackageSpec methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34360982!extractNameFromFile	file == nil ifTrue: [ ^nil ].	^(self loader nameComponentsFrom: self file) first! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34361171!fetch	self fetchUsing: self loader! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34361294!fetchPackage: aLoaderPolicy	self fetchUsing: 		(self loader			loaderPolicy: aLoaderPolicy;			yourself)! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34361487!fetchUsing: mcLoader	| fetchingSpecLoader |	fetchingSpecLoader := mcLoader fetchingSpecLoader.	fetchingSpecLoader		linearLoadPackageSpecs: (Array with: self) 		repositories: (fetchingSpecLoader repositoriesFrom: self repositorySpecs).! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34361807!file	file == nil ifTrue: [ ^self name ].	^file! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34361938!file: aString	file := aString! !!MetacelloPackageSpec methodsFor: 'construction' stamp: 'dkh 6/8/2012 14:04:22'!file: aString constructor: aVersionConstructor    aVersionConstructor fileForPackage: aString! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34362069!forceUpdatePackageSpec: updatedSpecs using: anMCLoader		self updatePackageSpec: updatedSpecs force: true using: anMCLoader! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34362274!getFile	"raw access to iv"		^file! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!getName    "raw access to iv"    ^ name! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34362399!getPostLoadDoIt	^postLoadDoIt! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34362519!getPreLoadDoIt	^preLoadDoIt! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!getRepositories    "raw access to iv"    ^ repositories! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34362638!goferBranchPackage: branchName message: commitMessage	"uses gofer to do commit ... non-interactive"	| latestFile pkgSpec   |	(file notNil and: [ (self name, '.', branchName) = self file ])		ifTrue: [ 			latestFile := self loader latestPackage: self file fromRepository: self repositorySpecs.			pkgSpec := self copy.			latestFile ~~ nil				ifTrue: [ 					pkgSpec file: latestFile.					pkgSpec goferCommitPackage: commitMessage.					^ self ] ].	self loader goferCommitBranchPackage: branchName using: self repositorySpecs commitMessage: commitMessage! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34363298!goferCommitPackage: commitMessage	"uses gofer to do commit ... non-interactive"		| latestFile pkgSpec |	^(file notNil and: [ self name = self file ])		ifTrue: [			latestFile := self loader latestPackage: self name fromRepository: self repositorySpecs.			pkgSpec := self copy.			pkgSpec file: latestFile.			pkgSpec goferCommitPackage: commitMessage ]		ifFalse: [ self loader goferCommitPackageUsing: self repositorySpecs commitMessage: commitMessage ]! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34363839!goferLoaderReference	^file == nil 		ifTrue: [ GoferPackageReference name: self name ]		ifFalse: [ 			"does Monticello-style #versionInfoFromVersionNamed: matching"			MetacelloGoferPackage name: self name packageFilename: self file ]! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34364158!goferPackage	goferPackage == nil 		ifTrue: [ goferPackage := MetacelloGoferPackage name: self name packageFilename: self file ].	^goferPackage! !!MetacelloPackageSpec methodsFor: 'testing' stamp: 'dkh 6/30/2012 13:23'!hasRepository    ^ self repositorySpecs notEmpty! !!MetacelloPackageSpec methodsFor: 'construction' stamp: 'dkh 6/8/2012 14:04:22'!includes: anObject constructor: aVersionConstructor    aVersionConstructor includesForPackage: anObject! !!MetacelloPackageSpec methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34364383!includesForPackageOrdering	^self includes! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34364505!info	"test compatibility method"	^self! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34364625!isPackageLoaded	^self isPackageLoaded: self loader! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34364756!isPackageLoaded: aLoader	^(self workingCopyNameFor: aLoader) ~~ nil! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34364911!load	self explicitLoadUsing: self loader! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34365040!loadUsing: mcLoader	self loader doingLoads: [ self explicitLoadUsing: mcLoader ]! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34365209!loadUsing: aLoader gofer: gofer	^aLoader linearLoadPackageSpec: self gofer: gofer! !!MetacelloPackageSpec methodsFor: 'merging' stamp: 'dkh 6/8/2012 14:04:22' prior: 34365379!mergeMap	| map |	map := super mergeMap.	map at: #file put: file.	map at: #repositories put: self repositories.	map at: #preLoadDoIt put: preLoadDoIt.	map at: #postLoadDoIt put: postLoadDoIt.	^map! !!MetacelloPackageSpec methodsFor: 'merging' stamp: 'dkh 6/8/2012 14:04:22' prior: 34365670!mergeSpec: anotherSpec	| newSpec map anotherPackages anotherRepositories |	newSpec := super mergeSpec: anotherSpec.	map := anotherSpec mergeMap.	(anotherRepositories := map at: #repositories) notEmpty		ifTrue: [ 			newSpec 				repositories: (self repositories isEmpty					ifTrue: [ anotherRepositories ]					ifFalse: [ self repositories mergeSpec: anotherRepositories ]) ].	^newSpec! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34366143!name	name == nil ifTrue: [ name := self extractNameFromFile ].	^name! !!MetacelloPackageSpec methodsFor: 'merging' stamp: 'dkh 6/8/2012 14:04:22' prior: 34366291!nonOverridable	^super nonOverridable, #( repositories)! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34366598!packageSpecsInLoadOrder	^{ self. }! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34366725!packagesNeedSavingVisited: visitedProjects using: repos into: aCollection	^self loader packagesNeedSavingUsing: repos into: aCollection! !!MetacelloPackageSpec methodsFor: 'copying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34366939!postCopy	super postCopy.	goferPackage := nil.	repositories := repositories copy.! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34367112!postLoadDoIt	^postLoadDoIt! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34367230!postLoadDoIt: anObject	anObject setPostLoadDoItInMetacelloSpec: self! !!MetacelloPackageSpec methodsFor: 'construction' stamp: 'dkh 6/8/2012 14:04:22'!postLoadDoIt: aSymbol constructor: aVersionConstructor    aVersionConstructor postLoadDoItForPackage: aSymbol! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34367388!preLoadDoIt	^preLoadDoIt! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34367504!preLoadDoIt: anObject	anObject setPreLoadDoItInMetacelloSpec: self! !!MetacelloPackageSpec methodsFor: 'construction' stamp: 'dkh 6/8/2012 14:04:22'!preLoadDoIt: aSymbol constructor: aVersionConstructor    aVersionConstructor preLoadDoItForPackage: aSymbol! !!MetacelloPackageSpec methodsFor: 'visiting' stamp: 'dkh 6/8/2012 14:04:22' prior: 34367651!projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	packageBlock value: self! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34367823!repositories	repositories == nil ifTrue: [ repositories := self project repositoriesSpec ].	^ repositories! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34368010!repositories: anObject	repositories := anObject! !!MetacelloPackageSpec methodsFor: 'construction' stamp: 'dkh 6/8/2012 14:04:22'!repositories: aBlock constructor: aVersionConstructor    aVersionConstructor repositoriesForPackage: aBlock! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 6/30/2012 13:30' prior: 34368136!repository    self deprecated: 'Use repositories or repositorySpecs'.    self repositorySpecs isEmpty        ifTrue: [ ^ nil ].    ^ self repositorySpecs first! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34368308!repository: aStringOrMetacelloRepositorySpec	self repositories repository: aStringOrMetacelloRepositorySpec! !!MetacelloPackageSpec methodsFor: 'construction' stamp: 'dkh 6/8/2012 14:04:22'!repository: anObject constructor: aVersionConstructor    aVersionConstructor repositoryForPackage: anObject! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34368496!repository: aString username: username password: password	self repositories repository: aString username: username password: password! !!MetacelloPackageSpec methodsFor: 'construction' stamp: 'dkh 6/8/2012 14:04:22'!repository: aString username: username password: password constructor: aVersionConstructor    aVersionConstructor repositoryForPackage: aString username: username password: password! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'dkh 7/2/2012 18:49'!repositoryDescriptions    ^ self repositorySpecs collect: [ :repoSpec | repoSpec description ]! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34368708!repositorySpecs	^self repositories map values! !!MetacelloPackageSpec methodsFor: 'construction' stamp: 'dkh 6/8/2012 14:04:22'!requires: anObject constructor: aVersionConstructor    aVersionConstructor requiresForPackage: anObject! !!MetacelloPackageSpec methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34368835!resolveToPackagesIn: aVersionSpec visited: visited	^{ self }! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34368997!savePackage	"Interactive save ... prompted for commit message and package name unless MCVersionNameAndMessageRequest handled"	| latestFile pkgSpec |	^(file notNil and: [ self name = self file ])		ifTrue: [			latestFile := self loader latestPackage: self name fromRepository: self repositorySpecs.			pkgSpec := self copy.			pkgSpec file: latestFile.			pkgSpec savePackage ]		ifFalse: [ self loader savePackageUsing: self repositorySpecs ]! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34369535!setPostLoadDoIt: aSymbol	postLoadDoIt := aSymbol! !!MetacelloPackageSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34369675!setPreLoadDoIt: aSymbol	preLoadDoIt := aSymbol! !!MetacelloPackageSpec methodsFor: 'construction' stamp: 'dkh 6/8/2012 14:04:22'!supplyingAnswers: anObject constructor: aVersionConstructor    aVersionConstructor supplyingAnswersForPackage: anObject! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'dkh 9/12/2012 12:14' prior: 34369823!updateForSpawnMethod: sourceSpec    "This means that this spec was used in a baseline and will be used in a version .... drop all information that isn't useful"    | nm fl |    nm := name.    fl := file.    fl == nil        ifTrue: [             "if only name has been set, then force the file to be non-nil, if any attribute besides file is set, then leave file nil"            {answers.            requires.            includes.            repositories.            preLoadDoIt.            postLoadDoIt} detect: [ :each | each ~~ nil ] ifNone: [ fl := name ] ].    super updateForSpawnMethod: sourceSpec.    file := repositories := goferPackage := preLoadDoIt := postLoadDoIt := nil.    name := nm.    file := fl.    ^ file == nil! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34370664!updatePackageRepositories: repositorySpecs	| resolvedPackageRef |	Transcript cr; show: '  Looking up version -> ', self file.	resolvedPackageRef := self loader resolveSpec: self from: repositorySpecs.	Transcript cr; show: 'Update repositoryGroup -> ', resolvedPackageRef name, ' ' , resolvedPackageRef repository description.	resolvedPackageRef version workingCopy repositoryGroup addRepository: resolvedPackageRef repository! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34371187!updatePackageRepositoriesFor: aVersionSpec	"Don't update the repository unless the package is loaded in the image"		self workingCopy == nil ifTrue: [ ^self ].	self updatePackageRepositories: self repositorySpecs, aVersionSpec repositorySpecs.	! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34371535!updatePackageSpec: updatedSpecs force: force using: anMCLoader	"Add pkg copy to updatedSpecs if the file in current image is different from the receiver's file"	| viName |	(force not and: [ self getFile == nil ])		ifTrue: [ ^ self ].	"no file explicitly specified in this spec"	(viName := self workingCopyNameFor: anMCLoader) == nil		ifTrue: [ ^ self ].	"no working copy"	viName ~= self file		ifTrue: [ 			| spec |			spec := self copy.			spec file: viName.			updatedSpecs at: spec name put: spec ]		ifFalse: [ updatedSpecs at: self name put: #uptodate ]! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34372202!updatePackageSpec: updatedSpecs using: anMCLoader	"Add pkg copy to updatedSpecs if the file in current image is different from the receiver's file"		self updatePackageSpec: updatedSpecs force: false using: anMCLoader! !!MetacelloPackageSpec methodsFor: 'visiting' stamp: 'dkh 6/8/2012 14:04:22' prior: 34372501!visitingWithPackages: packages	packages at: self name put: self! !!MetacelloPackageSpec methodsFor: 'gofer' stamp: 'dkh 6/8/2012 14:04:22' prior: 34372642!workingCopy	^self goferPackage workingCopy! !!MetacelloPackageSpec methodsFor: 'gofer' stamp: 'dkh 6/8/2012 14:04:22' prior: 34372763!workingCopyName	| wc |	(wc := self workingCopy) == nil ifTrue: [ ^nil ].	wc ancestry ancestors isEmpty not		ifTrue: [ ^wc ancestry ancestors first name ].	^nil! !!MetacelloPackageSpec methodsFor: 'gofer' stamp: 'dkh 6/8/2012 14:04:22' prior: 34373004!workingCopyNameFor: anMCLoader	| vi |	(vi := anMCLoader currentVersionInfoFor: self) == nil ifTrue: [ ^nil ].	^vi name! !!MetacelloAtomicLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34243179!directivesDo: aBlock	aBlock value: self.	self preloads do: [:directive | directive directivesDo: aBlock ].	self loadDirectives do: [:directive | directive directivesDo: aBlock ].	self postloads do: [:directive | directive directivesDo: aBlock ].! !!MetacelloAtomicLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34243525!finalizeLoad: aGofer	"load the accumulated packages (if any), reset the package list"	| pkgLoads |	self preloads do: [:directive | super loadPreloadDirective: directive ].	preloads := nil.	(pkgLoads := self packageloads) notEmpty 		ifTrue: [			self loader loadingSpecLoader 				loadPackageDirectives: pkgLoads 				gofer: aGofer.			self packageloads: nil ].	self postloads do: [:directive | super loadPostloadDirective: directive ].	postloads := nil! !!MetacelloAtomicLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34244081!loadAtomicLoadDirective: aLoaderDirective gofer: aGofer	aLoaderDirective loadDirectives do: [:directive | directive loadUsing: self gofer: aGofer ].! !!MetacelloAtomicLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34244327!loadLinearLoadDirective: aLoaderDirective gofer: aGofer	self finalizeLoad: aGofer.	super loadLinearLoadDirective: aLoaderDirective gofer: aGofer! !!MetacelloAtomicLoadDirective methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34244569!loadPackageDirective: aPackageLoadDirective gofer: aGofer	"accumulate packages"		self packageloads add: aPackageLoadDirective! !!MetacelloAtomicLoadDirective methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34244792!loadPostloadDirective: aPostloadDirective	"accumulate postloads"	self postloads add: aPostloadDirective! !!MetacelloAtomicLoadDirective methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34244993!loadPreloadDirective: aPreloadDirective 	"accumulate preloads"	self preloads add: aPreloadDirective! !!MetacelloAtomicLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34245190!loadUsing: aLoaderDirective gofer: aGofer	self loadDirectives isEmpty ifTrue: [ ^self ].	aLoaderDirective loadAtomicLoadDirective: self gofer: aGofer.! !!MetacelloAtomicLoadDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34245440!packageloads	packageloads == nil ifTrue: [ packageloads := OrderedCollection new ].	^ packageloads! !!MetacelloAtomicLoadDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34245637!packageloads: anObject	packageloads := anObject! !!MetacelloAtomicLoadDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34245781!postloads	postloads == nil ifTrue: [ postloads := OrderedCollection new ].	^ postloads! !!MetacelloAtomicLoadDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34245966!preloads	preloads == nil ifTrue: [ preloads := OrderedCollection new ].	^ preloads! !!MetacelloAtomicLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34246149!prepostLoadDirectivesDo: aBlock	self preloads do: [:directive | directive prepostLoadDirectivesDo: aBlock ].	self loadDirectives do: [:directive | directive prepostLoadDirectivesDo: aBlock ].	self postloads do: [:directive | directive prepostLoadDirectivesDo: aBlock ].! !!MetacelloAtomicLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34246520!prepostLoadsDo: aBlock	self preloads do: [:directive | directive prepostLoadDo: aBlock ].	self loadDirectives do: [:directive | directive prepostLoadDo: aBlock ].	self postloads do: [:directive | directive prepostLoadDo: aBlock ].	! !!MetacelloAtomicLoadDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34246852!title	^'atomic load'! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34399136!addToMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: self! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34399305!addToMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: self! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34399486!mergeIntoMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: self! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34399659!mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: self! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34399845!removeFromMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: self! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34400019!removeFromMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: self! !!MetacelloLoaderPolicy class methodsFor: 'instance creation' stamp: 'dkh 6/8/2012 14:04:22' prior: 34256228!overrideRepositories: aCollection	^self new overrideRepositories: aCollection! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34256388!cacheGofer	cacheGofer == nil 		ifTrue: [ 			"don't use a caching Gofer here, since we expect the contents to change during a fetch operation"			cacheGofer := Gofer new. 			cacheGofer disablePackageCache.			cacheGofer repository: self cacheRepository. ].	^ cacheGofer! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34256751!cacheRepository	cacheRepository == nil ifTrue: [ cacheRepository := MCDictionaryRepository new ].	^ cacheRepository! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34256949!cacheRepository: anMCRepository	cacheRepository := anMCRepository.	"getting a new repository, so wipe out the cacheGofer and ensureMap"	ensuredMap := cacheGofer := nil! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34257211!ensuredMap	ensuredMap == nil ifTrue: [ ensuredMap := Dictionary new ].	^ensuredMap! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34257387!ensuredMap: anObject	ensuredMap := anObject! !!MetacelloLoaderPolicy methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34257518!hasRepositoryOverrides	^self overrideRepositories ~~ nil! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34257665!ignoreImage	^ ignoreImage! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34257780!ignoreImage: anObject	ignoreImage := anObject! !!MetacelloLoaderPolicy methodsFor: 'initialize-release' stamp: 'dkh 6/8/2012 14:04:22' prior: 34257926!initialize	self 		repositoryMap; 		cacheRepository;		ensuredMap.	ignoreImage := false! !!MetacelloLoaderPolicy methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34258106!load	overrideRepositories := Array with: self cacheRepository. "ensure that hasRepositoryOverrides is true"	self loadDirective loadWithPolicy: self! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34258346!loadData 	loadData == nil ifTrue: [ loadData := MetacelloLoadData new ].	^loadData! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34258522!loadDirective	loadDirective == nil ifTrue: [ loadDirective := MetacelloLinearLoadDirective new ].	^ loadDirective! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34258727!overrideRepositories	^ overrideRepositories! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34258860!overrideRepositories: anObject	overrideRepositories := anObject! !!MetacelloLoaderPolicy methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34259011!pushAtomicLoadDirectivesDuring: aBlock for: aLoader	self pushLoadDirective: (MetacelloAtomicLoadDirective loader: aLoader) during: aBlock.! !!MetacelloLoaderPolicy methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34259240!pushExplicitLoadDirectivesDuring: aBlock for: aLoader	| directive |	directive := MetacelloExplicitLoadDirective loader: aLoader.	self pushLoadDirective: directive during: aBlock.	^directive! !!MetacelloLoaderPolicy methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34259521!pushLinearLoadDirectivesDuring: aBlock for: aLoader	self pushLoadDirective: (MetacelloLinearLoadDirective loader: aLoader) during: aBlock.! !!MetacelloLoaderPolicy methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34259749!pushLoadDirective: aLoaderDirective during: aBlock	|  oldRoot |	self loadDirective add: aLoaderDirective.	oldRoot := loadDirective.	loadDirective := aLoaderDirective.	aBlock ensure: [ loadDirective := oldRoot ].! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34260056!repositoryMap	repositoryMap == nil ifTrue: [ repositoryMap := Dictionary new ].	^repositoryMap! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34260242!repositoryMap: anObject	repositoryMap := anObject! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34260383!resetCacheGofer	cacheGofer := nil! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34260508!silently	silently == nil ifTrue: [ silently := false ].	^ silently! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34260667!silently: anObject	silently := anObject! !!MetacelloGoferPackage class methodsFor: 'instance creation' stamp: 'dkh 6/8/2012 14:04:22' prior: 34344730!name: aString packageFilename: packageFilename	^ self basicNew initializeName: aString packageFilename: packageFilename! !!MetacelloGoferPackage class methodsFor: 'package name matching' stamp: 'dkh 6/8/2012 14:04:22' prior: 34344958!packageFileName: pkgFileName matchesPackageName: wcPkgName	^(pkgFileName beginsWith: wcPkgName) 		ifTrue: [ 			(pkgFileName size = wcPkgName size) 			or: [ ((pkgFileName at: wcPkgName size + 1) = $-) 				or: [ ((pkgFileName at: wcPkgName size + 1) = $.) 					or: [ (pkgFileName at: wcPkgName size + 1) isDigit ]]]]		ifFalse: [			pkgFileName size >= wcPkgName size ifTrue: [ ^false ].			(wcPkgName beginsWith: pkgFileName) ifFalse: [ ^false ].			^(wcPkgName at: pkgFileName size + 1) = $. ]! !!MetacelloGoferPackage methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34345539!ancestors	| wc |	(wc := self workingCopy) ~~ nil		ifTrue: [ 			wc ancestry ancestors isEmpty not				ifTrue: [ ^wc ancestry ancestors ]].	^nil! !!MetacelloGoferPackage methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34345767!currentVersionInfo	| wc |	(wc := self workingCopy) ~~ nil		ifTrue: [ 			wc ancestry ancestors isEmpty not				ifTrue: [ ^wc ancestry ancestors first ]].	^nil! !!MetacelloGoferPackage methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34346010!findWorkingCopy	"Answer a working copy, or nil if the package is not loaded."	| wcs |	wcs := MCWorkingCopy allManagers select: [ :each | self matchesWorkingCopy: each ].	wcs isEmpty ifTrue: [ ^nil ].	^wcs detectMax: [:ea | ea package name size ]! !!MetacelloGoferPackage methodsFor: 'initialization' stamp: 'dkh 6/8/2012 14:04:22' prior: 34346348!initializeName: aString packageFilename: packagefilename	name := aString.	packageFilename := packagefilename! !!MetacelloGoferPackage methodsFor: 'private' stamp: 'dkh 6/30/2012 07:54' prior: 34346547!matches: aLoadableReference    "does Monticello-style #versionInfoFromVersionNamed: matching"    | pFilename refFilename char |    ((pFilename := self packageFilename) == nil or: [ self name = self packageFilename ])        ifTrue: [ ^ super matches: aLoadableReference ].    aLoadableReference name = pFilename        ifTrue: [ ^ true ].    (aLoadableReference name beginsWith: pFilename)        ifFalse: [ ^ false ].refFilename := aLoadableReference metacelloPackageNameWithBranch at: 2.    refFilename = pFilename        ifTrue: [ ^ true ].    pFilename size < refFilename size        ifTrue: [             (refFilename beginsWith: pFilename)                ifFalse: [ ^ false ].            (char := pFilename at: pFilename size) ~= $-                ifTrue: [ char := refFilename at: pFilename size + 1 ] ]        ifFalse: [             (pFilename beginsWith: refFilename)                ifFalse: [ ^ false ].            (char := refFilename at: refFilename size) ~= $-                ifTrue: [ char := pFilename at: refFilename size + 1 ] ].    ^ char = $. or: [ char = $- ]! !!MetacelloGoferPackage methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34346931!matchesWorkingCopy: aWorkingCopy	"check that the working copy package name matches the package file name and that the first ancestor's package file name	 matches the packageName"		| pFilename |	(pFilename := self packageFilename) == nil ifTrue: [ ^self error: 'cannot match working copy' ].	(self class 		packageFileName: pFilename 		matchesPackageName: aWorkingCopy package name)			ifTrue: [				aWorkingCopy ancestry ancestors isEmpty ifTrue: [ ^true ].				^self class 					packageFileName: aWorkingCopy ancestry ancestors first name 					matchesPackageName: self packageName ].	^false! !!MetacelloGoferPackage methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34347614!packageFilename	^packageFilename! !!MetacelloGoferPackage methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34347730!workingCopy		workingCopy == nil ifTrue: [ workingCopy := self findWorkingCopy ].	^workingCopy! !!MCDirectoryRepository methodsFor: '*metacello-mc' stamp: 'dkh 02/25/2013 16:13' prior: 34398905!asRepositorySpecFor: aMetacelloMCProject  ""  ^ directory asRepositorySpecFor: aMetacelloMCProject! !!MetacelloLoadData methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34254180!addVersion: version versionInfo: versionInfo resolvedReference: resolvedReference packageSpec: packageSpec	| vis |	"check for duplicates and use the one that is being added"	(vis := self packageNameMap at: packageSpec name ifAbsent: [  ]) ~~ nil		ifTrue: [ 			"remove old references"			vis				do: [ :vi | 					self dataMap removeKey: vi name.					self versionInfoMap removeKey: vi name ] ].	self dataMap		at: version info name		put:			{version.			resolvedReference.			packageSpec}.	self versionInfoMap at: versionInfo name put: {versionInfo}.	self packageNameMap at: packageSpec name put: {versionInfo}! !!MetacelloLoadData methodsFor: 'versionInfo' stamp: 'dkh 6/8/2012 14:04:22' prior: 34254878!ancestorsFor: packageSpec ifAbsent: aBlock	^self versionInfoMap 		at: packageSpec file 		ifAbsent: [ 			self  packageNameMap 				at: packageSpec name				ifAbsent: aBlock ]! !!MetacelloLoadData methodsFor: 'versionInfo' stamp: 'dkh 6/8/2012 14:04:22' prior: 34255136!currentVersionInfoFor: packageSpec ifAbsent: aBlock	^self versionInfoMap 		at: packageSpec file 		ifAbsent: [ 			self  packageNameMap 				at: packageSpec name				ifAbsent: aBlock ]! !!MetacelloLoadData methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34255401!dataMap	dataMap == nil ifTrue: [ dataMap := Dictionary new ].	^dataMap! !!MetacelloLoadData methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34255553!do: aBlock	self dataMap valuesDo: [:ar |		aBlock value: (ar at: 1) value: (ar at: 2) value: (ar at: 3) ]! !!MetacelloLoadData methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34255736!isEmpty	^self dataMap isEmpty! !!MetacelloLoadData methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34255845!packageNameMap	packageNameMap == nil ifTrue: [ packageNameMap := Dictionary new ].	^packageNameMap! !!MetacelloLoadData methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34256024!versionInfoMap	versionInfoMap == nil ifTrue: [ versionInfoMap := Dictionary new ].	^versionInfoMap! !!MCVersionLoader methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34277352!versions	^versions! !!MetacelloPostLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34241057!addTo: aLoaderDirective	spec postLoadDoIt value ~~ nil ifTrue: [ aLoaderDirective add: self ]! !!MetacelloPostLoadDirective methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34241247!label	^super label, ' >> ', self spec postLoadDoIt value asString! !!MetacelloPostLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34241407!loadUsing: aLoaderDirective gofer: aGofer	aLoaderDirective loadPostloadDirective: self.! !!MetacelloPostLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34241589!postLoadDo: aBlock	aBlock value: self! !!MetacelloPostLoadDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34241722!title	^'postload'! !!MetacelloCachingGoferResolvedReference methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34305246!version	"Answer a Monticello version of the receiver."	cachedVersion == nil ifTrue: [ cachedVersion := super version ].	^cachedVersion! !!MetacelloCachingGoferResolvedReference methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34305491!workingCopy	"Answer a working copy or throw an error if not present."	| pName |	cachedVersion == nil ifTrue: [ ^super workingCopy ].	pName := cachedVersion package name.	^MCWorkingCopy allManagers		detect: [ :each | pName = each packageName ]		ifNone: [ self error: 'Working copy for ' , self name , ' not found' ]! !!MetacelloBaselineConstructor methodsFor: '*metacello-mc-accessing' stamp: 'dkh 6/5/2012 19:01:24'!projectClass    ^ MetacelloMCBaselineProject! !!MetacelloRepositorySpec methodsFor: 'adding' stamp: 'dkh 6/8/2012 14:04:22' prior: 34278724!addToMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec addMember 			name: self name;			spec: self;			yourself)! !!MetacelloRepositorySpec methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34278991!configMethodCascadeOn: aStream lastCascade: lastCascade	aStream nextPutAll: 'repository: ', self description printString.	(self username isEmpty not or: [ self password isEmpty not ])		ifTrue: [ aStream nextPutAll: ' username: ', self username printString, ' password: ', self password printString ].	lastCascade ifFalse: [ aStream nextPut: $;; cr ].! !!MetacelloRepositorySpec methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34279430!configMethodOn: aStream indent: indent	aStream 		tab: indent; 		nextPutAll: 'spec '.	self configMethodCascadeOn: aStream lastCascade: true! !!MetacelloRepositorySpec methodsFor: 'mc support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34279658!createRepository    | repo |    repo := self project createRepository: self.    ^ MCRepositoryGroup default repositories detect: [ :each | each = repo ] ifNone: [ repo ]! !!MetacelloRepositorySpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34279797!description	^description! !!MetacelloRepositorySpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34279907!description: aString	description := aString! !!MetacelloRepositorySpec methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34280040!extractTypeFromDescription	^MetacelloPlatform current extractTypeFromDescription: self description! !!MetacelloRepositorySpec methodsFor: 'mc support' stamp: 'dkh 07/16/2013 19:35'!hasNoLoadConflicts: aMetacelloProjectSpec  self description = aMetacelloProjectSpec description    ifTrue: [ ^ true ].  self type = 'github'    ifTrue: [       ^ self createRepository        hasNoLoadConflicts: aMetacelloProjectSpec createRepository ].  ^ false! !!MetacelloRepositorySpec methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34280220!mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec mergeMember 			name: self name;			spec: self;			yourself)! !!MetacelloRepositorySpec methodsFor: 'merging' stamp: 'dkh 6/8/2012 14:04:22' prior: 34280492!mergeMap    | map |    map := super mergeMap.    map at: #'description' put: description.    map at: #'type' put: self type.    map at: #'username' put: username.    map at: #'password' put: password.    ^ map! !!MetacelloRepositorySpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34280755!name	^self description! !!MetacelloRepositorySpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34280862!password	password == nil ifTrue: [ password := '' ].	^password! !!MetacelloRepositorySpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34281011!password: aString	password := aString! !!MetacelloRepositorySpec methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34281130!removeFromMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec removeMember 			name: self name;			spec: self;			yourself)! !!MetacelloRepositorySpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34281405!type	type == nil ifTrue: [ type := self extractTypeFromDescription ].	^type! !!MetacelloRepositorySpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34281567!type: aString	type := aString! !!MetacelloRepositorySpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34281681!username	username == nil ifTrue: [ username := '' ].	^username! !!MetacelloRepositorySpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34281830!username: aString	username := aString! !!MetacelloPreLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34241834!addTo: aLoaderDirective	spec preLoadDoIt value ~~ nil ifTrue: [ aLoaderDirective add: self ]! !!MetacelloPreLoadDirective methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34242022!label	^super label, ' >> ', self spec preLoadDoIt value asString! !!MetacelloPreLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34242180!loadUsing: aLoaderDirective gofer: aGofer	aLoaderDirective loadPreloadDirective: self.	! !!MetacelloPreLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34242361!preLoadDo: aBlock	aBlock value: self! !!MetacelloPreLoadDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34242492!title	^'preload'! !!MetacelloAbstractVersionConstructor methodsFor: '*metacello-mc-accessing' stamp: 'dkh 6/8/2012 14:04:22'!projectClass    ^ MetacelloMCProject! !!MetacelloGroupSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34303138!loadUsing: aLoader gofer: gofer	"noop"! !!MetacelloGroupSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34303268!resolveToLoadableSpec	^nil! !!MetacelloGroupSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34303387!resolveToPackagesIn: aVersionSpec into: packages visited: visited	visited 		visit: self 		doing: [:aSpec | | map |			map := aVersionSpec packages map.			aSpec includes do: [:pkgName | 				(aVersionSpec packageNamed: pkgName forMap: map ifAbsent: [])					projectDo: [:ignored | ] 					packageDo: [:pkg | packages at: pkg name put: pkg ] 					groupDo: [:grp | grp resolveToPackagesIn: aVersionSpec into: packages visited: visited ]]]! !!MetacelloGroupSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34303911!resolveToPackagesIn: aVersionSpec visited: visited	| packages |	packages := Dictionary new.	self resolveToPackagesIn: aVersionSpec into: packages visited: visited.	^packages values asOrderedCollection! !!MCFileBasedRepository methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34230663!versionInfoFromVersionNamed: aString	| versions |	versions := self allVersionNames		select: [ :each | each beginsWith: aString ].	versions isEmpty ifTrue: [ ^ nil ].	versions := versions asSortedCollection: [ :a :b |		([ (a copyAfterLast: $.) asNumber ] on: Error do: [:ex | ex return: 0 ]) <= 			([ (b copyAfterLast: $.) asNumber ] on: Error do: [:ex | ex return: 0 ]) ].	^ self versionInfoFromFileNamed: versions last , '.mcz'! !!MetacelloGofer methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34276474!basicReferencesIn: aRepository	((aRepository isKindOf: MCDictionaryRepository) or: [aRepository isKindOf: MCDirectoryRepository])		ifTrue: [ 			"No need to cache references for a dictionary repository"			^ super basicReferencesIn: aRepository ].	"Use cache for network-based repositories - the contents of repository is cached based on first access 	 and is _not_ updated afterword, so any mcz files added after the initial cache is created won't be seen"	^ MetacelloPlatform current		stackCacheFor: #goferRepository		cacheClass: IdentityDictionary		at: aRepository		doing: [ :cache | 			^ cache at: aRepository put: (super basicReferencesIn: aRepository) ]! !!MetacelloGofer methodsFor: 'operations' stamp: 'dkh 6/8/2012 14:04:22' prior: 34277218!interactiveCommit	^ self execute: MetacelloGoferCommit! !!BlockClosure methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34348110!valueSupplyingMetacelloAnswers: aListOfPairs	"evaluate the block using a list of questions / answers that might be called upon to	automatically respond to Object>>confirm: or FillInTheBlank requests"	^ [self value] 		on: ProvideAnswerNotification		do: 			[:notify | | answer caption |						caption := notify messageText withSeparatorsCompacted. "to remove new lines"			answer := aListOfPairs				detect: 					[:each | caption = each first or:						[(caption includesSubstring: each first caseSensitive: false) or:						[(each first match: caption) or:						[(String includesSelector: #matchesRegex:) and: 						[ [ caption matchesRegex: each first ] on: Error do: [:ignored | false ]]]]]]					ifNone: [nil].			answer				ifNotNil: [notify resume: answer second]				ifNil: 					[ | outerAnswer |					outerAnswer := ProvideAnswerNotification signal: notify messageText.					outerAnswer 						ifNil: [notify resume] 						ifNotNil: [notify resume: outerAnswer]]]! !!MetacelloGoferCommit methodsFor: 'running' stamp: 'dkh 6/8/2012 14:04:22' prior: 34393723!execute: aWorkingCopy	| version |	version := aWorkingCopy newVersion.	self gofer repositories		do: [ :repository | repository storeVersion: version ]! !!MetacelloLinearLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34247906!loadUsing: aLoaderDirective gofer: aGofer	self loadDirectives isEmpty ifTrue: [ ^self ].	aLoaderDirective loadLinearLoadDirective: self gofer: aGofer.! !!MetacelloLinearLoadDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34248156!title	^'linear load'! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34281950!computeVersionStatus: matchBlock	self computeVersionStatus: (self expandToLoadableSpecNames: #('ALL')) matchBlock: matchBlock! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34282158!computeVersionStatus: resolvedPackageAndProjectNames matchBlock: matchBlock	| status |	status := resolvedPackageAndProjectNames isNil		ifTrue: [ self isPartiallyCurrent ]		ifFalse: [ self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames ].	status isAllLoadedToSpec: matchBlock.	status isLoadedToSpec: matchBlock.	status isLoadedMatchConstraints: matchBlock.	status isSomethingLoaded: matchBlock! !!MetacelloMCVersionSpec methodsFor: 'printing' stamp: 'dkh 9/10/2012 15:57' prior: 34282660!configMethodOn: aStream last: last indent: indent    | spec hasRepositories hasPackageSpecs hasImport |    hasRepositories := (spec := self repositoriesSpec) ~~ nil and: [ spec list isEmpty not ].    hasImport := self import ~~ nil.    hasPackageSpecs := false.    self packagesSpec list        do: [ :member |             member spec                projectDo: [ :proj |                     member spec name ~~ nil                        ifTrue: [ hasPackageSpecs := true ] ]                packageDo: [ :package |                     member spec name ~~ nil                        ifTrue: [ hasPackageSpecs := true ] ]                groupDo: [ :group |                     member spec name ~~ nil                        ifTrue: [ hasPackageSpecs := true ] ] ].    self configMethodBasicOn: aStream last: (hasRepositories | hasPackageSpecs | hasImport) not indent: indent.    hasImport        ifTrue: [             self                configMethodValueOn: aStream                for: self import                selector: 'import:'                last: (hasRepositories | hasPackageSpecs) not                indent: indent ].    hasRepositories        ifTrue: [             spec map values size = 1                ifTrue: [                     aStream                        tab: indent;                        nextPutAll: 'spec repository: ';                        nextPutAll: spec map values first description printString , '.'.                    hasPackageSpecs                        ifTrue: [ aStream cr ] ]                ifFalse: [                     self                        configMethodOn: aStream                        for: spec                        selector: 'repositories:'                        last: hasPackageSpecs not                        indent: indent ] ].    self configPackagesSpecMethodOn: aStream indent: indent.    last        ifFalse: [ aStream cr ]! !!MetacelloMCVersionSpec methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34285764!configSpawnMethodOn: aStream indent: indent	super configSpawnMethodOn: aStream indent: indent.	self configPackagesSpecMethodOn: aStream indent: indent.! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: 'dkh 05/08/2013 09:32' prior: 34286009!currentlyLoadedClassesInVersion  | classes |  classes := Set new.  self    projectDo: [ :ignored |  ]    packageDo: [ :packageSpec |       | wc |      wc := [ packageSpec workingCopy ]        on: Error        do: [ :ex | ex return: nil ].      wc ~~ nil        ifTrue: [ classes addAll: (MetacelloPlatform current packageInfoFor: wc) classes ] ]    groupDo: [ :ignored |  ].  ^ classes! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: 'dkh 05/08/2013 09:32' prior: 34286417!currentlyLoadedExtensionClassesInVersion  | classes |  classes := Dictionary new.  self    projectDo: [ :ignored |  ]    packageDo: [ :packageSpec |       | wc |      wc := [ packageSpec workingCopy ]        on: Error        do: [ :ex | ex return: nil ].      wc ~~ nil        ifTrue: [           | packageInfo |          packageInfo := MetacelloPlatform current packageInfoFor: wc.          packageInfo extensionClasses            do: [ :cl | classes at: cl put: (packageInfo extensionCategoriesForClass: cl) ] ] ]    groupDo: [ :ignored |  ].  ^ classes! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: 'dkh 9/11/2012 11:57' prior: 34287281!difference: otherVersionSpec    "Return a dictionary of additions, removals and modifications"    | report myProjectSpecs myPackageSpecs otherProjectSpecs otherPackageSpecs |    report := MetacelloVersionDiffReport new.    myProjectSpecs := Dictionary new.    myPackageSpecs := Dictionary new.    self        projectDo: [ :projectSpec | myProjectSpecs at: projectSpec name put: projectSpec ]        packageDo: [ :packageSpec | myPackageSpecs at: packageSpec name put: packageSpec ]        groupDo: [ :ignored |  ].    otherProjectSpecs := Dictionary new.    otherPackageSpecs := Dictionary new.    otherVersionSpec        projectDo: [ :projectSpec | otherProjectSpecs at: projectSpec name put: projectSpec ]        packageDo: [ :packageSpec | otherPackageSpecs at: packageSpec name put: packageSpec ]        groupDo: [ :ignored |  ].    myProjectSpecs        valuesDo: [ :myProjectSpec |             | otherProjectSpec |            otherProjectSpec := otherProjectSpecs at: myProjectSpec name ifAbsent: [  ].            otherProjectSpec == nil                ifTrue: [                     report removals                        at: myProjectSpec name                        put:                            {(myProjectSpec versionString).                            ''} ]                ifFalse: [                     myProjectSpec versionString = otherProjectSpec versionString                        ifFalse: [                             report modifications                                at: myProjectSpec name                                put:                                    {(myProjectSpec versionString).                                    (otherProjectSpec versionString)} ] ] ].    otherProjectSpecs        valuesDo: [ :otherProjectSpec |             (myProjectSpecs at: otherProjectSpec name ifAbsent: [  ]) == nil                ifTrue: [                     report additions                        at: otherProjectSpec name                        put:                            {''.                            (otherProjectSpec versionString)} ] ].    myPackageSpecs        valuesDo: [ :myPackageSpec |             | otherPackageSpec |            otherPackageSpec := otherPackageSpecs at: myPackageSpec name ifAbsent: [  ].            otherPackageSpec == nil                ifTrue: [                     report removals                        at: myPackageSpec name                        put:                            {(myPackageSpec file).                            ''} ]                ifFalse: [                     myPackageSpec file = otherPackageSpec file                        ifFalse: [                             report modifications                                at: myPackageSpec name                                put:                                    {(myPackageSpec file).                                    (otherPackageSpec file)} ] ] ].    otherPackageSpecs        valuesDo: [ :otherPackageSpec |             (myPackageSpecs at: otherPackageSpec name ifAbsent: [  ]) == nil                ifTrue: [                     report additions                        at: otherPackageSpec name                        put:                            {''.                            (otherPackageSpec file)} ] ].    ^ report! !!MetacelloMCVersionSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34290205!forceUpdatedPackageSpecs	| updatedSpecs mcLoader |	updatedSpecs := Dictionary new.	mcLoader := self loader.	self packages map valuesDo: [:pkg | pkg forceUpdatePackageSpec: updatedSpecs using: mcLoader].	^updatedSpecs! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34290508!isAllLoadedToSpec	"all projects and packages are loaded and match specification"	self isPartiallyCurrent isAllLoadedToSpec: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34290746!isAllLoadedToSpecAgainst: resolvedPackageAndProjectNames	"all projects and packages are loaded and match specification"	(self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames) isAllLoadedToSpec: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34291065!isLoadedMatchConstraints	"all loaded projects and packages match constraints (at least one package loaded)"		self isPartiallyCurrent isLoadedMatchConstraints: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34291338!isLoadedMatchConstraintsAgainst: resolvedPackageAndProjectNames	"all loaded projects and packages match constraints (at least one package loaded)"	(self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames) isLoadedMatchConstraints: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34291691!isLoadedToSpec	"all loaded projects and packages match specifications (at least one package loaded)"		self isPartiallyCurrent isLoadedToSpec: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34291948!isLoadedToSpecAgainst: resolvedPackageAndProjectNames	"all loaded projects and packages match specifications (at least one package loaded)"	(self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames) isLoadedToSpec: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34292282!isPartiallyCurrent	^self isPartiallyCurrentAgainst: (self expandToLoadableSpecNames: #('ALL'))! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34292458!isPartiallyCurrentAgainst: resolvedPackageAndProjectNames	| mcLoader status |	status := MetacelloMCPartiallyLoadedStatus new.	mcLoader := self loader.	self		specsNamed: resolvedPackageAndProjectNames		projectDo: [ :prj | 			| vrsn currentVersion |			status hasNoProject: false.			vrsn := prj versionOrNil.			vrsn ~~ nil				ifTrue: [ 					(currentVersion := prj relativeCurrentVersion) ~~ nil						ifTrue: [ status vrsnStatus add: currentVersion versionStatus ] ].			currentVersion ~~ nil				ifTrue: [ 					status aProjectIsLoaded: true.					(currentVersion perform: #= with: vrsn)						ifTrue: [ status aLoadedProjectIsExact: true ]						ifFalse: [ 							(currentVersion perform: prj projectReference operator with: vrsn)								ifTrue: [ status aLoadedProjectIsCurrent: true ]								ifFalse: [ status aLoadedProjectIsNotCurrent: true ] ] ]				ifFalse: [ status aProjectNotLoaded: true ] ]		packageDo: [ :pkg | 			status hasNoPackage: false.			pkg				currentPackageLoaded: [ :versionInfos :file | 					| wcName wcRef fileRef exact current |					status aPackageIsLoaded: true.					versionInfos isEmpty						ifTrue: [ status aLoadedPackageIsNotCurrent: true ]						ifFalse: [ 							exact := current := false.							versionInfos								do: [ :vi | 									wcName := vi name.									fileRef := GoferResolvedReference name: file.									wcRef := GoferResolvedReference name: wcName.									(wcRef compare: fileRef using: #=)										ifTrue: [ exact := true ] ].							exact								ifTrue: [ status aLoadedPackageIsExact: true ]								ifFalse: [ 									versionInfos										do: [ :vi | 											wcName := vi name.											fileRef := GoferResolvedReference name: file.											wcRef := GoferResolvedReference name: wcName.											(wcRef compare: fileRef using: #>=)												ifTrue: [ current := true ] ].									current										ifTrue: [ status aLoadedPackageIsCurrent: true ]										ifFalse: [ status aLoadedPackageIsNotCurrent: true ] ] ] ]				notLoaded: [ status aPackageNotLoaded: true ]				using: mcLoader ]		groupDo: [ :ignoredGroup | 			"if we encounter a group, trouble"			status abort: true.			^ status ].	^ status! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34294751!isPossibleBaseline	self 		projectDo: [:prj | prj isPossibleBaseline ifFalse: [ ^false ]] 		packageDo: [:pkg | pkg isPackageLoaded ifFalse: [ ^false ]] 		groupDo: [:ignored | ].	^true! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34295020!isSomethingLoaded	"at least one package loaded"		self isPartiallyCurrent isSomethingLoaded: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34295227!isSomethingLoadedAgainst: resolvedPackageAndProjectNames	"at least one package loaded"	(self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames) isSomethingLoaded: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'merging' stamp: 'dkh 9/11/2012 12:11' prior: 34295513!mergeMap    | map |    map := super mergeMap.    map at: #'repositories' put: self repositories.    ^ map! !!MetacelloMCVersionSpec methodsFor: 'merging' stamp: 'dkh 9/11/2012 12:12' prior: 34295727!mergeSpec: anotherSpec    | newSpec map anotherRepositories |    newSpec := super mergeSpec: anotherSpec.    map := anotherSpec mergeMap.    (anotherRepositories := map at: #'repositories') isEmpty not        ifTrue: [             newSpec                repositories:                    (self repositories isEmpty                        ifTrue: [ anotherRepositories ]                        ifFalse: [ self repositories mergeSpec: anotherRepositories ]) ].    ^ newSpec! !!MetacelloMCVersionSpec methodsFor: 'merging' stamp: 'dkh 9/11/2012 12:11' prior: 34296414!nonOverridable    ^ super nonOverridable , #(#'repositories')! !!MetacelloMCVersionSpec methodsFor: 'construction' stamp: 'dkh 6/8/2012 14:04:22'!package: aString constructor: aVersionConstructor    aVersionConstructor packageForVersion: aString! !!MetacelloMCVersionSpec methodsFor: 'construction' stamp: 'dkh 6/8/2012 14:04:22'!package: aString overrides: aBlock constructor: aVersionConstructor    aVersionConstructor packageForVersion: aString overrides: aBlock! !!MetacelloMCVersionSpec methodsFor: 'construction' stamp: 'dkh 6/8/2012 14:04:22'!package: packageName with: aBlockOrString constructor: aVersionConstructor    aVersionConstructor packageForVersion: packageName with: aBlockOrString! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: 'dkh 9/11/2012 13:42' prior: 34297362!packageNames    "leave reference to packages for upgrade purposes"    packages == nil        ifTrue: [ ^ super packageNames ].    ^ self packages map keys asSet! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: 'dkh 9/11/2012 12:26'!packageSpecsInLoadOrderForMap: packageMap    | loadOrder pkgs packageNames importNames importProjectSpec importSpec |    loadOrder := self packageSpecsInLoadOrder.    importNames := (packageNames := (packageMap values collect: [ :pkg | pkg name ]) asSet) copy.    self import ifNil: [ ^ loadOrder select: [ :pkg | packageNames includes: pkg name ] ].    loadOrder do: [ :pkg | importNames remove: pkg name ifAbsent: [  ] ].    pkgs := OrderedCollection new.    importProjectSpec := loadOrder detect: [ :pkg | pkg name = self import ].    loadOrder        do: [ :pkg |             (packageNames includes: pkg name)                ifTrue: [ pkgs add: pkg ].            pkg name = self import                ifTrue: [                     "insert the imports at this point"                    importNames                        do: [ :importedName |                             pkgs                                add:                                    (importSpec := importProjectSpec copy                                        name: importedName;                                        mergeImportLoads: {importedName};                                        yourself).                            importSpec projectReference name: importedName ] ] ].    ^ pkgs! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: 'dkh 9/11/2012 13:41' prior: 34297669!packages    "leave reference to packages for upgrade purposes"    packages == nil        ifTrue: [ ^ super packages ].    ^ packages! !!MetacelloMCVersionSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34297972!packagesNeedSavingVisited: visitedProjects into: aCollection	self packages map valuesDo: [:pkg | pkg packagesNeedSavingVisited: visitedProjects using: self repositories map values into: aCollection ].! !!MetacelloMCVersionSpec methodsFor: 'copying' stamp: 'dkh 9/11/2012 13:42' prior: 34298366!postCopy    super postCopy.    repositories := repositories copy.    packages := packages copy	"leave reference to packages for upgrade purposes"! !!MetacelloMCVersionSpec methodsFor: 'construction' stamp: 'dkh 6/8/2012 14:04:22'!removePackage: aString constructor: aVersionConstructor    aVersionConstructor removePackageForVersion: aString! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34298819!repositories	repositories == nil ifTrue: [ repositories := self project repositoriesSpec ].	^ repositories! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34299008!repositories: anObject	repositories := anObject! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34299138!repositoriesSpec	^self repositories! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34299257!repository: aString	self repositoriesSpec add: aString! !!MetacelloMCVersionSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34299395!repository: aString username: username password: password	self repositoriesSpec repository: aString username: username password: password! !!MetacelloMCVersionSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34299613!repositorySpecs	^self repositories map values! !!MetacelloMCVersionSpec methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34301696!specListProjectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	self packages specListDo: [:pkgSpec |		pkgSpec projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock ]! !!MetacelloMCVersionSpec methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34301985!specsNamed: packageAndProjectNames projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	| map |	map := self packages map.	packageAndProjectNames do: [:name | | pkgSpec |		(pkgSpec := map at: name ifAbsent: [ ]) ~~ nil			ifTrue: [ pkgSpec projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock ]]! !!MetacelloMCVersionSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34302416!updateForSpawnMethod: sourceSpec	"This means that this spec was used in a baseline and will be used in a version .... drop all information that isn't useful"		repositories := preLoadDoIt := postLoadDoIt := nil.! !!MetacelloMCVersionSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34302722!updatedPackageSpecs	| updatedSpecs mcLoader |	updatedSpecs := Dictionary new.	mcLoader := self loader.	self packages map valuesDo: [:pkg | pkg updatePackageSpec: updatedSpecs using: mcLoader].	^updatedSpecs! !!MetacelloMCVersionSpec methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34303014!versionClass	^MetacelloMCVersion! !!MetacelloExplicitLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34246971!explicitLoadUsing: aLoaderDirective gofer: aGofer	aLoaderDirective loadLinearLoadDirective: self gofer: aGofer.! !!MetacelloExplicitLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34247172!explicitLoadWithPolicy: aLoadPolicy	| gofer |	gofer := MetacelloGofer new.	gofer disablePackageCache.	gofer repository: aLoadPolicy cacheRepository.	self explicitLoadUsing: self gofer: gofer! !!MetacelloExplicitLoadDirective methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34247465!isExplicit	^true! !!MetacelloExplicitLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34247580!loadUsing: aLoaderDirective gofer: aGofer	aLoaderDirective loadExplicitLoadDirective: self gofer: aGofer.! !!MetacelloExplicitLoadDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34247787!title	^'explicit load'! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc-querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34349193!file 	"MetacelloPackageSpec compatibility"		^nil! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34349346!forceUpdatePackageSpec: updatedSpecs using: anMCLoader	^self updatePackageSpec: updatedSpecs using: anMCLoader! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc-querying' stamp: 'dkh 03/12/2013 20:25'!getFile  "MetacelloPackageSpec compatibility"  ^ nil! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc-querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34349569!isPackageLoaded	^false! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34349693!loadUsing: aLoader gofer: gofer	^self subclassResponsibility! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34349966!packagesNeedSavingVisited: visitedProjects using: repos into: aCollection	"noop by default"! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc-querying' stamp: 'dkh 6/30/2012 12:32' prior: 34350160!repository    self deprecated: 'Use repositories or repositorySpecs'.    ^ nil! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34350271!repositorySpecs	^#()! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34350386!resolveToAllPackagesIn: aVersionSpec into: packages visited: visited	visited		visit: self		doing: [:spec |			self visitingWithPackages: packages.			(spec includes, spec requires) do: [:pkgName |				(aVersionSpec packageNamed: pkgName)					projectDo: [:prj | 						(prj resolveToAllPackagesIn: aVersionSpec visited: visited) do: [:pkg | 							packages at: pkg name put: pkg ]] 					packageDo: [:pkg | 						packages at: pkg name put: pkg.						(pkg resolveToAllPackagesIn: aVersionSpec visited: visited) do: [:rpkg | 							packages at: rpkg name put: rpkg ] ] 					groupDo: [:grp | grp resolveToAllPackagesIn: aVersionSpec into: packages  visited: visited ]]]! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34351154!resolveToAllPackagesIn: aVersionSpec visited: visited	| packages |	packages := Dictionary new.	self resolveToAllPackagesIn: aVersionSpec into: packages visited: visited.	^packages values asOrderedCollection! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34351458!resolveToLoadableSpec	^self! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34351580!resolveToPackagesIn: aVersionSpec visited: visited	^self subclassResponsibility! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34351763!updateForSpawnMethod: sourceSpec	"This means that this spec was used in a baseline and will be used in a version .... drop all information that isn't useful"	answers := name := requires := includes := nil! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34352063!updatePackageRepositoriesFor: aVersionSpec	"noop by default"		^true! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34352226!updatePackageSpec: updatedSpecs using: anMCLoader	"Add pkg copy to updatedSpecs if the file in current image is different from the receiver's file"! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc-querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 34352477!version 	"MetacelloPackageSpec compatibility"		^nil! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34352624!visitingWithPackages: packages	"noop"! !!Collection methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34308886!addToMetacelloRepositories: aMetacelloRepositoriesSpec	self do: [:each | each addToMetacelloRepositories: aMetacelloRepositoriesSpec ]! !!Collection methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34309105!fetchRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doFetchRequiredFromArray: self.! !!Collection methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34309297!loadRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doLoadRequiredFromArray: self.! !!Collection methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34309478!mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec	self do: [:each | each mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec ]! !!Collection methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34309706!recordRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doRecordRequiredFromArray: self.! !!Collection methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34309891!removeFromMetacelloRepositories: aMetacelloRepositoriesSpec	self do: [:each | each removeFromMetacelloRepositories: aMetacelloRepositoriesSpec ]! !!Collection methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34310113!resolvePackageSpecsNamedForMetacelloMCVersion: aMetacelloMCVersion visited: visited ifAbsent: aBlock    ^ aMetacelloMCVersion        allPackagesForSpecs: (self collect: [ :ea | aMetacelloMCVersion packageNamed: ea ifAbsent: aBlock ])        visited: visited! !!MetacelloVersionLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34248273!add: aDirective	self loadDirectives add: aDirective! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34248425!directivesDo: aBlock	aBlock value: self.	self loadDirectives do: [:directive | directive directivesDo: aBlock ].! !!MetacelloVersionLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34248636!finalizeLoad: aGofer	"nothing special for linear loads"! !!MetacelloVersionLoadDirective methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34248788!isExplicit	^false! !!MetacelloVersionLoadDirective methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34248904!label	self spec == nil ifTrue: [ ^'' ].	^self spec label! !!MetacelloVersionLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34249059!loadAtomicLoadDirective: aLoaderDirective gofer: aGofer	aLoaderDirective loadDirectives do: [:directive | directive loadUsing: aLoaderDirective gofer: aGofer ].	aLoaderDirective finalizeLoad: aGofer.! !!MetacelloVersionLoadDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34249358!loadDirectives	loadDirectives == nil ifTrue: [ loadDirectives := OrderedCollection new ].	^ loadDirectives! !!MetacelloVersionLoadDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34249564!loadDirectives: anObject	loadDirectives := anObject! !!MetacelloVersionLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34249712!loadExplicitLoadDirective: aLoaderDirective gofer: aGofer	"load has already been performed, no need to load again"! !!MetacelloVersionLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34249923!loadLinearLoadDirective: aLoaderDirective gofer: aGofer	aLoaderDirective loadDirectives do: [:directive | directive loadUsing: aLoaderDirective gofer: aGofer ].	aLoaderDirective finalizeLoad: aGofer.! !!MetacelloVersionLoadDirective methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34250220!loadPackageDirective: aPackageLoadDirective gofer: aGofer	aPackageLoadDirective loader loadingSpecLoader 		loadPackageDirective: aPackageLoadDirective 		gofer: aGofer! !!MetacelloVersionLoadDirective methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34250487!loadPostloadDirective: aPostloadDirective 	| block |	(block :=  aPostloadDirective spec postLoadDoItBlock) ~~ nil		ifTrue: [			aPostloadDirective evaluateSupplyingAnswers: [ block valueWithPossibleArgs: 					(Array 						with: aPostloadDirective loader 						with: aPostloadDirective spec) ].			Transcript cr; show: 'Evaluated -> ', aPostloadDirective spec label, ' >> ', aPostloadDirective spec postLoadDoIt value asString]! !!MetacelloVersionLoadDirective methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34251017!loadPreloadDirective: aPreloadDirective 	| block |	(block :=  aPreloadDirective spec preLoadDoItBlock) ~~ nil		ifTrue: [			aPreloadDirective evaluateSupplyingAnswers: [ block valueWithPossibleArgs: 					(Array 						with: aPreloadDirective loader 						with: aPreloadDirective spec) ].			Transcript cr; show: 'Evaluated -> ', aPreloadDirective spec label, ' >> ', aPreloadDirective spec preLoadDoIt value asString]! !!MetacelloVersionLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34251526!loadWithPolicy: aLoadPolicy	| gofer |	gofer := MetacelloGofer new.	gofer disablePackageCache.	gofer repository: aLoadPolicy cacheRepository.	self loadUsing: self gofer: gofer! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34251806!packageDirectivesDo: aBlock	self loadDirectives do: [:directive | directive packageDirectivesDo: aBlock ].! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34252014!packagesDo: aBlock	self loadDirectives do: [:directive | directive packageDo: aBlock ].! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34252202!prepostLoadDirectivesDo: aBlock	self loadDirectives do: [:directive | directive prepostLoadDirectivesDo: aBlock ].! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34252417!prepostLoadsDo: aBlock	self loadDirectives do: [:directive | directive prepostLoadDo: aBlock ].! !!MetacelloVersionLoadDirective methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34252610!printLoadDirectivesOn: aStream indent: indent	self loadDirectives do: [:each |		aStream cr. 		each printOn: aStream indent: indent + 1 ].! !!MetacelloVersionLoadDirective methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34252847!printOn: aStream indent: indent	super printOn: aStream indent: indent.	self printLoadDirectivesOn: aStream indent: indent! !!MetacelloVersionLoadDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34253070!spec	"Expected to be a MetacelloVersionSpec"		(spec == nil  and: [  self loader ~~ nil ]) 		ifTrue: [ 			^[ self loader spec versionSpec ] 				on: MessageNotUnderstood				do: [:ex | ex return: self loader spec ]].	^spec! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34253397!versionDirectivesDepthFirstDo: aBlock	self loadDirectives do: [:directive | directive versionDirectivesDepthFirstDo: aBlock ].	aBlock value: self.! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34253647!versionDirectivesDo: aBlock	aBlock value: self.	self loadDirectives do: [:directive | directive versionDirectivesDo: aBlock ].! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34253875!versionDo: aBlock	aBlock value: self.! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34254014!versionsDo: aBlock	self loadDirectives do: [:directive | directive versionDo: aBlock ].! !!MetacelloMCVersionSpecLoader class methodsFor: 'instance creation' stamp: 'dkh 6/8/2012 14:04:22' prior: 34271086!on: aVersionSpec	^(self new) 		versionSpec: aVersionSpec;		yourself! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34271254!label	^self versionSpec label! !!MetacelloMCVersionSpecLoader methodsFor: 'loading' stamp: 'dkh 6/26/2012 11:50' prior: 34271381!load    | mcLoader |    packages := Dictionary new.    self resolveToLoadableSpecs.    mcLoader := self loader.    packages values        do: [ :pkg |             pkg ensureLoadedForDevelopmentUsing: mcLoader.            mcLoader ignoreImage                ifFalse: [                     (pkg compareCurrentVersion: self operator targetVersionStatus: #(#'allLoadedToSpec') using: mcLoader)                        ifTrue: [ packages removeKey: pkg name ] ] ].    packages notEmpty        ifTrue: [             mcLoader preLoad: self versionSpec.            mcLoader load.            mcLoader postLoad: self versionSpec ].    ^ mcLoader! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34272008!loader	loader == nil 		ifTrue: [			loader := self versionSpec loader copy.			loader spec: self.			loaderPolicy notNil ifTrue: [ loader loaderPolicy: loaderPolicy] ].	^loader! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34272284!loaderPolicy	^ loaderPolicy! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34272408!loaderPolicy: anObject	loaderPolicy := anObject! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34272545!name	^self versionSpec name! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34272663!operator	^self loader operator! !!MetacelloMCVersionSpecLoader methodsFor: 'spec compatibility' stamp: 'dkh 6/26/2012 12:11' prior: 34272792!packageSpecsInLoadOrder    ^ self versionSpec packageSpecsInLoadOrderForMap: packages! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34273214!packages	^packages! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34273322!project	^self versionSpec project! !!MetacelloMCVersionSpecLoader methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34273443!repositories	^self repositorySpecs! !!MetacelloMCVersionSpecLoader methodsFor: 'spec compatibility' stamp: 'dkh 6/8/2012 14:04:22' prior: 34273576!repositorySpecs	| repositoryMap |	repositoryMap := self versionSpec repositories ~~ nil		ifTrue: [ self versionSpec repositories map ]		ifFalse: [ Dictionary new ].	^repositoryMap values.! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34273856!required	required == nil ifTrue: [ ^#() ].	^ required! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34273999!required: anObject	required := anObject! !!MetacelloMCVersionSpecLoader methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34274125!resolvePackageNames	packages := Dictionary new.	self resolveToLoadableSpecs.	^packages values collect: [:pkg | pkg name ]! !!MetacelloMCVersionSpecLoader methodsFor: 'private' stamp: 'dkh 6/26/2012 16:12' prior: 34274345!resolveToLoadableSpecs    self versionSpec resolveToLoadableSpecs: required forLoad: true map: packages! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34274520!versionSpec	^ versionSpec! !!MetacelloMCVersionSpecLoader methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34274633!versionSpec: anObject	versionSpec := anObject! !!MetacelloMCVersionSpecLoader methodsFor: 'spec compatibility' stamp: 'dkh 6/8/2012 14:04:22' prior: 34274785!versionString	^self versionSpec versionString! !!MCHttpRepository methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34308671!asRepositorySpecFor: aMetacelloMCProject	^(aMetacelloMCProject repositorySpec)		description:  self description;	 	type: 'http';		yourself! !!MetacelloGoferLoad methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34396032!updateCategories	MetacelloPlatform current bypassGoferLoadUpdateCategories		ifFalse: [ super updateCategories ]! !!MetacelloGoferLoad methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34396229!updateRepositories	"Noop for Metacello...done by loader itself"! !!GoferVersionReference methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34277457!metacelloPackageNameWithBranch	"answer array with package name and package name with branch name"	self branch isEmpty		ifTrue: [ 			^ {(self packageName).			(self packageName)} ].	^ {(self packageName).	(self packageName , '.' , self branch)}! !!GoferPackageReference methodsFor: '*metacello-mc' stamp: 'dkh 6/30/2012 07:52'!metacelloPackageNameWithBranch    "answer array with package name and package name with branch name .. no branch name"    ^ {(self packageName).    (self packageName)}! !!MetacelloMCBaselineProject class methodsFor: 'accessing' stamp: 'dkh 6/13/2012 13:51'!singletonVersionName    ^ 'baseline'! !!MetacelloMCBaselineProject class methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22'!versionConstructorClass    ^ MetacelloBaselineConstructor! !!MetacelloMCBaselineProject methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!asBaselineProject    ^ self! !!MetacelloMCBaselineProject methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!asConfigurationProject    ^ MetacelloMCProject new! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: 'dkh 6/8/2012 14:04:22'!bleedingEdge    ^ nil! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: 'dkh 7/20/2012 12:12'!currentVersion    ^ self version isSomethingLoaded        ifTrue: [ self version ]        ifFalse: [ nil ]! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: 'dkh 6/8/2012 14:04:22'!currentVersionAgainst: resolvedPackageAndProjectNames    ^ nil! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: 'dkh 6/8/2012 14:04:22'!development    ^ nil! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: 'dkh 6/8/2012 14:04:22'!hasVersion: versionString    ^ versionString = 'baseline'! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: 'dkh 6/8/2012 14:04:22'!lastVersion    ^ self version! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: 'dkh 6/8/2012 14:04:22'!latestVersion    ^ self version! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: 'dkh 6/8/2012 14:04:22'!latestVersion: blessing    ^ nil! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: 'dkh 6/8/2012 14:04:22'!latestVersionMatching: versionPatternString    ^ nil! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: 'dkh 6/8/2012 14:04:22'!latestVersionMatching: versionPatternString excludedBlessings: excluded    ^ nil! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: 'dkh 6/8/2012 14:04:22'!latestVersionMatching: versionPatternString includedBlessings: included    ^ nil! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: 'dkh 6/8/2012 14:04:22'!latestVersionMatching: versionPatternString includedBlessings: included excludedBlessings: excludedBlessings    ^ nil! !!MetacelloMCBaselineProject methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!projectForScriptEngine: aMetacelloScriptEngine unconditionalLoad: aBool    ^ aMetacelloScriptEngine getBaselineProjectUnconditionalLoad: aBool! !!MetacelloMCBaselineProject methodsFor: 'as yet unclassified' stamp: 'dkh 7/2/2012 16:42'!setBaselineRepositoryDescription: aListOrRepositoryDescriptions    "set #version repositories to < aListOrRepositoryDescriptions>. Should be the directory where the BaselineOf is located."    aListOrRepositoryDescriptions do: [:desc | self version spec repository: desc]! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: 'dkh 6/13/2012 13:51'!singletonVersionName    ^ self class singletonVersionName! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: 'dkh 6/8/2012 14:04:22'!stableVersion    ^ nil! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: 'dkh 6/8/2012 14:04:22'!symbolicVersionSymbols    ^ nil! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: 'dkh 6/8/2012 14:04:22'!version    ^ self version: self singletonVersionName! !!MetacelloMCBaselineProject methodsFor: 'versions' stamp: 'dkh 05/15/2013 21:02'!versions  ^ [ {(self version)} ]    on: MetacelloVersionDoesNotExistError    do: [ :ex | ^ #() ]! !!MetacelloMCProject methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!asBaselineProject    ^ MetacelloMCBaselineProject new! !!MetacelloMCProject methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!asConfigurationProject    ^ self! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'dkh 6/8/2012 14:04:22'!baselineOfProjectSpecClass    ^ MetacelloMCBaselineOfProjectSpec! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'dkh 6/8/2012 14:04:22'!configurationOfProjectSpecClass    ^ MetacelloMCConfigurationOfProjectSpec! !!MetacelloMCProject methodsFor: 'repository creation' stamp: 'dkh 6/8/2012 14:04:22' prior: 34373215!createRepository: aRepositorySpec	^ MetacelloPlatform current createRepository: aRepositorySpec! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'dkh 6/8/2012 14:04:22' prior: 34373401!defaultLoaderClass	^MetacelloLoadingMCSpecLoader! !!MetacelloMCProject methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34373547!fetchProject	"fetch the latest version of the configuration package"		^self fetchProject: MetacelloLoaderPolicy new! !!MetacelloMCProject methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34373761!fetchProject: aLoaderPolicy	"fetch the latest version of the configuration package"		| mcLoader |	(mcLoader := self loader) == nil		ifTrue: [ mcLoader := self project loaderClass on: nil ].	mcLoader loaderPolicy: aLoaderPolicy.	mcLoader doingLoads: [ 		MCWorkingCopy			managersForClass: self configuration class			do: [:mgr | | pkg |				pkg := self packageSpec.				mgr repositoryGroup repositories do: [:repo | pkg repositories repository: (repo asRepositorySpecFor: self) ].				pkg name: mgr packageName.				pkg fetchUsing: mcLoader.				^true ]].	^true! !!MetacelloMCProject methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34374419!goferBranch: branchName project: commitMessage    | pkgSpec |    pkgSpec := self projectPackage.    pkgSpec file: pkgSpec name , '.' , branchName.    ^ pkgSpec goferBranchPackage: branchName message: commitMessage! !!MetacelloMCProject methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34374747!goferCommitProject: commitMessage	| pkgSpec |	(pkgSpec := self projectPackage) == nil ifTrue: [ ^false ].	^pkgSpec goferCommitPackage: commitMessage! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'dkh 6/8/2012 14:04:22' prior: 34374981!packageSpec	^self packageSpecClass for: self! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'dkh 6/8/2012 14:04:22' prior: 34375109!packageSpecClass	^MetacelloPackageSpec! !!MetacelloMCProject methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34375238!packagesNeedSaving: aVersionString	"Answer a collection of associations (package -> repository) representing the packages 	 reachable from this project that need to be saved"	| packages |	packages := Set new.	(self version: aVersionString) spec 		packagesNeedSavingVisited: (Set with: self configuration class name asString)		into: packages.	^packages! !!MetacelloMCProject methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34375674!pragmaKeywords	^super pragmaKeywords, #(projectPackage:attribute: packages:attribute: repositories:attribute: )! !!MetacelloMCProject methodsFor: 'scripting' stamp: 'dkh 6/8/2012 14:04:22'!projectForScriptEngine: aMetacelloScriptEngine unconditionalLoad: aBool    ^ aMetacelloScriptEngine getConfigurationProjectUnconditionalLoad: aBool! !!MetacelloMCProject methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34375885!projectPackage	MCWorkingCopy		managersForClass: self configuration class		do: [:mgr | | pkgSpec repo |			pkgSpec := 				self packageSpec					name: mgr packageName;					yourself.			mgr ancestors notEmpty				ifTrue: [ pkgSpec file: mgr ancestors first name ].			repo := mgr repositoryGroup repositories 				detect: [:each | each ~~ MCCacheRepository default ] 				ifNone: [ 					Transcript cr; show: 'Using cache repository for ', self label, ' project package'.					MCCacheRepository default ].			pkgSpec repository: (repo asRepositorySpecFor: self).			^pkgSpec].	^nil! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'dkh 6/8/2012 14:04:22' prior: 34376545!projectSpecClass	^MetacelloMCProjectSpec! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'dkh 6/8/2012 14:04:22' prior: 34376667!repositoriesSpec	^self repositoriesSpecClass for: self! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'dkh 6/8/2012 14:04:22' prior: 34376803!repositoriesSpecClass	^MetacelloRepositoriesSpec! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'dkh 6/8/2012 14:04:22' prior: 34376935!repositorySpec	^self repositorySpecClass for: self! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'dkh 6/8/2012 14:04:22' prior: 34377069!repositorySpecClass	^MetacelloRepositorySpec! !!MetacelloMCProject methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34377213!saveProject	| pkgSpec |	(pkgSpec := self projectPackage) == nil ifTrue: [ ^false ].	^pkgSpec savePackage! !!MetacelloMCProject methodsFor: 'as yet unclassified' stamp: 'dkh 7/2/2012 16:41'!setBaselineRepositoryDescription: aListOrRepositoryDescriptions    "noop "! !!MetacelloMCProject methodsFor: 'repository updating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34377408!updatePackageRepositoriesFor: versionString	| versionSpec |	(versionSpec := (self version: versionString) versionSpec) packageSpecsInLoadOrder do: [:pkgSpec |		pkgSpec updatePackageRepositoriesFor: versionSpec ].	^true! !!MetacelloMCProject methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34377728!updateProject	"load the latest version of the configuration package"	"WARNING: don't forget to refresh your project instance after doing an #updateProject, 	 otherwise your instance won't reflect the info in the freshly loaded configuration"		^self updateProject: MetacelloLoaderPolicy new! !!MetacelloMCProject methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34378110!updateProject: aLoaderPolicy	"load the latest version of the configuration package"	"WARNING: don't forget to refresh your project instance after doing an #updateProject, 	 otherwise your instance won't reflect the info in the freshly loaded configuration"	| mcLoader |	(mcLoader := self loader) == nil		ifTrue: [ mcLoader := self project loaderClass on: nil ].	mcLoader loaderPolicy: aLoaderPolicy.	mcLoader		doingLoads: [ 			MCWorkingCopy				managersForClass: self configuration class				do: [ :mgr | 					| pkg ar |					pkg := self packageSpec.					mgr repositoryGroup repositories do: [ :repo | pkg repositories repository: (repo asRepositorySpecFor: self) ].					ar := mgr metacelloPackageNameWithBranch.					pkg name: (ar at: 1).					(ar at: 2) notEmpty						ifTrue: [ pkg file: (ar at: 2) ].					pkg load.					^ true ] ].	^ true! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'dkh 6/8/2012 14:04:22' prior: 34379049!versionSpecClass	^MetacelloMCVersionSpec! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34396395!loadUsing: aLoader gofer: ignored	| required |	required := self resolveToLoadableSpec.	required loader: aLoader.	^required load! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34396629!packagesNeedSavingVisited: visitedProjects using: repos into: aCollection		| prjct clsName vrsn |	prjct := self resolveToLoadableSpec.	(visitedProjects includes: (clsName := prjct className)) ifTrue: [ ^self ].	visitedProjects add: clsName.	(vrsn := self versionOrNil) == nil ifTrue: [ ^self ].	vrsn spec 		packagesNeedSavingVisited: visitedProjects 		into: aCollection! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34397100!repository: aStringOrMetacelloRepositorySpec    ^ self projectReference repository: aStringOrMetacelloRepositorySpec! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34397310!resolveProjectSpec	^self projectReference! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34397447!resolveToAllPackagesIn: aVersionSpec into: packages visited: visited	(self resolveProjectSpec resolveToAllPackagesIn: aVersionSpec visited: visited) do: [:pkg |		packages at: pkg put: pkg ]! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34397733!resolveToLoadableSpec	^self resolveProjectSpec resolveToLoadableSpec! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34397897!resolveToPackagesIn: aVersionSpec visited: visited	^#()! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34398057!updateForSpawnMethod: sourceSpec	"This means that this spec was used in a baseline and will be used in a version .... drop all information that isn't useful"	| nm |	nm := name.	self projectReference updateForSpawnMethod: sourceSpec.	super updateForSpawnMethod: sourceSpec.	name := nm.! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34398443!updatePackageSpec: updatedSpecs using: anMCLoader	"Add project copy to updatedSpecs if the current version of the project 	 is different from the receiver's version"		self projectReference updatePackageSpec: updatedSpecs! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34398760!versionString	^self projectReference versionString! !!MetacelloPrePostLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34242605!evaluateSupplyingAnswers: loadBlock	| answers |	(answers := self spec answers) notEmpty		ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]		ifFalse: [ loadBlock value]! !!MetacelloPrePostLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34242888!prepostLoadDirectivesDo: aBlock	aBlock value: self! !!MetacelloPrePostLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34243039!prepostLoadDo: aBlock	aBlock value: self! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34393945!addToMetacelloRepositories: aMetacelloRepositoriesSpec	| spec |	spec := 		(aMetacelloRepositoriesSpec project repositorySpec)			description: self;			yourself.	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec addMember 			name: spec name;			spec: spec;			yourself)! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34394316!fetchRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doFetchRequiredFromArray: (Array with: self).! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34394518!loadRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doLoadRequiredFromArray: (Array with: self).! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34394709!mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec	| spec |	spec := 		(aMetacelloRepositoriesSpec project repositorySpec)			description: self;			yourself.	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec mergeMember 			name: spec name;			spec: spec;			yourself)! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34395079!packageFileSpecFor: aMetacelloPackagesSpec	^(aMetacelloPackagesSpec project packageSpec)			file: self;			yourself! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34395276!recordRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doRecordRequiredFromArray: (Array with: self).! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34395471!removeFromMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec removeMember 			name: self;			yourself)! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34395714!resolvePackageSpecsNamedForMetacelloMCVersion: aMetacelloMCVersion visited: visited ifAbsent: aBlock    ^ aMetacelloMCVersion        allPackagesForSpecs: {(aMetacelloMCVersion packageNamed: self ifAbsent: aBlock)}        visited: visited! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34239239!externalReference	^ externalReference! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34239374!file	^self externalReference name! !!MetacelloPackageLoadDirective methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34239505!label	^self file! !!MetacelloPackageLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 34239618!loadUsing: aLoaderDirective gofer: aGofer	aLoaderDirective loadPackageDirective: self gofer: aGofer! !!MetacelloPackageLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34239819!packageDirectivesDo: aBlock	aBlock value: self! !!MetacelloPackageLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 34239967!packageDo: aBlock	aBlock value: self! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34240103!packageName	^self externalReference packageName! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34240249!repository	^self externalReference repository! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34240393!resolvedReference	^ resolvedReference! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34240528!resolvedReference: anObject	resolvedReference := anObject! !!MetacelloPackageLoadDirective methodsFor: 'initialize-release' stamp: 'dkh 6/8/2012 14:04:22' prior: 34240692!spec: aPackageSpec externalReference: anExternalReference loader: aLoader	super spec: aPackageSpec loader: aLoader.	externalReference := anExternalReference! !!MetacelloPackageLoadDirective methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34240948!title	^'load'! !!Object class methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34275885!lastMetacelloVersionLoad	"Answer the last version loaded and the list of packages loaded for that version.	 See MetacelloConfigTemplate."	^nil -> 'default'! !!Object class methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 34276120!metacelloVersion: versionString loads: anArrayOrString	"Stash the last version loaded and the list of packages loaded for that version. The list	 of packages will be used by the tools when doing 'Load Package Version'.	See MetacelloConfigTemplate for example"		"noop by default"! !!MetacelloConfigTemplate class methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34231210!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!MetacelloConfigTemplate class methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34231569!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #'ConfigurationOf'		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #'ConfigurationOf' ifAbsent: aBlock ].! !!MetacelloConfigTemplate class methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34231873!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!MetacelloConfigTemplate class methodsFor: 'private' stamp: 'dkh 05/08/2013 11:39' prior: 34232044!ensureMetacelloBaseConfiguration  Smalltalk    at: #'ConfigurationOf'    ifAbsent: [       | repository version |      repository := MCHttpRepository        location: 'http://smalltalkhub.com/mc/dkh/metacello/main'        user: ''        password: ''.      repository        versionReaderForFileNamed: 'Metacello-Base-dkh.107'        do: [ :reader |           version := reader version.          version load.          version workingCopy repositoryGroup addRepository: repository ] ]! !!MetacelloConfigTemplate class methodsFor: 'metacello tool support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34232608!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!MetacelloConfigTemplate class methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34232790!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!MetacelloConfigTemplate class methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34233104!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!MetacelloConfigTemplate class methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 34233437!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!MetacelloConfigTemplate class methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34233773!project	^self new project! !!MetacelloConfigTemplate class methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 34233908!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!MetacelloConfigTemplate methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34234651!customProjectAttributes    "Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttrributes "    ^ #()! !!MetacelloConfigTemplate methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34235000!project    ^ project        ifNil: [             "Bootstrap Metacello if it is not already loaded"            self class ensureMetacello.            project := MetacelloMCProject new projectAttributes: self customProjectAttributes.	"Create the Metacello project"            (Smalltalk at: #'MetacelloVersionConstructor') on: self project: project.	"Construct the project"            project loadType: #'linear'.	"change to #atomic if desired"            project ]! !!MetacelloMCPartiallyLoadedStatus class methodsFor: 'instance creation' stamp: 'dkh 6/8/2012 14:04:22' prior: 34260813!new	^ self basicNew initialize! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34260936!aLoadedPackageIsCurrent	^ aLoadedPackageIsCurrent! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34261078!aLoadedPackageIsCurrent: aBoolean	aLoadedPackageIsCurrent := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34261240!aLoadedPackageIsExact	^ aLoadedPackageIsExact! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34261378!aLoadedPackageIsExact: aBoolean	aLoadedPackageIsExact := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34261536!aLoadedPackageIsNotCurrent	^ aLoadedPackageIsNotCurrent! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34261684!aLoadedPackageIsNotCurrent: aBoolean	aLoadedPackageIsNotCurrent := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34261852!aLoadedProjectIsCurrent: aBoolean	aLoadedProjectIsCurrent := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34262014!aLoadedProjectIsExact	^ aLoadedProjectIsExact! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34262152!aLoadedProjectIsExact: aBoolean	aLoadedProjectIsExact := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34262310!aLoadedProjectIsNotCurrent	^ aLoadedProjectIsNotCurrent! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34262458!aLoadedProjectIsNotCurrent: aBoolean	aLoadedProjectIsNotCurrent := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34262626!aPackageIsLoaded	^aPackageIsLoaded! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34262753!aPackageIsLoaded: aBoolean	aPackageIsLoaded := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34262901!aPackageNotLoaded	^aPackageNotLoaded! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34263030!aPackageNotLoaded: aBoolean	aPackageNotLoaded := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34263180!aProjectIsLoaded	^aProjectIsLoaded! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34263307!aProjectIsLoaded: aBoolean	aProjectIsLoaded := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34263455!aProjectNotLoaded	^aProjectNotLoaded! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34263584!aProjectNotLoaded: aBoolean	aProjectNotLoaded := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34263734!abort	^ abort! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34263840!abort: aBoolean	abort := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'evaulation' stamp: 'dkh 6/8/2012 14:04:22' prior: 34263967!evaluateStatus: validStatusList	^self abort		ifTrue: [ false ]		ifFalse: [ 			(self hasNoProject or: [ self vrsnStatus isEmpty ])				ifTrue: [ true ]				ifFalse: [ 					| valid |					valid := true.					vrsnStatus						do: [ :status | 							(validStatusList includes: status)								ifFalse: [ valid := false ] ].					valid ] ]! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34264399!hasNoPackage	^ hasNoPackage! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34264519!hasNoPackage: aBoolean	hasNoPackage := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34264659!hasNoProject	^ hasNoProject! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34264779!hasNoProject: aBoolean	hasNoProject := aBoolean! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'initialization' stamp: 'dkh 6/8/2012 14:04:22' prior: 34264924!initialize	super initialize.	hasNoPackage := hasNoProject := true.	aProjectIsLoaded := aPackageIsLoaded := false.	aLoadedProjectIsExact := aLoadedPackageIsExact := false.	aLoadedProjectIsCurrent := aLoadedPackageIsCurrent := false.	aLoadedProjectIsNotCurrent := aLoadedPackageIsNotCurrent := false.	aProjectNotLoaded := aPackageNotLoaded := false.	vrsnStatus := Set new.	abort := false! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34265408!isAllLoadedToSpec: matchBlock        "all projects and packages are loaded and match specification"	(self evaluateStatus: #(#allLoadedToSpec))		ifTrue: [ 			((hasNoPackage				or: [ 					aPackageIsLoaded & aPackageNotLoaded not & aLoadedPackageIsExact & aLoadedPackageIsNotCurrent not						& aLoadedPackageIsCurrent not ])				and: [ 					hasNoProject						or: [ 							aProjectIsLoaded & aProjectNotLoaded not & aLoadedProjectIsExact & aLoadedProjectIsNotCurrent not								& aLoadedProjectIsCurrent not ] ])				ifTrue: [ matchBlock value: #allLoadedToSpec ] ]! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34266071!isLoadedMatchConstraints: matchBlock	"all loaded projects and packages match constraints (at least one package loaded)"	| matchStatus |	matchStatus := #loadedMatchConstraints.	(self evaluateStatus: #(#allLoadedToSpec #loadedToSpec #loadedMatchConstraints))		ifTrue: [ 			aPackageIsLoaded & aProjectIsLoaded				ifTrue: [ 					(aLoadedPackageIsExact | aLoadedPackageIsCurrent & aLoadedPackageIsNotCurrent not						and: [ aLoadedProjectIsExact | aLoadedProjectIsCurrent & aLoadedProjectIsNotCurrent not ])						ifTrue: [ matchBlock value: matchStatus ] ]				ifFalse: [ 					aPackageIsLoaded						ifTrue: [ 							aLoadedPackageIsExact | aLoadedPackageIsCurrent & aLoadedPackageIsNotCurrent not								ifTrue: [ matchBlock value: matchStatus ] ]						ifFalse: [ 							hasNoPackage & (aLoadedProjectIsExact | aLoadedProjectIsCurrent) & aLoadedProjectIsNotCurrent not								ifTrue: [ matchBlock value: matchStatus ] ] ] ]! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34267097!isLoadedToSpec: matchBlock	"all loaded projects and packages match specifications (at least one package loaded)"	| matchStatus |	matchStatus := #loadedToSpec.	(self evaluateStatus: #(#allLoadedToSpec #loadedToSpec))		ifTrue: [ 			aPackageIsLoaded & aProjectIsLoaded				ifTrue: [ 					(aLoadedPackageIsExact & aLoadedPackageIsCurrent not & aLoadedPackageIsNotCurrent not						and: [ aLoadedProjectIsExact & aLoadedProjectIsCurrent not & aLoadedProjectIsNotCurrent not ])						ifTrue: [ matchBlock value: matchStatus ] ]				ifFalse: [ 					aPackageIsLoaded						ifTrue: [ 							aLoadedPackageIsExact & aLoadedPackageIsCurrent not & aLoadedPackageIsNotCurrent not								ifTrue: [ matchBlock value: matchStatus ] ]						ifFalse: [ 							hasNoPackage & aLoadedProjectIsExact & aLoadedProjectIsCurrent not & aLoadedProjectIsNotCurrent not								ifTrue: [ matchBlock value: matchStatus ] ] ] ]! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34268096!isSomethingLoaded: somethingLoadedBlock	"at least one package loaded"	(self evaluateStatus: #(#allLoadedToSpec #loadedToSpec #loadedMatchConstraints #somethingLoaded))		ifTrue: [ 			aPackageIsLoaded				ifTrue: [ somethingLoadedBlock value: #somethingLoaded ] ]! !!MetacelloMCPartiallyLoadedStatus methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34268454!vrsnStatus	^vrsnStatus! !!MetacelloVisitedPackages methodsFor: 'initialize-release' stamp: 'dkh 6/8/2012 14:04:22' prior: 34274926!initialize	groups := Set new.	packages := Set new.	projects := Set new.! !!MetacelloVisitedPackages methodsFor: 'visiting' stamp: 'dkh 6/8/2012 14:04:22' prior: 34275085!pushProject: aBlock	| oldGroups oldPackages oldProjects |	oldGroups := groups.	oldPackages := packages.	oldProjects := projects.	groups := Set new.	packages := Set new.	^aBlock ensure: [		groups := oldGroups.		packages := oldPackages.		projects := oldProjects ]! !!MetacelloVisitedPackages methodsFor: 'visiting' stamp: 'dkh 6/8/2012 14:04:22' prior: 34275441!visit: aSpec doing: aBlock	aSpec		projectDo: [:spec | 			(projects includes: spec name) ifTrue: [ ^self ].			projects add: spec name ] 		packageDo: [:spec | 			(packages includes: spec name) ifTrue: [ ^self ].			packages add: spec name ] 		groupDo: [:spec | 			(groups includes: spec name) ifTrue: [ ^self ].			groups add: spec name ].	aBlock value: aSpec! !MetacelloRepositoriesSpec removeSelector: #merge:type:!MetacelloRepositoriesSpec removeSelector: #add:type:!MetacelloMCProjectSpec removeSelector: #versionOrNil!MetacelloMCProjectSpec removeSelector: #resolveToLoadableSpec!MetacelloMCProjectSpec removeSelector: #repository:username:password:!MetacelloMCProjectSpec removeSelector: #repository:!MetacelloMCProjectSpec removeSelector: #repository!MetacelloMCProjectSpec removeSelector: #projectPackage:!MetacelloMCProjectSpec removeSelector: #projectDo:packageDo:groupDo:!MetacelloMCProjectSpec removeSelector: #postCopy!MetacelloMCProjectSpec removeSelector: #packageRepository!MetacelloMCProjectSpec removeSelector: #nonOverridable!MetacelloMCProjectSpec removeSelector: #mergeSpec:!MetacelloMCProjectSpec removeSelector: #mergeMap!MetacelloMCProjectSpec removeSelector: #loadListForVersion:!MetacelloMCProjectSpec removeSelector: #load!MetacelloMCProjectSpec removeSelector: #hasNonVersionStringField!MetacelloMCVersion removeSelector: #resolveToLoadableSpecs:!MetacelloMCVersion removeSelector: #projects!MetacelloMCVersion removeSelector: #packageNamed:ifAbsent:!MetacelloMCVersion removeSelector: #packageNamed:!MetacelloMCVersion removeSelector: #groups!MetacelloMCVersion removeSelector: #expandToLoadableSpecNames:!MetacelloMCVersion removeSelector: #difference:!MetacelloPackageSpec removeSelector: #packageRepository!MetacelloAbstractPackageSpec removeSelector: #packageRepository!MetacelloMCVersionSpec removeSelector: #resolveToLoadableSpecs:map:!MetacelloMCVersionSpec removeSelector: #resolveToLoadableSpecs:!MetacelloMCVersionSpec removeSelector: #resolveToLoadableSpec:forMap:packages:!MetacelloMCVersionSpec removeSelector: #projectDo:packageDo:groupDo:!MetacelloMCVersionSpec removeSelector: #packagesSpec!MetacelloMCVersionSpec removeSelector: #packages:!MetacelloMCVersionSpec removeSelector: #packageSpecsInLoadOrder!MetacelloMCVersionSpec removeSelector: #packageNamed:ifAbsent:!MetacelloMCVersionSpec removeSelector: #packageNamed:forMap:ifAbsent:!MetacelloMCVersionSpec removeSelector: #packageNamed:!MetacelloMCVersionSpec removeSelector: #expandToLoadableSpecNames:!MetacelloMCVersionSpec removeSelector: #defaultPackageNames!MetacelloMCVersionSpec removeSelector: #configPackagesSpecMethodOn:indent:!MetacelloMCVersionDiffReport removeSelector: #to:!MetacelloMCVersionDiffReport removeSelector: #to!MetacelloMCVersionDiffReport removeSelector: #removals:!MetacelloMCVersionDiffReport removeSelector: #removals!MetacelloMCVersionDiffReport removeSelector: #printOn:!MetacelloMCVersionDiffReport removeSelector: #modifications:!MetacelloMCVersionDiffReport removeSelector: #modifications!MetacelloMCVersionDiffReport removeSelector: #from:!MetacelloMCVersionDiffReport removeSelector: #from!MetacelloMCVersionDiffReport removeSelector: #configuration:!MetacelloMCVersionDiffReport removeSelector: #configuration!MetacelloMCVersionDiffReport removeSelector: #additions:!MetacelloMCVersionDiffReport removeSelector: #additions!Smalltalk removeClassNamed: #MetacelloMCVersionDiffReport!"Metacello-MC"!!MetacelloSqueakPlatform class methodsFor: 'initialize-release' stamp: 'dkh 6/12/2012 10:18:46.076' prior: 34442006!initialize  self select! !!MetacelloSqueakPlatform methodsFor: 'as yet unclassified' stamp: 'tfel 7/29/2014 14:39'!directoryFromPath: adirectoryPath relativeTo: anotherDirectoryPath	"Get a handle on the following path: anotherDirectoryPath/adirectoryPath"	| path |      "remove trailing slash - required for Windows compat"      path := adirectoryPath last = $/		ifTrue: [adirectoryPath allButLast] ifFalse: [adirectoryPath].	^ anotherDirectoryPath directoryNamed: path! !!MetacelloSqueakPlatform methodsFor: 'github support' stamp: 'tfel 7/29/2014 13:53' prior: 34445850!downloadFile: url to: outputFileName    "download from <url> into <outputFileName>"    | archive zipfile response |    response := WebClient httpGet: url.    archive := ZipArchive new.    zipfile := FileDirectory on: (FileDirectory default fullPathFor: outputFileName).    zipfile containingDirectory assureExistence.    response         streamTo: ((zipfile containingDirectory forceNewFileNamed: zipfile localName) binary; yourself)         size: response contentLength progress: nil.    zipfile containingDirectory		readOnlyFileNamed: zipfile localName		do: [:fileStream | archive readFrom: fileStream].    ^ archive! !!MetacelloSqueakPlatform methodsFor: 'github support' stamp: 'tfel 7/29/2014 14:42' prior: 34446801!extractRepositoryFrom: zipFile to: directory    "unzip <zipFile> into <directory>"    ZipArchive new        readFrom: zipFile;        extractAllTo: (FileDirectory on: directory) informing: nil overwrite: true.! !!FileDirectory methodsFor: '*metacello-platform' stamp: 'dkh 2/25/2013 17:18'!asRepositorySpecFor: aMetacelloMCProject  ""  ^ aMetacelloMCProject repositorySpec    description: self fullName;    type: 'directory';    yourself! !"Metacello-Platform"!SystemOrganization addCategory: #'Metacello-ToolBox'!Object subclass: #MetacelloToolBox	instanceVariableNames: 'project methodSpec'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-ToolBox'!!MetacelloToolBox commentStamp: '<historical>' prior: 0!MetacelloToolbox implements a toolbox API for Metacello.The toolbox methods on the class-side implement scripts for a number of commonly performed Metacello development tasks. The methods should be used in development scripts or GUI tools so that a common implementation is preserved across the toolset.!!MetacelloToolBox class methodsFor: 'private' stamp: 'dkh 3/7/2012 17:08:50'!appendDescription: aString to: versionSpec	aString isEmpty		ifTrue: [ ^ self ].	^ versionSpec description value isEmpty		ifTrue: [ versionSpec description: aString ]		ifFalse: [ 			| strm |			strm := WriteStream on: String new.			strm				nextPutAll: versionSpec description value;				cr;				nextPutAll: aString.			versionSpec description: strm contents ]! !!MetacelloToolBox class methodsFor: 'utility' stamp: 'dkh 07/14/2013 12:02'!baseNameOf: configurationClassName  "Return the baseName for the given configuration class name."  <apiDocumentation>  ^ (configurationClassName begindWith: 'ConfigurationOf')    ifTrue: [       configurationClassName        copyFrom: 'ConfigurationOf' size + 1        to: configurationClassName size ]    ifFalse: [ configurationClassName ]! !!MetacelloToolBox class methodsFor: 'utility' stamp: 'dkh 3/7/2012 17:08:50'!baseNameOfConfiguration: aConfigurationClass	"Return the baseName for the given configuration class."	<apiDocumentation>	^self baseNameOf: aConfigurationClass name asString! !!MetacelloToolBox class methodsFor: 'utility' stamp: 'dkh 05/15/2013 20:36'!baselineNameFrom: baseName  "Return the fully-qualified baseline class name."  <apiDocumentation>  ^ MetacelloScriptEngine baselineNameFrom: baseName! !!MetacelloToolBox class methodsFor: 'instance creation' stamp: 'dkh 05/15/2013 20:15'!baselineNamed: baseName  ^ self new    baselineNamed: baseName;    yourself! !!MetacelloToolBox class methodsFor: 'utility' stamp: 'dkh 3/7/2012 17:08:50'!checkForCriticalValidationIssues: configurationBasename	"Validate the named configuration and filter out all non-critical issues."	<apiDocumentation>	^ (MetacelloMCVersionValidator		validateConfiguration: (Smalltalk at: (self configurationNameFrom: configurationBasename) asSymbol))		select: [ :issue | issue isCritical ]! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!compareVersion: fromVersionString for: configurationBasename to: toVersionString	"Return a MetacelloMCVersionDiffReport that whose fields 		#additions		#removals		#modifications	   refer to a dictionary whose keys are package names and whose 	   values are a 2 element array. The first element is the mcz file 	   name for the first version and the second element is the mcz file 	   name for second version.	There are also fields for the name of the configuration (#configuration), 	the #from version string and the #to version string.		The printString of the version report should provide all of the necessary info for 	a developer."	<apiDocumentation>	| toolbox report |	toolbox := self configurationNamed: configurationBasename.	report := (toolbox project version: fromVersionString) difference: (toolbox project version: toVersionString).	report 		from: fromVersionString;		to: toVersionString;		configuration: configurationBasename.	^ report! !!MetacelloToolBox class methodsFor: 'development support' stamp: 'dkh 3/7/2012 17:08:50'!compareVersionsIn: aConfigurationClass	"Compare the current #stable version to current #development version"	<apiDocumentation>	| developmentVersion previousVersion |	developmentVersion := aConfigurationClass project version: #development.	previousVersion := aConfigurationClass project version: #stable.	^self		compareVersion: previousVersion versionString		for: aConfigurationClass name asString		to: developmentVersion versionString	! !!MetacelloToolBox class methodsFor: 'tool support' stamp: 'dkh 3/7/2012 17:08:50'!compiledMethodForVersion: aMetacelloVersion	| toolbox pragma |	toolbox := MetacelloToolBox new project: aMetacelloVersion project.	pragma := (toolbox constructor extractAllVersionPragmas at: aMetacelloVersion versionString ifAbsent: [ ^ nil ]) first.	^pragma method! !!MetacelloToolBox class methodsFor: 'utility' stamp: 'dkh 6/13/2012 13:07'!configurationClasses    "Return a set of the Metacello configuration classes that have been loaded into the image."    <apiDocumentation>    ^ MetacelloProjectRegistration configurationClasses! !!MetacelloToolBox class methodsFor: 'utility' stamp: 'dkh 3/7/2012 17:08:50'!configurationNameFrom: baseName    "Return the fully-qualified configuration class name."    <apiDocumentation>    ^ MetacelloScriptEngine configurationNameFrom: baseName! !!MetacelloToolBox class methodsFor: 'instance creation' stamp: 'dkh 3/7/2012 17:08:50'!configurationNamed: baseName	^self new 		configurationNamed: baseName;		yourself! !!MetacelloToolBox class methodsFor: 'validation' stamp: 'dkh 3/7/2012 17:08:50'!copyConfiguration: aConfigurationClass to: metacelloRepositoryString	"Copy the current configuration mcz file to the given repository (i.e., http: //... or directory://, etc.)"	<apiDocumentation>	| project |	project := aConfigurationClass project.	project projectPackage		copySpecTo:			((project repositorySpec)				description: metacelloRepositoryString;				yourself)! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!createBaseline: baselineVersionString for: configurationBasename from: existingBaselineVersionString description: aString	"Create a new baseline version based on the specification in an existing baseline"	<apiDocumentation>	^ self		createBaseline: baselineVersionString		for: configurationBasename		from: existingBaselineVersionString		description: aString		versionSpecsDo: [ :attribute :versionSpec | true ]! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!createBaseline: baselineVersionString for: configurationBasename from: existingBaselineVersionString description: aString versionSpecsDo: versionSpecBlock	"Create a new baseline version based on the specification in an existing baseline. Evaluate <versionSpecBlock> for each section."	<apiDocumentation>	| toolbox |	(toolbox := self configurationNamed: configurationBasename)		createVersionMethod: 'baseline' , (self stripVersionStringForSelector: baselineVersionString) , ':'			inCategory: 'baselines'			forVersion: baselineVersionString;		addSectionsFrom: existingBaselineVersionString			forBaseline: true			updateProjects: false			updatePackages: false			versionSpecsDo: [ :attribute :versionSpec | 				attribute == #common					ifTrue: [ 						aString notEmpty							ifTrue: [ versionSpec description: aString ] ].				versionSpecBlock value: attribute value: versionSpec ];		commitMethod.	^ toolbox! !!MetacelloToolBox class methodsFor: 'deprecated' stamp: 'dkh 3/7/2012 17:08:50'!createBaseline: baselineVersionString for: configurationBasename repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependencies groups: groups    "Create a new baseline version based on the specified project structure.		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		groups - collection of associations where key is the name of the group and value is the collection of group members	"    <apiDocumentation>    self        deprecated:            'Use createBaseline:for: repository:requiredProjects:packages:repositories:dependencies:groups: instead'.    ^ self        createBaseline: baselineVersionString        for: configurationBasename        repository: repositoryDescription        requiredProjects: projectList        packages: packageList        repositories: #()        dependencies: dependencies        groups: groups! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!createBaseline: baselineVersionString for: configurationBasename repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependencies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: groups	"Create a new baseline version based on the specified project structure.		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		groups - collection of associations where key is the name of the group and value is the collection of group members	"	<apiDocumentation>	| toolbox |	(toolbox := self configurationNamed: configurationBasename)		createVersionMethod: 'baseline' , (self stripVersionStringForSelector: baselineVersionString) , ':'			inCategory: 'baselines'			forVersion: baselineVersionString;		addSection: #common			repository: repositoryDescription			requiredProjects: projectList			packages: packageList			dependencies: dependencies			includes: includes			files: files			repositories: repositories			preLoadDoIts: preLoadDoIts			postLoadDoIts: postLoadDoIts			supplyingAnswers: supplyingAnswers			groups: groups			versionSpecsDo: [ :versionSpec | versionSpec blessing: #baseline ];		commitMethod.	^ toolbox! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!createBaseline: baselineVersionString for: configurationBasename repository: repositoryDescription requiredProjects: projectList packages: packageList repositories: repositories dependencies: dependencies groups: groups    "Create a new baseline version based on the specified project structure.		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		repositories - collection of associations where key is name of package and value is collection of repository descriptions		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		groups - collection of associations where key is the name of the group and value is the collection of group members	"    <apiDocumentation>    | toolbox |    (toolbox := self configurationNamed: configurationBasename)        createVersionMethod: 'baseline' , (self stripVersionStringForSelector: baselineVersionString) , ':'            inCategory: 'baselines'            forVersion: baselineVersionString;        addSection: #'common'            repository: repositoryDescription            requiredProjects: projectList            packages: packageList            repositories: repositories            dependencies: dependencies            groups: groups            versionSpecsDo: [ :versionSpec | versionSpec blessing: #'baseline' ];        commitMethod.    ^ toolbox! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!createBranch: branchName for: configurationBasename description: commitMessage	"Create a new branch for the project and save the configuration to it's repository."		<apiDocumentation>	| toolbox criticalIssues |	branchName isEmpty ifTrue: [ ^self saveConfigurationPackageFor: configurationBasename description: commitMessage ].	(criticalIssues := self checkForCriticalValidationIssues: configurationBasename) isEmpty		ifTrue: [ 			toolbox := self configurationNamed: configurationBasename.			toolbox project goferBranch: branchName project: commitMessage.			^toolbox ].	 self error: 'There are critical issues in configuration ' , configurationBasename printString, '. Configuration not saved'.	^nil! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!createDevelopment: developmentVersionString for: configurationBasename from: existingDevelopmentVersionString description: aString	"Create a new development version based on the specifications in an existing development version. Modify the #development symbolic version to reference the new version."	<apiDocumentation>	| toolbox |	(toolbox := self configurationNamed: configurationBasename)		createVersionMethod: 'version' , (self stripVersionStringForSelector: developmentVersionString) , ':'			inCategory: 'versions'			forVersion: developmentVersionString;		addSectionsFrom: existingDevelopmentVersionString			forBaseline: false			updateProjects: true			updatePackages: true			versionSpecsDo: [ :attribute :versionSpec | 				attribute == #common					ifTrue: [ 						"update the author, blessing, description and timeStamp"						versionSpec							author: MetacelloPlatform current authorName;							description: aString;							blessing: #development;							timestamp: MetacelloPlatform current timestamp ].				true ];		commitMethod.	toolbox		symbolicVersionMethod: #development;		addSymbolicSection: #common version: developmentVersionString;		commitMethod.	^ toolbox! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!createDevelopment: developmentVersionString for: configurationBasename from: existingDevelopmentVersionString imports: imports description: aString	"Create a new development version based on the specifications in an existing version, but override the imports for the new version. Modify the #development symbolic version to reference the new version."	<apiDocumentation>	| toolbox |	toolbox := self		createVersion: developmentVersionString		for: configurationBasename		from: existingDevelopmentVersionString		description: aString.	toolbox		modifyVersionMethodForVersion: developmentVersionString;		imports: imports;		commitMethod.	^ toolbox! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!createDevelopment: developmentVersionString for: configurationBasename importFromBaseline: baselineVersionString description: aString	"Create a new development version based on the specifications in an existing baseline version. Modify the #development symbolic version to reference the new version."	<apiDocumentation>	| toolbox |	(toolbox := self configurationNamed: configurationBasename)		createVersionMethod: 'version' , (self stripVersionStringForSelector: developmentVersionString) , ':'			inCategory: 'versions'			forVersion: developmentVersionString;		importFrom: baselineVersionString			updateProjects: true			updatePackages: true			versionSpecsDo: [ :attribute :versionSpec | 				attribute == #common					ifTrue: [ 						"update the author, blessing, description and timeStamp"						versionSpec							author: MetacelloPlatform current authorName;							blessing: #development;							description: aString;							timestamp: MetacelloPlatform current timestamp ].				true ];		commitMethod.	toolbox		symbolicVersionMethod: #development;		addSymbolicSection: #common version: developmentVersionString;		commitMethod.	^ toolbox! !!MetacelloToolBox class methodsFor: 'development support' stamp: 'dkh 3/7/2012 17:08:50'!createNewBaselineVersionIn: aConfigurationClass description: creationMessage	"Create a new baseline version based upon #stable version's baseline.	 A new baseline should be created if new packages or projects have been added or package dependencies have changed."	<apiDocumentation>	| currentVersion existingBaselineVersionString baselineVersionNumber |	currentVersion := aConfigurationClass project version: #stable.	existingBaselineVersionString := currentVersion importedVersions first.	baselineVersionNumber := existingBaselineVersionString asMetacelloVersionNumber incrementMinorVersionNumber.	self		createBaseline: baselineVersionNumber versionString		for: aConfigurationClass name asString		from: existingBaselineVersionString		description: creationMessage! !!MetacelloToolBox class methodsFor: 'development support' stamp: 'dkh 3/7/2012 17:08:50'!createNewBaselineVersionIn: aConfigurationClass description: creationMessage versionSpecsDo: versionSpecBlock	"Create a new baseline version based upon #stable version's baseline. Evaluate <versionSpecBlock> for each section.	 A new baseline should be created if new packages or projects have been added or package dependencies have changed."	<apiDocumentation>	| currentVersion existingBaselineVersionString baselineVersionNumber |	currentVersion := aConfigurationClass project version: #stable.	existingBaselineVersionString := currentVersion importedVersions first.	baselineVersionNumber := existingBaselineVersionString asMetacelloVersionNumber incrementMinorVersionNumber.	self		createBaseline: baselineVersionNumber versionString		for: aConfigurationClass name asString		from: existingBaselineVersionString		description: creationMessage		versionSpecsDo: versionSpecBlock! !!MetacelloToolBox class methodsFor: 'development support' stamp: 'dkh 3/7/2012 17:08:50'!createNewBaselineVersionIn: aConfigurationClass requiredProjects: projectList packages: packageList dependencies: dependencies  groups: groups	"Create a new baseline version based upon #stable version's baseline, modify the baseline based on the provided structural additions:		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		groups - collection of associations where key is the name of the group and value is the collection of group members	"	<apiDocumentation>	| currentVersion existingBaselineVersionString baselineVersionNumber |	currentVersion := aConfigurationClass project version: #development.	existingBaselineVersionString := currentVersion importedVersions first.	baselineVersionNumber := existingBaselineVersionString asMetacelloVersionNumber incrementMinorVersionNumber.	self		createBaseline: baselineVersionNumber versionString		for: aConfigurationClass name asString		from: existingBaselineVersionString		description: ''.	self		modifyVersion: baselineVersionNumber versionString		section: #common		for: aConfigurationClass name asString		repository: nil		requiredProjects: projectList		packages: packageList		dependencies: dependencies		includes: #()		files: #()		repositories: #()		preLoadDoIts: #()		postLoadDoIts: #()		supplyingAnswers: #()		groups: groups! !!MetacelloToolBox class methodsFor: 'development support' stamp: 'dkh 3/7/2012 17:08:50'!createNewDevelopmentVersionIn: aConfigurationClass description: creationMessage	"Create a new development version using the #stable version as model."	<apiDocumentation>	| currentVersion developmentVersion |	currentVersion := aConfigurationClass project version: #stable.	developmentVersion := currentVersion versionNumber copy incrementMinorVersionNumber.	self		createDevelopment: developmentVersion versionString		for: aConfigurationClass name asString		from: currentVersion versionString		imports: currentVersion importedVersions		description: creationMessage! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!createVersion: targetVersionString for: configurationBasename from: sourceVersionString description: aString	"Create a new version based on the specifications in the given version. 	 If the new version string contains 'baseline', then create a new baseline version.	 If the given version is a baseline, then create a new version based on the given baseline.	 If the given version is a non-baseline version, then create a new version based on the given version."	<apiDocumentation>	| toolbox sourceVersion |	toolbox := self configurationNamed: configurationBasename.	sourceVersion := toolbox project version: sourceVersionString.	^ (targetVersionString indexOfSubCollection: 'baseline') > 0		ifTrue: [ 			"create baseline version from baseline version"			sourceVersion blessing ~~ #baseline				ifTrue: [ 					self						error:							'Cannot create a baseline version ' , sourceVersionString printString , ' from a non-baseline version '								, targetVersionString printString ].			self				createBaseline: targetVersionString				for: configurationBasename				from: sourceVersionString				description: aString ]		ifFalse: [ 			sourceVersion blessing == #baseline				ifTrue: [ 					"create development version version from baseline version"					self						createDevelopment: targetVersionString						for: configurationBasename						importFromBaseline: sourceVersion versionString						description: aString ]				ifFalse: [ 					"create development version version from development version"					self						createDevelopment: targetVersionString						for: configurationBasename						from: sourceVersion versionString						description: aString ] ]! !!MetacelloToolBox class methodsFor: 'help' stamp: 'dkh 3/7/2012 17:08:50'!defaultTopic: pageSelector for: aConfigurationClass	| topic stream helpTopicClass |	(helpTopicClass := self helpTopicClass) ifNil: [^self error: 'Help system not installed'].	stream := WriteStream on: String new.	pageSelector == #helpInstallation		ifTrue: [ 			stream				nextPutAll: 'To install this configuration, execute the following expression in a workspace:'; cr; tab.			(aConfigurationClass project hasVersion: #stable)				ifTrue: [ stream nextPutAll: '(', aConfigurationClass name asString, ' project version: #stable) load.' ]				ifFalse: [ 					(aConfigurationClass respondsTo: #load)						ifTrue: [ stream nextPutAll: aConfigurationClass name asString , ' load.' ]						ifFalse: [ stream nextPutAll: aConfigurationClass name asString, ' project latestVersion load.' ]].			^ helpTopicClass perform: #title:contents: withArguments: { 'Installing'.  stream contents} ].	pageSelector == #helpIntro		ifTrue: [ 			stream				nextPutAll: 'I am a Metacello configuration for the ', (MetacelloToolBox baseNameOfConfiguration: aConfigurationClass), ' project.'.			^ helpTopicClass perform: #title:contents: withArguments: { 'Intro' . stream contents} ].	pageSelector == #helpGettingStarted		ifTrue: [ 			stream				nextPutAll: 'I guess you''re on your own:).'.			^ helpTopicClass perform: #title:contents: withArguments: { 'Getting Started' .stream contents} ].! !!MetacelloToolBox class methodsFor: 'validation' stamp: 'dkh 3/7/2012 17:08:50'!descriptionForValidationReasonCode: reasonCode	"Description of validation reasonCode"	<apiDocumentation>	^MetacelloMCVersionValidator descriptionForReasonCode: reasonCode! !!MetacelloToolBox class methodsFor: 'help' stamp: 'dkh 3/7/2012 17:08:50'!helpTopicClass	^Smalltalk at: #HelpTopic ifAbsent: []! !!MetacelloToolBox class methodsFor: 'help' stamp: 'dkh 3/7/2012 17:08:50'!helpTopicFor: aConfigurationClass	| topic pages page helpTopicClass |	(helpTopicClass := self helpTopicClass) ifNil: [^self error: 'Help system not installed'].	topic := helpTopicClass named: (self baseNameOfConfiguration: aConfigurationClass).	pages := (aConfigurationClass respondsTo: #helpPages)		ifTrue: [ aConfigurationClass perform: #helpPages ]		ifFalse: [ #(#helpIntro #helpInstallation #helpGettingStarted) ].	pages		do: [ :pageSelectorOrClass | 			page := (Smalltalk hasClassNamed: pageSelectorOrClass asString)				ifTrue: [ (Smalltalk classNamed: pageSelectorOrClass asString) perform: #asHelpTopic ]				ifFalse: [ 					[ aConfigurationClass perform: pageSelectorOrClass ]						on: MessageNotUnderstood						do: [ :ex | self defaultTopic: pageSelectorOrClass for: aConfigurationClass ] ].			topic perform: #addSubtopic: with: page ].	^ topic! !!MetacelloToolBox class methodsFor: 'development support' stamp: 'dkh 3/7/2012 17:08:50'!modifyBaselineVersionIn: aConfigurationClass repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependencies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: groups	"Modify #development version's baseline version based on the given structure		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		groups - collection of associations where key is the name of the group and value is the collection of group members	"	<apiDocumentation>	| currentVersion existingBaselineVersionString |	currentVersion := aConfigurationClass project version: #development.	existingBaselineVersionString := currentVersion importedVersions first.	self		modifyVersion: existingBaselineVersionString		section: #common		for: aConfigurationClass name asString		repository: repositoryDescription		requiredProjects: projectList		packages: packageList		dependencies: dependencies		includes: includes		files: files		repositories: repositories		preLoadDoIts: preLoadDoIts		postLoadDoIts: postLoadDoIts		supplyingAnswers: supplyingAnswers		groups: groups! !!MetacelloToolBox class methodsFor: 'development support' stamp: 'dkh 3/7/2012 17:08:50'!modifyDevelopmentVersionIn: aConfigurationClass imports: imports requiredProjects: projectList packages: packageList description: message	"Modify #development version's baseline version based on the given structure		imports - imports array		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names	"	<apiDocumentation>	| developmentVersion files |	developmentVersion := aConfigurationClass project version: #development.	files := OrderedCollection new.	packageList do: [:packageName | files add: packageName -> packageName ].	self		modifyVersion: developmentVersion versionString		section: #common		for: aConfigurationClass name asString		repository: nil		requiredProjects: projectList		packages: packageList		dependencies: #()		includes: #()		files: files		repositories: #()		preLoadDoIts: #()		postLoadDoIts: #()		supplyingAnswers: #()		groups: #().	(self configurationNamed: aConfigurationClass name asString)		modifyVersionMethodForVersion: developmentVersion versionString;		imports: imports;		commitMethod.	self		updateDevelopment: developmentVersion versionString		for: aConfigurationClass name asString		updateProjects: false 		description: message! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!modifySymbolicVersion: symbolicVersionSymbol for: configurationBasename attribute: attribute to: versionString	"Set the value of the symbolic version for the given attribute to the given version string"	<apiDocumentation>	| toolbox |	(toolbox := self configurationNamed: configurationBasename)		modifySymbolicVersionMethodFor: symbolicVersionSymbol;		addSymbolicSection: attribute version: versionString;		commitMethod.	^ toolbox! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!modifyVersion: sourceVersionString for: configurationBasename projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock	"Modify the project, package and/or group specifications for the given version"	<apiDocumentation>	self		modifyVersion: sourceVersionString		for: configurationBasename		versionSpecsDo: [ :attribute :versionSpec | 			versionSpec				specListProjectDo: [ :spec | projectBlock value: attribute value: versionSpec value: spec ]				packageDo: [ :spec | packageBlock value: attribute value: versionSpec value: spec ]				groupDo: [ :spec | groupBlock value: attribute value: versionSpec value: spec ].			true ]! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!modifyVersion: sourceVersionString for: configurationBasename versionSpecsDo: aBlock	"Modify the version specifications for the given version"	<apiDocumentation>	(self configurationNamed: configurationBasename)		modifyVersionMethodForVersion: sourceVersionString versionSpecsDo: aBlock;		commitMethod! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 9/7/2012 13:34'!modifyVersion: sourceVersionString section: sectionAttributeOrPath for: configurationBasename repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependencies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: groups	"Modify a new version based on the specified project structure.		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		groups - collection of associations where key is the name of the group and value is the collection of group members	"	<apiDocumentation>	| toolbox |	(toolbox := self configurationNamed: configurationBasename)		modifyVersionMethodForVersion: sourceVersionString versionSpecsDo: [:attribute :versionSpec | true ];		modifySection: sectionAttributeOrPath asMetacelloAttributePath			repository: repositoryDescription			requiredProjects: projectList			packages: packageList			dependencies: dependencies			includes: includes			files: files			repositories: repositories			preLoadDoIts: preLoadDoIts			postLoadDoIts: postLoadDoIts			supplyingAnswers: supplyingAnswers			groups: groups			versionSpecsDo: [ :versionSpec | true ];		commitMethod.	^ toolbox! !!MetacelloToolBox class methodsFor: 'utility' stamp: 'dkh 3/7/2012 17:08:50'!platformAttributes	"Answer the list of platform attributes for the current platform"	<apiDocumentation>	^MetacelloPlatform current defaultPlatformAttributes! !!MetacelloToolBox class methodsFor: 'development support' stamp: 'dkh 3/7/2012 17:08:50'!releaseDevelopmentVersionIn: aConfigurationClass description: commitMessage	"Release #development version: set version blessing to #release, update the #development and #stable symbolic version methods and save the configuration."	<apiDocumentation>	| version |	version := aConfigurationClass project version: #development.	self		releaseVersion: version versionString for: aConfigurationClass name asString;		saveConfigurationPackageFor: aConfigurationClass name asString description: commitMessage! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!releaseEarlyAccessVersion: earlyAccessVersionString for: configurationBasename from: developmentVersionString	"Update the #development and #earlyAccess symbolic versions."	<apiDocumentation>	| toolbox message previousEarlyAccessVersion previousEarlyAccessSeparator index earlyAccessDescription |	self flag: 'Make this more general purpose'.	toolbox := self configurationNamed: configurationBasename.	message := (toolbox project version: developmentVersionString) description.	previousEarlyAccessVersion := (MetacelloVersionNumber fromString: earlyAccessVersionString) decrementMinorVersionNumber		asString.	previousEarlyAccessSeparator := '---' , previousEarlyAccessVersion , '---'.	(index := message indexOfSubCollection: previousEarlyAccessSeparator) > 0		ifTrue: [ 			index + previousEarlyAccessSeparator size + 1 <= message size				ifTrue: [ earlyAccessDescription := message copyFrom: index + previousEarlyAccessSeparator size + 1 to: message size ] ].	toolbox		createVersionMethod: 'version' , (self stripVersionStringForSelector: earlyAccessVersionString) , ':'			inCategory: 'versions'			forVersion: earlyAccessVersionString;		addSectionsFrom: developmentVersionString			forBaseline: false			updateProjects: true			updatePackages: true			versionSpecsDo: [ :attribute :versionSpec | 				attribute == #common					ifTrue: [ 						"update the author, blessing, description and timeStamp"						versionSpec							author: MetacelloPlatform current authorName;							description: earlyAccessDescription;							blessing: #development;							timestamp: MetacelloPlatform current timestamp ].				true ];		commitMethod.	toolbox		symbolicVersionMethod: #earlyAccess;		addSymbolicSection: #common version: earlyAccessVersionString;		commitMethod.	toolbox		modifyVersionMethodForVersion: developmentVersionString			versionSpecsDo: [ :attribute :versionSpec | 					attribute == #common						ifTrue: [ 							"update the author, description and timeStamp"							versionSpec								author: MetacelloPlatform current authorName;								timestamp: MetacelloPlatform current timestamp.							self appendDescription: '---' , earlyAccessVersionString , '---' to: versionSpec ].					true ];		commitMethod.	^ toolbox! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!releaseVersion: developmentVersionString for: configurationBasename	"Set the #common blessing to #release and set the #common #stable symbolic version to the given version."	<apiDocumentation>	^ self		releaseVersion: developmentVersionString		for: configurationBasename		blessingAttribute: #common		platformAttribute: #common! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!releaseVersion: developmentVersionString for: configurationBasename blessingAttribute: attribute platformAttribute: platformAttribute	<apiDocumentation>	"Set the blessing to #release and set the #stable symbolic version to the given version, using the given attributes for each."		| toolbox |	(toolbox := self configurationNamed: configurationBasename)		modifyVersionMethodForVersion: developmentVersionString			versionSpecsDo: [ :attr :versionSpec | 					attr == attribute						ifTrue: [ versionSpec blessing: #release ].					true ];		commitMethod;		symbolicVersionMethod: #development;		addSymbolicSection: platformAttribute version: #notDefined;		commitMethod;		symbolicVersionMethod: #stable;		addSymbolicSection: platformAttribute version: developmentVersionString;		commitMethod.	^ toolbox! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!saveConfigurationPackageFor: configurationBasename description: commitMessage	"Save mcz file that contains the configuration to it's repository."		<apiDocumentation>	| toolbox criticalIssues |	(criticalIssues := self checkForCriticalValidationIssues: configurationBasename) isEmpty		ifTrue: [ 			toolbox := self configurationNamed: configurationBasename.			toolbox project goferCommitProject: commitMessage.			^toolbox ].	 self error: 'There are critical issues in configuration ' , configurationBasename printString, '. Configuration not saved'.	^nil! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!saveModifiedDevelopmentPackages: developmentVersionString for: configurationBasename description: commitMessage	"Save modified mcz files associated with the project. Then update given version to reflect the new mcz file versions."	<apiDocumentation>	| toolbox modifiedPackages cacheRepository |	modifiedPackages := Dictionary new.	(toolbox := self configurationNamed: configurationBasename)		modifiedPackageSpecs: developmentVersionString		packageSpecsDo: [ :versionSpec :packageSpec :monticelloWorkingCopy | 			| repositories repositoryGroup wcRepositoryGroup |			wcRepositoryGroup := monticelloWorkingCopy repositoryGroup.			repositoryGroup := MCRepositoryGroup new.			repositories := packageSpec repositories collect: [ :each | each createRepository ].			repositories isEmpty				ifTrue: [ 					repositories := versionSpec repositories collect: [ :repoSpec | repoSpec createRepository ].					wcRepositoryGroup repositories notEmpty						ifTrue: [ repositories := repositories select: [ :repo | wcRepositoryGroup includes: repo ] ].					repositories isEmpty						ifTrue: [ repositories := monticelloWorkingCopy repositoryGroup repositories reject: [ :repo | repo = MCCacheRepository default ] ] ].			repositories do: [ :repo | 				(monticelloWorkingCopy possiblyNewerVersionsIn: repo) notEmpty					ifTrue: [ self notify: 'There are possibly newer versions of the package ', packageSpec name printString, ' in the repository ', repo description printString, '. Cancel and manually merge if you want to pick up the changes from the later version.' ].				repositoryGroup addRepository: repo ].			modifiedPackages at: packageSpec name put: repositoryGroup ].	cacheRepository := MCCacheRepository default.	modifiedPackages isEmpty ifTrue: [ self notify: 'Empty modified packages list' "actually here for debugging purposes" ].	modifiedPackages		keysAndValuesDo: [ :packageName :repositoryGroup | 			| gofer repositoryList packageSpec |			gofer := Gofer new.			gofer disablePackageCache.			(repositoryGroup repositories reject: [:repo | repo = cacheRepository ]) do: [ :repository | gofer repository: repository ].			gofer package: packageName.			gofer commit: commitMessage ].	^ modifiedPackages! !!MetacelloToolBox class methodsFor: 'development support' stamp: 'dkh 3/7/2012 17:08:50'!saveModifiedPackagesAndConfigurationIn: aConfigurationClass description: commitMessage	"Save modified mcz files, update and then save the configuration."	<apiDocumentation>	| version |	version := aConfigurationClass project version: #development.	self		saveModifiedDevelopmentPackages: version versionString		for: aConfigurationClass name asString		description: commitMessage.	(self		updateDevelopment: version versionString		for: aConfigurationClass name asString		updateProjects: false		description: commitMessage) isEmpty		ifTrue: [ self updateDescription: version versionString for: aConfigurationClass name asString description: commitMessage ].	self saveConfigurationPackageFor: aConfigurationClass name asString description: commitMessage! !!MetacelloToolBox class methodsFor: 'development support' stamp: 'dkh 3/7/2012 17:08:50'!saveModifiedPackagesIn: aConfigurationClass description: commitMessage	"Save modified mcz files and update the configuration."	| version |	version := aConfigurationClass project version: #development.	self		saveModifiedDevelopmentPackages: version versionString for: aConfigurationClass name asString description: commitMessage;		updateDevelopment: version versionString			for: aConfigurationClass name asString			updateProjects: false			description: commitMessage! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!stableVersion: stableVersionString for: configurationBasename platformAttribute: platformAttribute	<apiDocumentation>	"Set the #stable symbolic version to the given version, using the given platformAttribute."		(MetacelloToolBox configurationNamed: configurationBasename)		symbolicVersionMethod: #stable;		addSymbolicSection: platformAttribute version: stableVersionString;		commitMethod.! !!MetacelloToolBox class methodsFor: 'private' stamp: 'dkh 3/7/2012 17:08:50'!stripVersionStringForSelector: versionString	^((versionString copyWithout: $.) copyWithout: $-) 		copyReplaceAll: 'baseline' with: '' ! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!updateDescription: developmentVersionString for: configurationBasename description: message	"Update description"	<apiDocumentation>	^ (self configurationNamed: configurationBasename)		updateVersionMethodForVersion: developmentVersionString			updateProjects: false			updatePackages: false			versionSpecsDo: [ :attribute :versionSpec | 				attribute == #common					ifTrue: [ 						"update the author, description and timeStamp"						versionSpec							author: MetacelloPlatform current authorName;							timestamp: MetacelloPlatform current timestamp.						self appendDescription: message to: versionSpec ].				true ];		commitMethod! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!updateDevelopment: developmentVersionString for: configurationBasename updatePackages: updatePackages description: message	"Update project specs and (conditionally) the package specs in the given version to reflect the new mcz file and project versions."	<apiDocumentation>	| toolbox updatedSpecs |	toolbox := self configurationNamed: configurationBasename.	updatedSpecs := toolbox		updateVersionMethodForVersion: developmentVersionString		updateProjects: true		updatePackages: updatePackages		versionSpecsDo: [ :attribute :versionSpec | 			attribute == #common				ifTrue: [ 					"update the author, description and timeStamp"					versionSpec						author: MetacelloPlatform current authorName;						timestamp: MetacelloPlatform current timestamp.					self appendDescription: message to: versionSpec ].			true ].	updatedSpecs notEmpty		ifTrue: [ toolbox commitMethod ].	^ updatedSpecs! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 3/7/2012 17:08:50'!updateDevelopment: developmentVersionString for: configurationBasename updateProjects: updateProjects description: message	"Update packageSpecs and (conditionally) the project specs in the given version to reflect the new mcz file and project versions."	<apiDocumentation>	| toolbox updatedSpecs |	toolbox := self configurationNamed: configurationBasename.	updatedSpecs := toolbox		updateVersionMethodForVersion: developmentVersionString		updateProjects: updateProjects		updatePackages: true		versionSpecsDo: [ :attribute :versionSpec | 			attribute == #common				ifTrue: [ 					"update the author, description and timeStamp"					versionSpec						author: MetacelloPlatform current authorName;						timestamp: MetacelloPlatform current timestamp.					self appendDescription: message to: versionSpec ].			true ].	updatedSpecs notEmpty		ifTrue: [ toolbox commitMethod ].	^ updatedSpecs! !!MetacelloToolBox class methodsFor: 'development support' stamp: 'dkh 3/7/2012 17:08:50'!updateToLatestPackageVersionsIn: aConfigurationClass description: descriptionString	"Update the #development version to match currently loaded mcz files."	"self updateToLatestPackageVersions: '- fixed a bug'"	<apiDocumentation>	^self		updateDevelopment: #development		for: aConfigurationClass name asString		updateProjects: false 		description: descriptionString! !!MetacelloToolBox class methodsFor: 'validation' stamp: 'dkh 3/7/2012 17:08:50'!validateConfiguration: configurationClass	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). "	<apiDocumentation>	^ self validateConfiguration: configurationClass debug: #() recurse: false! !!MetacelloToolBox class methodsFor: 'validation' stamp: 'dkh 3/7/2012 17:08:50'!validateConfiguration: configurationClass debug: debugList recurse: aBool	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). "	<apiDocumentation>	^ MetacelloMCVersionValidator validateConfiguration: configurationClass debug: debugList recurse: aBool! !!MetacelloToolBox class methodsFor: 'load validation' stamp: 'dkh 3/7/2012 17:08:50'!validatePlatformLoad: platformAttribute for: configurationBasename	"Validate, Load, and run tests for all versions of the given configuration. Return list of issues."	<apiDocumentation>	| issues configurationClass toolbox cleanDevelopmentLoads cleanLoadAndTests stableVersion |	configurationClass := Smalltalk at: (self configurationNameFrom: configurationBasename) asSymbol.	cleanDevelopmentLoads := OrderedCollection new.	cleanLoadAndTests := OrderedCollection new.	issues := [ MetacelloMCVersionValidator validateConfigurationLoad: configurationClass ]		on: MetacelloCleanNotification		do: [ :ex | 			(ex isKindOf: MetacelloCleanLoadAndTestsNotification)				ifTrue: [ cleanLoadAndTests add: ex version ].			((ex isKindOf: MetacelloCleanLoadNotification) and: [ ex version blessing == #development ])				ifTrue: [ cleanDevelopmentLoads add: ex version ].			ex resume ].	(cleanDevelopmentLoads isEmpty and: [ cleanLoadAndTests isEmpty ])		ifTrue: [ 			self inform: 'Failed validation with no versions load clean'.			^ issues ].	toolbox := self configurationNamed: configurationBasename.	cleanLoadAndTests notEmpty		ifTrue: [ 			toolbox				symbolicVersionMethod: #stable;				addSymbolicSection: platformAttribute version: (stableVersion := cleanLoadAndTests last) versionString;				commitMethod ].	stableVersion notNil		ifTrue: [ 			stableVersion blessing == #development				ifTrue: [ 					issues						add:							(MetacelloValidationWarning								configurationClass: configurationClass								reasonCode: #stableDevelopmentVersion								callSite: #validatePlatformLoad:for:								explanation:									'Development version ' , stableVersion versionString printString , ' is marked as #stableVersion for '										, configurationClass name asString) ].			cleanDevelopmentLoads := cleanDevelopmentLoads select: [ :version | version > stableVersion ] ].	cleanDevelopmentLoads notEmpty		ifTrue: [ 			toolbox				symbolicVersionMethod: #development;				addSymbolicSection: platformAttribute version: cleanDevelopmentLoads last versionString;				commitMethod ]		ifFalse: [ 			toolbox				symbolicVersionMethod: #development;				addSymbolicSection: platformAttribute version: #notDefined;				commitMethod ].	^ issues! !!MetacelloToolBox class methodsFor: 'load validation' stamp: 'dkh 3/7/2012 17:08:50'!validatePlatformLoad: platformAttribute for: configurationBasename version: versionString	"Load, and run tests for the given version of the configuration. Mark as #stable, if load and tests are clean. Return list of issues."	<apiDocumentation>	| issues configurationClass toolbox cleanLoadAndTests stableVersion |	configurationClass := Smalltalk at: (self configurationNameFrom: configurationBasename) asSymbol.	cleanLoadAndTests := OrderedCollection new.	issues := [ MetacelloMCVersionValidator validateConfigurationLoad: configurationClass version: versionString ]		on: MetacelloCleanNotification		do: [ :ex | 			(ex isKindOf: MetacelloCleanLoadAndTestsNotification)				ifTrue: [ cleanLoadAndTests add: ex version ].			ex resume ].	toolbox := self configurationNamed: configurationBasename.	cleanLoadAndTests isEmpty		ifTrue: [ ^issues ].	stableVersion := cleanLoadAndTests last.	toolbox		symbolicVersionMethod: #stable;		addSymbolicSection: platformAttribute version: stableVersion versionString;		commitMethod.	stableVersion blessing == #development		ifTrue: [ 			issues				add:					(MetacelloValidationWarning						configurationClass: configurationClass						reasonCode: #stableDevelopmentVersion						callSite: #validatePlatformLoad:for:version:						explanation:							'Development version ' , stableVersion versionString printString , ' is marked as #stableVersion for '								, configurationClass name asString) ].	^ issues! !!MetacelloToolBox class methodsFor: 'validation' stamp: 'dkh 3/7/2012 17:08:50'!validateProject: aMetacelloProject version: versionString	"Check a specific version in the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). "	<apiDocumentation>	^ self validateProject: aMetacelloProject version: versionString debug: #() recurse: false! !!MetacelloToolBox class methodsFor: 'validation' stamp: 'dkh 3/7/2012 17:08:50'!validateProject: aMetacelloProject version: versionString debug: debugList recurse: aBool	"Check a specific version in the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). "	<apiDocumentation>	^ MetacelloMCVersionValidator		validateProject: aMetacelloProject		version: versionString		debug: debugList		recurse: aBool! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 3/7/2012 17:08:50'!abortMethod	project := project configuration class project.	"recalculate project"	methodSpec := nil! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 3/7/2012 17:08:50'!addSection: sectionAttributeOrPath repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependecies groups: groups versionSpecsDo: aBlock	"		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		groups - collection of associations where key is the name of the group and value is the collection of group members	"	self		addSection: sectionAttributeOrPath		repository: repositoryDescription		requiredProjects: projectList		packages: packageList		dependencies: dependecies		includes: #()		files: #()		repositories: #()		preLoadDoIts: #()		postLoadDoIts: #()		supplyingAnswers: #()		groups: groups		versionSpecsDo: aBlock! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 9/7/2012 13:33'!addSection: sectionAttributeOrPath repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: groups versionSpecsDo: aBlock    "		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		groups - collection of associations where key is the name of the group and value is the collection of group members	"    | versionSpec dependencyMap includesMap filesMap repositoriesMap preLoadDoItsMap postLoadDoItsMap supplyingAnswersMap |    versionSpec := self createVersionSpec: self methodSpec versionString.    repositoryDescription ~~ nil        ifTrue: [ versionSpec repository: repositoryDescription ].    dependencyMap := self buildMapFrom: dependecies for: packageList.    includesMap := self buildMapFrom: includes for: packageList.    filesMap := self buildMapFrom: files for: packageList.    repositoriesMap := self buildMapFrom: repositories for: packageList , projectList.    preLoadDoItsMap := self buildMapFrom: preLoadDoIts for: packageList.    postLoadDoItsMap := self buildMapFrom: postLoadDoIts for: packageList.    supplyingAnswersMap := self buildMapFrom: supplyingAnswers for: packageList.    projectList        do: [ :projectName |             | spec |            spec := self createProjectReferenceSpec: projectName.            repositoriesMap                at: projectName                ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].            versionSpec packages merge: spec ].    packageList        do: [ :packageName |             | spec |            spec := self createPackageSpec: packageName.            dependencyMap at: packageName ifPresent: [ :dependencyList | spec requires: dependencyList ].            includesMap at: packageName ifPresent: [ :includesList | spec includes: includesList ].            filesMap at: packageName ifPresent: [ :file | spec file: file ].            repositoriesMap                at: packageName                ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].            preLoadDoItsMap at: packageName ifPresent: [ :preLoad | spec preLoadDoIt: preLoad ].            postLoadDoItsMap at: packageName ifPresent: [ :postLoad | spec postLoadDoIt: postLoad ].            supplyingAnswersMap at: packageName ifPresent: [ :answer | spec answers: answer ].            versionSpec packages merge: spec ].    groups        do: [ :assoc |             | spec |            spec := self createGroupSpec: assoc key.            spec includes: assoc value.            versionSpec packages merge: spec ].    aBlock value: versionSpec.    self methodSpec addMethodSection: sectionAttributeOrPath asMetacelloAttributePath versionSpec: versionSpec! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 3/7/2012 17:08:50'!addSection: sectionAttributeOrPath repository: repositoryDescription requiredProjects: projectList packages: packageList repositories: repositories dependencies: dependecies groups: groups versionSpecsDo: aBlock    "		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		repositories - collection of associations where key is name of package and value is collection of repository descriptions		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		groups - collection of associations where key is the name of the group and value is the collection of group members	"    self        addSection: sectionAttributeOrPath        repository: repositoryDescription        requiredProjects: projectList        packages: packageList        dependencies: dependecies        includes: #()        files: #()        repositories: repositories        preLoadDoIts: #()        postLoadDoIts: #()        supplyingAnswers: #()        groups: groups        versionSpecsDo: aBlock! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 9/8/2012 05:17'!addSectionsFrom: inputVersionStringOrSymbol forBaseline: forBaseline updateProjects: updateProjects updatePackages: updatePackages versionSpecsDo: aBlock    | constructor updatedSpecs projectAttributes fullVersionSpec version coll pragma imports visitedSpecs fromVersionString |    constructor := self constructor.    updatedSpecs := Set new.    visitedSpecs := Set new.    projectAttributes := project attributes.    version := project version: inputVersionStringOrSymbol.    fromVersionString := version versionString.    fullVersionSpec := version spec.    fullVersionSpec := version spec.    coll := constructor extractAllVersionPragmas at: fromVersionString ifAbsent: [ ^ nil ].    coll size > 1        ifTrue: [ self error: 'More than one pragma defining ' , fromVersionString printString ].    pragma := coll at: 1.    imports := pragma numArgs = 2        ifTrue: [ pragma argumentAt: 2 ]        ifFalse: [ #() ].    methodSpec imports: imports.    constructor extractMethodSectionsFor: fromVersionString.    constructor methodSections        do: [ :methodSection |             | versionSpec attributeList |            versionSpec := methodSection versionSpec.            attributeList := methodSection attributes.            forBaseline                ifFalse: [                     (projectAttributes includes: attributeList)                        ifTrue: [                             self                                updateVersionSpec: versionSpec                                fullVersionSpec: fullVersionSpec                                updateProjects: updateProjects                                updatePackages: updatePackages                                visited: visitedSpecs                                updated: updatedSpecs ] ].            (aBlock value: methodSection attributeOrPath value: versionSpec)                ifTrue: [ self methodSpec addMethodSection: methodSection attributePath versionSpec: versionSpec ] ]! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 9/7/2012 07:50'!addSymbolicSection: attribute version: versionString    self methodSpec methodSections        do: [ :methodSection |             methodSection attributes = {attribute}                ifTrue: [                     methodSection versionString: versionString.                    ^ self ] ].    self methodSpec addMethodSection: attribute versionString: versionString! !!MetacelloToolBox methodsFor: 'private' stamp: 'dkh 05/15/2013 20:39'!baselineNameFrom: baseName  ^ self class baselineNameFrom: baseName! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 05/15/2013 20:17'!baselineNamed: baseName  | baselineName |  "Check if the class does not exist"  baselineName := self baselineNameFrom: baseName.  (Smalltalk includesKey: baselineName asSymbol)    ifFalse: [       "Create the configuration class"      self ensureMetacello.      BaselineOf        subclass: baselineName        instVarNames: #()        classVars: #()        classInstVars: #()        poolDictionaries: #()        category: baselineName.      PackageInfo registerPackageName: baselineName ].  project := (MetacelloPlatform current globalNamed: baselineName asSymbol)    project! !!MetacelloToolBox methodsFor: 'private' stamp: 'dkh 3/7/2012 17:08:50'!buildMapFrom: mapList for: packageList	| map |	map := Dictionary new.	mapList		do: [ :assoc | 			| pkgName pkgSpec |			pkgName := assoc key.			(packageList includes: pkgName)				ifFalse: [ self error: 'package ' , pkgName printString , ' not found in packages.' ].			map at: pkgName put: assoc value ].	^ map! !!MetacelloToolBox methodsFor: 'private' stamp: 'dkh 3/7/2012 17:08:50'!clearVersionSpec: versionSpec fullVersionSpec: fullVersionSpec updateProjects: updateProjects updatePackages: updatePackages	versionSpec		specListProjectDo: [ :spec | 			updateProjects				ifTrue: [ 					| fullProjectReferenceSpec fullProjectSpec |					(fullProjectReferenceSpec := fullVersionSpec packageNamed: spec name) ~~ nil						ifTrue: [ 							fullProjectSpec := fullProjectReferenceSpec projectReference.							fullProjectSpec versionString == nil								ifTrue: [ spec projectReference versionString: '' ] ] ] ]		packageDo: [ :spec | 			updatePackages				ifTrue: [ 					spec getFile ~~ nil						ifTrue: [ spec file: '' ] ] ]		groupDo: [ :ignored |  ]! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 3/7/2012 17:08:50'!commitConfiguration: commitComment! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 3/7/2012 17:08:50'!commitMethod	| skipValidation isues |	skipValidation := false.	self methodSpec ifNil: [ ^self ].	self methodSpec compileMethod.	project := project configuration class project.	"recalculate project"	[ project version: self methodSpec versionString ]		on: MetacelloSymbolicVersionDoesNotExistError		do: [ :ex | 			"symbolic versions can be removed"			skipValidation := true ].	skipValidation		ifFalse: [ self validateVersion: self methodSpec versionString ].	methodSpec := nil! !!MetacelloToolBox methodsFor: 'private' stamp: 'dkh 3/7/2012 17:08:50'!configurationNameFrom: baseName		^self class configurationNameFrom: baseName! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 3/7/2012 17:08:50'!configurationNamed: baseName	| configurationName |	"Check if the class does not exist"	configurationName := self configurationNameFrom: baseName.	(Smalltalk includesKey: configurationName asSymbol)		ifFalse: [ 			self ensureMetacello.				"Create the configuration class"			MetacelloPlatform current				copyClass: (MetacelloPlatform current globalNamed: #MetacelloConfigTemplate)				as: configurationName asSymbol				inCategory: configurationName asString.				"Create the package that has the same name"			PackageInfo registerPackageName: configurationName ].	project := (MetacelloPlatform current globalNamed: configurationName asSymbol) project! !!MetacelloToolBox methodsFor: 'accessing' stamp: 'dkh 3/7/2012 17:08:50'!constructor	| constructor |	constructor := MetacelloToolBoxConstructor new.	constructor configuration: project configuration class new.	^constructor! !!MetacelloToolBox methodsFor: 'spec creation' stamp: 'dkh 3/7/2012 17:08:50'!createConfiguration: baseName	| configurationName |	"Check if the class does not exist"	configurationName := (baseName beginsWith: 'ConfigurationOf')		ifTrue: [ baseName ]		ifFalse: [ 'ConfigurationOf' , baseName ].	(Smalltalk includesKey: configurationName asSymbol)		ifFalse: [ 			self ensureMetacello.				"Create the configuration class"			MetacelloPlatform current				copyClass: (MetacelloPlatform current globalNamed: #MetacelloConfigTemplate)				as: configurationName asSymbol				inCategory: configurationName asString.				"Create the package that has the same name"			PackageInfo registerPackageName: configurationName ].	^(MetacelloPlatform current globalNamed: configurationName asSymbol) project! !!MetacelloToolBox methodsFor: 'spec creation' stamp: 'dkh 3/7/2012 17:08:50'!createGroupSpec: baseName	^ (self project groupSpec)		name: baseName;		yourself! !!MetacelloToolBox methodsFor: 'spec creation' stamp: 'dkh 3/7/2012 17:08:50'!createPackageSpec: baseName	^ (project packageSpec)		name: baseName;		yourself! !!MetacelloToolBox methodsFor: 'spec creation' stamp: 'dkh 3/7/2012 17:08:50'!createProjectReferenceSpec: projectBaseName    | configurationName projectReferenceProject versionString |    configurationName := self configurationNameFrom: projectBaseName.    projectReferenceProject := (MetacelloPlatform current        globalNamed: configurationName asSymbol        ifAbsent: [             self                error:                    'The configuration ' , configurationName printString , ' for the project ' , projectBaseName printString                        , ' is not currently loaded into the image.' ]) project.    versionString := (projectReferenceProject hasVersion: #'stable')        ifTrue: [ #'stable' ]        ifFalse: [ #'bleedingEdge' ].    ^ project projectReferenceSpec        name: projectBaseName;        projectReference:                (project projectSpec                        name: projectBaseName;                        className: configurationName;                        versionString: versionString;                        yourself);        yourself! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 3/7/2012 17:08:50'!createSymbolicVersionMethod: selector inCategory: category forVersion: versionSymbol	| constructor |	methodSpec := (MetacelloSymbolicVersionMethodSpec new)		project: project;		selector: selector;		category: category;		versionString: versionSymbol;		yourself.	constructor := self constructor.	self methodSpec methodSections: (constructor extractSymbolicVersionSpecsFor: versionSymbol) asOrderedCollection.! !!MetacelloToolBox methodsFor: 'spec creation' stamp: 'dkh 3/7/2012 17:08:50'!createVersion: versionString	| version  |	[ version := project version: versionString ]		on: MetacelloVersionDoesNotExistError		do: [ :ex | 			| versionSpec |			versionSpec := self createVersionSpec: versionString.			version := versionSpec createVersion.			project map == nil				ifTrue: [ project map: Dictionary new ].			project map at: versionString put: version ].	^version! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 3/7/2012 17:08:50'!createVersionMethod: selector inCategory: category forVersion: versionString		methodSpec := (MetacelloVersionMethodSpec new)		project: project;		selector: selector;		category: category;		versionString: versionString;		yourself.! !!MetacelloToolBox methodsFor: 'spec creation' stamp: 'dkh 3/7/2012 17:08:50'!createVersionSpec: versionString	| versionSpec |	versionSpec := project versionSpec.	versionSpec versionString: versionString.	^ versionSpec! !!MetacelloToolBox methodsFor: 'private' stamp: 'dkh 9/13/2012 16:18'!editVersionSpecsForImport: constructor projectAttributes: projectAttributes active: activeSection fullVersionSpec: fullVersionSpec updateProjects: updateProjects updatePackages: updatePackages visited: visitedSpecs updated: updatedSpecs    | fileSpecified encounteredPackageSpecs |    fileSpecified := Bag new.    encounteredPackageSpecs := Bag new.    constructor        methodSectionsInEvaluationOrder: projectAttributes reverse        do: [ :methodSection |             "collect packageSpec names ... interested in singletons"            methodSection versionSpec                specListProjectDo: [ :spec |  ]                packageDo: [ :spec |                     encounteredPackageSpecs add: spec name.                    (spec copy updateForSpawnMethod: spec)                        ifFalse: [ fileSpecified add: spec name ] ]                groupDo: [ :spec |  ] ].    constructor        methodSectionsInEvaluationOrder: projectAttributes reverse        do: [ :methodSection |             | versionSpec attributePath packageSpecsToDelete |            versionSpec := methodSection versionSpec.            attributePath := methodSection attributePath.            versionSpec updateForSpawnMethod: versionSpec.            packageSpecsToDelete := OrderedCollection new.            versionSpec                specListProjectDo: [ :spec | spec updateForSpawnMethod: spec ]                packageDo: [ :spec |                     encounteredPackageSpecs remove: spec name.                    (spec updateForSpawnMethod: spec)                        ifTrue: [                             "no file speced"                            ((fileSpecified includes: spec name) or: [ encounteredPackageSpecs includes: spec name ])                                ifTrue: [                                     "already specified somewhere else, need to delete this spec from version spec OR we're deleting all but first occurence"                                    packageSpecsToDelete add: spec ]                                ifFalse: [                                     "file hasn't been specified, so specify now"                                    spec file: spec name.                                    fileSpecified add: spec name ] ]                        ifFalse: [                             "file specified"                            (fileSpecified occurrencesOf: spec name) > 1                                ifTrue: [                                     "multiple specifications for file ... delete all but first occurence"                                    packageSpecsToDelete add: spec.                                    fileSpecified remove: spec name ] ] ]                groupDo: [ :spec | spec updateForSpawnMethod: spec ].            packageSpecsToDelete do: [ :spec | versionSpec deleteSpec: spec ].            activeSection                ifTrue: [                     self                        updateVersionSpec: versionSpec                        fullVersionSpec: fullVersionSpec                        updateProjects: updateProjects                        updatePackages: updatePackages                        visited: visitedSpecs                        updated: updatedSpecs ]                ifFalse: [                     self                        clearVersionSpec: versionSpec                        fullVersionSpec: fullVersionSpec                        updateProjects: updateProjects                        updatePackages: updatePackages ] ]! !!MetacelloToolBox methodsFor: 'private' stamp: 'dkh 3/7/2012 17:08:50'!ensureMetacello	"noop for now"! !!MetacelloToolBox methodsFor: 'testing' stamp: 'dkh 3/7/2012 17:08:50'!hasMethodForSymbolicVersion: versionSymbol	^(self constructor extractSymbolicVersionPragmas at: versionSymbol ifAbsent: [ ^ false ]) size > 0! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 9/14/2012 09:47'!importFrom: inputVersionStringOrSymbol projectAttributes: projectAttributes inactiveAttributes: inactiveAttributesList updateProjects: updateProjects updatePackages: updatePackages versionSpecsDo: aBlock    | constructor updatedSpecs fullVersionSpec version visitedSpecs fromVersionString attributeSet |    constructor := self constructor.    updatedSpecs := Set new.    visitedSpecs := Set new.    version := project version: inputVersionStringOrSymbol.    fromVersionString := version versionString.	"resolve symbolic versions"    fullVersionSpec := version spec.    self methodSpec imports: {fromVersionString}.    constructor extractMethodSectionsFor: fromVersionString.    self        editVersionSpecsForImport: constructor        projectAttributes: projectAttributes        active: true        fullVersionSpec: fullVersionSpec        updateProjects: updateProjects        updatePackages: updatePackages        visited: visitedSpecs        updated: updatedSpecs.    attributeSet := projectAttributes.    inactiveAttributesList        do: [ :inactiveAttributes |             self                editVersionSpecsForImport: constructor                projectAttributes: inactiveAttributes                active: false                fullVersionSpec: fullVersionSpec                updateProjects: updateProjects                updatePackages: updatePackages                visited: visitedSpecs                updated: updatedSpecs.            attributeSet := attributeSet , projectAttributes ].    attributeSet := attributeSet asSet.    constructor        methodSectionsDo: [ :methodSection |             | versionSpec attributePath |            versionSpec := methodSection versionSpec.            attributePath := methodSection attributePath.            (methodSection includesAttributeFrom: attributeSet)                ifFalse: [                     versionSpec updateForSpawnMethod: versionSpec.                    versionSpec                        specListProjectDo: [ :spec | spec updateForSpawnMethod: spec ]                        packageDo: [ :spec | spec updateForSpawnMethod: spec ]                        groupDo: [ :spec | spec updateForSpawnMethod: spec ].                    self                        clearVersionSpec: versionSpec                        fullVersionSpec: fullVersionSpec                        updateProjects: updateProjects                        updatePackages: updatePackages ].            (aBlock value: attributePath asAttributeOrPath value: versionSpec)                ifTrue: [ self methodSpec addMethodSection: attributePath versionSpec: versionSpec ] ]! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 9/13/2012 16:05'!importFrom: inputVersionStringOrSymbol updateProjects: updateProjects updatePackages: updatePackages versionSpecsDo: aBlock    ^ self        importFrom: inputVersionStringOrSymbol        projectAttributes: project attributes        inactiveAttributes: #()        updateProjects: updateProjects        updatePackages: updatePackages        versionSpecsDo: aBlock! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 3/7/2012 17:08:50'!imports: importList	self methodSpec imports: importList! !!MetacelloToolBox methodsFor: 'accessing' stamp: 'dkh 3/7/2012 17:08:50'!methodSpec	^methodSpec! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 3/7/2012 17:08:50'!modifiedPackageSpecs: versionStringOrSymbol packageSpecsDo: aBlock	| versionSpec |	versionSpec := (self project version: versionStringOrSymbol) spec.	versionSpec		projectDo: [ :ignored |  ]		packageDo: [ :packageSpec | 			| wc |			wc := packageSpec workingCopy.			wc ~~ nil				ifTrue: [ 					wc modified						ifTrue: [ aBlock value: versionSpec value: packageSpec value: wc ] ] ]		groupDo: [ :ignored |  ]! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 9/8/2012 05:04'!modifySection: sectionAttributeOrPath repository: repositoryDescription requiredProjects: newProjectList packages: newPackageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: newGroups versionSpecsDo: aBlock    "		repositoryDescription - metacello repository string		newProjectList - collection of project base names (without ConfigurationOf prefix)		newPackageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		newGroups - collection of associations where key is the name of the group and value is the collection of group members	"    self        modifySection: sectionAttributeOrPath        sectionIndex: 1        repository: repositoryDescription        requiredProjects: newProjectList        packages: newPackageList        dependencies: dependecies        includes: includes        files: files        repositories: repositories        preLoadDoIts: preLoadDoIts        postLoadDoIts: postLoadDoIts        supplyingAnswers: supplyingAnswers        groups: newGroups        versionSpecsDo: aBlock! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 9/8/2012 05:05'!modifySection: sectionAttributeOrPath sectionIndex: sectionIndex repository: repositoryDescription requiredProjects: newProjectList packages: newPackageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: newGroups versionSpecsDo: aBlock    "		repositoryDescription - metacello repository string		newProjectList - collection of project base names (without ConfigurationOf prefix)		newPackageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		newGroups - collection of associations where key is the name of the group and value is the collection of group members	"    | versionSpec dependencyMap includesMap filesMap repositoriesMap preLoadDoItsMap postLoadDoItsMap supplyingAnswersMap groups packageList newGroupNames |    versionSpec := (self methodSpec        findMethodSection: sectionAttributeOrPath asMetacelloAttributePath        sectionIndex: sectionIndex) versionSpec.    repositoryDescription ~~ nil        ifTrue: [ versionSpec repository: repositoryDescription ].    newProjectList        do: [ :projectName |             (versionSpec packages specListDetect: [ :spec | spec name = projectName ] ifNone: [  ]) == nil                ifTrue: [ versionSpec packages merge: (self createProjectReferenceSpec: projectName) ]                ifFalse: [ self error: 'Project named: ' , projectName printString , ' already exists.' ] ].    packageList := OrderedCollection new.    groups := OrderedCollection new.    newGroupNames := OrderedCollection new.    versionSpec        projectDo: [ :ignored |  ]        packageDo: [ :pkg | packageList add: pkg name ]        groupDo: [ :group |             groups add: group name -> group includes.            newGroupNames add: group name ].    newPackageList        do: [ :packageName |             (packageList includes: packageName)                ifTrue: [ self error: 'Package named: ' , packageName printString , ' already exists.' ]                ifFalse: [ packageList add: packageName ] ].    newGroups        do: [ :assoc |             (newGroupNames includes: assoc key)                ifTrue: [ self error: 'Group named: ' , assoc key printString , ' already exists.' ]                ifFalse: [ groups add: assoc ] ].    dependencyMap := self buildMapFrom: dependecies for: packageList.    includesMap := self buildMapFrom: includes for: packageList.    filesMap := self buildMapFrom: files for: packageList.    repositoriesMap := self buildMapFrom: repositories for: packageList.    preLoadDoItsMap := self buildMapFrom: preLoadDoIts for: packageList.    postLoadDoItsMap := self buildMapFrom: postLoadDoIts for: packageList.    supplyingAnswersMap := self buildMapFrom: supplyingAnswers for: packageList.    packageList        do: [ :packageName |             | spec |            (newPackageList includes: packageName)                ifTrue: [                     spec := self createPackageSpec: packageName.                    versionSpec packages merge: spec ]                ifFalse: [ spec := versionSpec packages specListDetect: [ :spc | spc name = packageName ] ].            dependencyMap                at: packageName                ifPresent: [ :dependencyList | spec setRequires: spec requires , dependencyList ].            includesMap at: packageName ifPresent: [ :includesList | spec setIncludes: spec includes , includesList ].            filesMap at: packageName ifPresent: [ :file | spec file: file ].            repositoriesMap                at: packageName                ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].            preLoadDoItsMap at: packageName ifPresent: [ :preLoad | spec preLoadDoIt: preLoad ].            postLoadDoItsMap at: packageName ifPresent: [ :postLoad | spec postLoadDoIt: postLoad ].            supplyingAnswersMap at: packageName ifPresent: [ :answer | spec answers: answer ] ].    groups        do: [ :assoc |             | spec |            (newGroupNames includes: assoc key)                ifFalse: [                     spec := self createGroupSpec: assoc key.                    versionSpec packages merge: spec.                    spec setIncludes: spec includes , assoc value ] ].    aBlock value: versionSpec! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 3/7/2012 17:08:50'!modifySymbolicVersionMethodFor: versionSymbol	^self modifySymbolicVersionMethodFor: versionSymbol symbolicVersionSpecsDo: [:symbolicVersionSpec | true ].! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 9/9/2012 07:36'!modifySymbolicVersionMethodFor: versionSymbol symbolicVersionSpecsDo: aBlock    | constructor coll pragma |    constructor := self constructor.    coll := constructor extractSymbolicVersionPragmas at: versionSymbol ifAbsent: [ ^ nil ].    coll size > 1        ifTrue: [ self error: 'More than one pragma defining ' , versionSymbol printString ].    pragma := coll at: 1.    methodSpec := MetacelloSymbolicVersionMethodSpec new        project: project;        selector: pragma selector;        category: (project configuration class whichCategoryIncludesSelector: pragma selector);        versionString: versionSymbol;        yourself.    (constructor extractSymbolicVersionSpecsFor: versionSymbol)        do: [ :symbolicVersionSpec |             (aBlock value: symbolicVersionSpec)                ifTrue: [ self methodSpec addMethodSection: symbolicVersionSpec attributes versionString: symbolicVersionSpec versionString ] ]! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 3/7/2012 17:08:50'!modifyVersionMethodForVersion: inputVersionStringOrSymbol	^ self modifyVersionMethodForVersion: inputVersionStringOrSymbol versionSpecsDo: [ :attribute :versionSpec | true ]! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 3/7/2012 17:08:50'!modifyVersionMethodForVersion: inputVersionStringOrSymbol versionSpecsDo: aBlock	^ self		updateVersionMethodForVersion: inputVersionStringOrSymbol		updateProjects: false		updatePackages: false		versionSpecsDo: aBlock! !!MetacelloToolBox methodsFor: 'accessing' stamp: 'dkh 3/7/2012 17:08:50'!project	^project! !!MetacelloToolBox methodsFor: 'accessing' stamp: 'dkh 3/7/2012 17:08:50'!project: aMetacelloProject	project := aMetacelloProject! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 3/7/2012 17:08:50'!symbolicVersionMethod: versionSymbol	(self hasMethodForSymbolicVersion: versionSymbol)		ifTrue: [ self modifySymbolicVersionMethodFor: versionSymbol ]		ifFalse: [ 			self				createSymbolicVersionMethod: versionSymbol asString , ':'				inCategory: 'symbolic versions'				forVersion: versionSymbol ].! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 9/13/2012 19:13'!updateVersionMethodForVersion: inputVersionStringOrSymbol projectAttributes: projectAttributes updateProjects: updateProjects updatePackages: updatePackages versionSpecsDo: aBlock    | constructor updatedSpecs fullVersionSpec version coll pragma imports blessing reversed addedSections visitedSpecs sourceVersionString keptSections |    updatedSpecs := Set new.    version := project version: inputVersionStringOrSymbol.    sourceVersionString := version versionString.	"resolve symbolic version"    blessing := version blessing.    blessing == #'release'        ifTrue: [             MetacelloCannotUpdateReleasedVersionError                signal: 'Should not update a version that has been released (resume to continue update).' ].    fullVersionSpec := version spec.    constructor := self constructor.    coll := constructor extractAllVersionPragmas at: sourceVersionString ifAbsent: [ ^ updatedSpecs ].    coll size > 1        ifTrue: [ self error: 'More than one pragma defining ' , sourceVersionString printString ].    pragma := coll at: 1.    imports := pragma numArgs = 2        ifTrue: [ pragma argumentAt: 2 ]        ifFalse: [ #() ].    methodSpec := MetacelloVersionMethodSpec new        project: project;        selector: pragma selector;        category: (project configuration class whichCategoryIncludesSelector: pragma selector);        versionString: sourceVersionString;        imports: imports;        yourself.    constructor extractMethodSectionsFor: sourceVersionString.    addedSections := Dictionary new.    visitedSpecs := Set new.    keptSections := IdentitySet new.    constructor        methodSectionsInEvaluationOrder: projectAttributes reverse        do: [ :methodSection |             | versionSpec |            versionSpec := methodSection versionSpec.            (blessing ~~ #'baseline' and: [ methodSection includesAttributeFrom: projectAttributes ])                ifTrue: [                     self                        updateVersionSpec: versionSpec                        fullVersionSpec: fullVersionSpec                        updateProjects: updateProjects                        updatePackages: updatePackages                        visited: visitedSpecs                        updated: updatedSpecs ].            (aBlock value: methodSection attributeOrPath value: versionSpec)                ifTrue: [ keptSections add: methodSection topParent ] ].    constructor methodSections        do: [ :methodSection |             (methodSection includesAttributeFrom: projectAttributes)                ifTrue: [                     (keptSections includes: methodSection)                        ifTrue: [ self methodSpec methodSections add: methodSection ] ]                ifFalse: [ self methodSpec methodSections add: methodSection ] ].    ^ updatedSpecs! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 9/13/2012 16:43'!updateVersionMethodForVersion: inputVersionStringOrSymbol updateProjects: updateProjects updatePackages: updatePackages versionSpecsDo: aBlock    ^ self        updateVersionMethodForVersion: inputVersionStringOrSymbol        projectAttributes: project attributes        updateProjects: updateProjects        updatePackages: updatePackages        versionSpecsDo: aBlock! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 3/7/2012 17:08:50'!updateVersionMethodForVersion: inputVersionStringOrSymbol versionSpecsDo: aBlock	^ self		updateVersionMethodForVersion: inputVersionStringOrSymbol		updateProjects: true		updatePackages: true		versionSpecsDo: aBlock! !!MetacelloToolBox methodsFor: 'private' stamp: 'dkh 9/13/2012 16:55'!updateVersionSpec: versionSpec fullVersionSpec: fullVersionSpec updateProjects: updateProjects updatePackages: updatePackages visited: visitedSpecs updated: updatedSpecs    versionSpec        specListProjectDo: [ :spec |             (updateProjects and: [ (visitedSpecs includes: spec name) not ])                ifTrue: [                     | fullProjectSpec |                    fullProjectSpec := (fullVersionSpec packageNamed: spec name) projectReference.                    (fullProjectSpec versionString ~~ nil                        and: [ fullProjectSpec versionString ~~ #'stable' and: [ fullProjectSpec projectClass ~~ nil ] ])                        ifTrue: [                             | cv |                            cv := fullProjectSpec projectClassProject currentVersion.                            cv ~~ nil                                ifTrue: [                                     cv versionString ~= fullProjectSpec versionString                                        ifTrue: [                                             spec projectReference versionString: cv versionString.                                            updatedSpecs add: spec name ] ]                                ifFalse: [                                     "set to an empty string as a place holder, since we know we should have a version, but we are unable to figure out the version"                                    spec projectReference versionString: ''.                                    updatedSpecs add: spec name ] ] ] ]        packageDo: [ :spec |             (updatePackages and: [ (visitedSpecs includes: spec name) not ])                ifTrue: [                     spec getFile ~~ nil                        ifTrue: [                             | viName |                            spec file = ''                                ifTrue: [ spec file: spec name ].                            (viName := spec workingCopyNameFor: spec loader) ~~ nil                                ifTrue: [                                     viName ~= spec file                                        ifTrue: [                                             spec file: viName.                                            updatedSpecs add: spec name ].                                    visitedSpecs add: spec name ] ] ] ]        groupDo: [ :ignored |  ]! !!MetacelloToolBox methodsFor: 'validation' stamp: 'dkh 3/7/2012 17:08:50'!validateConfiguration    | issues |    issues := (MetacelloMCVersionValidator validateConfiguration: project configuration class recurse: false)        select: [ :issue | issue isCritical ].    issues notEmpty        ifTrue: [ MetacelloValidationFailure issues: issues message: 'There are critical issues in the configuration' ]! !!MetacelloToolBox methodsFor: 'validation' stamp: 'dkh 3/7/2012 17:08:50'!validateVersion: versionStringOrSymbol    | issues |    issues := (MetacelloMCVersionValidator validateProject: project version: versionStringOrSymbol)        select: [ :issue | issue isError ].    issues notEmpty        ifTrue: [             MetacelloValidationFailure                issues: issues                message: 'There are error issues with version ' , versionStringOrSymbol printString ]! !"Metacello-ToolBox"!!MCFileTreeRepository methodsFor: '*metacello-filetree' stamp: 'dkh 5/16/2012 21:21:27'!metacelloProjectClassFor: aScriptEngine    aScriptEngine versionString isEmptyOrNil        ifFalse: [             "If we have a version in the script, then a BaselineOf is not being referenced...use a MetacelloMCProject	    	 see https://github.com/dalehenrich/metacello-work/issues/7"            ^ super metacelloProjectClassFor: aScriptEngine ].    ^ MetacelloMCBaselineProject! !"Metacello-FileTree"!SystemOrganization addCategory: #'Metacello-GitHub'!MCFileTreeRepository subclass: #MCGitHubRepository	instanceVariableNames: 'projectPath projectVersion repoPath'	classVariableNames: 'CacheDirectory DownloadCache'	poolDictionaries: ''	category: 'Metacello-GitHub'!!MCGitHubRepository class methodsFor: 'private' stamp: 'dkh 07/12/2013 11:52'!cacheDirectory  self resetCacheDirectoryIfInvalid.  CacheDirectory ifNil: [ CacheDirectory := self defaultCacheDirectory ].  ^ CacheDirectory! !!MCGitHubRepository class methodsFor: 'private' stamp: 'dkh 07/12/2013 11:36'!cacheDirectory: aDirectory  "explicitly set CacheDirectory"  CacheDirectory := aDirectory! !!MCGitHubRepository class methodsFor: 'private' stamp: 'ChristopheDemarey 4/29/2013 15:24'!cacheDirectoryFor: projectPath	| cacheDirectory projectDirectory |		cacheDirectory := self cacheDirectory.	projectDirectory := MetacelloPlatform current directoryFromPath: projectPath relativeTo: cacheDirectory.	MetacelloPlatform current ensureDirectoryExists: projectDirectory.	^ projectDirectory! !!MCGitHubRepository class methodsFor: 'private' stamp: 'dkh 07/12/2013 11:36'!defaultCacheDirectory  | defaultDirectory cacheDirectory |  defaultDirectory := MetacelloPlatform current defaultDirectory.  cacheDirectory := MetacelloPlatform current    directoryFromPath: 'github-cache'    relativeTo: defaultDirectory.  MetacelloPlatform current ensureDirectoryExists: cacheDirectory.  ^ cacheDirectory! !!MCGitHubRepository class methodsFor: 'accessing' stamp: 'dkh 5/16/2012 14:52:41'!description    ^ 'github://'! !!MCGitHubRepository class methodsFor: 'accessing' stamp: 'dkh 6/16/2012 08:29'!downloadCache    DownloadCache ifNil: [ DownloadCache := Dictionary new ].    ^ DownloadCache! !!MCGitHubRepository class methodsFor: 'accessing' stamp: 'dkh 7/24/2012 21:50'!downloadCacheKey: projectPath version: versionString    ^ projectPath , ':::' , versionString! !!MCGitHubRepository class methodsFor: 'initialization' stamp: 'dkh 6/16/2012 08:25'!flushDownloadCache    "self flushDownloadCache"    DownloadCache := nil! !!MCGitHubRepository class methodsFor: 'utility' stamp: 'dkh 7/24/2012 21:50'!flushProjectEntry: projectPath version: versionString    self downloadCache removeKey: (self downloadCacheKey: projectPath version: versionString) ifAbsent: [  ]! !!MCGitHubRepository class methodsFor: 'initialization' stamp: 'dkh 07/12/2013 11:52'!initialize  "self initialize"  Smalltalk addToStartUpList: self.  self flushDownloadCache.  self resetCacheDirectoryIfInvalid! !!MCGitHubRepository class methodsFor: 'accessing' stamp: 'dkh 5/16/2012 14:52:41'!isAbstract    "abstract as far as creating new repositories interactively? yes"    ^ true! !!MCGitHubRepository class methodsFor: 'instance creation' stamp: 'dkh 5/16/2012 14:52:41'!location: locationUrl    ^ self location: locationUrl version: nil! !!MCGitHubRepository class methodsFor: 'instance creation' stamp: 'dkh 6/16/2012 09:08'!location: locationUrl version: versionString    ^ self parseLocation: locationUrl version: versionString! !!MCGitHubRepository class methodsFor: 'private' stamp: 'dkh 5/16/2012 14:52:41'!parseLocation: locationUrl version: versionString    "self 	parseLocation: 'github://dalehenrich/MetacelloRepository:master/monticello/repos/itory/path'	version: nil     "    | projectPath projectVersion repoPath headerSize desc projectDelim repoDelim versionDelim |    headerSize := 'github://' size.    desc := locationUrl.    desc := desc copyFrom: headerSize + 1 to: desc size.    projectVersion := repoPath := nil.    projectDelim := desc indexOf: $/.    repoDelim := desc indexOf: $/ startingAt: projectDelim + 1.    (versionDelim := desc indexOf: $:) == 0        ifTrue: [             repoDelim == 0                ifTrue: [ projectPath := desc ]                ifFalse: [                     projectPath := desc copyFrom: 1 to: repoDelim - 1.                    repoPath := desc copyFrom: repoDelim + 1 to: desc size ] ]        ifFalse: [             projectPath := desc copyFrom: 1 to: versionDelim - 1.            repoDelim == 0                ifTrue: [ projectVersion := desc copyFrom: versionDelim + 1 to: desc size ]                ifFalse: [                     projectVersion := desc copyFrom: versionDelim + 1 to: repoDelim - 1.                    repoPath := desc copyFrom: repoDelim + 1 to: desc size ] ].    versionString ~~ nil        ifTrue: [ projectVersion := versionString ].    ^ self new        projectPath: projectPath;        projectVersion: projectVersion;        repoPath: repoPath;        yourself! !!MCGitHubRepository class methodsFor: 'utility' stamp: 'dkh 07/01/2013 08:48'!projectDirectoryFrom: projectPath version: versionString  | mcPlatform githubCacheDirectory projectDirectory downloadCacheKey cachePath |  downloadCacheKey := self downloadCacheKey: projectPath version: versionString.  mcPlatform := MetacelloPlatform current.  githubCacheDirectory := mcPlatform    directoryFromPath: versionString    relativeTo: (self cacheDirectoryFor: projectPath).  cachePath := self downloadCache at: downloadCacheKey ifAbsent: [  ].  (cachePath isNil    or: [       (projectDirectory := mcPlatform        directoryFromPath: cachePath        relativeTo: githubCacheDirectory) exists not ])    ifTrue: [       | url archive directory zipFileName |      MetacelloScriptGitHubDownloadNotification new        projectPath: projectPath;        versionString: versionString;        signal.	"for testing purposes"      mcPlatform ensureDirectoryExists: githubCacheDirectory.      url := 'https://github.com/' , projectPath , '/zipball/' , versionString.      zipFileName := '/tmp/github-'        , (downloadCacheKey select: [ :c | c isAlphaNumeric ]) , '.zip'.      archive := MetacelloPlatform current downloadFile: url to: zipFileName.      directory := mcPlatform        directoryFromPath: (cachePath := archive members first fileName)        relativeTo: githubCacheDirectory.      directory exists        ifFalse: [           MetacelloPlatform current            extractRepositoryFrom: zipFileName            to: githubCacheDirectory fullName ].      self downloadCache at: downloadCacheKey put: cachePath.      projectDirectory := mcPlatform        directoryFromPath: cachePath        relativeTo: githubCacheDirectory ].  ^ projectDirectory! !!MCGitHubRepository class methodsFor: 'private' stamp: 'dkh 07/12/2013 11:51'!resetCacheDirectoryIfInvalid  "Reset if invalid"  CacheDirectory notNil    and: [       (MCFileTreeFileUtils current directoryExists: CacheDirectory)        ifFalse: [ CacheDirectory := nil ] ]! !!MCGitHubRepository class methodsFor: 'system startup' stamp: 'dkh 6/16/2012 08:24'!startUp: resuming    "Flush the GitHub download cache"    resuming        ifTrue: [ self flushDownloadCache ]! !!MCGitHubRepository methodsFor: 'accessing' stamp: 'dkh 5/16/2012 14:52:41'!asRepositorySpecFor: aMetacelloMCProject    ^ aMetacelloMCProject repositorySpec        description: self description;        type: 'github';        yourself! !!MCGitHubRepository methodsFor: 'descriptions' stamp: 'dkh 5/16/2012 14:52:41'!description    | desc |    desc := self class description , self projectPath , ':' , self projectVersion.    self repoPath ifNil: [ ^ desc ].    ^ desc , '/' , self repoPath! !!MCGitHubRepository methodsFor: 'accessing' stamp: 'dkh 07/01/2013 13:23'!directory  directory    ifNil: [       directory := self class        projectDirectoryFrom: self projectPath        version: self projectVersion.      self repoPath        ifNotNil: [           directory := MetacelloPlatform current            directoryFromPath: self repoPath            relativeTo: directory ] ]    ifNotNil: [       (MCFileTreeFileUtils current directoryExists: directory)        ifFalse: [           self flushCache.          ^ self directory ] ].  ^ directory! !!MCGitHubRepository methodsFor: 'descriptions' stamp: 'dkh 6/16/2012 09:03'!directoryDescription    ^ self directory pathName! !!MCGitHubRepository methodsFor: 'initialize-release' stamp: 'dkh 6/16/2012 09:11'!flushCache    "the directory acts like a cache since we download the directory from github"    super flushCache.    self class flushDownloadCache.    directory := nil! !!MCGitHubRepository methodsFor: 'initialize-release' stamp: 'dkh 7/24/2012 21:52'!flushForScriptGet    self class flushProjectEntry: self projectPath version: self projectVersion.    directory := nil! !!MCGitHubRepository methodsFor: 'initialize-release' stamp: 'dkh 07/16/2013 20:48'!hasNoLoadConflicts: anMCGitHubRepository  ^ self projectPath = anMCGitHubRepository projectPath    and: [ self repoPath = anMCGitHubRepository repoPath ]! !!MCGitHubRepository methodsFor: 'comparing' stamp: 'dkh 6/16/2012 08:57'!hash    ^ self description hash! !!MCGitHubRepository methodsFor: 'initialize-release' stamp: 'dkh 6/16/2012 09:09'!initialize    super initialize.    directory := nil.	"we'll lazily create the directory instance"    self readonly: true! !!MCGitHubRepository methodsFor: 'testing' stamp: 'dkh 6/16/2012 09:00'!isValid    ^ true! !!MCGitHubRepository methodsFor: 'accessing' stamp: 'dkh 5/16/2012 14:52:41'!metacelloProjectClassFor: aScriptEngine    ^ MetacelloMCBaselineProject! !!MCGitHubRepository methodsFor: 'accessing' stamp: 'dkh 5/16/2012 14:52:41'!projectPath    ^ projectPath! !!MCGitHubRepository methodsFor: 'accessing' stamp: 'dkh 5/16/2012 14:52:41'!projectPath: anObject    projectPath := anObject! !!MCGitHubRepository methodsFor: 'accessing' stamp: 'dkh 5/16/2012 14:52:41'!projectVersion    (projectVersion == nil or: [ projectVersion isEmpty ])        ifTrue: [ projectVersion := 'master' ].    ^ projectVersion! !!MCGitHubRepository methodsFor: 'accessing' stamp: 'dkh 5/16/2012 14:52:41'!projectVersion: anObject    projectVersion := anObject! !!MCGitHubRepository methodsFor: 'accessing' stamp: 'dkh 5/16/2012 14:52:41'!repoPath    ^ repoPath! !!MCGitHubRepository methodsFor: 'accessing' stamp: 'dkh 5/16/2012 14:52:41'!repoPath: anObject    repoPath := anObject! !"Metacello-GitHub"!((Smalltalk at: #ConfigurationOfMetacello) project   version: #'previewBootstrap') load.!SystemOrganization addCategory: #ConfigurationOfMetacelloPreview!ConfigurationOf subclass: #ConfigurationOfMetacelloPreview	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ConfigurationOfMetacelloPreview'!!ConfigurationOfMetacelloPreview methodsFor: 'symbolic versions' stamp: 'dkh 08/24/2015 14:09'!stable: spec  <symbolicVersion: #'stable'>  spec for: #'common' version: '1.0.0-beta.32.18'! !!ConfigurationOfMetacelloPreview methodsFor: 'versions' stamp: 'dkh 6/17/2012 21:10'!version10beta3201: spec    <version: '1.0.0-beta.32.1'>    spec        for: #'common'        do: [             spec blessing: #'release'.            spec                description:                    'successful Pier3AddOns 3.0.2 load using scripting api!!  https://github.com/dalehenrich/metacello-work/commit/508399fbfa70a4fe64799893aa10a66f0b302ff5'.            spec author: 'dkh'.            spec timestamp: '6/16/2012 11:13' ].    spec        for: #'squeakCommon'        do: [             spec                baseline: 'Metacello'                with: [ spec repository: 'github://dalehenrich/metacello-work:508399fbfa70a4fe64799893aa10a66f0b302ff5/repository' ] ]! !!ConfigurationOfMetacelloPreview methodsFor: 'versions' stamp: 'dkh 7/29/2012 07:34'!version10beta3202: spec    <version: '1.0.0-beta.32.2'>    spec        for: #'common'        do: [             spec blessing: #'release'.            spec description: 'initial preview release'.            spec author: 'dkh'.            spec timestamp: '7/29/2012 07:34'.            spec                baseline: 'Metacello'                    with: [                             spec                                loads: #('batch');                                repository:                                        'github://dalehenrich/metacello-work:cecd1626d27f67175f22e6075ca2d1177da1d525/repository' ];                import: 'Metacello' ]! !!ConfigurationOfMetacelloPreview methodsFor: 'versions' stamp: 'dkh 9/18/2012 14:36'!version10beta3203: spec    <version: '1.0.0-beta.32.3'>    spec        for: #'common'        do: [             spec blessing: #'release'.            spec description: 'Synchronize with Metacello 1.0-beta.31.1.5'.            spec author: 'dkh'.            spec timestamp: '9/18/2012 14:36'.            spec                baseline: 'Metacello'                    with: [                             spec                                loads: #('batch');                                repository:                                        'github://dalehenrich/metacello-work:bdb13998bf2399ca7f9027c566d8e5ba9e837d3f/repository' ];                import: 'Metacello' ]! !!ConfigurationOfMetacelloPreview methodsFor: 'versions' stamp: 'dkh 03/06/2013 14:12'!version10beta3204: spec    <version: '1.0.0-beta.32.4'>    spec        for: #'common'        do: [             spec blessing: #'release'.            spec description: 'Synchronize with Metacello 1.0-beta.32 (dkh.752)'.            spec author: 'dkh'.            spec timestamp: '3/6/2013 14:12'.            spec                baseline: 'Metacello'                    with: [                             spec                                loads: #('batch');                                repository:                                        'github://dalehenrich/metacello-work:6fb14916d605429808f10bb2bc90be8f320beb42/repository' ];                import: 'Metacello' ]! !!ConfigurationOfMetacelloPreview methodsFor: 'versions' stamp: 'dkh 04/03/2013 20:32'!version10beta3205: spec  <version: '1.0.0-beta.32.5'>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec        description:          'Checkpoint release to make bugfix for Issue #136 available (https://github.com/dalehenrich/metacello-work/issues/136)'.      spec author: 'dkh'.      spec timestamp: 'dkh 4/3/2013 20:31'.      spec        baseline: 'Metacello'          with: [               spec                loads: #('batch');                repository:                    'github://dalehenrich/metacello-work:720e9f80740c23c6eaf1fb21e5eee90aaca27fb6/repository' ];        import: 'Metacello' ]! !!ConfigurationOfMetacelloPreview methodsFor: 'versions' stamp: 'dkh 05/12/2013 13:16'!version10beta3206: spec  <version: '1.0.0-beta.32.6'>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec        description:          'Checkpoint release to make bugfix for Issue #65 available (https://github.com/dalehenrich/metacello-work/issues/65) ... Port Metacello to Pharo-2.0- workaround for SmalltalkHub Issue 21: corrupted package  https://code.google.com/p/smalltalk-hub/issues/detail?id=21- bootstrap from Metacello-Base needs to load Metacello-PharoCommonPlatform- fix for Issue #156: MNU #compareEqual:  https://github.com/dalehenrich/metacello-work/issues/156- final checkpoint release for this phase of Issue #65...Metacello Preview bootstraps into Pharo2.0'.      spec author: 'dkh'.      spec timestamp: '5/12/2013 13:16'.      spec        baseline: 'Metacello'          with: [               spec                loads: #('batch');                repository:                    'github://dalehenrich/metacello-work:5a6be485bc61a2ac154305df1bc53caeda87242c/repository' ];        import: 'Metacello' ]! !!ConfigurationOfMetacelloPreview methodsFor: 'versions' stamp: 'dkh 06/30/2013 12:36'!version10beta3207: spec  <version: '1.0.0-beta.32.7'>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec        description:          '-synchronize with current 1.0-beta.32.1- fix Issue #172: Metacello-Base bootstrap code and configurations should reference seaside.gemtalksystems.com repos  https://github.com/dalehenrich/metacello-work/issues/172'.      spec author: 'dkh'.      spec timestamp: '6/30/2013 12:31'.      spec        baseline: 'Metacello'          with: [               spec                loads: #('batch');                repository:                    'github://dalehenrich/metacello-work:2fe0913fb619f7ab82ea8fc975d7d54a94c92622/repository' ];        import: 'Metacello' ]! !!ConfigurationOfMetacelloPreview methodsFor: 'versions' stamp: 'dkh 07/16/2013 22:15'!version10beta3208: spec  <version: '1.0.0-beta.32.8'>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec        description:          '- fix google Issue 184: github zip download failures due to filesystem issues  https://code.google.com/p/metacello/issues/detail?id=184- fix Issue #175: MCGitHubRepository and cache  https://github.com/dalehenrich/metacello-work/issues/175- fix Issue #174: `lock` should work with symbolic versions  https://github.com/dalehenrich/metacello-work/issues/174- fix Issue #176: attempt to modify immutable project spec  https://github.com/dalehenrich/metacello-work/issues/176- fix Issue #181: The case for `unconditional` baseline loading  https://github.com/dalehenrich/metacello-work/issues/181'.      spec author: 'dkh'.      spec timestamp: '7/16/2013 22:15'.      spec        baseline: 'Metacello'          with: [               spec                loads: #('batch');                repository:                    'github://dalehenrich/metacello-work:692e9c659810d40062aa63506b6875db76ec90e9/repository' ];        import: 'Metacello' ]! !!ConfigurationOfMetacelloPreview methodsFor: 'versions' stamp: 'dkh 07/23/2013 20:46'!version10beta3209: spec  <version: '1.0.0-beta.32.9'>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec        description:          '- fix Issue #188: Problems using <version:imports:> for structural reasons  https://github.com/dalehenrich/metacello-work/issues/188'.      spec author: 'dkh'.      spec timestamp: '7/23/2013 20:45'.      spec        baseline: 'Metacello'          with: [               spec                loads: #('batch');                repository:                    'github://dalehenrich/metacello-work:2ea5ae998b382cb13e8bde8f2c6d05b970cfb961/repository' ];        import: 'Metacello' ]! !!ConfigurationOfMetacelloPreview methodsFor: 'versions' stamp: 'dkh 10/06/2013 12:12'!version10beta3210: spec  <version: '1.0.0-beta.32.10'>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec        description:          '- Pharo3.0 Support Issue #187 and Pull request: #207  https://github.com/dalehenrich/metacello-work/issues/187  https://github.com/dalehenrich/metacello-work/pull/207- fix Issue #210: MetacelloProjectRegistry>>primeRegistryFromImage introduces `invalid` registrations  https://github.com/dalehenrich/metacello-work/issues/210'.      spec author: 'dkh'.      spec timestamp: '10/6/2013 12:12'.      spec        baseline: 'Metacello'          with: [               spec                loads: #('batch');                repository:                    'github://dalehenrich/metacello-work:9d7e7f8994abeb0b474ec54e9c8c714b3fe95fb9/repository' ];        import: 'Metacello' ]! !!ConfigurationOfMetacelloPreview methodsFor: 'versions' stamp: 'dkh 11/08/2013 21:38'!version10beta3211: spec  <version: '1.0.0-beta.32.11'>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec        description:          '- temporary patch for Issue #212: ineffective MetacelloProjectRegistry>>primeRegistryFromImage  https://github.com/dalehenrich/metacello-work/issues/212'.      spec author: 'dkh'.      spec timestamp: '11/8/2013 21:36'.      spec        baseline: 'Metacello'          with: [               spec                loads: #('batch');                repository:                    'github://dalehenrich/metacello-work:7cba83167ab7ab9548460ba176d9b0485345be3c/repository' ];        import: 'Metacello' ]! !!ConfigurationOfMetacelloPreview methodsFor: 'versions' stamp: 'dkh 11/09/2013 07:27'!version10beta3212: spec  <version: '1.0.0-beta.32.12'>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec        description:          '- fix for Issue #212: ineffective MetacelloProjectRegistry>>primeRegistryFromImage  https://github.com/dalehenrich/metacello-work/issues/212'.      spec author: 'dkh'.      spec timestamp: '11/9/2013 07:26'.      spec        baseline: 'Metacello'          with: [               spec                loads: #('batch');                repository:                    'github://dalehenrich/metacello-work:8d57503cbcdb4cbf31730e6d9b12b18a55fa0171/repository' ];        import: 'Metacello' ]! !!ConfigurationOfMetacelloPreview methodsFor: 'versions' stamp: 'dkh 07/05/2014 12:15'!version10beta3213: spec  <version: '1.0.0-beta.32.13'>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec description: '1.0-beta.32.13 in support of tODE  https://github.com/dalehenrich/metacello-work/issues?direction=desc&milestone=17&page=1&sort=updated&state=closed'.      spec author: 'dkh'.      spec timestamp: '7/5/2014 12:09'.      spec        baseline: 'Metacello'          with: [               spec                loads: #('batch');                repository:                    'github://dalehenrich/metacello-work:002d8f604bba6b86ed8e231a0bfcc809d3a6d787/repository' ];        import: 'Metacello' ]! !!ConfigurationOfMetacelloPreview methodsFor: 'versions' stamp: 'dkh 07/06/2014 16:13'!version10beta3214: spec  <version: '1.0.0-beta.32.14'>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec        description:          '1.0-beta.32.14 in support of tODE  https://github.com/dalehenrich/metacello-work/issues?direction=desc&milestone=18&page=1&sort=updated&state=closed'.      spec author: 'dkh'.      spec timestamp: '7/6/2014 16:12'.      spec        baseline: 'Metacello'          with: [               spec                loads: #('batch');                repository:                    'github://dalehenrich/metacello-work:257433ce59f6e856669753a34ba13498fb382b78/repository' ];        import: 'Metacello' ]! !!ConfigurationOfMetacelloPreview methodsFor: 'versions' stamp: 'dkh 09/26/2014 16:45'!version10beta3215: spec  <version: '1.0.0-beta.32.15'>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec        description:          '1.0-beta.32.15: backport PR #257, Issue #227 and Issue #226  https://github.com/dalehenrich/metacello-work/issues?q=milestone%3A1.0.0-beta.32.15+is%3Aclosed'.      spec author: 'dkh'.      spec timestamp: '9/26/2014 16:43'.      spec        baseline: 'Metacello'          with: [               spec                loads: #('batch');                repository:                    'github://dalehenrich/metacello-work:c1da7f8098b8759f806aaa952817709b767ed590/repository' ];        import: 'Metacello' ]! !!ConfigurationOfMetacelloPreview methodsFor: 'versions' stamp: 'dkh 11/11/2014 16:23'!version10beta3217: spec  <version: '1.0.0-beta.32.17'>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec        description:          '1.0-beta.32.17: add support for Pharo4.0  https://github.com/dalehenrich/metacello-work/issues?q=milestone%3A1.0.0-beta.32.17+is%3Aclosed'.      spec author: 'dkh'.      spec timestamp: '11/11/2014 10:16'.      spec        baseline: 'Metacello'          with: [               spec                loads: #('batch');                repository:                    'github://dalehenrich/metacello-work:e54f0a833fa31e7a7728bf886aca6c43e1e8f6a5/repository' ];        import: 'Metacello' ]! !!ConfigurationOfMetacelloPreview methodsFor: 'versions' stamp: 'dkh 09/11/2015 15:36'!version10beta3218: spec  <version: '1.0.0-beta.32.18'>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec        description:          '1.0-beta.32.18: add support for Squeak4.6 and Squeak5.0  https://github.com/dalehenrich/metacello-work/issues?q=milestone%3A1.0.0-beta.32.18+is%3Aclosed'.      spec author: 'dkh'.      spec timestamp: '9/11/2015 15:36'.      spec        baseline: 'Metacello'          with: [               spec                loads: #('batch');                repository:                    'github://dalehenrich/metacello-work:7deb62a415343f8ba8294c84c9c3438c75455fe3/repository' ];        import: 'Metacello' ]! !"ConfigurationOfMetacelloPreview"!SystemOrganization addCategory: #BaselineOfMetacello!BaselineOf subclass: #BaselineOfMetacello	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'BaselineOfMetacello'!!BaselineOfMetacello methodsFor: 'baseline' stamp: 'dkh 11/10/2014 15:25'!baseline: spec  <baseline>  spec    for: #'common'    do: [       spec postLoadDoIt: #'reprimeRegistryIssue197'.      spec baseline: 'FileTree'.      spec        project: 'Gofer'          with: [               spec                className: 'ConfigurationOfGofer';                versionString: #'stable';                loads: #('Core');                repository: 'http://seaside.gemtalksystems.com/ss/metacello' ];        project: 'Gofer Tests'          copyFrom: 'Gofer'          with: [ spec loads: #('Tests') ];        yourself.      spec        package: 'Metacello-Base';        package: 'Metacello-ToolBox'          with: [ spec requires: #('Metacello-Base' 'Metacello-Core') ];        package: 'Metacello-Core'          with: [               spec                requires: 'Metacello-Base';                includes: #('Metacello-MC' 'Metacello-Platform') ];        package: 'Metacello-Cypress' with: [ spec requires: 'Metacello-Core' ];        package: 'Metacello-FileTree'          with: [ spec requires: #('Metacello-MC' 'FileTree') ];        package: 'Metacello-GitBasedRepository'          with: [ spec requires: #('Metacello-MC' 'Metacello-FileTree') ];        package: 'Metacello-GitHub'          with: [ spec requires: #('Metacello-GitBasedRepository') ];        package: 'Metacello-Bitbucket'          with: [ spec requires: #('Metacello-GitBasedRepository') ];        package: 'Metacello-MC'          with: [ spec requires: #('Metacello-Core' 'Gofer') ];        package: 'Metacello-Platform'          with: [ spec requires: #('Metacello-MC') ];        package: 'Metacello-Reference'          with: [ spec requires: #('Metacello-MC') ];        package: 'Metacello-Tutorial'          with: [ spec requires: #('Metacello-Core') ];        package: 'Metacello-TestsCore'          with: [ spec requires: #('Metacello-Core') ];        package: 'Metacello-TestsMCResources'          with: [               spec                postLoadDoIt: #'testResourcePostLoadDoIt';                includes: #('Metacello-TestsCommonMC');                requires: #('Metacello-Core') ];        package: 'Metacello-TestsMCCore'          with: [               spec                requires:                  #('Metacello-Core' 'Metacello-TestsCore' 'Metacello-ToolBox' 'Metacello-TestsMCResources') ];        package: 'Metacello-TestsMC'          with: [               spec                requires:                  #('Metacello-MC' 'Gofer Tests' 'Metacello-ToolBox' 'Metacello-GitHub' 'Metacello-Bitbucket' 'Metacello-TestsMCResources') ];        package: 'Metacello-TestsMCA'          with: [ spec requires: #('Metacello-TestsMC') ];        package: 'Metacello-TestsMCB'          with: [ spec requires: #('Metacello-TestsMC') ];        package: 'Metacello-TestsCommonMC'          with: [               spec                file: 'Metacello-TestsCommonMC.common';                requires: 'Metacello-TestsMCResources' ];        package: 'Metacello-TestsReference'          with: [ spec requires: #('Metacello-Reference') ];        package: 'Metacello-TestsTutorial'          with: [ spec requires: #('Metacello-Tutorial' 'Metacello-TestsMCResources') ];        yourself.      spec        group: 'default' with: #('batch' 'Metacello-ToolBox');        group: 'batch'          with: #('Metacello-Core' 'Metacello-GitHub' 'Metacello-Bitbucket');        group: 'Base Configuration' with: #('Metacello-Base');        group: 'Core' with: #('default');        group: 'Cypress' with: #('Metacello-Cypress');        group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference');        group: 'UI' with: #('default');        group: 'TravisCI_1'          with:            #('Metacello-TestsCore' 'Metacello-TestsReference' 'Metacello-TestsMCCore');        group: 'TravisCI_2' with: #('Metacello-TestsMCA');        group: 'TravisCI_3'          with: #('Metacello-TestsMCB' 'Metacello-TestsTutorial');        group: 'TravisCI' with: #('TravisCI_1' 'TravisCI_2' 'TravisCI_3');        group: 'Tests'          with:            #('Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMCA' 'Metacello-TestsMCB' 'Metacello-TestsReference' 'Metacello-TestsMCCore');        yourself ].  spec    for: #'squeakCommon'    do: [       spec        configuration: 'HelpSystem'          with: [               spec                versionString: '1.1';                loads: #('Core');                repository: 'http://www.squeaksource.com/MetacelloRepository' ];        yourself.      spec        package: 'Metacello-TestsPlatform'          with: [               spec                requires: #('Metacello-Platform');                file: 'Metacello-TestsPlatform.squeakCommon' ];        package: 'Metacello-Help' with: [ spec requires: 'HelpSystem' ];        yourself.      spec        group: 'Tests' with: #('Metacello-TestsPlatform');        group: 'TravisCI_1' with: #('Metacello-TestsPlatform');        yourself ].  spec    for: #(#'pharo1.x' #'pharo2.x')    do: [       spec        project: 'ProfStef'          with: [               spec                className: 'ConfigurationOfProfStef';                versionString: #'stable';                repository:                    'http://smalltalkhub.com/mc/PharoExtras/ProfStef/main' ];        configuration: 'OSProcess'          with: [               spec                versionString: #'stable';                repository: 'http://seaside.gemtalksystems.com/ss/metacello' ];        yourself.      spec        package: 'Metacello-ProfStef'          with: [ spec requires: #('Metacello-Core' 'ProfStef' 'Metacello-ToolBox') ];        package: 'Metacello-TestsProfStef'          with: [ spec requires: #('Metacello-ProfStef') ];        package: 'Metacello-PharoCommonPlatform'          with: [ spec requires: #('Metacello-MC') ];        package: 'Metacello-Platform'          with: [ spec requires: #('Metacello-PharoCommonPlatform') ];        yourself.      spec        group: 'Tests' with: #('Metacello-TestsProfStef');        group: 'Tutorial' with: #('Metacello-ProfStef');        yourself ].  spec    for: #'pharo1.x'    do: [       spec        configuration: 'OSProcess'          with: [ spec repository: 'http://www.squeaksource.com/MetacelloRepository' ];        package: 'Metacello-Platform'          with: [               spec                file: 'Metacello-Platform.pharo';                requires: #('OSProcess') ] ].  spec    for: #'pharo1.1.x'    do: [       spec        baseline: 'FileTree'        with: [ spec repository: 'github://dalehenrich/filetree:pharo1.1/repository' ] ].  spec    for: #'pharo1.2.x'    do: [       spec        baseline: 'FileTree'        with: [ spec repository: 'github://dalehenrich/filetree:pharo1.1/repository' ] ].  spec    for: #'pharo1.3.x'    do: [       spec        baseline: 'FileTree'        with: [ spec repository: 'github://dalehenrich/filetree:pharo1.3/repository' ] ].  spec    for: #'pharo1.4.x'    do: [       spec        baseline: 'FileTree'        with: [ spec repository: 'github://dalehenrich/filetree:pharo1.4/repository' ] ].  spec    for: #'pharo2.x'    do: [       spec        configuration: 'OSProcess'          with: [ spec repository: 'http://ss3.gemtalksystems.com/ss/MetaRepoForPharo20' ];        yourself.      spec        package: 'Metacello-Platform'          with: [               spec                file: 'Metacello-Platform.pharo20';                requires: #('OSProcess') ];        package: 'Metacello-TestsCommonMC'          with: [ spec file: 'Metacello-TestsCommonMC.pharo20' ];        yourself.      spec        baseline: 'FileTree'        with: [ spec repository: 'github://dalehenrich/filetree:pharo2.0/repository' ] ].  spec    for: #(#'pharo3.x' #'pharo4.x')    do: [       spec        package: 'Metacello-PharoCommonPlatform'          with: [ spec requires: #('Metacello-MC') ];        package: 'Metacello-Platform'          with: [               spec                file: 'Metacello-Platform.pharo30';                requires: #('Metacello-PharoCommonPlatform') ];        package: 'Metacello-TestsCommonMC'          with: [ spec file: 'Metacello-TestsCommonMC.pharo20' ];        yourself.      spec        baseline: 'FileTree'        with: [ spec repository: 'github://dalehenrich/filetree:pharo3.0/repository' ] ].  spec    for: #'squeak'    do: [       spec        baseline: 'FileTree'          with: [ spec repository: 'github://dalehenrich/filetree:squeak4.3/repository' ];        yourself.      spec        package: 'SqueakSSL-Core'        with: [ spec repository: 'http://www.squeaksource.com/SqueakSSL' ].      spec        package: 'WebClient-Core'        with: [ spec repository: 'http://ss3.gemstone.com/ss/WebClient' ].      spec        package: 'Metacello-Platform'          with: [               spec                file: 'Metacello-Platform.squeak';                requires: #('WebClient-Core' 'SqueakSSL-Core') ];        yourself ].  spec    for: #'gemstone'    do: [       spec        baseline: 'FileTree'        with: [ spec repository: 'github://dalehenrich/filetree:gemstone2.4/repository' ].      spec        package: 'Metacello-Platform'          with: [               spec                file: 'Metacello-Platform.gemstone';                postLoadDoIt: #'gemstone10beta311PostLoadDoIt' ];        package: 'Metacello-TestsPlatform'          with: [               spec                requires: #('Metacello-Platform');                file: 'Metacello-TestsPlatform.gemstone' ];        package: 'Metacello-GemStone-TestsMCB'          with: [ spec requires: #('Metacello-TestsMCB') ];        yourself.      spec        group: 'Tests' with: #('Metacello-TestsPlatform');        group: 'TravisCI_1' with: #('Metacello-TestsPlatform');        group: 'TravisCI_3' with: #('Metacello-GemStone-TestsMCB');        yourself ].  spec    for: #'gs2.x'    do: [       spec        package: 'Metacello-GS2x-Platform'          with: [ spec requires: 'Metacello-Platform' ];        package: 'Metacello-Platform'          with: [ spec includes: 'Metacello-GS2x-Platform' ];        yourself ].  spec    for: #'gs3.x'    do: [       spec        package: 'Metacello-GS3x-Platform'          with: [ spec requires: 'Metacello-Platform' ];        package: 'Metacello-Platform'          with: [ spec includes: 'Metacello-GS3x-Platform' ];        yourself ]! !!BaselineOfMetacello methodsFor: 'doits' stamp: 'dkh 07/24/2012 18:09'!gemstone10beta311PostLoadDoIt	(Smalltalk at: #MetacelloGemStonePlatform) initialize! !!BaselineOfMetacello methodsFor: 'doits' stamp: 'dkh 09/30/2014 17:40'!reprimeRegistryIssue197  MetacelloScriptEngine defaultRepositoryDescription: nil.  MetacelloProjectRegistration registry baselineRegistry values    detect: [ :registration |       "inline MetacelloProjectRegistration>>isValid to correct invalid definition ... detecting INVALID registrations"      registration projectName        ifNil: [ true ]        ifNotNil: [           registration configurationProjectSpec            ifNil: [ registration baselineProjectSpec isNil ]            ifNotNil: [ registration baselineProjectSpec notNil ] ] ]    ifNone: [       "no invalid registrations, don't reset and prime"      ^ self ].  Transcript    cr;    show:        'priming registry from image. See https://github.com/dalehenrich/metacello-work/issues/197'.  [   MetacelloProjectRegistration    resetRegistry;    primeRegistryFromImage ]    on: Warning    do: [ :ex |       Transcript        cr;        show: 'Warning resumed: ' , ex description.      ex resume ]! !!BaselineOfMetacello methodsFor: 'doits' stamp: 'dkh 6/1/2012 09:18:17'!testResourcePostLoadDoIt    "reset test resources"    #(#'MetacelloAlternateResource' #'MetacelloAtomicConfigurationResource' #'MetacelloAtomicMonticelloResource' #'MetacelloConfigurationResource' #'MetacelloMonticelloResource' #'MetacelloScriptingResource' #'MetacelloIssue108Resource')        do: [ :className | Smalltalk at: className ifPresent: [ :cls | cls reset ] ]! !"BaselineOfMetacello"!SystemOrganization addCategory: #BaselineOfFileTree!BaselineOf subclass: #BaselineOfFileTree	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'BaselineOfFileTree'!!BaselineOfFileTree methodsFor: 'baseline' stamp: 'dkh 8/10/2012 19:02'!baseline: spec    <baseline>    spec        for: #'common'        do: [             spec                package: 'MonticelloFileTree-Core';                package: 'MonticelloFileTree-Tests' with: [ spec requires: #('default') ];                package: 'MonticelloFileTree-FileDirectory-Utilities'                    with: [ spec requires: #('MonticelloFileTree-Core') ];                package: 'MonticelloFileTree-FileDirectory-Tests'                    with: [ spec requires: #('MonticelloFileTree-Tests') ].            spec                group: 'default' with: #('MonticelloFileTree-Core' 'MonticelloFileTree-FileDirectory-Utilities');                group: 'Tests' with: #('MonticelloFileTree-Tests' 'MonticelloFileTree-FileDirectory-Tests');                group: 'TravisCI' with: #('Tests') ]! !"BaselineOfFileTree"!MCDirectoryRepository subclass: #MCFileTreeRepository	instanceVariableNames: 'readonly repositoryProperties versionNameToFileNameMap cacheInvalidationFlag'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloFileTree-Core'!!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'dkh 01/31/2015 06:51' prior: 34509307!addClassDefinitionFrom: classPropertiesDict comment: classComment  | categoryName className |  className := classPropertiesDict at: 'name'.  categoryName := classPropertiesDict    at: 'category'    ifAbsent: [ self packageNameFromPackageDirectory ].  self validateClassCategory: categoryName for: className.  definitions    add:      (MCClassDefinition        name: className        superclassName: (classPropertiesDict at: 'super')        traitComposition: (classPropertiesDict at: 'traitcomposition' ifAbsent: [ '{}' ])        classTraitComposition: (classPropertiesDict at: 'classtraitcomposition' ifAbsent: [ '{}' ])        category: categoryName        instVarNames: (classPropertiesDict at: 'instvars' ifAbsent: [ #() ])        classVarNames: (classPropertiesDict at: 'classvars' ifAbsent: [ #() ])        poolDictionaryNames: (classPropertiesDict at: 'pools' ifAbsent: [ #() ])        classInstVarNames:          (classPropertiesDict at: 'classinstvars' ifAbsent: [ #() ])        type: (classPropertiesDict at: 'type' ifAbsent: [ 'normal' ]) asSymbol        comment: classComment        commentStamp: (classPropertiesDict at: 'commentStamp' ifAbsent: [ '' ]))! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'dkh 01/31/2015 06:56' prior: 34510528!addExtensionClassAndMethodDefinitionsFromEntry: classEntry  | classDirectory classPropertiesDict methodPropertiesDict entries |  classDirectory := self fileUtils directoryFromEntry: classEntry.  ((entries := classDirectory entries)    detect: [ :entry | self isPropertyFile: entry ]    ifNone: [  ])    ifNotNil: [ :propertyEntry |       propertyEntry        readStreamDo: [ :fileStream |           classPropertiesDict := MCFileTreeJsonParser            parseStream: fileStream ] ].  methodPropertiesDict := Dictionary new.  (entries detect: [ :entry | self isMethodPropertyFile: entry ] ifNone: [  ])    ifNotNil: [ :propertyEntry |       propertyEntry        readStreamDo: [ :fileStream |           "Issue 33: https://github.com/dalehenrich/filetree/issues/33"          methodPropertiesDict := MCFileTreeJsonParser parseStream: fileStream ] ].  self    addMethodDefinitionsForClass: (classPropertiesDict at: 'name')    methodProperties: methodPropertiesDict    in: entries    extensionMethod: true! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'dkh 01/31/2015 06:55' prior: 34511626!addMethodDefinitionsForClass: className methodProperties: methodProperties in: entries  ^ self    addMethodDefinitionsForClass: className    methodProperties: methodProperties    in: entries    extensionMethod: false! !!MCFileTreeStCypressReader methodsFor: 'utilities' stamp: 'dkh 01/31/2015 06:56'!addMethodDefinitionsForClass: className methodProperties: methodProperties in: entries extensionMethod: extensionMethod    entries        do: [ :entry |             | classIsMeta |            classIsMeta := false.            entry name = 'class'                ifTrue: [ classIsMeta := true ].            (entry name = 'instance' or: [ entry name = 'class' ])                ifTrue: [                     ((self fileUtils directoryFromEntry: entry) entries select: [ :each | each name endsWith: '.st' ])                        do: [ :methodEntry |                             methodEntry                                readStreamDo: [ :fileStream |                                     | category source timestamp selector |                                    category := fileStream nextLine.                                    source := fileStream upToEnd.                                    selector := self methodSelectorFor: source.                                    timestamp := methodProperties                                        at:                                            (classIsMeta                                                ifTrue: [ 'class' ]                                                ifFalse: [ 'instance' ])                                        ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"                                    timestamp                                        ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' ' , self info time print24 ].                                    extensionMethod                                      ifTrue: [ self validateExtensionMethodCategory: category for: className selector: selector ].                                    definitions                                        add:                                            (MCMethodDefinition                                                className: className                                                classIsMeta: classIsMeta                                                selector: selector                                                category: category                                                timeStamp: timestamp                                                source: source) ] ] ] ]! !!MCFileTreeStCypressReader methodsFor: 'validation' stamp: 'dkh 01/31/2015 12:20'!validateClassCategory: categoryName for: className  "https://github.com/dalehenrich/filetree/issues/136"  "class category must match the package name ... guard against manual editing mistakes"  | prefix |  prefix := self packageNameFromPackageDirectory.  (self verifyCategory: categoryName matches: prefix)    ifTrue: [ ^ self ].  self    error:      'Class category name ' , categoryName printString , ' for the class '        , className printString , ' is inconsistent with the package name '        , prefix printString! !!MCFileTreeStCypressReader methodsFor: 'validation' stamp: 'dkh 01/31/2015 13:41'!validateExtensionMethodCategory: categoryName for: className selector: selector  "https://github.com/dalehenrich/filetree/issues/136"  "method category must match the package name for extension methods... guard against manual editing mistakes"  "extracted from PackageInfo>>isForeignClassExtension:"  | prefix prefixSize catSize |  prefix := '*' , self packageNameFromPackageDirectory asLowercase.  categoryName    ifNotNil: [       (categoryName isEmpty not        and: [           categoryName first = $*            and: [               "asLowercase needed in GemStone 3.1.0.6?"              self verifyCategory: categoryName asLowercase matches: prefix ] ])        ifTrue: [ ^ self ] ].  self    error:      'Method protocol ' , categoryName printString , ' for the method '        , selector asString printString , ' in class ' , className printString        , ' is inconsistent with the package name ' , prefix printString! !!MCFileTreeStCypressReader methodsFor: 'validation' stamp: 'dkh 01/31/2015 15:14'!verifyCategory: categoryName matches: basicPackageName  "https://github.com/dalehenrich/filetree/issues/136"  "copied from PackageInfo>>category:matches: and GoferVersionReference>>parseName:"  | prefixSize catSize packagePrefix |  categoryName ifNil: [ ^ false ].  packagePrefix := basicPackageName.  (packagePrefix includes: $.)    ifTrue: [       "exclude branch name"      packagePrefix := packagePrefix copyUpTo: $. ].  catSize := categoryName size.  prefixSize := packagePrefix size.  catSize < prefixSize    ifTrue: [ ^ false ].  (categoryName findString: packagePrefix startingAt: 1 caseSensitive: false)    = 1    ifFalse: [ ^ false ].  ^ (categoryName at: packagePrefix size + 1 ifAbsent: [ ^ true ]) = $-! !!MCFileTreeRepository methodsFor: 'private' stamp: 'DS 5/6/2015 11:02' prior: 34487652!cacheAllFileNamesDuring: aBlock 	"https://github.com/dalehenrich/filetree/issues/132"	| cacheInvalidated |	cacheInvalidated := false.	cacheInvalidationFlag ifNil: [cacheInvalidationFlag := true.		cacheInvalidated := true.		allFileNamesCache := nil.].		^ [super cacheAllFileNamesDuring: aBlock]		ensure: [cacheInvalidated ifTrue: [cacheInvalidationFlag := nil]]! !"MonticelloFileTree-Core"!!Metacello class methodsFor: 'instance creation' stamp: 'dkh 07/27/2013 08:45'!registrations  ^ MetacelloProjectRegistration registry registrations! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 09/29/2014 12:34'!bitbucketUser: userName project: projectName commitish: commitish path: path  | branchOrCommitOrTag |  branchOrCommitOrTag := commitish.  branchOrCommitOrTag isEmpty    ifTrue: [ branchOrCommitOrTag := 'master' ].  self    repository:      'bitbucket://' , userName , '/' , projectName , ':' , branchOrCommitOrTag , '/'        , path! !!Metacello methodsFor: 'private' stamp: 'dkh 09/30/2014 13:58'!execute: selector args: args  | script |  script := self statements copy.  script add: selector -> args.  ^ self scriptExecutor execute: script! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 13:59' prior: 34599303!fetch  ^ self execute: #'fetch:' args: #(#())! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 13:59' prior: 34599445!fetch: required  ^ self execute: #'fetch:' args: {required}! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 07/25/2013 15:21'!filetreeDirectory: directoryName  self repository: 'filetree://' , directoryName! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 13:59' prior: 34599784!get  "resolve project name in given repository and return an instance of MetacelloProject resolved from a ConfigurationOf or BaselineOf"  ^ self execute: #'get' args: #()! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 07/25/2013 15:26'!githubUser: userName project: projectName commitish: commitish path: path  | branchOrCommitOrTag |  branchOrCommitOrTag := commitish.  branchOrCommitOrTag isEmpty    ifTrue: [ branchOrCommitOrTag := 'master' ].  self    repository:      'github://' , userName , '/' , projectName , ':' , branchOrCommitOrTag , '/'        , path! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 14:00' prior: 34600380!list  "list projects in registry"  ^ self execute: #'list' args: #()! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 14:00' prior: 34600549!load  ^ self execute: #'load:' args: #(#())! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 14:00' prior: 34600692!load: required  ^ self execute: #'load:' args: {required}! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 14:00' prior: 34600846!lock  "lock projects in registry"  ^ self execute: #'lock' args: #()! !!Metacello methodsFor: 'api actions' stamp: 'dkh 07/25/2013 15:45'!locked  "list of locked projects in registry"  ^ self    project: [ :projectSpec | projectSpec isLocked ];    list! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/10/2014 15:25'!onConflictUseIncoming  self onConflict: [ :ex :loaded :incoming | ex useIncoming ]! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/10/2014 16:44'!onConflictUseIncoming: incomingProjects useLoaded: loadedProjects  self    onConflict: [ :ex :loaded :incoming |       (incomingProjects includes: incoming baseName)        ifTrue: [ ex useIncoming ]        ifFalse: [           (loadedProjects includes: incoming baseName)            ifTrue: [ ex useLoaded ] ].      ex pass ]! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/10/2014 15:25'!onConflictUseLoaded  self onConflict: [ :ex :loaded :incoming | ex useLoaded ]! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/10/2014 14:52'!onDowngradeUseIncoming  self onDowngrade: [ :ex :loaded :incoming | ex useIncoming ]! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/10/2014 14:52'!onDowngradeUseIncoming: projectNames  self    onDowngrade: [ :ex :loaded :incoming |       (projectNames includes: loaded baseName)        ifTrue: [ ex useIncoming ]        ifFalse: [ ex useLoaded ] ]! !!Metacello methodsFor: 'api options' stamp: 'dkh 07/24/2013 17:09'!onLock: aBlock  self addStatement: #'onLock:' args: {aBlock}! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/13/2014 09:31'!onLockBreak  self onLock: [ :ex :loaded :incoming | ex break ]! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/13/2014 09:32'!onLockBreak: projectNames  self    onLock: [ :ex :loaded :incoming |       (projectNames includes: loaded baseName)        ifTrue: [ ex break ]        ifFalse: [ ex honor ] ]! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/10/2014 14:52'!onUpgradeUseLoaded  self onUpgrade: [ :ex :loaded :incoming | ex useLoaded ]! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/10/2014 14:52'!onUpgradeUseLoaded: projectNames  self    onUpgrade: [ :ex :loaded :incoming |       (projectNames includes: loaded baseName)        ifTrue: [ ex useLoaded ]        ifFalse: [ ex useIncoming ] ]! !!Metacello methodsFor: 'api options' stamp: 'dkh 07/24/2013 15:22'!onWarning: aBlock  self addStatement: #'onWarning:' args: {aBlock}! !!Metacello methodsFor: 'api options' stamp: 'dkh 10/10/2014 14:53'!onWarningLog  self    onWarning: [ :ex |       Transcript        cr;        show: ex description.      ex resume ]! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 14:00' prior: 34601594!record  ^ self execute: #'record:' args: #(#())! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 14:00' prior: 34601738!record: required  ^ self execute: #'record:' args: {required}! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 14:01'!register  "change registered project"  ^ self execute: #'register' args: #()! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 07/25/2013 15:20'!smalltalkhubUser: userName project: projectName  self    repository:      'http://smalltalkhub.com/mc/' , userName , '/' , projectName , '/main'! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'dkh 07/25/2013 15:17' prior: 34603135!squeaksource3: projectName  self repository: 'http://ss3.gemtalksystems.com/ss/' , projectName! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 14:01' prior: 34603886!unlock  "unlock projects in registry"  ^ self execute: #'unlock' args: #()! !!Metacello methodsFor: 'api actions' stamp: 'dkh 09/30/2014 14:01'!unregister  "unlock projects in registry"  ^ self execute: #'unregister' args: #()! !!BaselineOf class methodsFor: 'accessing' stamp: 'dkh 10/11/2014 15:43'!validate  "Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."  "self validate"  <apiDocumentation>  self ensureMetacello.  ^ ((Smalltalk at: #'MetacelloToolBox')    validateBaseline: self    debug: #()    recurse: false) explore! !Metacello removeSelector: #execute!"Metacello-Base"!Notification subclass: #MetacelloIgnorePackageLoaded	instanceVariableNames: 'packageSpec'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Notifications'!Notification subclass: #MetacelloScriptGitBasedDownloadNotification	instanceVariableNames: 'projectPath versionString'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!MetacelloResolveProjectUpgrade subclass: #MetacelloAllowLockedProjectChange	instanceVariableNames: 'operationString'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!Error subclass: #MetacelloNameNotDefinedError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Exceptions-Errors'!MetacelloSpec subclass: #MetacelloVersionSpec	instanceVariableNames: 'versionString blessing description author timestamp preLoadDoIt postLoadDoIt packageList importName importArray'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Specs'!Object subclass: #MetacelloProjectRegistration	instanceVariableNames: 'projectName configurationProjectSpec baselineProjectSpec loadedInImage locked mutable versionInfo'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!Object subclass: #MetacelloProjectRegistrationVersionInfo	instanceVariableNames: 'versionString projectVersion'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Scripts'!!MetacelloGenericProjectSpec methodsFor: 'merging' stamp: 'dkh 06/21/2014 07:46'!mergeRepositoriesSpec: anotherRepositories  self    repositories:      (self getRepositories == nil        ifTrue: [ anotherRepositories ]        ifFalse: [ self repositories mergeSpec: anotherRepositories ])! !!MetacelloGenericProjectSpec methodsFor: 'merging' stamp: 'dkh 06/21/2014 07:50' prior: 34775731!mergeSpec: anotherSpec  | newSpec map anotherRepositories |  newSpec := super mergeSpec: anotherSpec.  map := anotherSpec mergeMap.  (anotherRepositories := map at: #'repositories') ~~ nil    ifTrue: [ newSpec mergeRepositoriesSpec: anotherRepositories ].  ^ newSpec! !!MetacelloAllowProjectUpgrade methodsFor: 'accessing' stamp: 'dkh 07/29/2013 16:49' prior: 34634211!operationString  ^ 'upgrade to'! !!MetacelloMergeMemberSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34623380!applyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock	mergeBlock value: self! !!MetacelloAllowProjectDowngrade methodsFor: 'exception handling' stamp: 'dkh 09/28/2014 15:00'!defaultAction  "Default for Downgrade is to disallow, but still should check for locks"  self checkAllowed.  ^ super defaultAction! !!MetacelloAllowProjectDowngrade methodsFor: 'accessing' stamp: 'dkh 07/29/2013 16:49' prior: 34633471!operationString  ^ 'downgrade to'! !!MCRepository methodsFor: '*metacello-core' stamp: 'dkh 7/24/2012 21:46' prior: 34624575!flushForScriptGet    "noop"! !!MCRepository methodsFor: '*metacello-core' stamp: 'dkh 05/09/2014 10:02'!repositoryBranchName  "extract a branch name from the repository ... if possible"  ^ ''! !!MCRepository methodsFor: '*metacello-core' stamp: 'dkh 09/04/2014 13:49'!repositoryDescription  "return a description that includes a repositoryVersionString and repositoryBranchName if present"  ^ self description! !!MCRepository methodsFor: '*metacello-core' stamp: 'dkh 09/04/2014 13:45'!repositoryVersionString  "extract a version string from the repository ... if possible"  ^ ''! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'dkh 9/10/2015 20:33' prior: 34746979!collectAllVersionsFromVersionImportPragmasInto: versionMap using: executionBlock satisfiedPragmas: pragmaDict    | defined done completed count |    done := false.    completed := IdentitySet new.    count := 0.    [     count := count + 1.    count > 10000        ifTrue: [ self error: 'Apparent loop in import expansion' ].    done ]        whileFalse: [             done := true.            pragmaDict                keysAndValuesDo: [ :versionString :pragmaColl |                     | versionSpec |                    versionSpec := nil.                    defined := false.                    [                     pragmaColl                        do: [ :pragma |                             (completed includes: pragma)                                ifFalse: [                                     | imports |                                    done := false.                                    imports := pragma argumentAt: 2.                                    imports                                        detect: [ :importedVersion | (versionMap includesKey: importedVersion) not ]                                        ifNone: [                                             imports                                                do: [ :importedVersion |                                                     | version |                                                    (version := versionMap at: importedVersion ifAbsent: [  ]) ~~ nil                                                        ifTrue: [                                                             defined := true.                                                            completed add: pragma.                                                            versionSpec == nil                                                                ifTrue: [ versionSpec := version spec copy ]                                                                ifFalse: [ versionSpec := versionSpec mergeSpec: version spec copy ].                                                            versionSpec versionString: versionString.                                                            executionBlock value: versionSpec value: pragma ] ] ] ] ] ]                        on: Error                        do: [ :ex |                             (MetacelloErrorInProjectConstructionNotification versionString: versionSpec versionString exception: ex)                                ifTrue: [ ^ ex pass ]                                ifFalse: [                                     self errorMap at: versionSpec versionString put: ex.                                    defined := false ] ].                    defined                        ifTrue: [                             | version importedVersions |                            importedVersions := OrderedCollection new.                            version := versionSpec createVersion.                            pragmaColl do: [ :pragma | importedVersions addAll: (pragma argumentAt: 2) ].                            version importedVersions: importedVersions.                            self validateVersionString: versionString againstSpec: versionSpec.                            versionMap at: versionSpec versionString put: version ].                    self reset ] ]! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34752605!commonDefaultSymbolicVersionResolverBlock	^ self defaultSymbolicVersionResolverBlock: (ConfigurationOf new project: self project)! !!MetacelloVersionConstructor methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34752839!defaultSymbolicVersionResolverBlock	^ self defaultSymbolicVersionResolverBlock: self configuration! !!MetacelloVersionConstructor methodsFor: 'deprecated' stamp: 'dkh 6/5/2012 19:01:24' prior: 34758378!spawnPackageMethodIn: aConfig category: methodCategory named: newSelector sourceVersion: sourceVersionString targetVersion: targetVersionString blessing: blessing	self deprecated: 'see MetacelloToolBox class>>createBaseline:for:from:description: for replacement method'.	self 		prepareForMethodUpdate: aConfig 		sourceVersion: sourceVersionString 		forceUpdate: blessing ~~ #baseline		generating: [:selector :pragmaMap :ar :updatedPackageSpecsMap | | strm |			strm := WriteStream on: String new.			strm 				nextPutAll: newSelector asString, ' spec'; cr;				tab; nextPutAll: 						'<version: ', 						targetVersionString printString, 						' imports: #(', sourceVersionString printString, 						')>';cr.			(ar at: 2) do: [:attribute | | vs d |				vs := (ar at: 1) at: attribute.				(d := updatedPackageSpecsMap at: attribute ifAbsent: []) ~~ nil					ifTrue: [ 						vs packagesSpec list do: [:member | | x |							x := d at: member spec name ifAbsent: [].						 	member spec updateForSpawnMethod: x ]]					ifFalse: [						vs packagesSpec list do: [:member |							member spec updateForSpawnMethod: member spec copy ]].				strm cr; tab; nextPutAll: 'spec for: ', attribute printString, ' do: ['; cr.				attribute == #common					ifTrue: [						vs 							author: MetacelloPlatform current authorName;							timestamp: MetacelloPlatform current timestamp.						blessing ~~ nil							ifTrue: [ vs blessing: blessing ]].				vs configSpawnMethodOn: strm indent: 2.				strm nextPutAll: '].'].				(aConfig class						compile: strm contents					classified: methodCategory) == nil 						ifTrue: [ self error: 'Error compiling the method' ]].	^true! !!MetacelloVersionConstructor methodsFor: 'deprecated' stamp: 'dkh 6/5/2012 19:01:24' prior: 34761177!updatePackageMethodIn: aConfig sourceVersion: sourceVersionString	self deprecated: 'see MetacelloToolBox class>>updateDevelopment:for:updateProjects:description: for replacement method'.	self 		prepareForMethodUpdate: aConfig 		sourceVersion: sourceVersionString 		forceUpdate: false		generating: [:selector :pragmaMap :ar :updatedPackageSpecsMap | | strm pragma |			updatedPackageSpecsMap isEmpty ifTrue: [ ^false ].			strm := WriteStream on: String new.			strm 				nextPutAll: selector asString, ' spec'; cr;				tab; nextPutAll: '<version: ', sourceVersionString printString.			pragma := pragmaMap at: selector.			pragma numArgs = 2				ifTrue: [					strm nextPutAll: ' imports: #('.					(pragma argumentAt: 2) do: [:versionString |						strm nextPutAll: versionString printString; space ]].			strm nextPutAll: ')>';cr.			(ar at: 2) do: [:attribute | | vs d |				vs := (ar at: 1) at: attribute.				(d := updatedPackageSpecsMap at: attribute ifAbsent: []) ~~ nil					ifTrue: [ 						vs packagesSpec list do: [:member | 							member spec file ~~ nil								ifTrue: [ | x |									(((x := d at: member spec name ifAbsent: []) ~~ nil) and: [ x ~~ #uptodate ])						 				ifTrue: [ member spec file: x file ]]]].				strm cr; tab; nextPutAll: 'spec for: ', attribute printString, ' do: ['; cr.				attribute == #common					ifTrue: [ 						vs 							author: MetacelloPlatform current authorName;							timestamp: MetacelloPlatform current timestamp ].				vs configMethodOn: strm indent: 2.				strm nextPutAll: '].'].			(aConfig class						compile: strm contents					classified: (aConfig class whichCategoryIncludesSelector: pragma selector)) == nil						ifTrue: [ self error: 'Error compiling the method' ]].	^true! !!MetacelloVersionConstructor methodsFor: 'validation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34763033!validateVersionString: versionString againstSpec: versionSpec	versionString = versionSpec versionString		ifFalse: [ 			MetacelloValidationNotification				signal:					(MetacelloValidationError						configurationClass: self configurationClass						reasonCode: #incorrectVersionString						callSite: #validateVersionString:againstSpec						explanation:							'The version declared in the pragma ', versionString printString , ' does not match the version in the spec '								, versionSpec versionString printString) ].! !!MetacelloIgnorePackageLoaded class methodsFor: 'signalling' stamp: 'dkh 05/14/2014 10:27'!signal: aMetacelloPackageSpec	^(self new packageSpec: aMetacelloPackageSpec) signal! !!MetacelloIgnorePackageLoaded methodsFor: 'accessing' stamp: 'dkh 05/14/2014 10:30'!defaultAction  "Default action is to NOT ignore whether or not the package is loaded.    Basically allow for package level ignoreImage. "  ^ false! !!MetacelloIgnorePackageLoaded methodsFor: 'accessing' stamp: 'dkh 05/14/2014 10:27'!packageSpec   ^packageSpec! !!MetacelloIgnorePackageLoaded methodsFor: 'accessing' stamp: 'dkh 05/14/2014 10:27'!packageSpec: anObject   packageSpec := anObject! !!MetacelloScriptGitBasedDownloadNotification methodsFor: 'accessing' stamp: 'dkh 09/29/2014 12:27'!projectPath	^ projectPath! !!MetacelloScriptGitBasedDownloadNotification methodsFor: 'accessing' stamp: 'dkh 09/29/2014 12:27'!projectPath: anObject	projectPath := anObject! !!MetacelloScriptGitBasedDownloadNotification methodsFor: 'accessing' stamp: 'dkh 09/29/2014 12:27'!versionString	^ versionString! !!MetacelloScriptGitBasedDownloadNotification methodsFor: 'accessing' stamp: 'dkh 09/29/2014 12:27'!versionString: anObject	versionString := anObject! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'dkh 10/09/2014 10:29'!validateBaseline: baselineClass  ^ self validateBaseline: baselineClass debug: #() recurse: false! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'dkh 10/09/2014 16:43'!validateBaseline: baselineClass debug: debugList recurse: aBool  ^ (self new    configurationClass: baselineClass;    debug: debugList;    recurse: aBool;    yourself) validateBaselineOf! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'dkh 10/09/2014 10:30'!validateBaseline: baselineClass recurse: aBool  ^ self validateBaseline: baselineClass debug: #() recurse: aBool! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34644789!validateProject: aMetacelloProject version: versionString	^self validateProject: aMetacelloProject version: versionString debug: #() recurse: false! !!MetacelloVersionValidator class methodsFor: 'instance creation' stamp: 'dkh 6/5/2012 19:01:24' prior: 34645056!validateProject: aMetacelloProject version: versionString debug: debugList	^self validateProject: aMetacelloProject version: versionString debug: debugList recurse: false! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34648177!recordValidationCriticalWarning: aString callSite: callSite reasonCode: aSymbol	^self recordValidationCriticalWarning: aString versionString: nil callSite: callSite reasonCode: aSymbol! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34649403!recordValidationError: aString callSite: callSite reasonCode: aSymbol	^self recordValidationError: aString versionString: nil callSite: callSite reasonCode: aSymbol! !!MetacelloVersionValidator methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34650690!recordValidationWarning: aString callSite: callSite reasonCode: aSymbol					^self recordValidationWarning: aString versionString: nil callSite: callSite reasonCode: aSymbol! !!MetacelloVersionValidator methodsFor: 'validation' stamp: 'dkh 10/09/2014 16:44'!validateBaselineOf  self validatePragmas.  ^ self validateBaselineProject! !!MetacelloVersionValidator methodsFor: 'private' stamp: 'dkh 10/09/2014 16:45'!validateBaselineProject  | project |  project := self    validateProjectCreationFrom: self configurationClass    onError: [ :ex |       self        recordValidationError:          'Error creating project: ' , ex description            , ' to reproduce evalutate the following: '''            , self configurationClass name asString , ' project'''        callSite: #'validateBaselineProject'        reasonCode: #'projectCreationError'.      ^ self validationReport ].  ^ self validateBaselineProject: project! !!MetacelloVersionValidator methodsFor: 'validation' stamp: 'dkh 10/09/2014 16:48'!validateBaselineProject: project  | version spec |  (self visited includes: project configuration class)    ifTrue: [ ^ self validationReport ].  self visited add: project configuration class.  version := project version.  spec := version spec.  [ self validateBaselineVersionSpec: spec ]    on: Error    do: [ :ex |       self        recordValidationError:          'Error composing version ' , version versionString printString , ': '            , ex description        versionString: version versionString        callSite: #'validateBaselineProject:'        reasonCode: #'versionCompositionError' ].  ^ self validationReport! !!MetacelloAllowConflictingProjectUpgrade methodsFor: 'exception handling' stamp: 'dkh 10/10/2014 14:34' prior: 34632428!defaultAction  self existingProjectRegistration locked    ifTrue: [       "https://github.com/dalehenrich/metacello-work/issues/263"      ^ self useIncoming ].  ^ MetacelloConflictingProjectError    signal:      'Load Conflict between existing ' , self existingProjectRegistration printString        , ' and ' , self newProjectRegistration printString! !!MetacelloAllowConflictingProjectUpgrade methodsFor: 'accessing' stamp: 'dkh 07/29/2013 16:44' prior: 34632928!operationString  ^ 'load with conflicts'! !!MetacelloScriptRegistryExecutor methodsFor: 'actions api' stamp: 'dkh 7/20/2012 12:00' prior: 34924976!prime! !!MetacelloScriptRegistryExecutor methodsFor: 'execution callback' stamp: 'dkh 07/28/2013 10:07'!projectSpecSelectBlock  ^ [ :projectSpec | projectSpec notNil ]! !!MetacelloScriptRegistryExecutor methodsFor: 'actions api' stamp: 'dkh 7/13/2012 09:37' prior: 34925075!remove! !!MetacelloScriptRegistryExecutor methodsFor: 'actions api' stamp: 'dkh 7/13/2012 09:36' prior: 34925175!reset! !!MetacelloToolBoxConstructor methodsFor: 'extraction' stamp: 'DaleHenrichs 12/22/2010 11:07' prior: 34043268!extractMethodSectionsFor: sourceVersionString	| coll pragma |	coll := self extractAllVersionPragmas at: sourceVersionString ifAbsent: [ ^ #() ].	coll size > 1		ifTrue: [ self error: 'More than one pragma defining ' , sourceVersionString printString ].	pragma := coll at: 1.	self evaluatePragma: pragma.	self methodSections do: [ :methodSection | self evaluateMethodSection: methodSection version: sourceVersionString ].! !!MetacelloToolBoxConstructor methodsFor: 'extraction' stamp: 'DaleHenrichs 11/15/2010 10:06' prior: 34043793!extractSymbolicVersionSpecsFor: sourceVersionSymbol	| coll versionSpec pragma |	coll := self extractSymbolicVersionPragmas at: sourceVersionSymbol ifAbsent: [ ^ #() ].	coll size > 1		ifTrue: [ self error: 'More than one pragma defining ' , sourceVersionSymbol printString ].	pragma := coll at: 1.	self evaluatePragma: pragma.	^ self methodSections! !!MetacelloToolBoxConstructor methodsFor: 'enumeration' stamp: 'DaleHenrichs 12/23/2010 15:10' prior: 34045613!methodSectionsDo: aBlock	self methodSection: self do: aBlock! !!MetacelloAllowLockedProjectChange methodsFor: 'exception handling' stamp: 'dkh 11/23/2013 14:11'!break  ^ self allow! !!MetacelloAllowLockedProjectChange methodsFor: 'private' stamp: 'dkh 07/25/2013 04:42'!checkAllowed  "noop ... if user decided to allow lock to be broken, then so be it"! !!MetacelloAllowLockedProjectChange methodsFor: 'exception handling' stamp: 'dkh 07/30/2013 07:51'!defaultAction  Warning    signal:      'LOCK ENFORCED: Attempt to ' , self operationString printString        , ' new project: ' , self newProjectRegistration printString printString        , ' when existing project: '        , self existingProjectRegistration printString printString        , ' is locked. New project not loaded. Use #onLock: to intercept.'.  ^ self disallow! !!MetacelloAllowLockedProjectChange methodsFor: 'handlers' stamp: 'dkh 07/24/2013 16:58'!handleResolutionFor: aScriptEngine  ^ aScriptEngine handleLock: self! !!MetacelloAllowLockedProjectChange methodsFor: 'exception handling' stamp: 'dkh 11/23/2013 14:10'!honor  ^ self disallow! !!MetacelloAllowLockedProjectChange methodsFor: 'accessing' stamp: 'dkh 07/24/2013 17:00'!operationString  ^ operationString! !!MetacelloAllowLockedProjectChange methodsFor: 'accessing' stamp: 'dkh 07/24/2013 17:00'!operationString: aString  operationString := aString! !!MetacelloResolveProjectUpgrade methodsFor: 'exception handling' stamp: 'dkh 07/25/2013 11:57' prior: 34634513!allowEvenIfLocked  "for internal ScriptEngine use only. from the Scripting API use:		onLocked: [:ex | ex allow]		"  self resume: self newProjectRegistration! !!MetacelloResolveProjectUpgrade methodsFor: 'private' stamp: 'dkh 07/25/2013 04:44' prior: 34634663!checkAllowed  self existingProjectRegistration locked    ifTrue: [       self        resume:          (MetacelloAllowLockedProjectChange new            operationString: self operationString;            existingProjectRegistration: self existingProjectRegistration;            newProjectRegistration: self newProjectRegistration;            signal) ]! !!MetacelloResolveProjectUpgrade methodsFor: 'exception handling' stamp: 'dkh 10/10/2014 14:36'!useExisting  "to be deprecated: useLoaded"  self disallow! !!MetacelloResolveProjectUpgrade methodsFor: 'exception handling' stamp: 'dkh 10/10/2014 13:18'!useIncoming  self allow! !!MetacelloResolveProjectUpgrade methodsFor: 'exception handling' stamp: 'dkh 10/10/2014 13:21'!useLoaded  self disallow! !!MetacelloResolveProjectUpgrade methodsFor: 'exception handling' stamp: 'dkh 10/10/2014 14:36'!useNew  "to be deprecated: useIncoming"  self allow! !!MetacelloAbstractConstructor methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34669754!extractPragmas: pragmaKeyword for: aClass into: versionDict	| versionString  pragmas |	(Pragma 		allNamed: pragmaKeyword		in: aClass) do: [:pragma |			versionString := pragma argumentAt: 1.			pragmas := versionDict 				at: versionString 				ifAbsent: [ | list |					list := OrderedCollection new.					versionDict at: versionString put: list.					list ].			pragmas add: pragma ].! !!MetacelloAbstractConstructor methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34670250!extractPragmas: pragmaKeyword into: versionDict	^self extractPragmas: pragmaKeyword for: self configurationClass into: versionDict! !!MetacelloVersionDoesNotExistError methodsFor: 'Signaling' stamp: 'dkh 09/26/2014 10:07' prior: 34710479!signal  "GemStone needs this to print exception correctly"  self messageText: self description.  ^ super signal! !!MetacelloMemberSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34671186!applyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock	self subclassResponsibility! !!MetacelloPlatform class methodsFor: 'initialize-release' stamp: 'dkh 05/05/2013 13:39' prior: 34687592!initialize  "noop ... use #select"! !!MetacelloPlatform methodsFor: 'package cache' stamp: 'dkh 10/16/2014 21:39'!clearPackageCache  "make sure that the package cache is empty, by hook or by crook"  | cache dir |  cache := self defaultPackageCache.  cache flushCache.	"GemStone and Pharo1.4"  dir := cache directory.  dir ~~ nil    ifTrue: [       "delete directory - Squeak and Pharo"      [ self recursiveDelete: dir ]        on: Error        do: [ :ignore |  ] ]! !!MetacelloPlatform methodsFor: 'repository creation' stamp: 'dkh 10/18/2014 09:14' prior: 34690158!createRepository: aRepositorySpec  | type |  type := aRepositorySpec type.  type = 'http'    ifTrue: [       ^ MCHttpRepository        location: aRepositorySpec description        user: aRepositorySpec username        password: aRepositorySpec password ].  type = 'directory'    ifTrue: [       ^ MCDirectoryRepository new        directory: (self fileHandleOn: aRepositorySpec description) ].  Smalltalk    at: #'MCFileTreeRepository'    ifPresent: [ :cl |       type = 'filetree'        ifTrue: [           | description headerSize |          description := aRepositorySpec description.          headerSize := 'filetree://' size.          ^ cl new            directory:              (self                fileHandleOn:                  (aRepositorySpec description copyFrom: headerSize + 1 to: description size)) ] ].  Smalltalk    at: #'MCGitHubRepository'    ifPresent: [ :cl |       type = 'github'        ifTrue: [ ^ cl location: aRepositorySpec description ] ].  Smalltalk    at: #'MCBitbucketRepository'    ifPresent: [ :cl |       type = 'bitbucket'        ifTrue: [ ^ cl location: aRepositorySpec description ] ].  Smalltalk    at: #'MCGitoriousRepository'    ifPresent: [ :cl |       type = 'gitorious'        ifTrue: [ ^ cl location: aRepositorySpec description ] ].  type = 'dictionary'    ifTrue: [       | description headerSize globalName |      description := aRepositorySpec description.      headerSize := 'dictionary://' size.      globalName := (description copyFrom: headerSize + 1 to: description size)        asSymbol.      ^ Smalltalk        at: globalName        ifAbsent: [           Smalltalk            at: globalName            put:              (MCDictionaryRepository new                description: description;                yourself) ] ].  ^ nil! !!MetacelloPlatform methodsFor: 'package cache' stamp: 'dkh 10/16/2014 09:46'!defaultPackageCache  "Apparently the MCCacheRepository api is changing in Pharo"  ^ MCCacheRepository default! !!MetacelloPlatform methodsFor: 'attributes' stamp: 'dkh 10/18/2014 12:06' prior: 34692201!defaultPlatformAttributes  | versionString |  Smalltalk    at: #'SystemVersion'    ifPresent: [ :cl |       versionString := cl current version.      (versionString beginsWith: 'Pharo')        ifTrue: [ ^ #(#'squeakCommon' #'pharo') ].      (versionString beginsWith: 'Squeak')        ifTrue: [ ^ #(#'squeakCommon' #'squeak') ].	"see http://code.google.com/p/metacello/issues/detail?id=146"      (self string: versionString includesSubstring: 'Pharo')        ifTrue: [ ^ #(#'squeakCommon' #'pharo') ].      (self string: versionString includesSubstring: 'Squeak')        ifTrue: [ ^ #(#'squeakCommon' #'squeak') ].      self error: 'Unrecognized version of Squeak/Pharo: ' , versionString ].  ^ #(#'gemstone')! !!MetacelloPlatform methodsFor: 'github/bitbucket support' stamp: 'dkh 09/19/2014 15:36' prior: 34693652!downloadErrorFileNameFor: zipFileName  | pid |  pid := self processPID.  ^ '/tmp/curl-' , pid , '-' , (zipFileName select: [ :c | c isAlphaNumeric ])    , '.err'! !!MetacelloPlatform methodsFor: 'github/bitbucket support' stamp: 'dkh 10/16/2014 13:52'!downloadJSON: url username: username pass: pass  "return result of parsing JSON downloaded from url. username:pass may be nil, but calls will be subject to severe rate limits."  self subclassResponsibility! !!MetacelloPlatform methodsFor: 'github/bitbucket support' stamp: 'dkh 10/14/2014 10:51'!downloadZipArchive: url to: outputFileName  "download zip archive from <url> into <outputFileName>"  self subclassResponsibility! !!MetacelloPlatform methodsFor: 'github/bitbucket support' stamp: 'dkh 7/7/2012 07:36' prior: 34694256!extractRepositoryFrom: zipFile to: directory    "unzip <zipFile> into <directory>"    self subclassResponsibility! !!MetacelloPlatform methodsFor: 'repository creation' stamp: 'dkh 09/29/2014 15:01' prior: 34694477!extractTypeFromDescription: description  description == nil    ifTrue: [ ^ nil ].  ((description beginsWith: '/') or: [ description second = $: ])    ifTrue: [ ^ 'directory' ].  (description beginsWith: 'dictionary://')    ifTrue: [ ^ 'dictionary' ].  (description beginsWith: 'filetree://')    ifTrue: [ ^ 'filetree' ].  (description beginsWith: 'github://')    ifTrue: [ ^ 'github' ].  (description beginsWith: 'gitorious://')    ifTrue: [ ^ 'gitorious' ].  (description beginsWith: 'bitbucket://')    ifTrue: [ ^ 'bitbucket' ].  ^ 'http'! !!MetacelloPlatform methodsFor: 'github/bitbucket support' stamp: 'dkh 07/09/2012 04:45' prior: 34694999!fileDirectoryClass	^FileDirectory! !!MetacelloPlatform methodsFor: 'git support' stamp: 'dkh 05/09/2014 10:06'!gitBranchNameFor: aDirectory  "return current branch for git repository located at <aDirectory>, if <aDirectory> is not a git repository, return nil"  ^ nil! !!MetacelloPlatform methodsFor: 'git support' stamp: 'dkh 05/08/2014 13:07'!gitCommitShaFor: aDirectory  "return SHA for git repository located at <aDirectory>, if <aDirectory> is not a git repository, return nil"  ^ nil! !!MetacelloPlatform methodsFor: 'monticello' stamp: 'dkh 09/23/2013 13:59'!newVersionForWorkingCopy: aWorkingCopy  ^ aWorkingCopy newVersion! !!MetacelloPlatform methodsFor: 'repository creation' stamp: 'dkh 05/08/2013 09:33' prior: 34695888!packageInfoFor: aMCWorkingCopy  ^ aMCWorkingCopy packageInfo! !!MetacelloPlatform methodsFor: 'github/bitbucket support' stamp: 'dkh 09/19/2014 14:56'!processPID  "return pid of process as string if available"  ^ ''! !!MetacelloPlatform methodsFor: 'repository creation' stamp: 'dkh 11/10/2014 16:34'!registerPackageNamed: packageName  ^ (Smalltalk at: #'PackageInfo') registerPackageName: packageName! !!MetacelloPlatform methodsFor: 'file system' stamp: 'ChristopheDemarey 8/29/2014 17:13'!tempFileFor: aName suffix: aSuffixString	^ '/tmp/' , aName , aSuffixString! !!MetacelloProjectSpecForLoad methodsFor: 'operations' stamp: 'dkh 11/23/2013 15:32' prior: 34893192!performLoad  | displayString spec |  spec := self projectSpec.  displayString := 'Project: ' , spec name.  spec versionString ~~ nil    ifTrue: [ displayString := displayString , ' ' , spec versionString ].  Transcript    cr;    show: displayString.  self hasOverride    ifTrue: [       | override |      override := self overrideProjectSpec copy.      override mergeScriptLoads: spec.      override loadVersion: nil ]    ifFalse: [       spec        loadVersion:          (self useDetermineVersionForLoad            ifTrue: [ spec determineCurrentVersionForLoad ]            ifFalse: [ spec versionOrNil ]) ]! !!MetacelloPackageSpecResolutionError methodsFor: 'Signaling' stamp: 'dkh 09/26/2014 10:06' prior: 34704921!signal  "GemStone needs this to print exception correctly"  self messageText: self description.  ^ super signal! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34849748!attributes	^(OrderedCollection with: #common)		addAll: self platformAttributes;		yourself! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34853713!excludeFromLatestVersion	^#(structural development broken baseline)! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34855291!latestVersionMatching: versionPatternString	"Answer whether the version number of the receiver matches the given pattern string.	 A Metacello version number is made up of version sequences delimited by the characters $. and $-.	 The $. introduces a numeric version sequence and $- introduces an alphanumeric version sequence.	 	 A version pattern is made up of version pattern match sequences. also delimited by the characters $. 	 and $-.. Each pattern match sequence is tested against the corresponding version sequence of the 	 receiver, using the 'standard' pattern matching rules. All sequences must answer true for a match.		 The special pattern sequence '?' is a match for the corresponding version sequence and all subsequent 	 version sequences. '?' as the version pattern matches all versions. No more version pattern 	 sequences are permitted once the '?' sequence is used. If used, it is the last version pattern	 sequence."	^self 		latestVersionMatching: versionPatternString 		includedBlessings: #()		excludedBlessings: self excludeFromLatestVersion! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34856466!latestVersionMatching: versionPatternString excludedBlessings: excluded	^self 		latestVersionMatching: versionPatternString 		includedBlessings: #()		excludedBlessings: excluded! !!MetacelloProject methodsFor: 'versions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34856742!latestVersionMatching: versionPatternString includedBlessings: included	^self 		latestVersionMatching: versionPatternString 		includedBlessings: included		excludedBlessings: self excludeFromLatestVersion! !!MetacelloProject methodsFor: 'loading' stamp: 'dkh 6/5/2012 19:01:24' prior: 34857599!load: aVersionString	^(self version: aVersionString) load! !!MetacelloProject methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34862265!sortedAndFilteredVersions		^(self map values asArray sort: [:a :b | a >= b ]) select: [:vrsn | (#(structural broken baseline) includes: vrsn blessing) not ].! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34862639!symbolicVersionMap	^symbolicVersionMap! !!MetacelloProject methodsFor: 'accessing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34862783!symbolicVersionMap: aDictionary	symbolicVersionMap := aDictionary! !!MetacelloNameNotDefinedError methodsFor: 'Accessing' stamp: 'dkh 10/17/2014 16:45'!isResumable  "Pharo and Squeak compatibility"  ^ true! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'dkh 11/17/2013 17:09' prior: 34719377!import: aStringOrCollection  "import names defined in baseline <aString> to be used when loading the version		spec baseline: 'Sample' with: [ spec repository: 'github://dalehenrich/sample:master/repository' ].		spec import: 'Sample' ]		or a list of names for multiple project imports:			spec baseline: 'Sample' with: [ spec repository: 'github://dalehenrich/sample:master/repository' ].		spec baseline: 'Example' with: [ spec repository: 'github://dalehenrich/example:master/repository' ].		spec import: #('Sample' 'Example')]		 "  self root import: aStringOrCollection constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'dkh 11/24/2013 20:38'!import: aString provides: aCollection  "import names defined in baseline <aString> to be used when loading the version			spec baseline: 'Sample' with: [ spec repository: 'github://dalehenrich/sample:master/repository' ].		spec import: 'Sample' provides: #('Sample Core');		spec baseline: 'Example' with: [ spec repository: 'github://dalehenrich/example:master/repository' ].		spec import: 'Example' provides: #('Example Core')]		 "  self root import: aString provides: aCollection constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api spec callbacks' stamp: 'dkh 11/17/2013 17:48'!importForVersion: aString provides: anArray  self root import: aString provides: anArray! !!MetacelloAbstractVersionConstructor methodsFor: 'api' stamp: 'dkh 11/17/2013 17:12' prior: 34720293!loads: aStringOrCollection  self root loads: aStringOrCollection constructor: self! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34039295!setPackage: aString withString: aFile	| spec |	spec := 		(self project packageSpec)			name: aString;			file: aFile;			yourself.	self root packages merge: spec.! !!MetacelloAbstractVersionConstructor methodsFor: 'api callbacks' stamp: 'DaleHenrichs 11/12/2010 09:54' prior: 34040250!setProject: aString withString: versionString	| spec projectSpec |	projectSpec := 		(self project projectSpec)			name: aString;			versionString: versionString;			yourself.	spec := 		(self project projectReferenceSpec)			name: aString;			projectReference: projectSpec;			yourself.	self root packages merge: spec.! !!MetacelloAbstractVersionConstructor methodsFor: 'validation' stamp: 'DaleHenrichs 11/12/2010 10:28' prior: 34041796!validateDoItSelector: anObject	anObject == nil ifTrue: [ ^ self ].	anObject isSymbol ifFalse: [ self error: 'Invalid message selector for doit: ', anObject printString ].! !!MetacelloGroupSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34765446!configMethodCascadeOn: aStream member: aMember last: lastCascade indent: indent	aMember methodUpdateSelector == #remove:		ifTrue: [ aStream nextPutAll: 'removeGroup: ', self name printString. ]		ifFalse: [			aStream 				nextPutAll: 'group: ', self name printString;				space; 				nextPutAll: aMember methodUpdateSelector asString, ' #('.			self includes do: [:str | aStream nextPutAll: str printString, ' ' ].			aStream nextPut: $) ].	lastCascade		ifTrue: [ aStream nextPut: $. ]		ifFalse: [ aStream nextPut: $;; cr ].! !!MetacelloGroupSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34766073!configMethodOn: aStream indent: indent	aStream 		tab: indent;		nextPutAll: 'spec '; cr;		tab: indent + 1;		nextPutAll: 'name: ', self name printString, ';'.	self configMethodBodyOn: aStream hasName: true cascading: false indent: indent + 1.	aStream nextPut: $.! !!MetacelloGroupSpec methodsFor: 'private' stamp: 'dkh 10/03/2014 18:45'!includeSpecNamesForPackageOrdering: aVersionSpec  ^ #()! !!MetacelloGroupSpec methodsFor: 'private' stamp: 'dkh 10/03/2014 11:39'!requiredSpecsForPackageOrdering: aVersionSpec  ^ #()! !!MetacelloGroupSpec methodsFor: 'private' stamp: 'dkh 10/03/2014 14:39'!requiresSpecsForPackageOrdering: aVersionSpec  "expand the names in the group to a package or project"  | packageOrProjectSpecs |  packageOrProjectSpecs := Set new.  self includes    do: [ :specName |       (aVersionSpec packageNamed: specName ifAbsent: [  ])        ifNotNil: [ :pkgSpec |           packageOrProjectSpecs            addAll:              (pkgSpec                resolveToPackagesIn: aVersionSpec                andProjects: true                visited: MetacelloVisitedPackages new) ] ].  ^ packageOrProjectSpecs! !!MetacelloGroupSpec methodsFor: 'private' stamp: 'dkh 10/03/2014 18:42'!resolveSpecsForPackageOrdering: aVersionSpec  "expand the names in the group to a package or project"  | packageOrProjectSpecs |  packageOrProjectSpecs := Set new.  self includes    do: [ :specName |       (aVersionSpec packageNamed: specName ifAbsent: [  ])        ifNotNil: [ :pkgSpec |           packageOrProjectSpecs            addAll:              (pkgSpec                resolveToPackagesIn: aVersionSpec                andProjects: true                visited: MetacelloVisitedPackages new) ] ].  ^ packageOrProjectSpecs! !!MetacelloPackagesSpec methodsFor: 'accessing' stamp: 'dkh 10/09/2014 14:18'!applyIncludesTo: orderedSpecs for: pkgSpec firstTime: firstTime for: aVersionSpec  | movedSpecs baseIndex |  movedSpecs := Set new.  baseIndex := orderedSpecs indexOf: pkgSpec.  (pkgSpec includeSpecNamesForPackageOrdering: aVersionSpec)    do: [ :includedSpec |       | includedSpecName spec |      includedSpecName := includedSpec name.      spec := orderedSpecs        detect: [ :aSpec | aSpec name = includedSpecName ]        ifNone: [  ].      (self        slideIn: orderedSpecs        spec: spec        baseIndex: baseIndex        seen: IdentitySet new        firstTime: firstTime        for: aVersionSpec)        ifTrue: [ movedSpecs add: spec name ] ].  ^ movedSpecs! !!MetacelloPackagesSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34768399!copy: specNamed to: spec	self addMember: 		(self copyMember 			name: spec name;			sourceName: specNamed;			spec: spec;			yourself)! !!MetacelloPackagesSpec methodsFor: 'accessing' stamp: 'dkh 10/03/2014 18:10'!packageSpecsInLoadOrderFor: aVersionSpec  "order only the packageSpecs and projectSpecs. groupSpec order does not matter"  | orderedPackageSpecs groupSpecs moved lastMovedSpecs count terminationLimit map specsWithIncludes firstTime groupLoops |  map := self map.  orderedPackageSpecs := OrderedCollection new.  groupSpecs := Set new.  self list    do: [ :member |       | spec |      spec := map at: member name ifAbsent: [  ].      (spec == nil or: [ orderedPackageSpecs includes: spec ])        ifFalse: [           spec            projectDo: [ :prjSpec |               "specification order is the default order"              orderedPackageSpecs add: prjSpec ]            packageDo: [ :pkgSpec |               "specification order is the default order"              orderedPackageSpecs add: pkgSpec ]            groupDo: [ :groupSpec | groupSpecs add: groupSpec ] ] ].  orderedPackageSpecs isEmpty    ifTrue: [ ^ orderedPackageSpecs , groupSpecs asOrderedCollection ].  moved := true.  count := 0.  terminationLimit := orderedPackageSpecs size * 2.  groupLoops := IdentitySet new.  [ moved ]    whileTrue: [       count := count + 1.      count > terminationLimit        ifTrue: [           "Cheap termination hack - an APPARENT loop"          self error: 'Apparent loop in before/after dependency definitions' ].      moved := false.      orderedPackageSpecs copy        do: [ :packageSpec |           moved := moved            or: [               self                sortPackageSpecs: orderedPackageSpecs                packageSpec: packageSpec                groupLoops: groupLoops                for: aVersionSpec ] ] ].  lastMovedSpecs := Set new.  moved := true.  count := 0.  specsWithIncludes := orderedPackageSpecs    select: [ :pkgSpec | pkgSpec includesForPackageOrdering isEmpty not ].  firstTime := true.  [ moved ]    whileTrue: [       | result |      count := count + 1.	"count > terminationLimit"      count > 14        ifTrue: [           "Cheap termination hack - an APPARENT loop"          self error: 'Apparent loop in before/after dependency definitions' ].      moved := false.      result := Set new.      specsWithIncludes        do: [ :packageSpec |           result            addAll:              (self                applyIncludesTo: orderedPackageSpecs                for: packageSpec                firstTime: firstTime                for: aVersionSpec) ].      result size = lastMovedSpecs size        ifTrue: [           result            do: [ :name |               (lastMovedSpecs includes: name)                ifFalse: [ moved := true ] ] ]        ifFalse: [ moved := true ].      lastMovedSpecs := result.      firstTime := false ].  ^ orderedPackageSpecs , groupSpecs asOrderedCollection! !!MetacelloPackagesSpec methodsFor: 'accessing' stamp: 'dkh 10/09/2014 15:59'!slideIn: orderedSpecs spec: targetSpec baseIndex: baseIndex seen: seen firstTime: firstTime for: aVersionSpec  | targetIndex requiredSpecNames targetRequires targetRequiresIndexes minIndex baseSpec required |  (seen includes: targetSpec)    ifTrue: [ ^ false ].  targetIndex := orderedSpecs indexOf: targetSpec.  baseIndex >= targetIndex    ifTrue: [ ^ false ].  required := false.  baseSpec := orderedSpecs at: baseIndex.  baseIndex + 1 to: targetIndex - 1 do: [ :index |     | spec |    spec := orderedSpecs at: index.    ((spec requiredSpecNamesForPackageOrdering: aVersionSpec)      includes: baseSpec name)      ifTrue: [ required := true ] ].  firstTime    ifFalse: [       required        ifFalse: [ ^ false ] ].  requiredSpecNames := targetSpec    requiredSpecNamesForPackageOrdering: aVersionSpec.  targetRequires := orderedSpecs    select: [ :spec | requiredSpecNames includes: spec name ].  targetRequiresIndexes := targetRequires    collect: [ :spec | orderedSpecs indexOf: spec ].  targetRequiresIndexes add: baseIndex.  minIndex := targetRequiresIndexes detectMax: [ :each | each ].  minIndex + 1 < targetIndex    ifTrue: [       orderedSpecs remove: targetSpec.      orderedSpecs add: targetSpec afterIndex: minIndex.      seen add: targetSpec ]    ifFalse: [       ^ self        slideIn: orderedSpecs        spec: (orderedSpecs at: minIndex)        baseIndex: 1        seen: seen        firstTime: firstTime        for: aVersionSpec ].  ^ true! !!MetacelloPackagesSpec methodsFor: 'private' stamp: 'dkh 10/17/2014 16:54'!sortPackageSpecs: orderedSpecs packageSpec: packageSpec groupLoops: groupLoops for: aVersionSpec  | packageIndex moved movePackage targetPackage targetIndex targetSpecNames groupLoopDetected |  packageIndex := orderedSpecs indexOf: packageSpec.  moved := movePackage := false.  targetSpecNames := packageSpec    requiredSpecNamesForPackageOrdering: aVersionSpec.  groupLoopDetected := groupLoops includes: packageSpec.  groupLoopDetected    ifFalse: [       targetSpecNames        do: [ :targetPackageOrProjectName |           targetPackage := orderedSpecs            detect: [ :each | each name = targetPackageOrProjectName ]            ifNone: [               MetacelloNameNotDefinedError                signal:                  'project group, or package named: ' , targetPackageOrProjectName printString                    ,                      ' not found when used in requires: or includes: field of package: '                    , packageSpec name printString , ' for version: '                    , aVersionSpec versionString , ' of '                    , aVersionSpec projectLabel , '.'.              nil	"return nil if resumed" ].          targetIndex := orderedSpecs indexOf: targetPackage.          (groupLoopDetected not and: [ packageIndex = targetIndex ])            ifTrue: [               self                notify:                  'A group loop has been detected. The package: ' , packageSpec name printString                    ,                      ' requires a group that includes itself. If you resume, the group loop will be ignored and details will be written to the Transcript.'.              groupLoopDetected := true.              groupLoops add: packageSpec.              Transcript                cr;                show: 'Package: ' , packageSpec name printString;                cr;                tab;                show: 'Raw Requires:'.              packageSpec requires                do: [ :each |                   Transcript                    cr;                    tab;                    tab;                    show: each name ].              Transcript                cr;                show:                    'Package: ' , packageSpec name printString , ' has a group loop:';                cr;                tab;                show: 'Expanded Requires:'.              targetSpecNames                do: [ :each |                   Transcript                    cr;                    tab;                    tab;                    show: each name ] ].          movePackage := movePackage or: [ packageIndex <= targetIndex ].          false            ifTrue: [               "use for debugging non-obvious reference loops"              packageIndex < targetIndex                ifTrue: [                   Transcript                    cr;                    show:                        'Moving ' , targetPackageOrProjectName , ' from ' , targetIndex printString                            , ' to ' , packageIndex printString ] ] ] ].  groupLoopDetected    ifTrue: [       "old implementation that does not resolve group names"      targetSpecNames := packageSpec requires.      targetSpecNames        do: [ :targetPackageName |           targetPackage := orderedSpecs            detect: [ :each | each name = targetPackageName ]            ifNone: [  ].          targetIndex := orderedSpecs indexOf: targetPackage.          movePackage := movePackage or: [ packageIndex <= targetIndex ] ] ].  movePackage    ifTrue: [       moved := true.      orderedSpecs        remove: packageSpec        ifAbsent: [ ^ self error: 'unexpected error removing package' ].      targetIndex := 0.      targetSpecNames        do: [ :targetPackageOrProjectName |           (targetPackage := orderedSpecs            detect: [ :each | each name = targetPackageOrProjectName ]            ifNone: [  ]) ~~ nil            ifTrue: [ targetIndex := targetIndex max: (orderedSpecs indexOf: targetPackage) ] ].      targetIndex == 0        ifTrue: [ orderedSpecs add: packageSpec beforeIndex: packageIndex ]        ifFalse: [ orderedSpecs add: packageSpec afterIndex: targetIndex ] ].  ^ moved! !!MetacelloProjectSpec methodsFor: 'adding' stamp: 'dkh 6/5/2012 19:01:24' prior: 34779739!addToMetacelloPackages: aMetacelloPackagesSpec	| spec |	spec := (aMetacelloPackagesSpec project projectReferenceSpec)			name: self name;			projectReference: self copy;			yourself.	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec addMember 			name: spec name;			spec: spec;			yourself)! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: 'dkh 07/29/2013 11:18' prior: 34780130!canDowngradeTo: aMetacelloProjectSpec  (self className = aMetacelloProjectSpec className    and: [ self operator == aMetacelloProjectSpec operator ])    ifFalse: [ ^ false ].  self versionOrNil == nil    ifTrue: [       "https://github.com/dalehenrich/metacello-work/issues/198#issuecomment-21737458"      ^ true ].  ^ (self compareVersions: aMetacelloProjectSpec usingOperator: self operator)    not! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: 'dkh 07/29/2013 11:18' prior: 34780473!canUpgradeTo: aMetacelloProjectSpec  (self className = aMetacelloProjectSpec className    and: [ self operator == aMetacelloProjectSpec operator ])    ifFalse: [ ^ false ].  self versionOrNil == nil    ifTrue: [       "https://github.com/dalehenrich/metacello-work/issues/198#issuecomment-21737458"      ^ true ].  ^ self compareVersions: aMetacelloProjectSpec usingOperator: self operator! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: 'dkh 07/29/2013 11:18'!compareVersions: aMetacelloProjectSpec usingOperator: anOperator  ^ aMetacelloProjectSpec versionOrNil == nil    ifTrue: [       "https://github.com/dalehenrich/metacello-work/issues/199#issuecomment-21739622"      aMetacelloProjectSpec versionString asMetacelloVersionNumber        perform: anOperator        with: self version versionNumber ]    ifFalse: [ ^ aMetacelloProjectSpec version perform: anOperator with: self version ]! !!MetacelloProjectSpec methodsFor: 'testing' stamp: 'dkh 04/02/2013 20:28' prior: 34791546!hasLoadConflicts: aMetacelloProjectSpec  ^ (self hasNoLoadConflicts: aMetacelloProjectSpec) not! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: 'dkh 06/11/2014 16:50' prior: 34791723!hasNoLoadConflicts: aMetacelloProjectSpec  "same as compareEqual:, except if versionString and/or repositories are not 	specified for either one, then there are not conflicts"  ^ self className = aMetacelloProjectSpec className    and: [       (self compareVersionsEqual: aMetacelloProjectSpec)        and: [ self operator == aMetacelloProjectSpec operator ] ]! !!MetacelloProjectSpec methodsFor: 'scripting' stamp: 'dkh 07/25/2013 15:43'!isLocked  ^ self registration locked! !!MetacelloProjectSpec methodsFor: 'querying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34800104!versionOrNil	^[ self version ] on: MetacelloVersionDoesNotExistError do: [:ex | ^nil ].! !!MetacelloScriptEngine class methodsFor: 'defaults' stamp: 'dkh 09/30/2014 17:39'!defaultRepositoryDescription: descriptionOrNil  DefaultRepositoryDescription := descriptionOrNil! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: 'dkh 10/01/2014 12:12' prior: 34900869!get  " load a fresh copy from repo"  | spec projectPackage |  MetacelloProjectRegistration    copyRegistryRestoreOnErrorWhile: [       self setDefaultsAndValidateProjectSpec.      spec := self projectSpec.      projectPackage := spec projectPackage.      projectPackage repositorySpecs        do: [ :repoSpec | repoSpec createRepository flushForScriptGet ].      self cacheRepository        ifNotNil: [ :cacheRepository | projectPackage loader loaderPolicy cacheRepository: cacheRepository ].      projectPackage load.      self root: (Smalltalk at: spec className asSymbol) project.      MetacelloProjectRegistration        registrationForProjectSpec: spec        ifAbsent: [ :new | new registerProject ]        ifPresent: [ :existing :new |           existing            copyOnWrite: [ :existingCopy |               spec                copyForRegistration: existingCopy                onWrite: [ :specCopy |                   specCopy                    ifNil: [ existingCopy merge: new ]                    ifNotNil: [ specCopy mergeScriptRepository: spec ] ] ] ] ]! !!MetacelloScriptEngine methodsFor: 'project lookup' stamp: 'dkh 06/18/2014 09:59' prior: 34902224!getBaselineUnconditionalLoad: unconditionalLoad  | spec |  spec := self projectSpec.  Smalltalk    at: spec className asSymbol    ifPresent: [ :cl |       unconditionalLoad        ifFalse: [ ^ cl ] ].  spec := self lookupProjectSpecFor: spec.  [ spec projectPackage load ]    on: MetacelloIgnorePackageLoaded    do: [ :ex |       "see https://github.com/dalehenrich/metacello-work/issues/244 ... uncoditionally load        baseline"      ex resume: true ].  ^ Smalltalk at: spec className asSymbol! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: 'dkh 07/24/2013 17:08'!handleLock: exception  ^ (self options at: #'onLock' ifAbsent: [ ^ exception pass ])    cull: exception    cull: exception existingProjectRegistration    cull: exception newProjectRegistration! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: 'dkh 07/24/2013 17:07' prior: 34905742!handleNotificationsForAction: actionBlock  [   [   [   actionBlock    on:      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad        , MetacelloProjectSpecLoadedNotification        , MetacelloScriptEnsureProjectLoadedForDevelopment        , MetacelloLookupBaselineSpecForEnsureLoad    do: [ :ex |       "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"      ex handleResolutionFor: self ] ]    on:      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade        , MetacelloAllowConflictingProjectUpgrade    do: [ :ex |       "option handlers need to be outermost set of handlers ... last line of defense before users are involved"      ex handleResolutionFor: self ] ]    on: MetacelloAllowLockedProjectChange    do: [ :ex |       "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"      ex handleResolutionFor: self ] ]    on: Warning    do: [ :ex |       "Warning is absolute outermost handler"      self handleWarning: ex ]! !!MetacelloScriptEngine methodsFor: 'handlers' stamp: 'dkh 07/24/2013 15:38'!handleWarning: exception  ^ (self options at: #'onWarning' ifAbsent: [ ^ exception pass ])    cull: exception! !!MetacelloScriptEngine methodsFor: 'project lookup' stamp: 'dkh 09/03/2014 13:14' prior: 34910341!lookupProjectSpecFor: aProjectSpec  "if there is no conflict, choose new spec"  | registration loadedSpec |  registration := MetacelloProjectRegistration    registrationForProjectSpec: aProjectSpec    ifAbsent: [ :new | new ]    ifPresent: [ :existing :new |       (existing hasLoadConflicts: new)        ifTrue: [           ((existing canUpgradeTo: new)            ifTrue: [ MetacelloAllowProjectUpgrade new ]            ifFalse: [               (existing canDowngradeTo: new)                ifTrue: [ MetacelloAllowProjectDowngrade new ]                ifFalse: [ MetacelloAllowConflictingProjectUpgrade new ] ])            existingProjectRegistration: existing;            newProjectRegistration: new;            signal ]        ifFalse: [ new ] ].  ^ registration projectSpec! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: 'dkh 05/21/2014 14:22'!register  | spec |  self setDefaultsAndValidate: self projectSpec copy.	"don't add defaults"  spec := self projectSpec.  MetacelloProjectRegistration    registrationForProjectSpec: spec    ifAbsent: [ :new | new registerProject ]    ifPresent: [ :existing :new | existing copyOnWrite: [ :existingCopy | existingCopy merge: new ] ].  self root: spec! !!MetacelloScriptEngine methodsFor: 'actions api' stamp: 'dkh 11/18/2013 06:59'!unregister  | spec |  self setDefaultsAndValidate: self projectSpec copy.	"don't add defaults"  spec := self projectSpec.  MetacelloProjectRegistration    registrationForProjectSpec: spec    ifAbsent: [ :ignored |  ]    ifPresent: [ :existing :new | existing unregisterProject ].  self root: spec! !!MetacelloScriptApiExecutor methodsFor: 'execution callback' stamp: 'dkh 09/04/2014 16:41' prior: 34915218!executeString: aString do: projectSpecBlock  singleRoot ifNil: [ self singleRoot: true ].  (projectSpecGenerator projectSpecCreationBlock value: aString)    do: [ :projectSpec |       projectSpec        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ]! !!MetacelloAbstractPackageSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34805268!configMethodBodyOn: aStream hasName: hasName cascading: cascading indent: indent	| hasCascading hasRequires hasIncludes hasAnswers |	hasCascading := cascading.	hasRequires := self requires isEmpty not.	hasIncludes := self includes isEmpty not.	hasAnswers := self answers isEmpty not.	hasRequires		ifTrue: [ 			hasName | hasIncludes | hasAnswers | hasCascading				ifTrue: [ aStream cr; tab: indent ].			aStream nextPutAll: 'requires: #('.			self requires do: [:str | aStream nextPutAll: str printString, ' ' ].			hasIncludes | hasAnswers | hasCascading				ifTrue: [ aStream nextPutAll: ');' ]				ifFalse: [ aStream nextPut: $) ]].	hasIncludes		ifTrue: [ 			hasName | hasRequires | hasAnswers | hasCascading				ifTrue: [ aStream cr; tab: indent ].			aStream nextPutAll: 'includes: #('.			self includes do: [:str | aStream nextPutAll: str printString, ' ' ].			hasAnswers | hasCascading				ifTrue: [ aStream nextPutAll: ');' ]				ifFalse: [ aStream nextPut: $) ]].	hasAnswers		ifTrue: [ 			hasName | hasRequires | hasIncludes | hasCascading				ifTrue: [ aStream cr; tab: indent ].			aStream nextPutAll: 'supplyingAnswers: #( '.			self answers do: [:ar | 				aStream nextPutAll: '#( '.				ar do: [:val | 					(val isString or: [ val isNumber or: [ val isSymbol or: [ val isCharacter ]]])						ifTrue: [  aStream nextPutAll: val printString, ' ' ].					val == true						ifTrue: [  aStream nextPutAll: 'true ' ].					val == false						ifTrue: [  aStream nextPutAll: 'false ' ]].				aStream nextPutAll: ') ' ].			hasCascading				ifTrue: [ aStream nextPutAll: ');' ]				ifFalse: [ aStream nextPut: $) ]].! !!MetacelloAbstractPackageSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34807012!configMethodCascadeOn: aStream member: aMember last: lastCascade indent: indent	self subclassResponsibility! !!MetacelloAbstractPackageSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34807227!configMethodOn: aStream for: aValue selector: selector cascading: cascading cascade: cascade indent: indent	| valuePrintString |	aValue == nil ifTrue: [ ^self ].	cascading ifTrue: [ aStream cr; tab: indent ].	valuePrintString := aValue value isSymbol		ifTrue: [ '#' , aValue value asString printString ]		ifFalse: [ aValue value printString ].	aStream  nextPutAll: selector, valuePrintString.	cascade ifTrue: [ aStream nextPut: $; ]! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: 'dkh 10/03/2014 18:45'!includeSpecNamesForPackageOrdering: aVersionSpec  ^ self specs: self includesForPackageOrdering forPackageOrdering: aVersionSpec! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: 'dkh 10/03/2014 18:32' prior: 34808232!includesForPackageOrdering  ^ #()! !!MetacelloAbstractPackageSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24' prior: 34809022!mergeSpec: anotherSpec	| newSpec map anotherRequires anotherIncludes anotherAnswers |	newSpec := super mergeSpec: anotherSpec.	map := anotherSpec mergeMap.	anotherSpec name ~~ nil 		ifTrue: [ newSpec name: anotherSpec name ].	(anotherRequires := map at: #requires) ~~ nil		ifTrue: [ newSpec setRequires: self requires, anotherRequires ].	(anotherIncludes := map at: #includes) ~~ nil		ifTrue: [ newSpec setIncludes: self includes, anotherIncludes ].	(anotherAnswers := map at: #answers) ~~ nil		ifTrue: [ newSpec setAnswers: self answers, anotherAnswers ].	^newSpec! !!MetacelloAbstractPackageSpec methodsFor: 'copying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34810311!postCopy	super postCopy.	requires := requires copy.	includes := includes copy.	answers := answers copy.! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: 'dkh 10/03/2014 11:57'!requiredSpecNamesForPackageOrdering: aVersionSpec  ^ (self requiredSpecsForPackageOrdering: aVersionSpec)    collect: [ :spec | spec name ]! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: 'dkh 10/03/2014 18:44'!requiredSpecsForPackageOrdering: aVersionSpec  ^ self specs: self requires forPackageOrdering: aVersionSpec! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: 'dkh 10/03/2014 14:39'!requiresSpecsForPackageOrdering: aVersionSpec  ^ {self}! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: 'dkh 10/03/2014 18:42'!resolveSpecsForPackageOrdering: aVersionSpec  ^ {self}! !!MetacelloAbstractPackageSpec methodsFor: 'private' stamp: 'dkh 10/17/2014 16:52'!specs: specNames forPackageOrdering: aVersionSpec  | packageOrProjectSpecs |  packageOrProjectSpecs := Set new.  specNames    do: [ :specName |       | spec |      "get project/group/package specs"      spec := aVersionSpec        packageNamed: specName        ifAbsent: [           MetacelloNameNotDefinedError            signal:              'project group, or package named: ' , specName printString                ,                  ' not found when used in requires: or includes: field of package: '                , self name printString , ' for version: '                , aVersionSpec versionString , ' of '                , aVersionSpec projectLabel , '.'.          nil	"return nil if resumed" ].      spec        ifNotNil: [           packageOrProjectSpecs            addAll: (spec resolveSpecsForPackageOrdering: aVersionSpec) ] ].  ^ packageOrProjectSpecs! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 6/6/2009 11:45' prior: 34184360!addToMetacelloPackages: aMetacelloPackagesSpec	self do: [:each | each addToMetacelloPackages: aMetacelloPackagesSpec ]! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 6/6/2009 11:46' prior: 34184818!mergeIntoMetacelloPackages: aMetacelloPackagesSpec	self do: [:each | each mergeIntoMetacelloPackages: aMetacelloPackagesSpec ]! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 6/6/2009 11:42' prior: 34185022!removeFromMetacelloPackages: aMetacelloPackagesSpec	self do: [:each | each removeFromMetacelloPackages: aMetacelloPackagesSpec ]! !!Collection methodsFor: '*metacello-core' stamp: 'dkh 11/17/2013 17:19'!setImportInVersionSpec: aMetacelloVersionSpec  aMetacelloVersionSpec setImport: self asArray! !!MetacelloRemoveMemberSpec methodsFor: 'actions' stamp: 'dkh 6/5/2012 19:01:24' prior: 34812869!applyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock	removeBlock value: self! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 9/11/2012 10:16' prior: 34815338!groups	"Answers the list of groups associated with this version"		| groups |	groups := OrderedCollection new.	self spec projectDo: [:ignored | ] packageDo: [:ignored | ] groupDo: [:grp | groups add: grp ].	^groups! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 9/11/2012 10:35' prior: 34817548!packageNamed: aString	^self packageNamed: aString ifAbsent: [ ^nil ].! !!MetacelloVersion methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34817948!printOn: aStream    | label vs |    (#(structural broken) includes: self blessing) not        ifTrue: [             (vs := self versionStatus) == #'somethingLoaded'                ifTrue: [ aStream nextPutAll: '<>' ].            vs == #'loadedMatchConstraints'                ifTrue: [ aStream nextPutAll: '>=' ].            vs == #'loadedToSpec'                ifTrue: [ aStream nextPut: $~ ] ].    self versionNumber printOn: aStream.    self basicSpec ~~ nil        ifTrue: [             (label := self projectLabel) isEmpty                ifFalse: [ aStream nextPutAll: ' [' , label , ']' ] ]! !!MetacelloVersion methodsFor: 'querying' stamp: 'dkh 9/11/2012 10:16' prior: 34818878!projects	"Answers the list of projects associated with this version"	| projects |	projects := OrderedCollection new.	self spec projectDo: [:prj | projects add: prj projectReference ] packageDo: [:ignored | ] groupDo: [:ignored | ].	^projects! !!MetacelloScriptExecutor methodsFor: 'execution' stamp: 'dkh 09/04/2014 16:36' prior: 34917761!execute: statements  statements    do: [ :assoc |       assoc value        ifNil: [ self perform: assoc key ]        ifNotNil: [ self perform: assoc key withArguments: assoc value ] ].  projectSpecGenerator := self projectSpecGenerator.  projectSpecGenerator target    execute: [ :projectSpec |       | engine |      engine := MetacelloScriptEngine new        options: self options copy;        projectSpec: projectSpec;        yourself.      engine perform: actionArg key withArguments: actionArg value.      engine root ifNotNil: [ :root | self roots add: root ] ]    against: self.  ^ (self singleRoot and: [ self roots size == 1 ])    ifTrue: [ self roots first ]    ifFalse: [ self roots ]! !!MetacelloScriptExecutor methodsFor: 'execution callback' stamp: 'dkh 09/04/2014 16:41' prior: 34919389!executeString: aString do: projectSpecBlock  singleRoot ifNil: [ self singleRoot: true ].  ((projectSpecGenerator projectSpecLookupBlock value: aString)    select: self projectSpecSelectBlock)    do: [ :projectSpec | projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ]! !!MetacelloScriptExecutor methodsFor: 'actions api' stamp: 'dkh 09/04/2014 16:41' prior: 34920160!list  actionArg := #'list' -> #().  self singleRoot: false! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: 'dkh 07/24/2013 17:10'!onLock: aBlock  self options at: #'onLock' put: aBlock! !!MetacelloScriptExecutor methodsFor: 'options api' stamp: 'dkh 07/24/2013 18:37'!onWarning: aBlock  self options at: #'onWarning' put: aBlock! !!MetacelloScriptExecutor methodsFor: 'actions api' stamp: 'dkh 05/16/2014 13:51'!register  actionArg := #'register' -> #()! !!MetacelloScriptExecutor methodsFor: 'accessing' stamp: 'dkh 09/04/2014 16:34' prior: 34923662!singleRoot  singleRoot ifNil: [ singleRoot := false ].  ^ singleRoot! !!MetacelloScriptExecutor methodsFor: 'accessing' stamp: 'dkh 09/04/2014 16:33' prior: 34923819!singleRoot: aBool  singleRoot := aBool! !!MetacelloScriptExecutor methodsFor: 'actions api' stamp: 'dkh 11/18/2013 06:56'!unregister  actionArg := #'unregister' -> #()! !!MetacelloMemberListSpec methodsFor: 'adding' stamp: 'dkh 6/5/2012 19:01:24' prior: 34135489!addMember: aMember	self list add: aMember.	self clearMemberMap! !!MetacelloVersionNumber methodsFor: 'private' stamp: 'dkh 6/5/2012 19:01:24' prior: 34831065!compareLessThan: aMetacelloVersionNumber	| mySize aSize commonSize count more |	mySize := self size.	aSize := aMetacelloVersionNumber size.	commonSize :=  mySize min: aSize.	count := 0.	more := true.	[ more and: [ count < commonSize ]] whileTrue: [		(self at: count + 1) = (aMetacelloVersionNumber at: count + 1)			ifTrue: [ count := count + 1 ]			ifFalse: [ more := false ]].	count < commonSize		ifTrue: [ 			^(self at: count + 1) 				metacelloVersionComponentLessThan: (aMetacelloVersionNumber at: count + 1) ].	mySize < aSize		ifTrue: [ 			mySize = 0 ifTrue: [ ^true ].			"if the versions at commonSize are equal and the next version slot in aMetacelloVersionNumber 			 is a string, then it's considered that I'm > aMetacelloVersionNumber			 (i.e., '2.9.9' is greater than '2.9.9-alpha.2')"			(self at: commonSize) = (aMetacelloVersionNumber at: commonSize)				ifFalse: [ ^true ]. 			^(aMetacelloVersionNumber at: commonSize+1) isString not]		ifFalse: [ 			mySize = aSize ifTrue: [ ^false ].			aSize <= 0 ifTrue: [ ^false ].			"if the versions at commonSize are equal and the next version slot is a string, 			 then it's considered that I'm < aMetacelloVersionNumber			 (i.e., '2.9.9-alpha.2' is less than '2.9.9')"			(self at: commonSize) = (aMetacelloVersionNumber at: commonSize)				ifFalse: [ ^false ].			 ^(self at: commonSize+1) isString]! !!MetacelloVersionNumber methodsFor: 'operations' stamp: 'dkh 05/20/2014 09:43'!decrementMajorVersion  self decrementVersionAt: 1! !!MetacelloVersionNumber methodsFor: 'operations' stamp: 'dkh 05/20/2014 09:45'!decrementMinorVersion  self size < 2    ifTrue: [ self at: 2 put: 0 ].  self decrementVersionAt: 2! !!MetacelloVersionNumber methodsFor: 'operations' stamp: 'dkh 05/20/2014 09:46'!decrementPatchVersion  self size < 2    ifTrue: [ self at: 2 put: 0 ].  self size < 3    ifTrue: [ self at: 3 put: 0 ].  self decrementVersionAt: 3! !!MetacelloVersionNumber methodsFor: 'private' stamp: 'dkh 05/20/2014 09:42'!decrementVersionAt: index  | int |  int := self at: index.  (int := self at: index) isString    ifFalse: [       int > 0        ifTrue: [ self at: index put: int - 1 ] ]! !!MetacelloVersionNumber methodsFor: 'comparing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34833906!hash"Returns a numeric hash key for the receiver."| mySize interval hashValue |(mySize := self size) == 0  ifTrue: [ ^15243 ]."Choose an interval so that we sample at most 5 elements of the receiver"interval := ((mySize - 1) // 4) max: 1.hashValue := 4459.1 to: mySize by: interval do: [ :i | | anElement |  anElement := self at: i.  (anElement isKindOf: SequenceableCollection)    ifTrue: [      hashValue := (hashValue bitShift: -1) bitXor: anElement size.      ]    ifFalse: [      hashValue := (hashValue bitShift: -1) bitXor: anElement hash.      ].  ].^ hashValue abs! !!MetacelloVersionNumber methodsFor: 'operations' stamp: 'dkh 05/20/2014 09:44'!incrementMajorVersion  self incrementVersionAt: 1! !!MetacelloVersionNumber methodsFor: 'operations' stamp: 'dkh 05/20/2014 09:46'!incrementMinorVersion  self size < 2    ifTrue: [ self at: 2 put: 0 ].  self incrementVersionAt: 2! !!MetacelloVersionNumber methodsFor: 'operations' stamp: 'dkh 05/20/2014 09:47'!incrementPatchVersion  self size < 2    ifTrue: [ self at: 2 put: 0 ].  self size < 3    ifTrue: [ self at: 3 put: 0 ].  self incrementVersionAt: 3! !!MetacelloVersionNumber methodsFor: 'private' stamp: 'dkh 05/20/2014 09:46'!incrementVersionAt: index  | int |  int := self at: index.  (int := self at: index) isString    ifFalse: [ self at: index put: int + 1 ]! !!MetacelloVersionNumber methodsFor: 'comparing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34834879!match: aVersionPattern	"Answer whether the version number of the receiver matches the given pattern string.	 A Metacello version number is made up of version sequences delimited by the characters $. and $-.	 The $. introduces a numeric version sequence and $- introduces an alphanumeric version sequence.	 	 A version pattern is made up of version pattern match sequences. also delimited by the characters $. 	 and $-.. Each pattern match sequence is tested against the corresponding version sequence of the 	 receiver, using the 'standard' pattern matching rules. All sequences must answer true for a match.		 The special pattern sequence '?' is a match for the corresponding version sequence and all subsequent 	 version sequences. '?' as the version pattern matches all versions. No more version pattern 	 sequences are permitted once the '?' sequence is used. If used, it is the last version pattern	 sequence. "		| patternVersion mySize patternSize |	patternVersion := aVersionPattern asMetacelloVersionNumber.	mySize := self size.	patternSize := patternVersion size.	mySize = patternSize 		ifFalse: [ 			mySize < patternSize ifTrue: [ ^false ].			(patternVersion at: patternSize) ~= '?' ifTrue: [ ^false ].			mySize := patternSize ].	1 to: mySize do: [:i | | pattern |		pattern := (patternVersion at: i) asString.		pattern = '?'			ifTrue: [i = mySize ifFalse: [ ^self error: 'Invalid version match pattern: ', aVersionPattern printString ]]			ifFalse: [ (pattern match: (self at: i) asString)  ifFalse: [ ^false ]]].	^true"  '1.1.1' asMetacelloVersionNumber match: '*.*.*'. -> true  '1.1.1' asMetacelloVersionNumber match: '*.#.*'. -> true  '1.10.1' asMetacelloVersionNumber match: '*.#.*'. -> false  '1.1.1' asMetacelloVersionNumber match: '*.*'. -> false  '1.1.1' asMetacelloVersionNumber match: '*.?'. -> true  '1.0' asMetacelloVersionNumber match: '1.?'. -> true  '2.0' asMetacelloVersionNumber match: '1.?'. -> false  '1.1.1' asMetacelloVersionNumber match: '?'. -> true  '1' asMetacelloVersionNumber match: '*.?'. -> false  '1-alpha5.0' asMetacelloVersionNumber match: '1-alpha*.?'. -> true  '1-alpha15.0.1' asMetacelloVersionNumber match: '1-alpha*.?'. -> true  '1.1' asMetacelloVersionNumber match: '?.?'. -> ERROR: invalid version match pattern"! !!MetacelloVersionNumber methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34837282!printOn: aStream	| beforeFirst | 	beforeFirst := true.	self do:		[:each |		beforeFirst			ifTrue: [beforeFirst := false]			ifFalse: [				each isString					ifTrue: [ aStream nextPut: $- ]					ifFalse: [ aStream nextPut: $. ] ].		aStream nextPutAll: each asString ]! !!MetacelloSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24' prior: 34925552!aboutToCopy! !!MetacelloSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34925906!configMethodOn: aStream	self configMethodOn: aStream indent: 0! !!MetacelloSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34926062!configMethodOn: aStream indent: indent	self subclassResponsibility! !!MetacelloSpec methodsFor: 'doits' stamp: 'dkh 6/5/2012 19:01:24' prior: 34926625!doItBlock: selector	selector == nil ifTrue: [ ^nil ].	selector numArgs = 0		ifTrue: [ ^[ self project configuration perform: selector ] ].	selector numArgs = 1		ifTrue: [ ^[:aLoader | self project configuration perform: selector with: aLoader ] ].	selector numArgs = 2		ifTrue: [ ^[:aLoader :pkgSpec | self project configuration perform: selector with: aLoader with: pkgSpec ] ].	^nil! !!MetacelloSpec methodsFor: 'merging' stamp: 'dkh 6/5/2012 19:01:24' prior: 34928349!mergeMap	^Dictionary new.! !!MetacelloSpec methodsFor: 'copying' stamp: 'dkh 7/19/2012 21:12' prior: 34929336!postCopy    super postCopy.    mutable := nil.    loader ~~ nil        ifTrue: [ self loader: loader ].! !!MetacelloSpec methodsFor: 'doits' stamp: 'dkh 6/5/2012 19:01:24' prior: 34929675!postLoadDoItBlock	^self doItBlock: self postLoadDoIt value! !!MetacelloSpec methodsFor: 'doits' stamp: 'dkh 6/5/2012 19:01:24' prior: 34929967!preLoadDoItBlock	^self doItBlock: self preLoadDoIt value! !!MetacelloSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34930116!printOn: aStream	self configMethodOn: aStream indent: 0! !!MetacelloVersionSpec methodsFor: 'printing' stamp: 'dkh 9/10/2012 15:58' prior: 34936420!configPackagesSpecMethodOn: aStream indent: indent	| projectSpecs packageSpecs groupSpecs |	projectSpecs := OrderedCollection new.	packageSpecs := OrderedCollection new.	groupSpecs := OrderedCollection new.	self packagesSpec list do: [:member |		member spec 			projectDo: [:proj | member spec name ~~ nil ifTrue: [ projectSpecs add: member ]]			packageDo: [:package | member spec name ~~ nil ifTrue: [ packageSpecs add: member ]]			groupDo: [:group | member spec name ~~ nil ifTrue: [ groupSpecs add: member ]]].	projectSpecs isEmpty not		ifTrue: [			aStream tab: indent; nextPutAll: 'spec '.			projectSpecs size > 1 ifTrue: [ aStream cr; tab: indent + 1 ].			1 to: projectSpecs size  do: [:index | 				(projectSpecs at: index) configMethodCascadeOn: aStream last: index == projectSpecs size indent: indent + 1.				index ~= projectSpecs size ifTrue: [ aStream tab: indent + 1 ]]].	packageSpecs isEmpty not		ifTrue: [			projectSpecs isEmpty not ifTrue: [ aStream cr ].			aStream tab: indent; nextPutAll: 'spec '.			packageSpecs size > 1 ifTrue: [ aStream cr; tab: indent + 1 ].			1 to: packageSpecs size  do: [:index | 				(packageSpecs at: index) configMethodCascadeOn: aStream last: index == packageSpecs size indent: indent + 1.				index ~= packageSpecs size ifTrue: [ aStream tab: indent + 1 ]]].	groupSpecs isEmpty not		ifTrue: [			projectSpecs isEmpty not | packageSpecs isEmpty not ifTrue: [ aStream cr ].			aStream tab: indent; nextPutAll: 'spec '.			groupSpecs size > 1 ifTrue: [ aStream cr; tab: indent + 1 ].			1 to: groupSpecs size  do: [:index | 				(groupSpecs at: index) configMethodCascadeOn: aStream last: index == groupSpecs size indent: indent + 1.				index ~= groupSpecs size ifTrue: [ aStream tab: indent + 1 ]]].! !!MetacelloVersionSpec methodsFor: 'printing' stamp: 'dkh 6/5/2012 19:01:24' prior: 34938284!configSpawnMethodOn: aStream indent: indent	self configMethodValueOn: aStream for: self getBlessing selector: 'blessing:' last: false indent: indent.	self configMethodValueOn: aStream for: self getAuthor selector: 'author:' last: false indent: indent.	self configMethodValueOn: aStream for: self getTimestamp selector: 'timestamp:' last: false indent: indent.! !!MetacelloVersionSpec methodsFor: 'loading' stamp: 'dkh 9/11/2012 12:09' prior: 34942032!expandToLoadableSpecNames: nameList	| cacheKey names |	cacheKey := Array with: self label with: nameList.	^MetacelloPlatform current		stackCacheFor: #loadableSpecNames		at: cacheKey		doing: [ :cache | 			names := (self resolveToLoadableSpecs: nameList) collect: [:spec | spec name ].			cache at: cacheKey put: names ].! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 11/17/2013 17:45' prior: 34943753!import: aString  importName := aString! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 11/17/2013 17:56'!import: aString provides: anArray  importArray := importArray    ifNil: [ {(aString -> anArray)} ]    ifNotNil: [ importArray , {(aString -> anArray)} ]! !!MetacelloVersionSpec methodsFor: 'construction' stamp: 'dkh 11/17/2013 17:47'!import: aString provides: anArray constructor: aVersionConstructor  aVersionConstructor importForVersion: aString provides: anArray! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 11/17/2013 17:21'!importArray  ^ importArray! !!MetacelloVersionSpec methodsFor: 'querying' stamp: 'dkh 09/30/2014 16:36' prior: 34945859!packageNamed: aString forLoad: ignored forMap: map ifAbsent: absentBlock  "at the end of the day, I don't the forLoad arg is important ...    it just ends up triggering an error ... when during a real load, you would    not get error. After a decent period of mourning we should just scrub this    arg from system"  | importSpec |  ^ map    at: aString    ifAbsent: [       (self importArray notNil or: [ self import notNil ])        ifTrue: [           "expect the 'missing' name to be satisfied within context of imported project"          importArray            ifNotNil: [               importArray                do: [ :assoc |                   ((assoc value includes: aString) and: [ map includesKey: assoc key ])                    ifTrue: [                       importSpec := (map at: assoc key)                        mergeImportLoads: {aString};                        yourself ] ].              importSpec ifNotNil: [ ^ importSpec ] ].          (importSpec isNil and: [ self import notNil ])            ifTrue: [               ^ (map at: self import ifAbsent: absentBlock)                mergeImportLoads: {aString};                yourself ] ].      (aString = 'default' or: [ aString = 'ALL' ])        ifTrue: [           self project groupSpec            name: aString;            includes: self packageNames;            yourself ]        ifFalse: [ absentBlock value ] ]! !!MetacelloVersionSpec methodsFor: 'querying' stamp: 'dkh 10/01/2014 16:55' prior: 34947631!packageSpecsInLoadOrder  ^ self packages packageSpecsInLoadOrderFor: self! !!MetacelloVersionSpec methodsFor: 'loading' stamp: 'dkh 06/12/2014 08:03' prior: 34952182!resolveToLoadableSpecs: nameList  "Resolves names in namelist to the  list of packages and projects in the version that would be loaded. Projects are 	not traversed during the transitive closure. The scope is that of the version itself.	   If the spec is a package, answer a list including the package and the transitive closure on 			its #requires: and #includes: fields.	   If the spec is a project, answer the project.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"  | map |  map := Dictionary new.  self resolveToLoadableSpecs: nameList forLoad: false map: map.  ^ map values! !!MetacelloVersionSpec methodsFor: 'loading' stamp: 'dkh 06/20/2014 21:11' prior: 34952999!resolveToLoadableSpecs: required forLoad: forLoad map: packageMap  | reqd allReqd map newReqd spec |  reqd := required copy.  allReqd := Set new.  map := self packages map.  [ reqd isEmpty ]    whileFalse: [       newReqd := Set new.      reqd        do: [ :req |           (self            resolveToLoadableSpec: req            forLoad: forLoad            forMap: map            packages: packageMap)            do: [ :loadableSpec |               newReqd addAll: loadableSpec requires.              newReqd addAll: loadableSpec includes ] ].      allReqd addAll: reqd.      newReqd removeAllFoundIn: allReqd.      reqd := newReqd ].  packageMap keys    do: [ :pkgName |       (spec := (packageMap at: pkgName) resolveToLoadableSpec) == nil        ifTrue: [ packageMap removeKey: pkgName ]        ifFalse: [ packageMap at: pkgName put: (packageMap at: pkgName) resolveToLoadableSpec ] ]! !!MetacelloVersionSpec methodsFor: 'accessing' stamp: 'dkh 11/17/2013 17:28'!setImport: anArray  importArray := importArray    ifNil: [ anArray ]    ifNotNil: [ importArray , anArray ]! !!MetacelloProjectReferenceSpec methodsFor: 'copying' stamp: 'dkh 6/5/2012 19:01:24' prior: 34841269!postCopy	super postCopy.	projectReference := projectReference copy.! !!String methodsFor: '*metacello-core' stamp: 'dkh 6/5/2012 19:01:24' prior: 34844318!mergeIntoMetacelloPackages: aMetacelloPackagesSpec	| spec |	spec := 		(aMetacelloPackagesSpec project packageSpec)			file: self;			yourself.	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec mergeMember 			name: spec name;			spec: spec;			yourself)! !!String methodsFor: '*metacello-core' stamp: 'dkh 11/17/2013 17:19'!setImportInVersionSpec: aMetacelloVersionSpec  aMetacelloVersionSpec setImport: {self}! !!MetacelloSemanticVersionNumber methodsFor: 'operations' stamp: 'dkh 05/20/2014 09:40'!decrementMajorVersion  self decrementNormalVersionAt: 1! !!MetacelloSemanticVersionNumber methodsFor: 'operations' stamp: 'dkh 05/20/2014 09:40'!decrementMinorVersion  self decrementNormalVersionAt: 2! !!MetacelloSemanticVersionNumber methodsFor: 'operations' stamp: 'dkh 05/20/2014 10:03' prior: 34682077!decrementMinorVersionNumber  self decrementNormalVersionAt: 3! !!MetacelloSemanticVersionNumber methodsFor: 'private' stamp: 'dkh 05/17/2014 08:04'!decrementNormalVersionAt: index  | int col |  col := self normalVersion.  int := col at: index.  int > 0    ifTrue: [ col at: index put: int - 1 ]! !!MetacelloSemanticVersionNumber methodsFor: 'operations' stamp: 'dkh 05/20/2014 10:02'!decrementPatchVersion  self decrementNormalVersionAt: 3! !!MetacelloSemanticVersionNumber methodsFor: 'operations' stamp: 'dkh 05/20/2014 09:40'!incrementMajorVersion  self incrementNormalVersionAt: 1! !!MetacelloSemanticVersionNumber methodsFor: 'operations' stamp: 'dkh 05/20/2014 09:40'!incrementMinorVersion  self incrementNormalVersionAt: 2! !!MetacelloSemanticVersionNumber methodsFor: 'operations' stamp: 'dkh 05/20/2014 10:02' prior: 34683121!incrementMinorVersionNumber  self incrementNormalVersionAt: 3! !!MetacelloSemanticVersionNumber methodsFor: 'private' stamp: 'dkh 05/17/2014 08:04'!incrementNormalVersionAt: index  | int col |  col := self normalVersion.  int := col at: index.  col at: index put: int + 1! !!MetacelloSemanticVersionNumber methodsFor: 'operations' stamp: 'dkh 05/20/2014 09:40'!incrementPatchVersion  self incrementNormalVersionAt: 3! !!MetacelloSemanticVersionNumber methodsFor: 'copying' stamp: 'dkh 05/16/2014 16:46'!postCopy  normalVersion := normalVersion copy.  preReleaseVersion := preReleaseVersion copy.  buildVersion := buildVersion copy! !!MetacelloProjectRegistration class methodsFor: 'accessing' stamp: 'dkh 05/14/2014 07:07'!classRemoved: aClassRemovalAnnouncement  "aRemovalAnnouncement is platform-specific ... responds to #itemClass to    answer the class that was removed."  | aClass registration |  aClass := aClassRemovalAnnouncement itemClass.  registration := self registry    registrationForExactClassNamed: aClass name asString    ifAbsent: [ ^ self ].  registration unregisterProject! !!MetacelloProjectRegistration class methodsFor: 'mutability' stamp: 'dkh 10/06/2013 09:35' prior: 34866963!copyRegistryRestoreOnErrorWhile: aBlock  "install copy of registry for duration of <aBlock> execution."  "registrations will be copied on write during <aBlock> execution."  "if <aBlock> does not return control to this context, revert to the original	version of the registry. Otherwise leave the new copy installed."  | oldRegistry newRegistry |  oldRegistry := self registry.  newRegistry := self registry copy.  self registry: newRegistry.  aBlock    ensure: [       "install old version of registry"      newRegistry := self registry.	"see https://github.com/dalehenrich/metacello-work/issues/210"      self registry: oldRegistry ].  self registry: newRegistry	"if control returned, install newRegistry"! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'otto 11/18/2013 12:59' prior: 34871518!baseName	^ self projectSpec baseName! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 07/26/2013 15:55' prior: 34871724!baselineProjectSpec  "only one of baselineProjectSpec or configurationProjectSpec should ever be set"  ^ baselineProjectSpec! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 07/06/2014 11:41' prior: 34871854!baselineProjectSpec: anObject  "force the registration to be consistent -- difficult for Metacello to    repair registrations during load -- I've tried. "  "https://github.com/dalehenrich/metacello-work/issues/212"  self shouldBeMutable.  configurationProjectSpec := nil.  self assert: anObject isBaselineOfProjectSpec.  baselineProjectSpec := anObject! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 05/07/2014 14:54' prior: 34872035!baselineProjectSpecIfAbsent: absentBlock  ^ baselineProjectSpec ifNil: absentBlock! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 07/24/2012 17:49' prior: 34872209!baselineProjectSpecIfPresent: presentBlock ifAbsent: absentBlock     ^ baselineProjectSpec ifNotNil: [ presentBlock cull: baselineProjectSpec ]  ifNil: absentBlock! !!MetacelloProjectRegistration methodsFor: 'testing' stamp: 'dkh 07/05/2014 18:23' prior: 34873132!canUpgradeTo: aProjectRegistration  "true if there are no load conflicts        OR       if the load conflicts involved two cofigurations ONLY and an upgrade is allowed"  (self hasLoadConflicts: aProjectRegistration)    ifFalse: [ ^ true ].  configurationProjectSpec    ifNotNil: [       aProjectRegistration configurationProjectSpec        ifNotNil: [           configurationProjectSpec copy ensureProjectLoaded.          ^ configurationProjectSpec            canUpgradeTo: aProjectRegistration configurationProjectSpec ] ].  baselineProjectSpec    ifNotNil: [       aProjectRegistration baselineProjectSpec        ifNotNil: [           baselineProjectSpec copy ensureProjectLoaded.          ^ baselineProjectSpec            canUpgradeTo: aProjectRegistration baselineProjectSpec ] ].  ^ false! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 07/26/2013 16:01' prior: 34873808!configurationProjectSpec  "only one of baselineProjectSpec or configurationProjectSpec should ever be set"  ^ configurationProjectSpec! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 07/06/2014 11:41' prior: 34873948!configurationProjectSpec: anObject  "force the registration to be consistent -- difficult for Metacello to    repair registrations during load -- I've tried. "  "https://github.com/dalehenrich/metacello-work/issues/212"  self shouldBeMutable.  baselineProjectSpec := nil.  self assert: anObject isConfigurationOfProjectSpec.  configurationProjectSpec := anObject! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 08/10/2014 22:21'!currentBranchName  ^ self configurationProjectSpec    ifNotNil: [       configurationProjectSpec versionOrNil        ifNil: [ '' ]        ifNotNil: [ :vrsn | vrsn blessing asString ] ]    ifNil: [ baselineProjectSpec repositoryBranchName ]! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 05/08/2014 18:25'!currentVersionString  ^ self configurationProjectSpec    ifNotNilDo: [ :aSpec | aSpec versionString ]    ifNil: [ baselineProjectSpec repositoryVersionString ]! !!MetacelloProjectRegistration methodsFor: 'querying' stamp: 'otto 11/18/2013 12:57' prior: 34875078!currentlyLoadedClassesInProject	^ self projectSpec currentlyLoadedClassesInVersion asSet! !!MetacelloProjectRegistration methodsFor: 'testing' stamp: 'otto 11/18/2013 11:31' prior: 34875511!hasLoadConflicts: aProjectRegistration	"5 combinations of loads with no load conflicts:        No configs and baselines =        configs = and no baselines        configs = and baselines =        configs = and no baseline loaded (self) with a baseline to load (aProjectRegistration)        config loaded (self), no config to load (aProjectRegistration) and no baseline loaded(self) with a baseline to load (aProjectRegistration) "	aProjectRegistration validate.	self isValid		ifFalse: [ ^ false ].	^ self projectSpec hasConflictWithProjectSpec: aProjectRegistration projectSpec! !!MetacelloProjectRegistration methodsFor: 'testing' stamp: 'dkh 05/10/2014 09:38' prior: 34877422!isValid  " has a name and one or the other of the projectSpecs is non-nil, but not both ... this is CRITICAL"  projectName ifNil: [ ^ false ].  configurationProjectSpec isNil    ifTrue: [ ^ baselineProjectSpec notNil ].  ^ baselineProjectSpec isNil! !!MetacelloProjectRegistration methodsFor: 'lookup' stamp: 'dkh 05/07/2014 14:51' prior: 34878334!lookupBaselineSpec  baselineProjectSpec ifNotNil: [ :spec | ^ spec ].  ^ configurationProjectSpec! !!MetacelloProjectRegistration methodsFor: 'lookup' stamp: 'dkh 05/07/2014 14:52' prior: 34878522!lookupConfigurationSpec  configurationProjectSpec ifNotNil: [ :spec | ^ spec ].  ^ baselineProjectSpec! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 09/04/2014 09:53' prior: 34879095!merge: aProjectRegistration  " ... merge is done when a spec has been loaded into the image"  self shouldBeMutable.  aProjectRegistration validate.  aProjectRegistration configurationProjectSpec    ifNotNilDo: [ :aSpec |       configurationProjectSpec := aSpec copy.      configurationProjectSpec versionOrNil        ifNotNil: [ :version |           "resolve symbolic versions for loaded projects"          configurationProjectSpec versionString: version versionString ].      baselineProjectSpec := nil.      self versionInfo versionString: configurationProjectSpec versionString ]    ifNil: [       baselineProjectSpec := aProjectRegistration baselineProjectSpec.      configurationProjectSpec := nil.      self versionInfo        versionString: baselineProjectSpec repositoryVersionString ]! !!MetacelloProjectRegistration methodsFor: 'printing' stamp: 'dkh 06/10/2014 21:52' prior: 34880416!printOn: aStream  | label versionString descriptions |  self    configurationProjectSpecIfPresent: [ :spec |       label := spec className.      versionString := spec versionString ]    ifAbsent: [       "baseline"      label := self baselineProjectSpec className.      versionString := '[baseline]' ].  aStream nextPutAll: label.  versionString    ifNil: [ aStream nextPutAll: ' --no version specified--' ]    ifNotNil: [       aStream        space;        nextPutAll: versionString ].  (descriptions := self repositoryDescriptions) isEmpty    ifTrue: [ ^ self ].  aStream nextPutAll: ' from '.  descriptions size = 1    ifTrue: [ aStream nextPutAll: descriptions first ]    ifFalse: [       aStream nextPut: ${.      descriptions do: [ :description | aStream nextPutAll: description ].      aStream nextPut: $} ]! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'otto 11/18/2013 11:21'!projectSpec	^ baselineProjectSpec		ifNil: [ 			self assert: configurationProjectSpec notNil.			configurationProjectSpec ]! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 08/10/2014 22:22'!projectVersion  | pv |  pv := self versionInfo projectVersion.  pv    ifNil: [       pv := self projectSpec versionOrNil.      self versionInfo projectVersion: pv ].  ^ pv! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'otto 11/18/2013 11:25'!validate	self isValid		ifFalse: [ self error: 'Invalid project registration' ]! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 05/08/2014 11:32'!versionInfo  versionInfo    ifNil: [       versionInfo := MetacelloProjectRegistrationVersionInfo new        versionString: self version ].  ^ versionInfo! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 05/08/2014 11:31'!versionInfo: aMetacelloProjectRegistrationVersionInfo  versionInfo := aMetacelloProjectRegistrationVersionInfo! !!MetacelloProjectRegistrationVersionInfo methodsFor: 'accessing' stamp: 'dkh 08/11/2014 07:00'!projectVersion  ^ projectVersion! !!MetacelloProjectRegistrationVersionInfo methodsFor: 'accessing' stamp: 'dkh 08/11/2014 07:01'!projectVersion: anObject  projectVersion := anObject! !!MetacelloProjectRegistrationVersionInfo methodsFor: 'accessing' stamp: 'dkh 05/08/2014 11:31'!versionString   ^versionString! !!MetacelloProjectRegistrationVersionInfo methodsFor: 'accessing' stamp: 'dkh 08/20/2014 07:32'!versionString: anObject  versionString := anObject.  projectVersion := nil! !!MetacelloProjectRegistry methodsFor: 'initialization' stamp: 'dkh 07/27/2013 08:36'!primeRegisterLoadedProjectSpec: projectSpec  MetacelloProjectRegistration    registrationForProjectSpec: projectSpec    ifAbsent: [ :new |       new        loadedInImage: true;        registerProject ]    ifPresent: [ :existing :new |       existing        copyOnWrite: [ :existingCopy |           existingCopy loadedInImage: true.          existing locked            ifFalse: [               "lock takes precedence when priming from image"              existingCopy merge: new ] ] ]! !!MetacelloProjectRegistry methodsFor: 'initialization' stamp: 'dkh 07/29/2013 16:58'!primeRegistryCurrentVersionFor: cl  ^ [ cl project currentVersion ]    on: Error    do: [ :ex |       Warning        signal:          'Error finding current version of ' , cl name asString            , '. Probably an invalid specification.'.      nil ]! !!MetacelloProjectRegistry methodsFor: 'initialization' stamp: 'dkh 05/07/2014 17:28' prior: 34884323!primeRegistryFromImage  "MetacelloProjectRegistration primeRegistryFromImage"  self primeRegistryFromImage: false! !!MetacelloProjectRegistry methodsFor: 'initialization' stamp: 'dkh 05/07/2014 17:28'!primeRegistryFromImage: prioritizeConfiguration  "MetacelloProjectRegistration primeRegistryFromImage"  self    primeRegistryFromImage: MetacelloProjectRegistration configurationClasses    baselineClasses: MetacelloProjectRegistration baselineClasses    prioritizeConfiguration: prioritizeConfiguration! !!MetacelloProjectRegistry methodsFor: 'initialization' stamp: 'dkh 05/07/2014 17:28'!primeRegistryFromImage: configurationClasses baselineClasses: baselineClasses  "MetacelloProjectRegistration primeRegistryFromImage"  self    primeRegistryFromImage: configurationClasses    baselineClasses: baselineClasses    prioritizeConfiguration: false! !!MetacelloProjectRegistry methodsFor: 'initialization' stamp: 'dkh 05/07/2014 17:26'!primeRegistryFromImage: configurationClasses baselineClasses: baselineClasses prioritizeConfiguration: prioritizeConfiguration  "MetacelloProjectRegistration primeRegistryFromImage"  baselineClasses    do: [ :cl |       (self baselineRegistry includesKey: cl name asString)        ifFalse: [           "not registered"          (self primeRegistryCurrentVersionFor: cl)            ifNotNil: [ :version |               | projectSpec |              projectSpec := (version project projectSpec                name: (MetacelloScriptEngine baseNameOf: cl name asString);                repositories: version project projectPackage repositories copy;                yourself) asBaselineProjectSpec.              self primeRegisterLoadedProjectSpec: projectSpec ] ] ].  configurationClasses    do: [ :cl |       (self configurationRegistry includesKey: cl name asString)        ifFalse: [           "not registered"          (self primeRegistryCurrentVersionFor: cl)            ifNotNil: [ :version |               | projectSpec repos projectPackage project |              project := version project.              projectPackage := project projectPackage.              repos := nil.              projectPackage ~~ nil                ifTrue: [ repos := projectPackage repositories copy ].              projectSpec := (version project projectSpec                name: (MetacelloScriptEngine baseNameOf: cl name asString);                className: cl name asString;                versionString: version versionString;                repositories: repos;                yourself) asConfigurationProjectSpec.              (prioritizeConfiguration                or: [ (self primeRegistryProjectSpecRegistered: projectSpec) not ])                ifTrue: [                   "Configuration override existing registrations or nothing registered yet"                  self primeRegisterLoadedProjectSpec: projectSpec ] ] ] ]! !!MetacelloProjectRegistry methodsFor: 'initialization' stamp: 'dkh 05/07/2014 14:46'!primeRegistryProjectSpecRegistered: projectSpec  MetacelloProjectRegistration    registrationForProjectSpec: projectSpec    ifAbsent: [ :new | ^ false ]    ifPresent: [ :existing :new | ^ true ]! !!MetacelloProjectRegistry methodsFor: 'registration' stamp: 'dkh 09/04/2014 09:54' prior: 34886837!registerProjectRegistration: aMetacelloProjectRegistration  "unconditionally register <newRegistration> ... use with care"  aMetacelloProjectRegistration configurationProjectSpec copy    ifNotNil: [ :spec |       self configurationRegistry        at: spec className        ifPresent: [ :existing |           (existing configurationProjectSpec registrationsCompareEqual: spec)            ifFalse: [               Transcript                cr;                show:                    'REGISTRATION OF INCOMPATABLE PROJECTS: ' , existing printString                        , ' REPLACED BY '                        , aMetacelloProjectRegistration printString ] ].      spec versionOrNil        ifNotNil: [ :version |           "resolve symbolic versions for loaded projects"          spec versionString: version versionString ].      aMetacelloProjectRegistration configurationProjectSpec: spec.      (aMetacelloProjectRegistration respondsTo: #'versionInfo')        ifTrue: [ aMetacelloProjectRegistration versionInfo versionString: spec versionString ].      spec immutable.      self configurationRegistry        at: spec className        put: aMetacelloProjectRegistration ].  aMetacelloProjectRegistration baselineProjectSpec    ifNotNil: [ :spec |       self baselineRegistry        at: spec className        ifPresent: [ :existing |           (existing baselineProjectSpec registrationsCompareEqual: spec)            ifFalse: [               Transcript                cr;                show:                    'REGISTRATION OF INCOMPATABLE PROJECTS: ' , existing printString                        , ' REPLACED BY '                        , aMetacelloProjectRegistration printString ] ].      (aMetacelloProjectRegistration respondsTo: #'versionInfo')        ifTrue: [           aMetacelloProjectRegistration versionInfo            versionString: spec repositoryVersionString ].      spec immutable.      self baselineRegistry        at: spec className        put: aMetacelloProjectRegistration ].  aMetacelloProjectRegistration immutable! !!MetacelloProjectRegistry methodsFor: 'querying' stamp: 'dkh 05/14/2014 07:06' prior: 34889546!registrationForClassNamed: aClassName ifAbsent: absentBlock  ^ self    registrationForExactClassNamed: aClassName    ifAbsent: [       | baseName |      baseName := MetacelloScriptEngine baseNameOf: aClassName.      self configurationRegistry        at: 'ConfigurationOf' , baseName        ifPresent: [ :registration | ^ registration ].      self baselineRegistry        at: 'BaselineOf' , baseName        ifPresent: [ :registration | ^ registration ].      absentBlock value ]! !!MetacelloProjectRegistry methodsFor: 'querying' stamp: 'dkh 05/14/2014 07:05'!registrationForExactClassNamed: aClassName ifAbsent: absentBlock  self configurationRegistry    at: aClassName    ifPresent: [ :registration | ^ registration ].  self baselineRegistry    at: aClassName    ifPresent: [ :registration | ^ registration ].  ^ absentBlock value! !!MetacelloProjectRegistry methodsFor: 'accessing' stamp: 'dkh 07/27/2013 08:45'!registrations  ^ self baselineRegistry values , self configurationRegistry values! !!MetacelloSkipDirtyPackageLoad methodsFor: 'accessing' stamp: 'dkh 05/14/2014 10:26' prior: 34639276!defaultAction	"Default action is to skip the load of a dirty package"	^true! !Smalltalk removeClassNamed: #MetacelloLockedProjectError!MetacelloProjectRegistration removeSelector: #lookupSpec:!MetacelloPlatform removeSelector: #fileFromPath:relativeTo:!MetacelloPlatform removeSelector: #downloadFile:to:!MetacelloScriptGitHubDownloadNotification removeSelector: #versionString:!MetacelloScriptGitHubDownloadNotification removeSelector: #versionString!MetacelloScriptGitHubDownloadNotification removeSelector: #projectPath:!MetacelloScriptGitHubDownloadNotification removeSelector: #projectPath!Smalltalk removeClassNamed: #MetacelloScriptGitHubDownloadNotification!MetacelloPackagesSpec removeSelector: #sortPackageSpecs:for:!MetacelloPackagesSpec removeSelector: #slideIn:spec:baseIndex:seen:firstTime:!MetacelloPackagesSpec removeSelector: #packageSpecsInLoadOrder!MetacelloPackagesSpec removeSelector: #applyIncludesTo:for:firstTime:!MetacelloScriptEngine class removeSelector: #configurationProjectNameOf:!MetacelloScriptEngine class removeSelector: #baselineProjectNameOf:!"Metacello-Core"!Object subclass: #MetacelloConfigTemplateExample	instanceVariableNames: 'project'	classVariableNames: 'LastVersionLoad'	poolDictionaries: ''	category: 'Metacello-MC-Model'!!MetacelloConfigTemplateExample commentStamp: '<historical>' prior: 0!Copy me to create a new configuration or edit and evaluate the following doits.        "Create configuration class and initial baseline method"        MetacelloToolBox                 createBaseline: '1.0-baseline'                for: 'MyProject'                repository: 'http://www.example.com/MyProjectRepository'                requiredProjects: #('Gofer')                packages: #('MyProject-Core' 'MyProject-Tests')                dependencies:                        {('MyProject-Core' -> #('Gofer')).                         ('MyProject-Tests' -> #('MyProject-Core'))}                groups:                        {('default' -> #('Core')).                        ('Core' -> #('MyProject-Core')).                        ('Tests' -> #('MyProject-Tests'))}.	   "create initial development method from the baseline"         MetacelloToolBox               createDevelopment: '1.0'               for: 'MyProject'                importFromBaseline: '1.0-baseline'                description: 'initial version'.!MetacelloMCProjectSpec subclass: #MetacelloMCNamelessProjectSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-MC-Specs'!!MetacelloMCVersionSpecLoader methodsFor: 'loading' stamp: 'dkh 05/15/2014 15:39' prior: 35163518!load  | mcLoader |  packages := Dictionary new.  self resolveToLoadableSpecs.  mcLoader := self loader.  packages values    do: [ :pkg |       pkg ensureLoadedForDevelopmentUsing: mcLoader.      (MetacelloIgnorePackageLoaded signal: pkg)        ifFalse: [           mcLoader ignoreImage            ifFalse: [               (pkg                compareCurrentVersion: self operator                targetVersionStatus: #(#'allLoadedToSpec')                using: mcLoader)                ifTrue: [ packages removeKey: pkg name ] ] ] ].  packages notEmpty    ifTrue: [       mcLoader preLoad: self versionSpec.      mcLoader load.      mcLoader postLoad: self versionSpec ].  ^ mcLoader! !!MetacelloConfigTemplateExample class methodsFor: 'development support' stamp: 'ChristopheDemarey 1/15/2014 11:32'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!MetacelloConfigTemplateExample class methodsFor: 'private' stamp: 'ChristopheDemarey 1/15/2014 11:32'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!MetacelloConfigTemplateExample class methodsFor: 'private' stamp: 'ChristopheDemarey 1/15/2014 11:32'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!MetacelloConfigTemplateExample class methodsFor: 'private' stamp: 'ChristopheDemarey 1/15/2014 11:32'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!MetacelloConfigTemplateExample class methodsFor: 'metacello tool support' stamp: 'ChristopheDemarey 1/15/2014 11:32'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!MetacelloConfigTemplateExample class methodsFor: 'loading' stamp: 'ChristopheDemarey 1/15/2014 11:32'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!MetacelloConfigTemplateExample class methodsFor: 'loading' stamp: 'ChristopheDemarey 1/15/2014 11:32'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!MetacelloConfigTemplateExample class methodsFor: 'loading' stamp: 'ChristopheDemarey 1/15/2014 11:32'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!MetacelloConfigTemplateExample class methodsFor: 'accessing' stamp: 'ChristopheDemarey 1/15/2014 11:32'!project	^self new project! !!MetacelloConfigTemplateExample class methodsFor: 'development support' stamp: 'ChristopheDemarey 1/15/2014 11:32'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!MetacelloConfigTemplateExample methodsFor: 'baselines' stamp: 'ChristopheDemarey 1/15/2014 11:32'!baseline10: spec	"Baselines are used by convention in Metacello and essentially are nothing else than normal versions.	Name the baseline after the first version it was introduced.	In this case 1.0-baseline was introduced the first time with the 1.0 version defined in the #version10 method.	Metacello only uses the following tag to figure out the name of this baseline:"	<version: '1.0-baseline'>	"Using #common makes this dependency declaration available for all Smalltalks.	If you need more fine-grained control you can add several #for:do: sections for other releases."	spec for: #common do: [			spec blessing: #baseline.		"specify the default repository for your project's packages"		spec repository: 'http://smalltalkhub.com/mc/JohnDoe/MyProject/main'.			"use separate methods for external projects"		self 			fuelMetalevel: spec;			fileSystemLegacy: spec.				"specify the dependencies between packages and projects"		spec			"a package without dependencies:"			package: 'MyProject-Core';			package: 'MyProject-Tests' with: [ 				"Specfiy dependencies using the #requires: directive, you can refer to any name here, in this case to an external project"				spec requires: #('MyProject-Core' 'FuelMetalevel' 'FileSystemLegacy')].					"using groups certain packages and projects can be loaded conditionally"		spec 			"load the tests by default"			group: 'default' with: #('core' 'test');			group: 'test'    with: #('MyProject-Tests');			group: 'core'    with: #('MyProject-Core')]! !!MetacelloConfigTemplateExample methodsFor: 'accessing' stamp: 'ChristopheDemarey 1/15/2014 11:32'!customProjectAttributes	 "Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttrributes"	^ #().! !!MetacelloConfigTemplateExample methodsFor: 'tags' stamp: 'ChristopheDemarey 1/15/2014 11:32'!development: spec	"By convention the development branch should point to a fixed version that is regularly updated and might contain unstable code.	The name used by Metacello is only defined by the following pragma:"	<symbolicVersion: #development >		"For the development tag refer to a fixed version which you update if you commit new code.	Note that you can refer here to any other version name from this configuration"	spec for: #'common' version: 'dev'.! !!MetacelloConfigTemplateExample methodsFor: 'external projects' stamp: 'ChristopheDemarey 1/15/2014 11:32'!fileSystemLegacy: spec	"This is an example of an external project which does not have a configuration yet.	Note that the package name is only used in the Metacello configuration and does not have be exactly the same as the Monticello project/version name."	spec package: 'FileSystemLegacy' with: [		spec 			repository: 'http://smalltalkhub.com/mc/PharoExtras/FileSystemLegacy/main';			"if you do not specify a version, automatically the newest version is chose."			file:  'FileSystem-Legacy-JohanBrichau.2' ]! !!MetacelloConfigTemplateExample methodsFor: 'external projects' stamp: 'ChristopheDemarey 1/15/2014 11:32'!fuelMetalevel: spec	"Specify a dependency on an external project which has it's own configuration.	The given project name can be chosen freely, for simplicity use the same name as the configuration or the conditional group you load."	spec project: 'FuelMetalevel' with: [		spec 			repository: 'http://ss3.gemstone.com/ss/Fuel';			className: 'ConfigurationOfFuel';			"if you want to load by default a special group usse the #loads: message plus a group name of the external configuration"			loads: #FuelMetalevel ].! !!MetacelloConfigTemplateExample methodsFor: 'accessing' stamp: 'ChristopheDemarey 1/15/2014 11:32'!project	^ project ifNil: [ 		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		project := MetacelloMCProject new projectAttributes: self customProjectAttributes. 		(Smalltalk at: #MetacelloVersionConstructor) on: self project: project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!MetacelloConfigTemplateExample methodsFor: 'tags' stamp: 'ChristopheDemarey 1/15/2014 11:32'!stable: spec	"Symbolic versions can be used to introduce an indirection to a version number.	The real name used by Metacello is only defined by the following pragma:"	<symbolicVersion: #stable >		"If another version is stable for a differen Smalltalk use a specific name"	"spec for: #'pharo1.4.x' version: '0.9'"		"Specfiy which exact version you want to load"	spec for: #'common' version: '1.0'.	! !!MetacelloConfigTemplateExample methodsFor: 'versions' stamp: 'ChristopheDemarey 1/15/2014 11:32'!version10: spec	"The name for this version is solely defined by the following pragma:"	<version: '1.0' imports: #('1.0-baseline') >	"Baselines are used to define more complex setups for your project.	If you want to use external projects and have fine-graind control of the dependencies between packages use the #imports: part.	See the #baseline10: for more details."		"Using #for:do: with the #common release specifier the following version declaration is valid for all platforms."	spec for: #common do: [		spec 			description: 'Version 1.0 the current stable release';			blessing: #release;			author: 'John Doe';			timestamp: '2013-05-01'.				"Specify the versions for each package and external project defined in the baseline, here the 1.0-baseline defined in the baseline10 method."		spec			"For standard Monticello packages simply refere to the full version name without the extension:"			package: 'MyProject-Core'  with: 'MyProject-Core-JohnDoe.52';			package: 'MyProject-Tests' with: 'MyProject-Tests-JohnDoe.73';						"External projects versions are specified using #project:with:.			Note the project name referes to the name used in the Metacello declaration.			FuelMetalevel is defined in the #fuelMetalevel: method."			project: 'FuelMetalevel' with: #stable ].			"If you want to specify different version on other platforms add another #for:do: block with a different version identifier."! !!MetacelloConfigTemplateExample methodsFor: 'versions' stamp: 'ChristopheDemarey 1/15/2014 11:32'!versionDevelopment: spec	"version specification for the current development branch, see #version10 for a complete explanation of a version declaration.	In this case the 'dev' version uses the same baselin as version '1.0':"	<version: 'dev' imports: #('1.0-baseline') >		"Update this configuration regulrarly with intermediate releases.	If a version is more stable or should stay accessible copy this 'dev' definition and give it a proper version name on its own.	For example, in this case you might want to split a new version '1.1' by copying over this definition."	spec for: #common do: [		spec 			description: 'Development Version';			blessing: #development;			author: 'John Doe';			timestamp: '2013-05-09'.				spec			package: 'MyProject-Core'  with: 'MyProject-Core-JohnDoe.152';			package: 'MyProject-Tests' with: 'MyProject-Tests-JohnDoe.173';			"note that for the 'dev' version we rely on the #development version of the external FuleMetalevel project"			project: 'FuelMetalevel'   with: #development ].! !!MetacelloCommonMCSpecLoader methodsFor: 'testing' stamp: 'dkh 07/28/2013 16:10' prior: 35057932!ensureForDevelopment  ^ true! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: 'dkh 09/04/2014 13:56' prior: 35059690!loadPackageDirective: aPackageLoadDirective gofer: aGofer  | packageSpec |  packageSpec := aPackageLoadDirective spec.  MetacelloPlatform current    do: [       | loadBlock goferLoad answers resolvedReference |      aGofer disablePackageCache.	"for good luck:)"      resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.      resolvedReference isNil        ifTrue: [           "Package version already loaded into image"          ^ self ].      loadBlock := [       "mcLoader preLoad: packageSpec."      goferLoad := MetacelloGoferLoad on: aGofer.      goferLoad addResolved: resolvedReference.      goferLoad execute.      MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec" ].      (answers := packageSpec answers) notEmpty        ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]        ifFalse: [ loadBlock value ].      resolvedReference workingCopy repositoryGroup        addRepository: aPackageLoadDirective repository.      Transcript        cr;        show:            'Loaded -> ' , resolvedReference name , ' --- '                , aPackageLoadDirective repository repositoryDescription                , ' --- ' , resolvedReference repository description ]    displaying: 'Loading ' , packageSpec file! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: 'dkh 09/04/2014 13:57' prior: 35060973!loadPackageDirectives: pkgLoads gofer: aGofer  MetacelloPlatform current    do: [       | goferLoad loadBlock answers |      goferLoad := MetacelloGoferLoad on: aGofer.      answers := OrderedCollection new.      pkgLoads        do: [ :packageLoadDirective |           | resolvedReference |          aGofer disablePackageCache.	"for good luck:)"          (resolvedReference := self            resolvePackageSpec: packageLoadDirective spec            gofer: aGofer) ~~ nil            ifTrue: [               goferLoad addResolved: resolvedReference.              answers addAll: packageLoadDirective spec answers.              packageLoadDirective resolvedReference: resolvedReference ] ].      Transcript        cr;        show: 'Starting atomic load'.      loadBlock := [       "pkgLoads do: [:packageLoadDirective |  mcLoader preLoad: packageLoadDirective spec ]."      goferLoad execute.      pkgLoads        do: [ :packageLoadDirective |           packageLoadDirective resolvedReference == nil            ifTrue: [               Transcript                cr;                tab;                show: 'Already Loaded -> ' , packageLoadDirective file ]            ifFalse: [               Transcript                cr;                tab;                show:                    'Loaded -> ' , packageLoadDirective file , ' --- '                        , packageLoadDirective repository repositoryDescription                        , ' --- '                        ,                          packageLoadDirective resolvedReference repository description.              packageLoadDirective resolvedReference workingCopy repositoryGroup                addRepository: packageLoadDirective repository ] ].      MetacelloPlatform current clearCurrentVersionCache	"pkgLoads do: [:packageLoadDirective | 					packageLoadDirective resolvedReference ~~ nil						ifTrue: [mcLoader postLoad: packageLoadDirective spec ]]" ].      answers notEmpty        ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]        ifFalse: [ loadBlock value ].      Transcript        cr;        show: 'Finished atomic load' ]    displaying: 'Atomic Load...'! !!MetacelloCommonMCSpecLoader methodsFor: 'private' stamp: 'dkh 06/02/2014 15:10' prior: 35065504!resolvePackageSpec: packageSpec gofer: gofer  | references resolvedReference mcVersion loadedVersionInfos |  references := self    retryingResolvePackageSpecReferences: packageSpec    gofer: gofer.  resolvedReference := references last asMetacelloCachingResolvedReference.  mcVersion := resolvedReference version.  (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil    ifTrue: [       loadedVersionInfos        do: [ :info |           info name = mcVersion info name            ifTrue: [               | spc |              "package already loaded, don't load again"              spc := packageSpec copy.              spc file: info name.              (MetacelloIgnorePackageLoaded signal: spc)                ifFalse: [ ^ nil ] ] ] ].  ^ resolvedReference! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: 'dkh 11/23/2013 15:09' prior: 35145542!packageSpecsInLoadOrderForMap: packageMap  | loadOrder pkgs packageNames importNames importSpec importProjectSpecs importProjectNameMap |  loadOrder := self packageSpecsInLoadOrder.  importNames := (packageNames := (packageMap values    collect: [ :pkg | pkg name ]) asSet) copy.  (self import isNil and: [ self importArray isNil ])    ifTrue: [ ^ loadOrder select: [ :pkg | packageNames includes: pkg name ] ].  loadOrder do: [ :pkg | importNames remove: pkg name ifAbsent: [  ] ].  pkgs := OrderedCollection new.  importProjectSpecs := Dictionary new.  importProjectNameMap := Dictionary new.  importArray    ifNotNil: [       loadOrder        do: [ :pkg |           importArray            do: [ :assoc |               assoc key = pkg name                ifTrue: [                   importProjectSpecs at: pkg name put: pkg.                  (assoc value select: [ :each | importNames includes: each ])                    do: [ :each |                       (importProjectNameMap                        at: pkg name                        ifAbsent: [ importProjectNameMap at: pkg name put: Set new ])                        add: each ] ] ] ] ].  self import    ifNotNil: [       loadOrder        do: [ :pkg |           pkg name = self import            ifTrue: [               importProjectSpecs at: pkg name put: pkg.              importProjectNameMap at: pkg name put: importNames ] ] ].  loadOrder    do: [ :pkg |       (packageNames includes: pkg name)        ifTrue: [ pkgs add: pkg ].      importProjectSpecs        at: pkg name        ifPresent: [ :importProjectSpec |           "insert the imports at this point"          (importProjectNameMap at: pkg name ifAbsent: [ #() ])            do: [ :importedName |               pkgs                add:                  (importSpec := importProjectSpec copy                    name: importedName;                    mergeImportLoads: {importedName};                    yourself).              importSpec projectReference name: importedName ] ] ].  ^ pkgs! !!GoferVersionReference methodsFor: '*metacello-mc' stamp: 'dkh 07/19/2013 15:25'!compare: aLoadableReference using: aComparisonOperator	"Compare versions using <aComparisonOperator>. package names #= then compare based upon version number	Branches and Author names are used in the case of a version number tie, because we need to avoid seesaw loading."			self packageName = aLoadableReference packageName		ifFalse: [ ^false ].	self versionNumber = aLoadableReference versionNumber		ifFalse: [ ^ self versionNumber perform: aComparisonOperator with: aLoadableReference versionNumber ].	self branch = aLoadableReference branch 		ifFalse: [ ^ self branch perform: aComparisonOperator with: aLoadableReference branch ].	^ self author perform: aComparisonOperator with: aLoadableReference author! !!MetacelloMCProject methodsFor: 'development support' stamp: 'dkh 10/16/2014 09:47' prior: 35175585!projectPackage  MCWorkingCopy    managersForClass: self configuration class    do: [ :mgr |       | pkgSpec repo |      pkgSpec := self packageSpec        name: mgr packageName;        yourself.      mgr ancestors notEmpty        ifTrue: [ pkgSpec file: mgr ancestors first name ].      repo := mgr repositoryGroup repositories        detect: [ :each | each ~~ MetacelloPlatform current defaultPackageCache ]        ifNone: [           Transcript            cr;            show:                'Using cache repository for ' , self label , ' project package'.          MetacelloPlatform current defaultPackageCache ].      pkgSpec repository: (repo asRepositorySpecFor: self).      ^ pkgSpec ].  ^ nil! !!MetacelloMCProject methodsFor: 'spec classes' stamp: 'otto 11/19/2013 10:26' prior: 35176269!projectSpecClass	^ MetacelloMCNamelessProjectSpec! !!MetacelloGroupSpec methodsFor: '*metacello-mc' stamp: 'dkh 10/01/2014 17:13'!resolveToPackagesIn: aVersionSpec andProjects: andProjectsBool into: packages visited: visited  visited    visit: self    doing: [ :aSpec |       | map |      map := aVersionSpec packages map.      aSpec includes        do: [ :pkgName |           (aVersionSpec packageNamed: pkgName forMap: map ifAbsent: [  ])            projectDo: [ :prj |               andProjectsBool                ifTrue: [ packages at: prj name put: prj ] ]            packageDo: [ :pkg | packages at: pkg name put: pkg ]            groupDo: [ :grp |               grp                resolveToPackagesIn: aVersionSpec                andProjects: andProjectsBool                into: packages                visited: visited ] ] ]! !!MetacelloGroupSpec methodsFor: '*metacello-mc' stamp: 'dkh 10/01/2014 17:13'!resolveToPackagesIn: aVersionSpec andProjects: andProjectsBool visited: visited  | packages |  packages := Dictionary new.  self    resolveToPackagesIn: aVersionSpec    andProjects: andProjectsBool    into: packages    visited: visited.  ^ packages values asOrderedCollection! !!MetacelloGroupSpec methodsFor: '*metacello-mc' stamp: 'dkh 10/01/2014 17:13' prior: 35126571!resolveToPackagesIn: aVersionSpec into: packages visited: visited  self    resolveToPackagesIn: aVersionSpec    andProjects: false    into: packages    visited: visited! !!MetacelloGroupSpec methodsFor: '*metacello-mc' stamp: 'dkh 10/01/2014 17:14' prior: 35127112!resolveToPackagesIn: aVersionSpec visited: visited  | packages |  packages := Dictionary new.  self    resolveToPackagesIn: aVersionSpec    andProjects: false    into: packages    visited: visited.  ^ packages values asOrderedCollection! !!MetacelloLoadingMCSpecLoader methodsFor: 'private' stamp: 'dkh 09/04/2014 13:52' prior: 35009186!linearLoadPackageSpec: packageSpec gofer: gofer  MetacelloPlatform current    do: [       | loadBlock goferLoad answers resolvedReference repo |      resolvedReference := self resolvePackageSpec: packageSpec gofer: gofer.      resolvedReference isNil        ifTrue: [           "Package version already loaded into image"          ^ self ].      loadBlock := [       self preLoad: packageSpec.      goferLoad := MetacelloGoferLoad on: MetacelloGofer new.      goferLoad addResolved: resolvedReference.      goferLoad execute.      MetacelloPlatform current clearCurrentVersionCache.      self postLoad: packageSpec ].      (answers := packageSpec answers) notEmpty        ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]        ifFalse: [ loadBlock value ].      repo := resolvedReference repository.      self hasRepositoryOverrides        ifTrue: [           repo := self loaderPolicy repositoryMap            at: resolvedReference name            ifAbsent: [ resolvedReference repository ].          resolvedReference workingCopy repositoryGroup addRepository: repo ]        ifFalse: [           resolvedReference workingCopy repositoryGroup            addRepository: resolvedReference repository ].      Transcript        cr;        show:            'Loaded -> ' , resolvedReference name , ' --- ' , repo repositoryDescription                , ' --- ' , resolvedReference repository description ]    displaying: 'Loading ' , packageSpec file! !!MetacelloLoadingMCSpecLoader methodsFor: 'development support' stamp: 'ChristopheDemarey 9/11/2013 13:21' prior: 35013006!savePackageUsing: repositorySpecs	| wc repo repoSpecs newVersion |	(wc := self spec workingCopy) == nil ifTrue: [ ^false ].	(wc ancestry ancestors notEmpty and: [ wc modified not])		ifTrue: [ ^false ].	repoSpecs := self spec repositorySpecs notEmpty				ifTrue: [ self spec repositorySpecs ]				ifFalse: [ repositorySpecs ].	(self spec getFile == nil or: [ wc ancestry ancestors isEmpty ])		ifTrue: [ repo := (self repositoriesFrom: repoSpecs ignoreOverrides: true) first ]		ifFalse: [			[ 	| newer |				repo := (self resolveSpec: self spec from: repoSpecs) repository.				newer := wc possiblyNewerVersionsIn: repo.				newer isEmpty not 					ifTrue: [						(MetacelloPlatform current confirm: 'CAUTION!! These versions in the repository may be newer:', 							String cr, newer printString, String cr,							'Do you really want to save this version?') ifFalse: [ ^false ]] ] 				on: Error 				do: [:ignored | ^false ] ].	(newVersion :=  MetacelloPlatform current newVersionForWorkingCopy: wc) == nil ifTrue: [ ^false ].	repo storeVersion: newVersion.	^true! !!MetacelloMCVersionValidator methodsFor: 'private' stamp: 'dkh 06/12/2014 07:21' prior: 35030134!validateVersionSpec: versionSpec  versionSpec blessing value == #'broken'    ifTrue: [ ^ self ].  versionSpec    projectDo: [ :projectSpec |       | referencedProjectSpec |      projectSpec versionString == nil        ifTrue: [           self            recordValidationCriticalWarning:              'No version specified for the project reference ' , projectSpec name printString                , ' in version ' , versionSpec versionString printString            versionString: versionSpec versionString            callSite: #'validateVersionSpec:'            reasonCode: #'noVersionSpecified' ].      referencedProjectSpec := projectSpec referencedSpec.      versionSpec blessing value == #'baseline'        ifTrue: [           referencedProjectSpec hasRepository            ifTrue: [               (referencedProjectSpec file beginsWith: referencedProjectSpec className)                ifFalse: [                   self                    recordValidationCriticalWarning:                      'The class name of project ' , referencedProjectSpec className printString                        , ' does not match the file name '                        , referencedProjectSpec file printString                        , ' in version ' , versionSpec versionString printString                    versionString: versionSpec versionString                    callSite: #'validateVersionSpec:'                    reasonCode: #'projectClassNameFileMismatch' ] ]            ifFalse: [               self                recordValidationError:                  'The specification for the project reference ' , projectSpec name printString                    , ' in version ' , versionSpec versionString printString                    , ' is missing the required repository field'                versionString: versionSpec versionString                callSite: #'validateVersionSpec:'                reasonCode: #'incompleteProjectSpec' ] ].      referencedProjectSpec ensureProjectLoaded        ifTrue: [           [ projectSpec version ]            on: MetacelloVersionDoesNotExistError            do: [ :ex |               | explanation |              explanation := projectSpec versionString == nil                ifTrue: [ 'the default version' ]                ifFalse: [ 'version ' , projectSpec versionString printString ].              self                recordValidationError:                  'Cannot resolve ' , explanation , ' for the project reference '                    , projectSpec name printString , ' in version '                    , versionSpec versionString printString                versionString: versionSpec versionString                callSite: #'validateVersionSpec:'                reasonCode: #'cannotResolveVersion' ] ] ]    packageDo: [ :packageSpec |       (packageSpec file beginsWith: packageSpec name)        ifFalse: [           self            recordValidationCriticalWarning:              'The name of package ' , packageSpec name printString                , ' does not match the file name '                , packageSpec file printString , ' in version '                , versionSpec versionString printString            versionString: versionSpec versionString            callSite: #'validateVersionSpec:'            reasonCode: #'packageNameMismatch' ].      packageSpec file = packageSpec name        ifTrue: [           self            recordValidationCriticalWarning:              'No version specified for the package ' , packageSpec name printString                , ' in version ' , versionSpec versionString printString            versionString: versionSpec versionString            callSite: #'validateVersionSpec:'            reasonCode: #'noVersionSpecified' ] ]    groupDo: [ :ignored |  ].  self validateBaselineVersionSpec: versionSpec! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'mutability' stamp: 'dkh 07/06/2014 11:35' prior: 34970965!copyForRegistration: aMetacelloProjectRegistration onWrite: aBlock  | copy |  aMetacelloProjectRegistration    configurationProjectSpecIfPresent: [ :spec |       copy := spec copy.      aBlock value: copy.      aMetacelloProjectRegistration configurationProjectSpec: copy ]    ifAbsent: [       aMetacelloProjectRegistration        baselineProjectSpecIfPresent: [ :spec |           copy := spec copy.          aBlock value: copy.          aMetacelloProjectRegistration baselineProjectSpec: copy ]        ifAbsent: [ aBlock value: nil ] ]! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'testing' stamp: 'otto 11/18/2013 12:09'!hasConflictWithBaselineSpec: projectSpec	projectSpec name = self name		ifFalse: [ ^ true ].	projectSpec project configuration className = self project configuration className		ifFalse: [ ^ true ].	^ ((projectSpec repositories isEmpty or: [ self repositories isEmpty ])		or: [ projectSpec repositories hasNoLoadConflicts: self repositories ]) not! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'testing' stamp: 'otto 11/18/2013 12:08'!hasConflictWithProjectSpec: projectSpec	^ projectSpec hasConflictWithConfigurationSpec: self! !!MetacelloMCConfigurationOfProjectSpec methodsFor: 'testing' stamp: 'talita 11/18/2013 22:21'!isConfigurationOfProjectSpec	^ true! !!MetacelloEnsureFetchingMCSpecLoader methodsFor: 'private' stamp: 'dkh 09/04/2014 13:50' prior: 34993269!scheduleFetchFor: packageSpec cachedReference: reference  "reference already in the cache during fetch ...schedule a load directive for reference, so ensured load will come from cache"  ^ self    scheduleFetchFor: packageSpec    reference: reference    message:      'Fetched -> (cached) ' , reference name , ' --- '        , reference repository repositoryDescription , ' --- '        , reference repository description! !!MetacelloEnsureFetchingMCSpecLoader methodsFor: 'private' stamp: 'dkh 09/04/2014 13:50' prior: 34993760!scheduleFetchFor: packageSpec nearestReference: reference  "latest version in repository already matches the cached reference...schedule a load directive for reference, so ensured load will come from cache"  ^ self    scheduleFetchFor: packageSpec    reference: reference    message:      'Fetched -> (nearest) ' , reference name , ' --- '        , reference repository repositoryDescription , ' --- '        , reference repository description! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'private' stamp: 'dkh 10/16/2014 09:47' prior: 35074585!resolveRecordingPackageSpecReference: packageSpec gofer: gofer  | externalPackageReference |  externalPackageReference := packageSpec file == nil    ifTrue: [ GoferPackageReference name: packageSpec name ]    ifFalse: [ GoferResolvedReference name: packageSpec file repository: nil ].  packageSpec repositorySpecs isEmpty    ifTrue: [       self repositoryMap        at: externalPackageReference packageName        put:          (gofer repositories            reject: [ :repo | repo = MetacelloPlatform current defaultPackageCache ]) ]    ifFalse: [       self repositoryMap        at: externalPackageReference packageName        put:          (packageSpec repositorySpecs collect: [ :repoSpec | repoSpec createRepository ]) ].  ^ externalPackageReference! !!MetacelloMCNamelessProjectSpec methodsFor: 'mutability' stamp: 'otto 11/19/2013 10:05'!copyForRegistration: aMetacelloProjectRegistration onWrite: aBlock	self error: 'Should be converting to configuration spec for the registration, so we should not get here'! !!MetacelloMCProjectSpec class methodsFor: 'instance creation' stamp: 'otto 11/19/2013 10:27'!new	self name == #MetacelloMCProjectSpec		ifTrue: [ self error: 'This class is abstract' ].	^ super new! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: 'dkh 06/30/2014 17:13' prior: 34973132!asProjectRegistration  (self className beginsWith: 'BaselineOf')    ifTrue: [       ^ MetacelloProjectRegistration        fromMCBaselineProjectSpec: self asBaselineProjectSpec ].  ^ MetacelloProjectRegistration    fromMCConfigurationProjectSpec: self asConfigurationProjectSpec! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: 'otto 11/18/2013 12:59'!baseName	^ MetacelloScriptEngine baseNameOf: self className! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: 'dkh 09/30/2014 11:08' prior: 34977671!ensureConfigurationLoaded: vrsn ensured: ensured  "answer true if the configuration should be reloaded:    blessing is #development    symbolic version (https://github.com/dalehenrich/metacello-work/issues/283)"  (vrsn blessing == #'development' or: [ self versionString isSymbol ])    ifTrue: [       ensured ~~ #'latest'        ifTrue: [ ^ MetacelloScriptEnsureProjectLoadedForDevelopment signal ] ].  ^ false! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: 'dkh 09/19/2014 14:03' prior: 34978025!ensureLoadUsing: aLoader  | pp |  pp := (MetacelloLookupProjectSpec new    projectSpec: self;    yourself) signal projectPackage.  pp    ifNil: [       self        error:          'Unable to resolve project package for ' , self name printString            ,              '. It is likely that that the configuration referencing this project will not validate properly (see MetacelloToolBox class>>validateConfiguration:).' ].  pp ensureLoadUsing: aLoader! !!MetacelloMCProjectSpec methodsFor: 'loading' stamp: 'dkh 07/29/2013 07:16' prior: 34978274!ensureLoadedForDevelopmentUsing: mcLoader  "for #development projects, always need latest version of package when contemplating a load"  | ensured |  ensured := mcLoader ensuredMap at: self name ifAbsent: [ nil ].  self projectClass ~~ nil    ifTrue: [       | vrsn |      vrsn := self versionOrNil.      vrsn ~~ nil        ifTrue: [           (self ensureConfigurationLoaded: vrsn ensured: ensured)            ifTrue: [               mcLoader ensureForDevelopment                ifTrue: [                   | pc |                  (pc := self projectClass) ~~ nil                    ifTrue: [                       MetacelloClearStackCacheNotification                        signal:                          #(#'currentVersion' #'currentVersionAgainst:' #'currentVersionInfo' #'versionConstructor' #'loadableSpecNames')                            , {pc} ].                  self ensureLoadUsing: mcLoader ]                ifFalse: [ self projectPackage fetchUsing: mcLoader ].              mcLoader ensuredMap at: self name put: #'latest' ].          ^ self ] ].  ensured == nil    ifTrue: [       "projectClass == nil or version == nil"      mcLoader ensureForDevelopment        ifTrue: [           | pc |          (pc := self projectClass) ~~ nil            ifTrue: [               MetacelloClearStackCacheNotification                signal:                  #(#'currentVersion' #'currentVersionAgainst:' #'currentVersionInfo' #'versionConstructor' #'loadableSpecNames')                    , {pc} ].          self ensureLoadUsing: mcLoader ]        ifFalse: [ self fetchUsing: mcLoader ].      mcLoader ensuredMap at: self name put: #'present' ]! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: 'otto 11/18/2013 12:10'!hasConflictWithBaselineSpec: projectSpec	^ self hasLoadConflicts: projectSpec! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: 'otto 11/18/2013 12:07'!hasConflictWithConfigurationSpec: projectSpec	^ self hasLoadConflicts: projectSpec! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: 'dkh 10/01/2014 13:47'!hasConflictWithProjectSpec: projectSpec  (self className beginsWith: 'BaselineOf')    ifTrue: [ ^ projectSpec hasConflictWithBaselineSpec: self asBaselineProjectSpec ].  ^ projectSpec    hasConflictWithConfigurationSpec: self asConfigurationProjectSpec! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: 'talita 11/18/2013 22:22'!isBaselineOfProjectSpec	^ false! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: 'talita 11/18/2013 22:20'!isConfigurationOfProjectSpec	^ false! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: 'dkh 05/15/2014 15:44'!workingCopy  ^ self projectPackage workingCopy! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'scripting' stamp: 'dkh 07/05/2014 18:12' prior: 34966191!canUpgradeTo: aProjectSpec  "cannot upgrade between baselines unless repositories can be upgraded"  (self repositories canUpgradeTo: aProjectSpec repositories)    ifTrue: [ ^ true ].  ^ false! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'mutability' stamp: 'dkh 07/06/2014 11:35' prior: 34966503!copyForRegistration: aMetacelloProjectRegistration onWrite: aBlock  | copy |  aMetacelloProjectRegistration    baselineProjectSpecIfPresent: [ :spec |       copy := spec copy.      aBlock value: copy.      aMetacelloProjectRegistration baselineProjectSpec: copy ]    ifAbsent: [       aMetacelloProjectRegistration        configurationProjectSpecIfPresent: [ :spec |           copy := spec copy.          aBlock value: copy.          aMetacelloProjectRegistration configurationProjectSpec: copy ]        ifAbsent: [ aBlock value: nil ] ]! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'loading' stamp: 'dkh 06/20/2014 15:42'!ensureLoadUsing: aLoader  "see https://github.com/dalehenrich/metacello-work/issues/244 ... uncoditionally load   baseline"  [ super ensureLoadUsing: aLoader ]    on: MetacelloIgnorePackageLoaded    do: [ :ex | ex resume: ex packageSpec name = self name ]! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'testing' stamp: 'dkh 05/10/2014 22:16'!hasConflictWithConfigurationSpec: projectSpec  "baseline can be loaded on top of a configuration without a conflict"  ^ false! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'testing' stamp: 'otto 11/18/2013 12:04'!hasConflictWithProjectSpec: projectSpec	^ projectSpec hasConflictWithBaselineSpec: self! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'testing' stamp: 'talita 11/18/2013 22:22'!isBaselineOfProjectSpec	^ true! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'merging' stamp: 'dkh 06/21/2014 07:50'!mergeRepositoriesSpec: anotherRepositories  "anotherRepositories wins ... there can ever only be one repository for the    baseline to load from"  "https://github.com/dalehenrich/metacello-work/issues/251"  self repositories: anotherRepositories! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'querying' stamp: 'dkh 05/09/2014 10:05'!repositoryBranchName  "extract a branch name from the repository ... if possible"  "must parallel implementation of MetacelloMCBaselineProject>>setBaselineRepositoryDescription: we want the same repoSpec"  | spec repo |  self repositorySpecs do: [ :repoSpec | spec := repoSpec ].  repo := spec createRepository.  ^ repo repositoryBranchName! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'querying' stamp: 'dkh 05/08/2014 15:12'!repositoryVersionString  "extract a version string from the repository ... if possible"  "must parallel implementation of MetacelloMCBaselineProject>>setBaselineRepositoryDescription: we want the same repoSpec"  | spec repo |  self repositorySpecs do: [ :repoSpec | spec := repoSpec ].  repo := spec createRepository.  ^ repo repositoryVersionString! !!MetacelloRepositoriesSpec methodsFor: 'scripting' stamp: 'dkh 07/05/2014 18:21'!canUpgradeTo: aMetacelloRepositoriesSpec  | repositorySpecs anotherRepositorySpecs |  repositorySpecs := self map values    sort: [ :a :b | a description <= b description ].  anotherRepositorySpecs := aMetacelloRepositoriesSpec map values    sort: [ :a :b | a description <= b description ].  repositorySpecs size ~= anotherRepositorySpecs size    ifTrue: [ ^ false ].  1 to: repositorySpecs size do: [ :index |     | repoSpec anotherRepoSpec |    repoSpec := repositorySpecs at: index.    anotherRepoSpec := anotherRepositorySpecs at: index.    (repoSpec canUpgradeTo: anotherRepoSpec)      ifTrue: [ ^ true ] ].  ^ false! !!MetacelloRepositoriesSpec methodsFor: 'scripting' stamp: 'dkh 07/05/2014 18:13' prior: 35038693!hasNoLoadConflicts: aMetacelloRepositoriesSpec  | repositorySpecs anotherRepositorySpecs |  repositorySpecs := self map values    sort: [ :a :b | a description <= b description ].  anotherRepositorySpecs := aMetacelloRepositoriesSpec map values    sort: [ :a :b | a description <= b description ].  repositorySpecs size ~= anotherRepositorySpecs size    ifTrue: [ ^ false ].  1 to: repositorySpecs size do: [ :index |     | repoSpec anotherRepoSpec |    repoSpec := repositorySpecs at: index.    anotherRepoSpec := anotherRepositorySpecs at: index.    (repoSpec hasNoLoadConflicts: anotherRepoSpec)      ifFalse: [ ^ false ] ].  ^ true! !!MetacelloRepositorySpec methodsFor: 'mc support' stamp: 'dkh 09/29/2014 12:37'!canUpgradeTo: aMetacelloRepositorySpec  self description = aMetacelloRepositorySpec description    ifTrue: [ ^ true ].  (#('github' 'gitorious' 'bitbucket') includes: self type)    ifTrue: [ ^ self createRepository canUpgradeTo: aMetacelloRepositorySpec createRepository ].  ^ false! !!MetacelloRepositorySpec methodsFor: 'mc support' stamp: 'dkh 06/20/2014 16:09' prior: 35122307!createRepository  | repo |  repo := self project createRepository: self.  ^ MCRepositoryGroup default repositories    detect: [ :each | each = repo ]    ifNone: [       MCRepositoryGroup default addRepository: repo.      repo ]! !!MetacelloRepositorySpec methodsFor: 'mc support' stamp: 'dkh 09/29/2014 12:38' prior: 35123035!hasNoLoadConflicts: aMetacelloRepositorySpec  self description = aMetacelloRepositorySpec description    ifTrue: [ ^ true ].  (#('github' 'gitorious' 'bitbucket') includes: self type)    ifTrue: [       ^ self createRepository        hasNoLoadConflicts: aMetacelloRepositorySpec createRepository ].  ^ false! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 10/01/2014 17:20'!resolveToPackagesIn: aVersionSpec andProjects: andProjectsBool visited: visited  ^ self resolveToPackagesIn: aVersionSpec visited: visited! !!MetacelloGoferCommit methodsFor: 'running' stamp: 'ChristopheDemarey 9/11/2013 13:21' prior: 35129939!execute: aWorkingCopy	| version |	version := MetacelloPlatform current newVersionForWorkingCopy: aWorkingCopy.	self gofer repositories		do: [ :repository | repository storeVersion: version ]! !!MetacelloFetchingMCSpecLoader methodsFor: 'actions' stamp: 'dkh 06/02/2014 15:10' prior: 34996361!linearLoadPackageSpec: packageSpec gofer: gofer  MetacelloPlatform current    do: [       | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |      "check to see if mcz file is already in cacheRepository"      cachedReference := self        resolvePackageSpec: packageSpec        cachedGofer: self loaderPolicy cacheGofer.      (cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])        ifTrue: [           cachedReference name = packageSpec file            ifTrue: [               "exact match between packageSpec file and cache"              ^ self                scheduleFetchFor: packageSpec                cachedReference: cachedReference ] ].	"look up mcz file"      references := self        retryingResolvePackageSpecReferences: packageSpec        gofer: gofer.      nearestReference := references last asMetacelloCachingResolvedReference.	"If the mcz is already in the cacheRepository, no need to copy"      (cachedReference ~~ nil        and: [ cachedReference name = nearestReference name ])        ifTrue: [           "latest reference in repository matches cachedReference ... "          ^ self            scheduleFetchFor: packageSpec            nearestReference: nearestReference ].	"If the mcz is already loaded into the image, no need to copy"      (self ignoreImage not        and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])        ifTrue: [           loadedVersionInfos            do: [ :info |               info name = nearestReference name                ifTrue: [                   | spc |                  spc := packageSpec copy.                  spc file: info name.                  (MetacelloIgnorePackageLoaded signal: spc)                    ifFalse: [ ^ self ] ] ] ].      externalReference := (references        select: [ :ref | ref name = nearestReference name ]) first        asMetacelloCachingResolvedReference.      self repositoryMap        at: externalReference name        put: externalReference repository.      (self        resolveDependencies: externalReference        nearest: nearestReference        into: (OrderedCollection with: nearestReference))        do: [ :reference |           | pSpec l |          mcVersion := reference version.          (l := (GoferVersionReference name: reference name)            resolveAllWith: self loaderPolicy cacheGofer) isEmpty            ifTrue: [               self cacheRepository storeVersion: mcVersion.              reference == nearestReference                ifTrue: [ pSpec := packageSpec ]                ifFalse: [                   pSpec := packageSpec project packageSpec.                  pSpec name: mcVersion package name ].              self loadData                addVersion: mcVersion                versionInfo: mcVersion info                resolvedReference: reference                packageSpec: pSpec ] ].      self scheduleFetchFor: packageSpec externalReference: externalReference ]    displaying: 'Fetching ' , packageSpec file! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: 'dkh 09/04/2014 13:50' prior: 35000543!resolveDependencies: aResolvedReference nearest: nearestReference into: aCollection  | block retryCount coll notDone |  self flag: 'Not used, but retained to avoid upgrade issues'.  block := [ :dependency |   | reference |  reference := MetacelloCachingGoferResolvedReference    name: dependency versionInfo name    repository: aResolvedReference repository.  coll add: reference.  Transcript    cr;    show:        'Fetched dependency -> ' , reference name , ' --- '            , reference repository repositoryDescription.  self resolveDependencies: reference nearest: reference into: coll ].  retryCount := 0.  notDone := true.  coll := OrderedCollection new.  [ notDone and: [ retryCount < 3 ] ]    whileTrue: [       retryCount > 0        ifTrue: [           Transcript            cr;            show: '...RETRY' ].      [       "ensure that all resolved references have cached their version while wrapped by error handler"      aCollection do: [ :each | each version ].      nearestReference version dependencies do: block.      notDone := false ]        on: Error        do: [ :ex |           retryCount := retryCount + 1.          retryCount >= 3            ifTrue: [ ex pass ].          coll := OrderedCollection new ] ].  aCollection addAll: coll.  ^ aCollection! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: 'dkh 09/04/2014 13:50' prior: 35002410!scheduleFetchFor: packageSpec externalReference: reference  ^ self    scheduleFetchFor: packageSpec    reference: reference    message:      'Fetched -> ' , reference name , ' --- '        , reference repository repositoryDescription , ' --- '        , reference repository description! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'dkh 10/01/2014 17:29'!resolveToPackagesIn: aVersionSpec andProjects: andProjectsBool visited: visited  ^ andProjectsBool    ifTrue: [ {self} ]    ifFalse: [ self resolveToPackagesIn: aVersionSpec visited: visited ]! !!MetacelloMCBaselineProject methodsFor: 'scripting' stamp: 'dkh 06/18/2014 09:55' prior: 35170700!projectForScriptEngine: aMetacelloScriptEngine unconditionalLoad: aBool  "see https://github.com/dalehenrich/metacello-work/issues/244 ... uncoditionally load   baseline"  ^ aMetacelloScriptEngine getBaselineProjectUnconditionalLoad: true! !!MetacelloPackageSpec methodsFor: 'testing' stamp: 'dkh 07/19/2013 15:50' prior: 35085327!currentPackageLoaded: loadedBlock comparing: comarisonOperator notLoaded: notLoadedBlock using: anMCLoader  "Use currentVersionInfoFor: because it involves the loader and returns versionInfo for a planned load 	 (atomic loaders) or currently loaded package"  | wcName vis |  vis := anMCLoader ancestorsFor: self.  vis notNil    ifTrue: [       | fileRef wcRef |      self getFile == nil        ifTrue: [ ^ loadedBlock value: false ].      vis        do: [ :vi |           wcName := vi name.          fileRef := GoferVersionReference name: self file.          fileRef versionNumber = 0            ifTrue: [               "a shame that GoferVersionReference doesn't have better method for recognizing a missing verion number"              "fix for: https://github.com/dalehenrich/metacello-work/issues/185"              ^ loadedBlock value: false ].          wcRef := GoferVersionReference name: wcName.          (wcRef compare: fileRef using: comarisonOperator)            ifTrue: [ ^ loadedBlock value: true ] ].      ^ loadedBlock value: false ].  ^ notLoadedBlock value: true! !!MetacelloPackageSpec methodsFor: 'private' stamp: 'dkh 10/03/2014 18:32' prior: 35092222!includesForPackageOrdering  ^ self includes! !MetacelloMCConfigurationOfProjectSpec removeSelector: #asProjectSpec!MetacelloMCBaselineOfProjectSpec removeSelector: #asProjectSpec!GoferResolvedReference removeSelector: #compare:using:!"Metacello-MC"!!MetacelloSqueakPlatform methodsFor: 'attributes' stamp: 'pad 8/21/2015 09:57' prior: 34444479!defaultPlatformAttributes	| attributes  |	attributes := OrderedCollection with: #squeakCommon with: #squeak.	Smalltalk		at: #SystemVersion		ifPresent: [:cl | |versionString|			versionString := cl current version asString.			" Major version "			#(	'Squeak3.10' (#'squeak3.10.x' ())				'Squeak4' (#'squeak4.x' (					'Squeak4.1' #'squeak4.1.x'					'Squeak4.2' #'squeak4.2.x'					'Squeak4.3' #'squeak4.3.x'					'Squeak4.4' #'squeak4.4.x'					'Squeak4.5' #'squeak4.5.x'					'Squeak4.6' #'squeak4.6.x'))				'Squeak5' (#'squeak5.x' (					'Squeak5.0' #'squeak5.0.x')))			pairsDo: [:major :allAttributes |				(versionString beginsWith: major) ifTrue: [					attributes add: allAttributes first.					allAttributes second ifNotEmpty: [:minorVersions |						minorVersions pairsDo: [:minor :attribute |							(versionString beginsWith: minor) ifTrue: [								attributes add: attribute.								^ attributes]]]]]]. 	^ attributes! !!MetacelloSqueakPlatform methodsFor: 'github/bitbucket support' stamp: 'dkh 10/14/2014 17:20:25'!downloadJSON: url username: username pass: pass  "return result of parsing JSON downloaded from url. username:pass may be nil, but calls will be subject to severe rate limits."  | response |  response := WebClient httpDo: [ :client |     username ifNotNil: [      client         username: username;        password: pass;        yourself ].    client httpGet: url].  response isSuccess ifFalse: [ Transcript cr; show: 'downloadJSON:username:pass: ', response printString ].  ^ MCFileTreeJsonParser parse: response content! !!MetacelloSqueakPlatform methodsFor: 'github support' stamp: 'tfel 09/29/2014 09:54:55'!downloadZipArchive: url to: outputFileName  "download zip archive from <url> into <outputFileName>"    | archive zipfile response |    response := WebClient httpGet: url.    archive := ZipArchive new.    zipfile := FileDirectory on: (FileDirectory default fullPathFor: outputFileName).    zipfile containingDirectory assureExistence.    response         streamTo: ((zipfile containingDirectory forceNewFileNamed: zipfile localName) binary; yourself)         size: response contentLength progress: nil.    zipfile containingDirectory		readOnlyFileNamed: zipfile localName		do: [:fileStream | archive readFrom: fileStream].    ^ archive! !MetacelloSqueakPlatform removeSelector: #downloadFile:to:!"Metacello-Platform"!!MetacelloToolBox class methodsFor: 'utility' stamp: 'dkh 07/18/2013 07:42' prior: 35207269!baseNameOf: configurationClassName  "Return the baseName for the given configuration class name."  <apiDocumentation>  ^ (configurationClassName beginsWith: 'ConfigurationOf')    ifTrue: [       configurationClassName        copyFrom: 'ConfigurationOf' size + 1        to: configurationClassName size ]    ifFalse: [ configurationClassName ]! !!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 10/16/2014 09:47' prior: 35243927!saveModifiedDevelopmentPackages: developmentVersionString for: configurationBasename description: commitMessage  "Save modified mcz files associated with the project. Then update given version to reflect the new mcz file versions."  <apiDocumentation>  | toolbox modifiedPackages cacheRepository |  modifiedPackages := Dictionary new.  (toolbox := self configurationNamed: configurationBasename)    modifiedPackageSpecs: developmentVersionString    packageSpecsDo: [ :versionSpec :packageSpec :monticelloWorkingCopy |       | repositories repositoryGroup wcRepositoryGroup |      wcRepositoryGroup := monticelloWorkingCopy repositoryGroup.      repositoryGroup := MCRepositoryGroup new.      repositories := packageSpec repositories        collect: [ :each | each createRepository ].      repositories isEmpty        ifTrue: [           repositories := versionSpec repositories            collect: [ :repoSpec | repoSpec createRepository ].          wcRepositoryGroup repositories notEmpty            ifTrue: [               repositories := repositories                select: [ :repo | wcRepositoryGroup includes: repo ] ].          repositories isEmpty            ifTrue: [               repositories := monticelloWorkingCopy repositoryGroup repositories                reject: [ :repo | repo = MetacelloPlatform current defaultPackageCache ] ] ].      repositories        do: [ :repo |           (monticelloWorkingCopy possiblyNewerVersionsIn: repo) notEmpty            ifTrue: [               self                notify:                  'There are possibly newer versions of the package '                    , packageSpec name printString , ' in the repository '                    , repo description printString                    ,                      '. Cancel and manually merge if you want to pick up the changes from the later version.' ].          repositoryGroup addRepository: repo ].      modifiedPackages at: packageSpec name put: repositoryGroup ].  cacheRepository := MetacelloPlatform current defaultPackageCache.  modifiedPackages isEmpty    ifTrue: [ self notify: 'Empty modified packages list'	"actually here for debugging purposes" ].  modifiedPackages    keysAndValuesDo: [ :packageName :repositoryGroup |       | gofer repositoryList packageSpec |      gofer := Gofer new.      gofer disablePackageCache.      (repositoryGroup repositories reject: [ :repo | repo = cacheRepository ])        do: [ :repository | gofer repository: repository ].      gofer package: packageName.      gofer commit: commitMessage ].  ^ modifiedPackages! !!MetacelloToolBox class methodsFor: 'validation' stamp: 'dkh 10/09/2014 10:27'!validateBaseline: baselineClass  "Check the baseline for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). "  <apiDocumentation>  ^ self validateBaseline: baselineClass debug: #() recurse: false! !!MetacelloToolBox class methodsFor: 'validation' stamp: 'dkh 10/09/2014 10:27'!validateBaseline: baselineClass debug: debugList recurse: aBool  "Check the baseline for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). "  <apiDocumentation>  ^ MetacelloMCVersionValidator    validateBaseline: baselineClass    debug: debugList    recurse: aBool! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 11/10/2014 16:35' prior: 35266278!baselineNamed: baseName  | baselineName |  "Check if the class does not exist"  baselineName := self baselineNameFrom: baseName.  (Smalltalk includesKey: baselineName asSymbol)    ifFalse: [       "Create the configuration class"      self ensureMetacello.      BaselineOf        subclass: baselineName        instVarNames: #()        classVars: #()        classInstVars: #()        poolDictionaries: #()        category: baselineName.      MetacelloPlatform current registerPackageNamed: baselineName ].  project := (MetacelloPlatform current globalNamed: baselineName asSymbol)    project! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 11/10/2014 16:35' prior: 35268947!configurationNamed: baseName  | configurationName |  "Check if the class does not exist"  configurationName := self configurationNameFrom: baseName.  (Smalltalk includesKey: configurationName asSymbol)    ifFalse: [       self ensureMetacello.	"Create the configuration class"      MetacelloPlatform current        copyClass:          (MetacelloPlatform current globalNamed: #'MetacelloConfigTemplate')        as: configurationName asSymbol        inCategory: configurationName asString.	"Create the package that has the same name"      MetacelloPlatform current registerPackageNamed: configurationName ].  project := (MetacelloPlatform current globalNamed: configurationName asSymbol)    project! !!MetacelloToolBox methodsFor: 'spec creation' stamp: 'dkh 11/10/2014 16:35' prior: 35269919!createConfiguration: baseName  | configurationName |  "Check if the class does not exist"  configurationName := (baseName beginsWith: 'ConfigurationOf')    ifTrue: [ baseName ]    ifFalse: [ 'ConfigurationOf' , baseName ].  (Smalltalk includesKey: configurationName asSymbol)    ifFalse: [       self ensureMetacello.	"Create the configuration class"      MetacelloPlatform current        copyClass:          (MetacelloPlatform current globalNamed: #'MetacelloConfigTemplate')        as: configurationName asSymbol        inCategory: configurationName asString.	"Create the package that has the same name"      MetacelloPlatform current registerPackageNamed: configurationName ].  ^ (MetacelloPlatform current globalNamed: configurationName asSymbol) project! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 09/17/2014 16:41'!methodSectionsFrom: inputVersionStringOrSymbol do: methodSectionBlock  | constructor version fromVersionString |  constructor := self constructor.  version := project version: inputVersionStringOrSymbol.  fromVersionString := version versionString.	"resolve symbolic versions"  constructor extractMethodSectionsFor: fromVersionString.  constructor methodSectionsDo: methodSectionBlock! !"Metacello-ToolBox"!!MCFileTreeRepository methodsFor: '*metacello-filetree' stamp: 'dkh 05/15/2014 20:47'!repositoryBranchName  "extract a branch name from the repository ... if possible"  (MetacelloPlatform current gitBranchNameFor: self directory fullName)    ifNotNil: [ :sha | ^ sha ].  ^ super repositoryBranchName! !!MCFileTreeRepository methodsFor: '*metacello-filetree' stamp: 'dkh 09/04/2014 13:48'!repositoryDescription  ^ self description , ' [' , self repositoryVersionString , ':'    , self repositoryBranchName , ']'! !!MCFileTreeRepository methodsFor: '*metacello-filetree' stamp: 'dkh 05/15/2014 20:48'!repositoryVersionString  "extract a version string from the repository ... if possible"  (MetacelloPlatform current gitCommitShaFor: self directory fullName)    ifNotNil: [ :sha | ^ sha ].  ^ super repositoryVersionString! !"Metacello-FileTree"!SystemOrganization addCategory: #'Metacello-GitBasedRepository'!MCFileTreeRepository subclass: #MCGitBasedNetworkRepository	instanceVariableNames: 'projectPath projectVersion repoPath projectVersionPattern'	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-GitBasedRepository'!MCGitBasedNetworkRepository class	instanceVariableNames: 'repoCacheDirectory repoDownloadCache siteUsername sitePassword'!!MCGitBasedNetworkRepository class methodsFor: 'accessing' stamp: 'dkh 10/14/2014 09:42'!basicDescription  ^ self subclassResponsibility! !!MCGitBasedNetworkRepository class methodsFor: 'private' stamp: 'dkh 10/14/2014 09:42'!cacheDirectory  self resetCacheDirectoryIfInvalid.  repoCacheDirectory ifNil: [ repoCacheDirectory := self defaultCacheDirectory ].  ^ repoCacheDirectory! !!MCGitBasedNetworkRepository class methodsFor: 'private' stamp: 'dkh 10/14/2014 09:42'!cacheDirectory: aDirectory  "explicitly set repoCacheDirectory"  repoCacheDirectory := aDirectory! !!MCGitBasedNetworkRepository class methodsFor: 'private' stamp: 'dkh 10/14/2014 09:42'!cacheDirectoryFor: projectPath	| cacheDirectory projectDirectory |		cacheDirectory := self cacheDirectory.	projectDirectory := MetacelloPlatform current directoryFromPath: projectPath relativeTo: cacheDirectory.	MetacelloPlatform current ensureDirectoryExists: projectDirectory.	^ projectDirectory! !!MCGitBasedNetworkRepository class methodsFor: 'accessing' stamp: 'dkh 11/10/2014 15:40'!cacheDirectoryPath  <preference: 'GitHub Cache' category: 'Metacello' description: '' type:    #'String'>  ^ MCFileTreeFileUtils current directoryPathString: self cacheDirectory! !!MCGitBasedNetworkRepository class methodsFor: 'accessing' stamp: 'dkh 11/10/2014 14:26'!cacheDirectoryPath: aString  self    cacheDirectory:      (aString        ifEmpty: [  ]        ifNotEmpty: [ MetacelloPlatform current fileHandleOn: aString ])! !!MCGitBasedNetworkRepository class methodsFor: 'private' stamp: 'dkh 10/14/2014 09:42'!defaultCacheDirectory  | defaultDirectory cacheDirectory |  defaultDirectory := MetacelloPlatform current defaultDirectory.  cacheDirectory := MetacelloPlatform current    directoryFromPath: self basicDescription , '-cache'    relativeTo: defaultDirectory.  MetacelloPlatform current ensureDirectoryExists: cacheDirectory.  ^ cacheDirectory! !!MCGitBasedNetworkRepository class methodsFor: 'accessing' stamp: 'dkh 10/14/2014 09:42'!description  ^ self basicDescription , '://'! !!MCGitBasedNetworkRepository class methodsFor: 'accessing' stamp: 'dkh 10/14/2014 09:42'!downloadCache  repoDownloadCache ifNil: [ repoDownloadCache := Dictionary new ].  ^ repoDownloadCache! !!MCGitBasedNetworkRepository class methodsFor: 'accessing' stamp: 'dkh 10/14/2014 09:42'!downloadCacheKey: projectPath version: versionString  ^ projectPath , ':::' , versionString! !!MCGitBasedNetworkRepository class methodsFor: 'initialization' stamp: 'dkh 10/14/2014 09:42'!flushDownloadCache  "self flushDownloadCache"  repoDownloadCache := nil! !!MCGitBasedNetworkRepository class methodsFor: 'utility' stamp: 'dkh 10/14/2014 09:42'!flushProjectEntry: projectPath version: versionString    self downloadCache removeKey: (self downloadCacheKey: projectPath version: versionString) ifAbsent: [  ]! !!MCGitBasedNetworkRepository class methodsFor: 'initialization' stamp: 'dkh 10/14/2014 09:42'!initialize  "self initialize"  Smalltalk addToStartUpList: self.  self flushDownloadCache.  self resetCacheDirectoryIfInvalid! !!MCGitBasedNetworkRepository class methodsFor: 'accessing' stamp: 'dkh 10/14/2014 09:42'!isAbstract    "abstract as far as creating new repositories interactively? yes"    ^ true! !!MCGitBasedNetworkRepository class methodsFor: 'testing' stamp: 'dkh 10/14/2014 09:42'!isEnabled	^false! !!MCGitBasedNetworkRepository class methodsFor: 'instance creation' stamp: 'dkh 10/14/2014 09:42'!location: locationUrl    ^ self location: locationUrl version: nil! !!MCGitBasedNetworkRepository class methodsFor: 'instance creation' stamp: 'dkh 10/14/2014 09:42'!location: locationUrl version: versionString    ^ self parseLocation: locationUrl version: versionString! !!MCGitBasedNetworkRepository class methodsFor: 'private' stamp: 'dkh 10/14/2014 10:14'!parseLocation: locationUrl version: versionString  "self 	parseLocation: 'github://dalehenrich/MetacelloRepository:master/monticello/repos/itory/path'	version: nil     "  | projectPath projectVersion repoPath headerSize desc projectDelim repoDelim versionDelim |  headerSize := self description size.  desc := locationUrl.  desc := desc copyFrom: headerSize + 1 to: desc size.  projectVersion := repoPath := nil.  projectDelim := desc indexOf: $/.  repoDelim := desc indexOf: $/ startingAt: projectDelim + 1.  (versionDelim := desc indexOf: $:) == 0    ifTrue: [       repoDelim == 0        ifTrue: [ projectPath := desc ]        ifFalse: [           projectPath := desc copyFrom: 1 to: repoDelim - 1.          repoPath := desc copyFrom: repoDelim + 1 to: desc size ] ]    ifFalse: [       projectPath := desc copyFrom: 1 to: versionDelim - 1.      repoDelim == 0        ifTrue: [ projectVersion := desc copyFrom: versionDelim + 1 to: desc size ]        ifFalse: [           projectPath := desc copyFrom: 1 to: versionDelim - 1.          self            parseProjectVersionField: [ :pv :rp |               projectVersion := pv.              repoPath := rp ]            desc: desc            versionDelim: versionDelim ] ].  versionString ~~ nil    ifTrue: [ projectVersion := versionString ].  ^ self new    projectPath: projectPath    projectVersion: projectVersion    repoPath: repoPath! !!MCGitBasedNetworkRepository class methodsFor: 'private' stamp: 'dkh 10/14/2014 09:42'!parseProjectVersionField: parseBlock desc: desc versionDelim: versionDelim  "Issue #234: have to allow for commitish containing slashes"  | strm done escaped repoDelim |  strm := WriteStream on: String new.  repoDelim := versionDelim + 1.  escaped := done := false.  [ done ]    whileFalse: [       | char |      repoDelim > desc size        ifTrue: [ done := true ]        ifFalse: [           char := desc at: repoDelim.          char == $\            ifTrue: [               escaped                ifTrue: [                   "$\ not legal in branch name ... literally ignored"                  escaped := false ]                ifFalse: [ escaped := true ] ]            ifFalse: [               char == $/                ifTrue: [                   escaped                    ifFalse: [ done := true ] ].              done                ifFalse: [ strm nextPut: char ].              escaped := false ].          repoDelim := repoDelim + 1 ] ].  repoDelim := repoDelim - 1.  parseBlock    value: strm contents    value: (desc copyFrom: repoDelim + 1 to: desc size)! !!MCGitBasedNetworkRepository class methodsFor: 'utility' stamp: 'dkh 10/14/2014 10:52'!projectDirectoryFrom: projectPath version: versionString  | mcPlatform theCacheDirectory projectDirectory downloadCacheKey cachePath pid |  downloadCacheKey := self downloadCacheKey: projectPath version: versionString.  mcPlatform := MetacelloPlatform current.  theCacheDirectory := mcPlatform    directoryFromPath: versionString    relativeTo: (self cacheDirectoryFor: projectPath).  cachePath := self downloadCache at: downloadCacheKey ifAbsent: [  ].  (cachePath isNil    or: [       (projectDirectory := mcPlatform        directoryFromPath: cachePath        relativeTo: theCacheDirectory) exists not ])    ifTrue: [       | url archive directory zipFileName |      MetacelloScriptGitBasedDownloadNotification new        projectPath: projectPath;        versionString: versionString;        signal.	"for testing purposes"      mcPlatform ensureDirectoryExists: theCacheDirectory.      url := self projectZipUrlFor: projectPath versionString: versionString.      pid := MetacelloPlatform current processPID.      zipFileName := MetacelloPlatform current        tempFileFor:          self basicDescription , '-' , pid , '-'            , (downloadCacheKey select: [ :c | c isAlphaNumeric ])        suffix: '.zip'.      archive := MetacelloPlatform current        downloadZipArchive: url        to: zipFileName.      directory := mcPlatform        directoryFromPath: (cachePath := archive members first fileName)        relativeTo: theCacheDirectory.      directory exists        ifFalse: [           MetacelloPlatform current            extractRepositoryFrom: zipFileName            to: theCacheDirectory fullName ].      self downloadCache at: downloadCacheKey put: cachePath.      projectDirectory := mcPlatform        directoryFromPath: cachePath        relativeTo: theCacheDirectory ].  ^ projectDirectory! !!MCGitBasedNetworkRepository class methodsFor: 'private' stamp: 'dkh 10/14/2014 11:18'!projectTagsUrlFor: aProjectPath  self subclassResponsibility! !!MCGitBasedNetworkRepository class methodsFor: 'version patterns' stamp: 'dkh 10/14/2014 14:48'!projectVersionFromString: aString  "strip leading $v if present and return an instance of MetacelloVersionNumber"  | versionString |  versionString := aString.  (versionString beginsWith: 'v')    ifTrue: [ versionString := versionString copyFrom: 2 to: versionString size ].  ^ MetacelloVersionNumber fromString: versionString! !!MCGitBasedNetworkRepository class methodsFor: 'private' stamp: 'dkh 10/14/2014 09:42'!projectZipUrlFor: projectPath versionString: versionString  self subclassResponsibility! !!MCGitBasedNetworkRepository class methodsFor: 'private' stamp: 'dkh 10/14/2014 09:42'!resetCacheDirectoryIfInvalid  "Reset if invalid"  repoCacheDirectory notNil    and: [       (MCFileTreeFileUtils current directoryExists: repoCacheDirectory)        ifFalse: [ repoCacheDirectory := nil ] ]! !!MCGitBasedNetworkRepository class methodsFor: 'site credentials' stamp: 'dkh 10/16/2014 13:50'!sitePassword  ^ sitePassword! !!MCGitBasedNetworkRepository class methodsFor: 'site credentials' stamp: 'dkh 10/16/2014 13:50'!sitePassword: aString  sitePassword := aString! !!MCGitBasedNetworkRepository class methodsFor: 'site credentials' stamp: 'dkh 10/16/2014 13:50'!siteUsername  ^ siteUsername! !!MCGitBasedNetworkRepository class methodsFor: 'site credentials' stamp: 'dkh 10/16/2014 13:50'!siteUsername: aString  siteUsername := aString! !!MCGitBasedNetworkRepository class methodsFor: 'site credentials' stamp: 'dkh 10/16/2014 14:05'!siteUsername: username sitePassword: pass  "MCBitbucketRepository siteUsername: '' sitePassword: ''"  "MCGitHubRepository siteUsername: '' sitePassword: ''"  self    siteUsername: username;    sitePassword: pass! !!MCGitBasedNetworkRepository class methodsFor: 'system startup' stamp: 'dkh 10/14/2014 09:42'!startUp: resuming    "Flush the GitHub download cache"    resuming        ifTrue: [ self flushDownloadCache ]! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: 'dkh 10/14/2014 09:42'!asRepositorySpecFor: aMetacelloMCProject  ^ aMetacelloMCProject repositorySpec    description: self description;    type: self class basicDescription;    yourself! !!MCGitBasedNetworkRepository methodsFor: 'initialize-release' stamp: 'dkh 10/14/2014 09:42'!canUpgradeTo: anMCGitBasedRepository  (anMCGitBasedRepository isKindOf: self class)    ifFalse: [ ^ false ].  ^ self projectPath = anMCGitBasedRepository projectPath    and: [ self repoPath = anMCGitBasedRepository repoPath ]! !!MCGitBasedNetworkRepository methodsFor: 'descriptions' stamp: 'dkh 10/14/2014 09:42'!description  | desc |  desc := self class description , self projectPath , ':'    , self projectVersionEscaped.  self repoPath isEmpty    ifTrue: [ ^ desc ].  ^ desc , '/' , self repoPath! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: 'dkh 10/14/2014 09:42'!directory  directory    ifNil: [       directory := self class        projectDirectoryFrom: self projectPath        version: self projectVersion.      self repoPath isEmpty        ifFalse: [           directory := MetacelloPlatform current            directoryFromPath: self repoPath            relativeTo: directory ] ]    ifNotNil: [       (MCFileTreeFileUtils current directoryExists: directory)        ifFalse: [           self flushCache.          ^ self directory ] ].  ^ directory! !!MCGitBasedNetworkRepository methodsFor: 'descriptions' stamp: 'dkh 10/14/2014 09:42'!directoryDescription    ^ self directory pathName! !!MCGitBasedNetworkRepository methodsFor: 'private' stamp: 'dkh 10/16/2014 13:51'!downloadJSONTags  | tagsUrl jsonObject |  tagsUrl := self projectTagsUrlFor: self projectPath.  jsonObject := MetacelloPlatform current    downloadJSON: tagsUrl    username: self class siteUsername    pass: self class sitePassword.  ^ self normalizeTagsData: jsonObject! !!MCGitBasedNetworkRepository methodsFor: 'initialize-release' stamp: 'dkh 10/14/2014 09:42'!flushCache  "the directory acts like a cache since we download the directory from a git-based repository (github, bitbucket, etc.)"  super flushCache.  self class flushDownloadCache.  directory := nil! !!MCGitBasedNetworkRepository methodsFor: 'initialize-release' stamp: 'dkh 10/14/2014 09:42'!flushForScriptGet    self class flushProjectEntry: self projectPath version: self projectVersion.    directory := nil! !!MCGitBasedNetworkRepository methodsFor: 'initialize-release' stamp: 'dkh 10/14/2014 09:42'!hasNoLoadConflicts: anMCGitBasedRepository  (anMCGitBasedRepository isKindOf: self class)    ifFalse: [ ^ false ].  ^ self projectPath = anMCGitBasedRepository projectPath    and: [       self repoPath = anMCGitBasedRepository repoPath        and: [ self projectVersion = anMCGitBasedRepository projectVersion ] ]! !!MCGitBasedNetworkRepository methodsFor: 'comparing' stamp: 'dkh 10/14/2014 09:42'!hash    ^ self description hash! !!MCGitBasedNetworkRepository methodsFor: 'initialize-release' stamp: 'dkh 10/14/2014 09:42'!initialize    super initialize.    directory := nil.	"we'll lazily create the directory instance"    self readonly: true! !!MCGitBasedNetworkRepository methodsFor: 'testing' stamp: 'dkh 10/14/2014 09:42'!isValid    ^ true! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: 'dkh 10/14/2014 09:42'!metacelloProjectClassFor: aScriptEngine    ^ MetacelloMCBaselineProject! !!MCGitBasedNetworkRepository methodsFor: 'private' stamp: 'dkh 10/14/2014 14:00'!normalizeTagsData: jsonObject  ^ self subclassResponsibility! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: 'dkh 10/14/2014 09:42'!projectPath    ^ projectPath! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: 'dkh 10/14/2014 09:42'!projectPath: anObject    projectPath := anObject! !!MCGitBasedNetworkRepository methodsFor: 'initialize-release' stamp: 'dkh 10/14/2014 10:17'!projectPath: aProjectPath projectVersion: aProjectVersion repoPath: aRepoPath  self projectPath: aProjectPath.  self projectVersion: aProjectVersion.	"Important that projectVersion be set AFTER projectPath"  self repoPath: aRepoPath! !!MCGitBasedNetworkRepository methodsFor: 'private' stamp: 'dkh 10/14/2014 11:18'!projectTagsUrlFor: aProjectPath  ^ self class projectTagsUrlFor: aProjectPath! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: 'dkh 10/14/2014 09:42'!projectVersion    (projectVersion == nil or: [ projectVersion isEmpty ])        ifTrue: [ projectVersion := 'master' ].    ^ projectVersion! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: 'dkh 10/15/2014 15:41'!projectVersion: aString  "Important that projectVersion be set AFTER projectPath, as projectPath needed for resolving projectVersionPattern"  | x |  aString    ifNil: [       projectVersion := aString.      ^ self ].  (x := aString    findDelimiters:      {$#.      $*.      $?}    startingAt: 1) <= aString size    ifTrue: [ self resolveProjectVersionPattern: aString ]    ifFalse: [ projectVersion := aString ]! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: 'dkh 10/14/2014 09:42'!projectVersionEscaped  | pv |  pv := self projectVersion.  (projectVersion includes: $/)    ifTrue: [ ^ pv copyReplaceAll: '/' with: '\/' ].  ^ pv! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: 'dkh 10/14/2014 10:03'!projectVersionPattern  "do not set projectVersionPattern unless it _is_ a pattern: includes $#, %*, or $?"  projectVersionPattern ifNil: [ ^ self projectVersion ].  ^ projectVersionPattern! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: 'dkh 10/14/2014 10:03'!projectVersionPattern: aString  "do not set projectVersionPattern unless it _is_ a pattern: includes $#, %*, or $?"  projectVersionPattern := aString! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: 'dkh 10/14/2014 09:42'!repoPath  repoPath ifNil: [ repoPath := '' ].  ^ repoPath! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: 'dkh 10/14/2014 09:42'!repoPath: anObject    repoPath := anObject! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: 'dkh 10/14/2014 09:42'!repositoryBranchName  "for git-based network repos, answer the value of the projectVersion field"  ^ self projectVersion! !!MCGitBasedNetworkRepository methodsFor: 'accessing' stamp: 'dkh 10/14/2014 09:42'!repositoryVersionString  "for git-based network repos, answer the SHA associated with the download: a commit SHA or tag SHA"  | versionComponents versionElement pathElements gitBasedPath repositoryDirPath projectDirPath projectDir projectVersionDir |  repositoryDirPath := self directory fullName.  projectDir := self class cacheDirectoryFor: self projectPath.  projectVersionDir := MCFileTreeFileUtils current    directoryFromPath: self projectVersion    relativeTo: projectDir.  projectDirPath := projectVersionDir fullName.  (repositoryDirPath beginsWith: projectDirPath)    ifFalse: [ ^ self projectVersion ].  gitBasedPath := repositoryDirPath    copyFrom: projectDirPath size + 2    to: repositoryDirPath size.  pathElements := gitBasedPath findTokens: '/'.  versionElement := pathElements at: 1.  versionComponents := versionElement findTokens: '-'.  ^ versionComponents last! !!MCGitBasedNetworkRepository methodsFor: 'private' stamp: 'dkh 10/15/2014 14:38'!resolveProjectVersionPattern: aString  "aString must conform to the syntax for MetacelloVersionNumber with the exception that aString may have a leading $v which is stripped before conversion to a MetacelloVersionNumber patterm"  | patternString tagDictionary matchingTags tagAssocs sortedMatchingTags theTag |  self projectPath    ifNil: [ self error: 'projectPath must be set to resolve project version pattern.' ].  patternString := (MCGitBasedNetworkRepository    projectVersionFromString: aString) asString.  tagDictionary := self downloadJSONTags.  tagAssocs := tagDictionary keys    collect: [ :tagName |       | tagVersion |      tagVersion := self class projectVersionFromString: tagName.      tagVersion -> tagName ].  matchingTags := tagAssocs select: [ :assoc | assoc key match: patternString ].  matchingTags isEmpty    ifTrue: [       projectVersion := aString.      ^ self        error:          'No tags matching the pattern ' , aString printString            , ' found for repository description '            , self description printString ].  sortedMatchingTags := matchingTags asArray sort: [ :a :b | a key <= b key ].  theTag := sortedMatchingTags last.  projectVersionPattern := aString.  projectVersion := theTag value! !"Metacello-GitBasedRepository"!SystemOrganization addCategory: #'Metacello-Bitbucket'!MCGitBasedNetworkRepository subclass: #MCBitbucketRepository	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Bitbucket'!!MCBitbucketRepository class methodsFor: 'accessing' stamp: 'dkh 09/29/2014 12:19'!basicDescription  ^ 'bitbucket'! !!MCBitbucketRepository class methodsFor: 'testing' stamp: 'JohanBrichau 10/11/2014 02:04'!isEnabled	^true! !!MCBitbucketRepository class methodsFor: 'private' stamp: 'dkh 10/14/2014 14:31'!projectTagsUrlFor: projectPath  ^ 'https://bitbucket.org/api/1.0/repositories/' , projectPath , '/tags'! !!MCBitbucketRepository class methodsFor: 'private' stamp: 'dkh 09/29/2014 13:24'!projectZipUrlFor: projectPath versionString: versionString  ^ 'https://bitbucket.org/' , projectPath , '/get/' , versionString , '.zip'! !!MCBitbucketRepository methodsFor: 'private' stamp: 'dkh 10/14/2014 15:21'!normalizeTagsData: jsonObject  "return a dictionay mapping the tag name to the commit SHA"  | tagDict |  jsonObject    at: 'error'    ifPresent: [ :errorObject |       self        error:          'Error accessing tags for bitbucket project: ' , self projectPath printString            , ' -> ' , (errorObject at: 'message') printString            ,              ((errorObject at: 'detail')                ifNil: [ '' ]                ifNotNil: [ :detail | ' :: ' , detail printString ]) ].  tagDict := Dictionary new.  jsonObject    keysAndValuesDo: [ :tag :tagObject |       | sha |      sha := tagObject at: 'node'.      tagDict at: tag put: sha ].  ^ tagDict! !"Metacello-Bitbucket"!MCGitBasedNetworkRepository subclass: #MCGitHubRepository	instanceVariableNames: ''	classVariableNames: 'CacheDirectory DownloadCache'	poolDictionaries: ''	category: 'Metacello-GitHub'!!MCGitHubRepository class methodsFor: 'accessing' stamp: 'dkh 09/29/2014 12:20'!basicDescription  ^ 'github'! !!MCGitHubRepository class methodsFor: 'private' stamp: 'dkh 09/29/2014 12:17' prior: 35299170!cacheDirectory  "use class var to survive upgrade when MCGitHubRepository moved to subclass of MCGitBasedRepository"  self resetCacheDirectoryIfInvalid.  CacheDirectory ifNil: [ CacheDirectory := self defaultCacheDirectory ].  ^ CacheDirectory! !!MCGitHubRepository class methodsFor: 'private' stamp: 'dkh 09/29/2014 12:17' prior: 35299397!cacheDirectory: aDirectory  "use class var to survive upgrade when MCGitHubRepository moved to subclass of MCGitBasedRepository"  CacheDirectory := aDirectory! !!MCGitHubRepository class methodsFor: 'accessing' stamp: 'dkh 09/29/2014 12:17' prior: 35300500!downloadCache  "use class var to survive upgrade when MCGitHubRepository moved to subclass of MCGitBasedRepository"  DownloadCache ifNil: [ DownloadCache := Dictionary new ].  ^ DownloadCache! !!MCGitHubRepository class methodsFor: 'initialization' stamp: 'dkh 09/29/2014 12:17' prior: 35300862!flushDownloadCache  "use class var to survive upgrade when MCGitHubRepository moved to subclass of MCGitBasedRepository"  "self flushDownloadCache"  DownloadCache := nil! !!MCGitHubRepository class methodsFor: 'testing' stamp: 'JohanBrichau 10/11/2014 02:04'!isEnabled	^true! !!MCGitHubRepository class methodsFor: 'private' stamp: 'dkh 10/14/2014 14:26'!projectTagsUrlFor: projectPath  ^ 'https://api.github.com/repos/' , projectPath , '/tags'! !!MCGitHubRepository class methodsFor: 'private' stamp: 'dkh 09/29/2014 12:24'!projectZipUrlFor: projectPath versionString: versionString  ^ 'https://github.com/' , projectPath , '/zipball/' , versionString! !!MCGitHubRepository class methodsFor: 'private' stamp: 'dkh 09/29/2014 12:17' prior: 35305346!resetCacheDirectoryIfInvalid  "use class var to survive upgrade when MCGitHubRepository moved to subclass of MCGitBasedRepository"  "Reset if invalid"  CacheDirectory notNil    and: [       (MCFileTreeFileUtils current directoryExists: CacheDirectory)        ifFalse: [ CacheDirectory := nil ] ]! !!MCGitHubRepository methodsFor: 'private' stamp: 'dkh 10/14/2014 15:18'!normalizeTagsData: jsonObject  "return a dictionay mapping the tag name to the commit SHA"  | tagDict |  jsonObject isDictionary    ifTrue: [       jsonObject        at: 'message'        ifPresent: [ :errorString |           self            error:              'Error accessing tags for github project: ' , self projectPath printString                , ' -> ' , errorString printString ] ].  tagDict := Dictionary new.  jsonObject    do: [ :tagObject |       | tag commit |      tag := tagObject at: 'name'.      commit := tagObject at: 'commit'.      tagDict at: tag put: (commit at: 'sha') ].  ^ tagDict! !MCGitHubRepository removeSelector: #repoPath:!MCGitHubRepository removeSelector: #repoPath!MCGitHubRepository removeSelector: #projectVersion:!MCGitHubRepository removeSelector: #projectVersion!MCGitHubRepository removeSelector: #projectPath:!MCGitHubRepository removeSelector: #projectPath!MCGitHubRepository removeSelector: #metacelloProjectClassFor:!MCGitHubRepository removeSelector: #isValid!MCGitHubRepository removeSelector: #initialize!MCGitHubRepository removeSelector: #hash!MCGitHubRepository removeSelector: #hasNoLoadConflicts:!MCGitHubRepository removeSelector: #flushForScriptGet!MCGitHubRepository removeSelector: #flushCache!MCGitHubRepository removeSelector: #directoryDescription!MCGitHubRepository removeSelector: #directory!MCGitHubRepository removeSelector: #description!MCGitHubRepository removeSelector: #asRepositorySpecFor:!MCGitHubRepository class removeSelector: #startUp:!MCGitHubRepository class removeSelector: #projectDirectoryFrom:version:!MCGitHubRepository class removeSelector: #parseLocation:version:!MCGitHubRepository class removeSelector: #location:version:!MCGitHubRepository class removeSelector: #location:!MCGitHubRepository class removeSelector: #isAbstract!MCGitHubRepository class removeSelector: #initialize!MCGitHubRepository class removeSelector: #flushProjectEntry:version:!MCGitHubRepository class removeSelector: #downloadCacheKey:version:!MCGitHubRepository class removeSelector: #description!MCGitHubRepository class removeSelector: #defaultCacheDirectory!MCGitHubRepository class removeSelector: #cacheDirectoryFor:!"Metacello-GitHub"!(Smalltalk at: #Metacello) new  configuration: 'MetacelloPreview';  version: #stable;  repository: 'github://dalehenrich/metacello-work:configuration';  load.!!BaselineOfMetacello methodsFor: 'baseline' stamp: 'ChristopheDemarey 7/10/2015 18:10' prior: 35323945!baseline: spec  <baseline>  spec    for: #'common'    do: [       spec postLoadDoIt: #'reprimeRegistryIssue197'.      spec baseline: 'FileTree'.      spec        project: 'Gofer'          with: [               spec                className: 'ConfigurationOfGofer';                versionString: #'stable';                loads: #('Core');                repository: 'http://seaside.gemtalksystems.com/ss/metacello' ];        project: 'Gofer Tests'          copyFrom: 'Gofer'          with: [ spec loads: #('Tests') ];        yourself.      spec        package: 'Metacello-Base';        package: 'Metacello-ToolBox'          with: [ spec requires: #('Metacello-Base' 'Metacello-Core') ];        package: 'Metacello-Core'          with: [               spec                requires: 'Metacello-Base';                includes: #('Metacello-MC' 'Metacello-Platform') ];        package: 'Metacello-Cypress' with: [ spec requires: 'Metacello-Core' ];        package: 'Metacello-FileTree'          with: [ spec requires: #('Metacello-MC' 'FileTree') ];        package: 'Metacello-GitBasedRepository'          with: [ spec requires: #('Metacello-MC' 'Metacello-FileTree') ];        package: 'Metacello-GitHub'          with: [ spec requires: #('Metacello-GitBasedRepository') ];        package: 'Metacello-Bitbucket'          with: [ spec requires: #('Metacello-GitBasedRepository') ];        package: 'Metacello-MC'          with: [ spec requires: #('Metacello-Core' 'Gofer') ];        package: 'Metacello-Platform'          with: [ spec requires: #('Metacello-MC') ];        package: 'Metacello-Reference'          with: [ spec requires: #('Metacello-MC') ];        package: 'Metacello-Tutorial'          with: [ spec requires: #('Metacello-Core') ];        package: 'Metacello-TestsCore'          with: [ spec requires: #('Metacello-Core') ];        package: 'Metacello-TestsMCResources'          with: [               spec                postLoadDoIt: #'testResourcePostLoadDoIt';                includes: #('Metacello-TestsCommonMC');                requires: #('Metacello-Core') ];        package: 'Metacello-TestsMCCore'          with: [               spec                requires:                  #('Metacello-Core' 'Metacello-TestsCore' 'Metacello-ToolBox' 'Metacello-TestsMCResources') ];        package: 'Metacello-TestsMC'          with: [               spec                requires:                  #('Metacello-MC' 'Gofer Tests' 'Metacello-ToolBox' 'Metacello-GitHub' 'Metacello-Bitbucket' 'Metacello-TestsMCResources') ];        package: 'Metacello-TestsMCA'          with: [ spec requires: #('Metacello-TestsMC') ];        package: 'Metacello-TestsMCB'          with: [ spec requires: #('Metacello-TestsMC') ];        package: 'Metacello-TestsCommonMC'          with: [               spec                file: 'Metacello-TestsCommonMC.common';                requires: 'Metacello-TestsMCResources' ];        package: 'Metacello-TestsReference'          with: [ spec requires: #('Metacello-Reference') ];        package: 'Metacello-TestsTutorial'          with: [ spec requires: #('Metacello-Tutorial' 'Metacello-TestsMCResources') ];        yourself.      spec        group: 'default' with: #('batch' 'Metacello-ToolBox');        group: 'batch'          with: #('Metacello-Core' 'Metacello-GitHub' 'Metacello-Bitbucket');        group: 'Base Configuration' with: #('Metacello-Base');        group: 'Core' with: #('default');        group: 'Cypress' with: #('Metacello-Cypress');        group: 'Tutorial' with: #('Metacello-Tutorial' 'Metacello-Reference');        group: 'UI' with: #('default');        group: 'TravisCI_1'          with:            #('Metacello-TestsCore' 'Metacello-TestsReference' 'Metacello-TestsMCCore');        group: 'TravisCI_2' with: #('Metacello-TestsMCA');        group: 'TravisCI_3'          with: #('Metacello-TestsMCB' 'Metacello-TestsTutorial');        group: 'TravisCI' with: #('TravisCI_1' 'TravisCI_2' 'TravisCI_3');        group: 'Tests'          with:            #('Metacello-TestsCore' 'Metacello-TestsTutorial' 'Metacello-TestsMCA' 'Metacello-TestsMCB' 'Metacello-TestsReference' 'Metacello-TestsMCCore');        yourself ].  spec    for: #'squeakCommon'    do: [       spec        configuration: 'HelpSystem'          with: [               spec                versionString: '1.1';                loads: #('Core');                repository: 'http://www.squeaksource.com/MetacelloRepository' ];        yourself.      spec        package: 'Metacello-TestsPlatform'          with: [               spec                requires: #('Metacello-Platform');                file: 'Metacello-TestsPlatform.squeakCommon' ];        package: 'Metacello-Help' with: [ spec requires: 'HelpSystem' ];        yourself.      spec        group: 'Tests' with: #('Metacello-TestsPlatform');        group: 'TravisCI_1' with: #('Metacello-TestsPlatform');        yourself ].  spec    for: #(#'pharo1.x' #'pharo2.x')    do: [       spec        project: 'ProfStef'          with: [               spec                className: 'ConfigurationOfProfStef';                versionString: #'stable';                repository:                    'http://smalltalkhub.com/mc/PharoExtras/ProfStef/main' ];        configuration: 'OSProcess'          with: [               spec                versionString: #'stable';                repository: 'http://seaside.gemtalksystems.com/ss/metacello' ];        yourself.      spec        package: 'Metacello-ProfStef'          with: [ spec requires: #('Metacello-Core' 'ProfStef' 'Metacello-ToolBox') ];        package: 'Metacello-TestsProfStef'          with: [ spec requires: #('Metacello-ProfStef') ];        package: 'Metacello-PharoCommonPlatform'          with: [ spec requires: #('Metacello-MC') ];        package: 'Metacello-Platform'          with: [ spec requires: #('Metacello-PharoCommonPlatform') ];        yourself.      spec        group: 'Tests' with: #('Metacello-TestsProfStef');        group: 'Tutorial' with: #('Metacello-ProfStef');        yourself ].  spec    for: #'pharo1.x'    do: [       spec        configuration: 'OSProcess'          with: [ spec repository: 'http://www.squeaksource.com/MetacelloRepository' ];        package: 'Metacello-Platform'          with: [               spec                file: 'Metacello-Platform.pharo';                requires: #('OSProcess') ] ].  spec    for: #'pharo1.1.x'    do: [       spec        baseline: 'FileTree'        with: [ spec repository: 'github://dalehenrich/filetree:pharo1.1/repository' ] ].  spec    for: #'pharo1.2.x'    do: [       spec        baseline: 'FileTree'        with: [ spec repository: 'github://dalehenrich/filetree:pharo1.1/repository' ] ].  spec    for: #'pharo1.3.x'    do: [       spec        baseline: 'FileTree'        with: [ spec repository: 'github://dalehenrich/filetree:pharo1.3/repository' ] ].  spec    for: #'pharo1.4.x'    do: [       spec        baseline: 'FileTree'        with: [ spec repository: 'github://dalehenrich/filetree:pharo1.4/repository' ] ].  spec    for: #'pharo2.x'    do: [       spec        configuration: 'OSProcess'          with: [ spec repository: 'http://ss3.gemtalksystems.com/ss/MetaRepoForPharo20' ];        yourself.      spec        package: 'Metacello-Platform'          with: [               spec                file: 'Metacello-Platform.pharo20';                requires: #('OSProcess') ];        package: 'Metacello-TestsCommonMC'          with: [ spec file: 'Metacello-TestsCommonMC.pharo20' ];        yourself.      spec        baseline: 'FileTree'        with: [ spec repository: 'github://dalehenrich/filetree:pharo2.0/repository' ] ].  spec    for: #(#'pharo3.x' #'pharo4.x' #'pharo5.x')    do: [       spec        package: 'Metacello-PharoCommonPlatform'          with: [ spec requires: #('Metacello-MC') ];        package: 'Metacello-Platform'          with: [               spec                file: 'Metacello-Platform.pharo30';                requires: #('Metacello-PharoCommonPlatform') ];        package: 'Metacello-TestsCommonMC'          with: [ spec file: 'Metacello-TestsCommonMC.pharo20' ];        yourself ].  spec    for: #(#'pharo3.x')    do: [       spec        baseline: 'FileTree'        with: [ spec repository: 'github://dalehenrich/filetree:pharo3.0/repository' ] ].  spec    for: #(#'pharo4.x')    do: [       spec        baseline: 'FileTree'        with: [ spec repository: 'github://dalehenrich/filetree:pharo4.0/repository' ] ].  spec    for: #(#'pharo5.x')    do: [       spec        baseline: 'FileTree'        with: [ spec repository: 'github://dalehenrich/filetree:pharo5.0/repository' ] ].  spec    for: #'squeak'    do: [       spec        baseline: 'FileTree'          with: [ spec repository: 'github://dalehenrich/filetree:squeak4.3/repository' ];        yourself.      spec        package: 'SqueakSSL-Core'        with: [ spec repository: 'http://www.squeaksource.com/SqueakSSL' ].      spec        package: 'WebClient-Core'        with: [ spec repository: 'http://ss3.gemstone.com/ss/WebClient' ].      spec        package: 'Metacello-Platform'          with: [               spec                file: 'Metacello-Platform.squeak';                requires: #('WebClient-Core' 'SqueakSSL-Core') ];        yourself ].  spec    for: #'gemstone'    do: [       spec        baseline: 'FileTree'        with: [ spec repository: 'github://dalehenrich/filetree:gemstone2.4/repository' ].      spec        package: 'Metacello-Platform'          with: [               spec                file: 'Metacello-Platform.gemstone';                postLoadDoIt: #'gemstone10beta311PostLoadDoIt' ];        package: 'Metacello-TestsPlatform'          with: [               spec                requires: #('Metacello-Platform');                file: 'Metacello-TestsPlatform.gemstone' ];        package: 'Metacello-GemStone-TestsMCB'          with: [ spec requires: #('Metacello-TestsMCB') ];        yourself.      spec        group: 'Tests' with: #('Metacello-TestsPlatform');        group: 'TravisCI_1' with: #('Metacello-TestsPlatform');        group: 'TravisCI_3' with: #('Metacello-GemStone-TestsMCB');        yourself ].  spec    for: #'gs2.x'    do: [       spec        package: 'Metacello-GS2x-Platform'          with: [ spec requires: 'Metacello-Platform' ];        package: 'Metacello-Platform'          with: [ spec includes: 'Metacello-GS2x-Platform' ];        yourself ].  spec    for: #'gs3.x'    do: [       spec        package: 'Metacello-GS3x-Platform'          with: [ spec requires: 'Metacello-Platform' ];        package: 'Metacello-Platform'          with: [ spec includes: 'Metacello-GS3x-Platform' ];        yourself ]! !"BaselineOfMetacello"!"Now load latest version of Metacello"(Smalltalk at: #Metacello) new  baseline: 'Metacello';  repository: 'github://dalehenrich/metacello-work:master/repository';  get.!ConfigurationOf subclass: #BaselineOf	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Base'!!BaselineOf commentStamp: 'dkh 5/30/2012 16:30' prior: 34573868!You should use a *baseline* when you are using a disk-based sourcecode manager (SCM) like [git][1].When using a disk-based SCM it is not necessary to use the Metacello*version* method, because it is intended for use with `.mcz` files. With a disk-based SCM you only need a single `baseline:` method. Whenyou change the structure of your project you can change the baseline andsave everything in a single commit. So multiple `baseline:` methods areno longer needed.You may still need a *configuration* when using a *baseline*. The[Sample project][3] on GitHub has a good example of a configuration usedin conjunction with a *baseline*. See the [**ConfigurationOf** class comment][2] for information on creating a *configuration*.To create a new Metacello baseline:1. Create a subclass of the **BaselineOf** class. The baseline   class for your project should be named by appending the name of   your project to the string `BaselineOf`. The name of the category and   package should be the same as the name of the class:    ```Smalltalk    BaselineOf subclass: #BaselineOfExample      instanceVariableNames: ''      classVariableNames: ''      poolDictionaries: ''      category: 'BaselineOfExample'    ```2. Create a **baseline:** method where you specify the structure of your project:    ```Smalltalk    baseline: spec      <baseline>      spec for: #common do: [        spec          package: 'Example-Core';          package: 'Example-Tests' with: [            spec requires: 'Example-Core' ]].    ```3. Create a Monticello package for your **BaselineOf** class and save it in the repository where your packages are stored.4. To load a package from GitHub that contains a baseline evaluate the following:```Smalltalk| repositorySpec |"edit to match your username, repository name and branch"repositorySpec := 'dalehenrich/metacello-work:master'.Metacello new  baseline: 'Sample';  repository: 'github://', repositorySpec;  load.```For further documentation see For more information on the [github://](MetacelloScriptingAPI.md#github) url specifigation see the [Metacello Scripting APIreference](MetacelloScriptingAPI.md). There more information on [working with GitHub here](GettingStartedWithGitHub.md).[1]: http://git-scm.com/[2]: https://github.com/dalehenrich/metacello-work/blob/master/repository/Metacello-Base.package/ConfigurationOf.class/README.md[3]: https://github.com/dalehenrich/sample/tree/configuration/ConfigurationOfSample.package/ConfigurationOfSample.class!!Metacello methodsFor: 'api repository shortcuts' stamp: 'topa 1/19/2015 15:25'!swa: projectName    self swasource: projectName! !!Metacello methodsFor: 'api repository shortcuts' stamp: 'topa 1/19/2015 15:25'!swasource: projectName    self repository: 'http://www.hpi.uni-potsdam.de/hirschfeld/squeaksource/' , projectName! !"Metacello-Base"!MetacelloVersionMethodSpec subclass: #MetacelloBaselineOfMethodSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Metacello-Core-Constructors'!!MetacelloVersionConstructor methodsFor: 'private' stamp: 'pad 8/25/2015 13:30' prior: 35356509!collectAllVersionsFromVersionImportPragmasInto: versionMap using: executionBlock satisfiedPragmas: pragmaDict    | defined done completed count |    done := false.    completed := IdentitySet new.    count := 0.    [     count := count + 1.    count > 10000        ifTrue: [ self error: 'Apparent loop in import expansion' ].    done ]        whileFalse: [             done := true.            pragmaDict                keysAndValuesDo: [ :versionString :pragmaColl |                     | versionSpec |                    versionSpec := nil.                    defined := false.                    [                     pragmaColl                        do: [ :pragma |                             (completed includes: pragma)                                ifFalse: [                                     | imports |                                    done := false.                                    imports := pragma argumentAt: 2.                                    imports                                        detect: [ :importedVersion | (versionMap includesKey: importedVersion) not ]                                        ifNone: [                                             imports                                                do: [ :importedVersion |                                                     | version |                                                    (version := versionMap at: importedVersion ifAbsent: [  ]) ~~ nil                                                        ifTrue: [                                                             defined := true.                                                            completed add: pragma.                                                            versionSpec == nil                                                                ifTrue: [ versionSpec := version spec copy ]                                                                ifFalse: [ versionSpec := versionSpec mergeSpec: version spec copy ].                                                            versionSpec versionString: versionString.                                                            executionBlock value: versionSpec value: pragma ] ] ] ] ] ]                        on: Error                        do: [ :ex |                             (MetacelloErrorInProjectConstructionNotification versionString: versionSpec versionString exception: ex)                                ifTrue: [ ^ ex pass ]                                ifFalse: [                                     self errorMap at: versionSpec versionString put: ex.                                                                     defined := false ] ].                    defined                        ifTrue: [                             | version importedVersions |                            importedVersions := OrderedCollection new.                            version := versionSpec createVersion.                            pragmaColl do: [ :pragma | importedVersions addAll: (pragma argumentAt: 2) ].                            version importedVersions: importedVersions.                            self validateVersionString: versionString againstSpec: versionSpec.                            versionMap at: versionSpec versionString put: version ].                    self reset ] ]! !!MetacelloProjectSpecForLoad methodsFor: 'operations' stamp: 'dkh 02/19/2015 13:02' prior: 35382301!performLoad  | displayString spec |  spec := self projectSpec.  displayString := 'Project: ' , spec name.  spec versionString ~~ nil    ifTrue: [ displayString := displayString , ' ' , spec versionString ].  Transcript    cr;    show: displayString.  self hasOverride    ifTrue: [       | override |      override := self overrideProjectSpec copy.      override mergeScriptLoads: spec.      override loadVersion: nil ]    ifFalse: [       | vrsn |      vrsn := self useDetermineVersionForLoad        ifTrue: [ spec determineCurrentVersionForLoad ]        ifFalse: [ spec versionOrNil ].      (spec asProjectSpecForVersion: vrsn) loadVersion: vrsn ]! !!MetacelloBaselineOfMethodSpec methodsFor: 'method generation' stamp: 'dkh 10/23/2015 16:26'!methodSelectorAndPragma: aSelector imports: importList on: strm  strm    nextPutAll: aSelector asString , ' spec';    cr;    tab;    nextPutAll: '<baseline>'! !!MetacelloBaselineOfMethodSpec methodsFor: 'method generation' stamp: 'dkh 10/23/2015 16:26'!methodSource  | strm |  strm := WriteStream on: String new.  self methodSelectorAndPragma: self selector imports: self imports on: strm.  self    methodSection: self    pre: [ :methodSection :indent |       strm        cr;        tab: indent;        nextPutAll: 'spec for: ' , methodSection attributePrintString , ' do: [';        cr.      methodSection versionSpec        configMethodOn: strm        last: methodSection methodSections isEmpty        indent: indent + 1 ]    last: false    post: [ :methodSection :indent :last |       strm nextPutAll: ' ].'.      (last        or: [ indent = 1 or: [ methodSection methodSections isEmpty and: [ indent = 1 ] ] ])        ifTrue: [ strm cr ] ]    indent: 0.  ^ strm contents! !!MetacelloBaselineOfMethodSpec methodsFor: 'accessing' stamp: 'dkh 10/23/2015 16:26'!versionString  ^ MetacelloMCBaselineProject singletonVersionName! !!MetacelloProjectRegistrationVersionInfo methodsFor: 'accessing' stamp: 'dkh 02/14/2015 09:16'!setVersionString: anObject  "set versionString, only if it does not already have avalue"  versionString ifNil: [ self versionString: anObject ]! !!MetacelloProjectRegistry methodsFor: 'registration' stamp: 'dkh 02/14/2015 07:52' prior: 35452424!registerProjectRegistration: aMetacelloProjectRegistration  "unconditionally register <newRegistration> ... use with care"  aMetacelloProjectRegistration configurationProjectSpec copy    ifNotNil: [ :spec |       self configurationRegistry        at: spec className        ifPresent: [ :existing |           (existing configurationProjectSpec registrationsCompareEqual: spec)            ifFalse: [               Transcript                cr;                show:                    'REGISTRATION OF INCOMPATABLE PROJECTS: ' , existing printString                        , ' REPLACED BY '                        , aMetacelloProjectRegistration printString ] ].      spec versionOrNil        ifNotNil: [ :version |           "resolve symbolic versions for loaded projects"          spec versionString: version versionString ].      aMetacelloProjectRegistration configurationProjectSpec: spec.      (aMetacelloProjectRegistration respondsTo: #'versionInfo')        ifTrue: [ aMetacelloProjectRegistration versionInfo setVersionString: spec versionString ].      spec immutable.      self configurationRegistry        at: spec className        put: aMetacelloProjectRegistration ].  aMetacelloProjectRegistration baselineProjectSpec    ifNotNil: [ :spec |       self baselineRegistry        at: spec className        ifPresent: [ :existing |           (existing baselineProjectSpec registrationsCompareEqual: spec)            ifFalse: [               Transcript                cr;                show:                    'REGISTRATION OF INCOMPATABLE PROJECTS: ' , existing printString                        , ' REPLACED BY '                        , aMetacelloProjectRegistration printString ] ].      (aMetacelloProjectRegistration respondsTo: #'versionInfo')        ifTrue: [           aMetacelloProjectRegistration versionInfo            setVersionString: spec repositoryVersionString ].      spec immutable.      self baselineRegistry        at: spec className        put: aMetacelloProjectRegistration ].  aMetacelloProjectRegistration immutable! !!MetacelloProjectSpec methodsFor: 'printing' stamp: 'dkh 10/31/2015 11:08'!configHasVersionString  ^ self versionString ~~ nil! !!MetacelloProjectSpec methodsFor: 'printing' stamp: 'dkh 10/31/2015 15:41' prior: 34782407!configMethodBodyOn: aStream indent: indent  ^ self configMethodBodyOn: aStream indent: indent fromShortCut: false! !!MetacelloProjectSpec methodsFor: 'printing' stamp: 'dkh 10/31/2015 15:45'!configMethodBodyOn: aStream indent: indent fromShortCut: fromShortCut  | hasVersionString hasOperator hasProjectPackage hasLoads hasClassName hasPreLoadDoIt hasPostLoadDoIt |  hasClassName := self hasClassName.  hasVersionString := self configHasVersionString.  hasOperator := operator ~~ nil.  hasProjectPackage := self hasRepository    or: [ hasClassName & (self getFile ~~ nil) ].  hasLoads := self loads ~~ nil.  hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.  hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.  hasClassName    ifTrue: [       hasVersionString | hasOperator | hasProjectPackage | hasLoads        ifTrue: [           aStream            cr;            tab: indent + 1 ]        ifFalse: [ aStream space ].      aStream nextPutAll: 'className: ' , self className printString.      hasVersionString | hasPreLoadDoIt | hasPostLoadDoIt | hasOperator        | hasLoads | hasProjectPackage        ifTrue: [ aStream nextPut: $; ] ].  hasVersionString    ifTrue: [       | vs |      hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPreLoadDoIt        | hasPostLoadDoIt        ifTrue: [           aStream            cr;            tab: indent + 1 ]        ifFalse: [ aStream space ].      vs := self versionString.      aStream nextPutAll: 'versionString: '.      vs isSymbol        ifTrue: [ aStream nextPut: $# ].      aStream nextPutAll: vs asString printString.      hasPreLoadDoIt | hasPostLoadDoIt | hasOperator | hasProjectPackage        | hasLoads        ifTrue: [ aStream nextPut: $; ] ].  hasPreLoadDoIt    ifTrue: [       hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPreLoadDoIt        ifTrue: [           aStream            cr;            tab: indent + 1 ]        ifFalse: [ aStream space ].      aStream nextPutAll: 'preLoadDoIt: '.      self preLoadDoIt value isSymbol        ifTrue: [           aStream            nextPut: $#;            nextPutAll: self preLoadDoIt value asString printString ]        ifFalse: [ aStream nextPutAll: self preLoadDoIt value asString ].      hasPostLoadDoIt | hasOperator | hasProjectPackage | hasLoads        ifTrue: [ aStream nextPut: $; ] ].  hasPostLoadDoIt    ifTrue: [       hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPostLoadDoIt        ifTrue: [           aStream            cr;            tab: indent + 1 ]        ifFalse: [ aStream space ].      aStream nextPutAll: 'postLoadDoIt: '.      self postLoadDoIt value isSymbol        ifTrue: [           aStream            nextPut: $#;            nextPutAll: self postLoadDoIt value asString printString ]        ifFalse: [ aStream nextPutAll: self postLoadDoIt value asString ].      hasOperator | hasProjectPackage | hasLoads        ifTrue: [ aStream nextPut: $; ] ].  hasOperator    ifTrue: [       hasClassName | hasVersionString | hasProjectPackage | hasLoads | hasPreLoadDoIt        | hasPostLoadDoIt        ifTrue: [           aStream            cr;            tab: indent + 1 ]        ifFalse: [ aStream space ].      aStream nextPutAll: 'operator: #' , self operator asString printString.      hasProjectPackage | hasLoads        ifTrue: [ aStream nextPut: $; ] ].  hasLoads    ifTrue: [       hasClassName | hasVersionString | hasOperator | hasProjectPackage        | hasPreLoadDoIt | hasPostLoadDoIt        ifTrue: [           aStream            cr;            tab: indent + 1 ]        ifFalse: [ aStream space ].      aStream nextPutAll: 'loads: #('.      self loads do: [ :str | aStream nextPutAll: str printString , ' ' ].      aStream nextPut: $).      hasProjectPackage        ifTrue: [ aStream nextPut: $; ] ].  hasProjectPackage    ifTrue: [       | hasName hasRepo |      hasRepo := self hasRepository.      hasName := self file ~= self className.      hasName        ifTrue: [           hasClassName | hasVersionString | hasOperator | hasLoads | hasPreLoadDoIt            | hasPostLoadDoIt            ifTrue: [               aStream                cr;                tab: indent + 1 ]            ifFalse: [ aStream space ].          aStream nextPutAll: 'file: ' , self file printString.          hasRepo            ifTrue: [ aStream nextPut: $; ] ].      hasRepo        ifTrue: [           | repos |          repos := self repositories map values.          repos size = 1            ifTrue: [               fromShortCut                ifTrue: [                   hasClassName | hasVersionString | hasOperator | hasLoads | hasPreLoadDoIt                    | hasPostLoadDoIt | hasName                    ifTrue: [                       aStream                        cr;                        tab: indent + 1 ]                    ifFalse: [ aStream space ] ]                ifFalse: [                   aStream                    cr;                    tab: indent + 1 ].              repos first configMethodCascadeOn: aStream lastCascade: true ]            ifFalse: [               aStream cr.              self repositories configMethodCascadeOn: aStream indent: indent ] ] ]! !!MetacelloProjectSpec methodsFor: 'printing' stamp: 'dkh 10/31/2015 15:41' prior: 34788656!configShortCutMethodOn: aStream member: aMember indent: indent  | hasVersionString hasOperator hasProjectPackage hasLoads hasClassName hasPreLoadDoIt hasPostLoadDoIt |  hasClassName := self hasClassName.  hasVersionString := self configHasVersionString.  hasOperator := operator ~~ nil.  hasProjectPackage := self hasRepository    or: [ hasClassName & (self getFile ~~ nil or: [ className ~= self name ]) ].  hasLoads := self loads ~~ nil.  hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.  hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.  hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPreLoadDoIt    | hasPostLoadDoIt    ifTrue: [       (aMember methodUpdateSelector == #'copy:'        or: [ aMember methodUpdateSelector == #'with:' ])        ifTrue: [           aStream            nextPutAll: 'with: [';            cr ]        ifFalse: [           aStream            nextPutAll: 'overrides: [';            cr ].      aStream        tab: indent;        nextPutAll: 'spec'.      self configMethodBodyOn: aStream indent: indent fromShortCut: true.      aStream nextPutAll: ' ]'.      ^ self ].  hasVersionString    ifTrue: [       | vs |      vs := self versionString.      aStream nextPutAll: 'with: '.      vs isSymbol        ifTrue: [ aStream nextPut: $# ].      aStream nextPutAll: vs asString printString ]! !!MetacelloPlatform methodsFor: 'github/bitbucket support' stamp: 'dkh 03/18/2015 06:40'!downloadJSON: url eTagsCache: eTagsCache eTagsKey: eTagsKey username: username pass: pass  "return result of parsing JSON downloaded from url. username:pass may be nil, but calls will be subject to severe rate limits."  "To minimize GitHub rate limiting problems, we are caching the ETags for the tag request: https://developer.github.com/v3/#conditional-requests"  ^ self downloadJSON: url username: username pass: pass! !!MetacelloProjectRegistration methodsFor: 'accessing' stamp: 'dkh 02/14/2015 09:15' prior: 35447131!versionInfo  versionInfo    ifNil: [       versionInfo := MetacelloProjectRegistrationVersionInfo new.      self        configurationProjectSpecIfPresent: [ versionInfo versionString: self version ]        ifAbsent: [           "do not set versionString for freshly minted baseline ...            see https://github.com/dalehenrich/metacello-work/issues/328"           ] ].  ^ versionInfo! !"Metacello-Core"!!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 34994645!atomicLoadPackageSpecs: packageSpecs repositories: repositories	self loaderPolicy 		pushAtomicLoadDirectivesDuring: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ]		for: self! !!MetacelloFetchingMCSpecLoader methodsFor: 'doits' stamp: 'dkh 6/8/2012 14:04:22' prior: 34999851!postLoad: packageOrVersionSpec	(MetacelloDirective postLoadSpec: packageOrVersionSpec loader: self)  addTo: self loadDirective! !!MetacelloFetchingMCSpecLoader methodsFor: 'doits' stamp: 'dkh 6/8/2012 14:04:22' prior: 35000084!preLoad: packageOrVersionSpec	(MetacelloDirective preLoadSpec: packageOrVersionSpec loader: self) addTo: self loadDirective! !!MetacelloFetchingMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 35001810!resolvePackageSpec: packageSpec cachedGofer: gofer	|  versionReference references |	versionReference := packageSpec goferLoaderReference.	(references := versionReference resolveAllWith: gofer) isEmpty 		ifTrue: [ ^nil ].	^references last asMetacelloCachingResolvedReference.! !!MCRepository methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 35004749!projectVersion: aString    "noop"! !!MetacelloLoadingMCSpecLoader methodsFor: 'packages' stamp: 'dkh 6/8/2012 14:04:22' prior: 35008770!latestPackage: aString fromRepository: repositorySpecs	| gofer |	gofer := MetacelloGofer new.	gofer disablePackageCache.	(self repositoriesFrom: repositorySpecs) do: [:repo | gofer repository: repo ].	^([(GoferPackageReference name: aString) resolveWith: gofer]		on: Error		do: [:ignored | ^ nil ]) name! !!MetacelloMCProjectSpec methodsFor: 'scripting' stamp: 'dkh 02/19/2015 13:06'!asProjectSpecForVersion: vrsn  ^ self! !!MetacelloMCProjectSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34974877!compareRelativeCurrentVersion: anOperator targetVersionStatus: targetVersionStatus using: anMCLoader	| cv vrsn |	(vrsn := self versionOrNil) == nil ifTrue: [ ^false ].	(cv := self relativeCurrentVersion) == nil ifTrue: [ ^false ].	(targetVersionStatus includes: cv versionStatus)		ifTrue: [ ^cv perform: anOperator with: vrsn ].	^false! !!MetacelloMCProjectSpec methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 34985641!packageFileSpecFor: aMetacelloPackagesSpec	^(aMetacelloPackagesSpec project projectReferenceSpec)			name: self name;			projectReference: self copy;			yourself.! !!MetacelloConfigTemplateExample class methodsFor: 'development support' stamp: 'ChristopheDemarey 1/15/2014 11:32' prior: 35459260!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!MetacelloConfigTemplateExample class methodsFor: 'private' stamp: 'ChristopheDemarey 1/15/2014 11:32' prior: 35459631!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!MetacelloConfigTemplateExample methodsFor: 'tags' stamp: 'ChristopheDemarey 1/15/2014 11:32' prior: 35464798!development: spec	"By convention the development branch should point to a fixed version that is regularly updated and might contain unstable code.	The name used by Metacello is only defined by the following pragma:"	<symbolicVersion: #development >		"For the development tag refer to a fixed version which you update if you commit new code.	Note that you can refer here to any other version name from this configuration"	spec for: #'common' version: 'dev'.! !!MetacelloConfigTemplateExample methodsFor: 'tags' stamp: 'ChristopheDemarey 1/15/2014 11:32' prior: 35467139!stable: spec	"Symbolic versions can be used to introduce an indirection to a version number.	The real name used by Metacello is only defined by the following pragma:"	<symbolicVersion: #stable >		"If another version is stable for a differen Smalltalk use a specific name"	"spec for: #'pharo1.4.x' version: '0.9'"		"Specfiy which exact version you want to load"	spec for: #'common' version: '1.0'.! !!MetacelloMCVersionSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 35143406!isSomethingLoadedAgainst: resolvedPackageAndProjectNames	"at least one package loaded"	(self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames) isSomethingLoaded: [ :ignored | ^ true ].	^ false! !!MetacelloMCVersionSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 35147171!packagesNeedSavingVisited: visitedProjects into: aCollection	self packages map valuesDo: [:pkg | pkg packagesNeedSavingVisited: visitedProjects using: self repositories map values into: aCollection ].! !!MetacelloMCVersionSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 35149686!updateForSpawnMethod: sourceSpec	"This means that this spec was used in a baseline and will be used in a version .... drop all information that isn't useful"		repositories := preLoadDoIt := postLoadDoIt := nil.! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 35042894!allPackagesForSpecNamed: aStringOrArray ifAbsent: aBlock	"resolves list of packages associated with the named spec.	   If the spec is a packages, answer a list including the package and the transitive closure on 			its #requires: and #includes: fields.	   If the spec is a project, answer a list of the packages associated with the project,			following the transitive closure on packages reachable starting with the #loads: field.	   If the spec is a group, answers the list of packages in the #includes: field of the group. 			Groups in the #includes: field are expanded following the transitive closure on groups"	"In essence, this query answers the list of all packages that would be loaded if the package 		named <aString> were loaded."	"If there is no spec named <aString>, aBlock is evaluated"	^aStringOrArray 		resolvePackageSpecsNamedForMetacelloMCVersion: self 		visited: MetacelloVisitedPackages new 		ifAbsent: aBlock! !!MetacelloMCVersion methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 35043933!allPackagesForSpecs: pkgSpecs visited: visited 	| coll |	coll := Dictionary new.	pkgSpecs		do: [:pkgSpec | (pkgSpec resolveToAllPackagesIn: self spec visited: visited)				do: [:pkg | coll at: pkg name put: pkg ]].	^ coll values asOrderedCollection! !!MetacelloMCVersion methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 35045963!doFetchRequiredFromArray: anArray	| oldPolicy oldBypassProgress displayString |	displayString := self versionNumber printString, ' of ', self spec projectLabel.	Transcript cr; show: 'Fetching ', displayString, '...'.	oldPolicy := loaderPolicy. 	oldBypassProgress := MetacelloPlatform current bypassProgressBars.	self loaderPolicy silently ifTrue: [ MetacelloPlatform current bypassProgressBars: true ].	[ 	| ans |		ans := self fetchRequiredFromArray: anArray.		Transcript cr; show: '...finished ', self versionNumber printString.		^ans ]			ensure: [ 				MetacelloPlatform current bypassProgressBars: oldBypassProgress.				loaderPolicy := oldPolicy ]! !!MetacelloMCVersion methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 35046722!doLoadRequiredFromArray: anArray	| displayString oldPolicy oldBypassProgress |	displayString := self versionNumber printString, ' of ', self spec projectLabel.	Transcript cr; show: 'Loading ', displayString, '...'.	oldPolicy := loaderPolicy. 	oldBypassProgress := MetacelloPlatform current bypassProgressBars.	self loaderPolicy silently ifTrue: [ MetacelloPlatform current bypassProgressBars: true ].	[	| fetchLoader |		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).		MetacelloPlatform current			do:  [  fetchLoader doLoad ]			displaying: 'Loading ', displayString.		Transcript cr; show: '...finished ', self versionNumber printString.		^fetchLoader ]		ensure: [ 			MetacelloPlatform current bypassProgressBars: oldBypassProgress.			loaderPolicy := oldPolicy ]! !!MetacelloMCVersion methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 35049128!fetch: required	^required fetchRequiredForMetacelloMCVersion: self! !!MetacelloMCVersion methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 35050318!load: required	^required loadRequiredForMetacelloMCVersion: self! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'dkh 9/11/2012 10:16' prior: 35052940!packages	"Answers the list of packages associated with this version"	| packages |	packages := OrderedCollection new.	self spec projectDo: [:ignored | ] packageDo: [:pkg | packages add: pkg ] groupDo: [:ignored | ].	^packages! !!MetacelloMCVersion methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 35054903!record: required	^required recordRequiredForMetacelloMCVersion: self! !!MetacelloMCNamelessProjectSpec methodsFor: 'scripting' stamp: 'dkh 02/19/2015 14:50'!asProjectSpecForVersion: vrsn  "I'm a reference spec and my project comes from the project I'm loaded from, not the project I am loading"  "https://github.com/dalehenrich/metacello-work/issues/331"  | proj spec |  proj := vrsn ifNil: [ ^ self ] ifNotNil: [ vrsn versionSpec project ].  spec := proj configurationOfProjectSpecClass for: proj.  self copyForScriptingInto: spec.  spec loader: self loader.  self assert: (self className beginsWith: 'BaselineOf') not.  ^ spec! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'versionInfo' stamp: 'dkh 6/8/2012 14:04:22' prior: 35069852!currentVersionInfoFor: packageSpec	^self loadData		currentVersionInfoFor: packageSpec 		ifAbsent: [ nil ]! !!MetacelloNullRecordingMCSpecLoader methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 35070072!doingLoads: aBlock	"escape mechanism for recording and null loaders to skip doing loaderlike things"! !!MetacelloDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 35077092!packageDirectivesDo: aBlock! !!MetacelloDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 35077214!packageDo: aBlock! !!MetacelloDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 35077326!postLoadDo: aBlock! !!MetacelloDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 35077556!prepostLoadDirectivesDo: aBlock! !!MetacelloDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 35077686!prepostLoadDo: aBlock! !!MetacelloDirective methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 35077948!printOn: aStream indent: indent	indent timesRepeat: [ aStream tab ].	aStream		nextPutAll: self title;		nextPutAll: ' : ';		nextPutAll: self label.! !!MetacelloDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 35078917!versionDirectivesDepthFirstDo: aBlock! !!MetacelloDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 35079053!versionDirectivesDo: aBlock! !!MetacelloDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 35079175!versionDo: aBlock! !!MetacelloAtomicLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 35103097!directivesDo: aBlock	aBlock value: self.	self preloads do: [:directive | directive directivesDo: aBlock ].	self loadDirectives do: [:directive | directive directivesDo: aBlock ].	self postloads do: [:directive | directive directivesDo: aBlock ].! !!MetacelloAtomicLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 35104017!loadAtomicLoadDirective: aLoaderDirective gofer: aGofer	aLoaderDirective loadDirectives do: [:directive | directive loadUsing: self gofer: aGofer ].! !!MetacelloAtomicLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 35105171!loadUsing: aLoaderDirective gofer: aGofer	self loadDirectives isEmpty ifTrue: [ ^self ].	aLoaderDirective loadAtomicLoadDirective: self gofer: aGofer.! !!MetacelloAtomicLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 35106561!prepostLoadsDo: aBlock	self preloads do: [:directive | directive prepostLoadDo: aBlock ].	self loadDirectives do: [:directive | directive prepostLoadDo: aBlock ].	self postloads do: [:directive | directive prepostLoadDo: aBlock ].! !!MetacelloPackageSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 35079423!compareCurrentVersion: anOperator targetVersionStatus: statusIgnored using: anMCLoader	self 		currentPackageLoaded: [:bool | ^bool ] 		comparing: anOperator 		notLoaded: [:ignored | ^false ]		using: anMCLoader! !!MetacelloPackageSpec methodsFor: 'testing' stamp: 'dkh 6/8/2012 14:04:22' prior: 35079735!compareRelativeCurrentVersion: anOperator targetVersionStatus: statusIgnored using: anMCLoader	^self compareCurrentVersion: anOperator targetVersionStatus: statusIgnored using: anMCLoader! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 35087192!explicitLoadUsing: mcLoader	| wc fetchingSpecLoader |	((wc := self workingCopy) ~~ nil and: [ wc needsSaving ]) 		ifTrue: [ 			(MetacelloSkipDirtyPackageLoad signal: self)				ifTrue:  [					Transcript cr; show: 'Skipping load of modified package: ', self file.					^self]				ifFalse: [Transcript cr; show: 'Load over modified package: ', self file] ].	"fetch and explicitly load it"	fetchingSpecLoader := mcLoader fetchingSpecLoader.	fetchingSpecLoader		explicitLoadPackageSpecs: (Array with: self) 		repositories: (fetchingSpecLoader repositoriesFrom: self repositorySpecs).! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 35088412!fetchUsing: mcLoader	| fetchingSpecLoader |	fetchingSpecLoader := mcLoader fetchingSpecLoader.	fetchingSpecLoader		linearLoadPackageSpecs: (Array with: self) 		repositories: (fetchingSpecLoader repositoriesFrom: self repositorySpecs).! !!MetacelloPackageSpec methodsFor: 'querying' stamp: 'dkh 6/8/2012 14:04:22' prior: 35088750!file	file == nil ifTrue: [ ^self name ].	^file! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 35090769!goferCommitPackage: commitMessage	"uses gofer to do commit ... non-interactive"		| latestFile pkgSpec |	^(file notNil and: [ self name = self file ])		ifTrue: [			latestFile := self loader latestPackage: self name fromRepository: self repositorySpecs.			pkgSpec := self copy.			pkgSpec file: latestFile.			pkgSpec goferCommitPackage: commitMessage ]		ifFalse: [ self loader goferCommitPackageUsing: self repositorySpecs commitMessage: commitMessage ]! !!MetacelloPackageSpec methodsFor: 'loading' stamp: 'dkh 6/8/2012 14:04:22' prior: 35092953!loadUsing: mcLoader	self loader doingLoads: [ self explicitLoadUsing: mcLoader ]! !!MetacelloPackageSpec methodsFor: 'copying' stamp: 'dkh 6/8/2012 14:04:22' prior: 35094796!postCopy	super postCopy.	goferPackage := nil.	repositories := repositories copy.! !!MetacelloPackageSpec methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 35098342!resolveToPackagesIn: aVersionSpec visited: visited	^{ self }! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 35098513!savePackage	"Interactive save ... prompted for commit message and package name unless MCVersionNameAndMessageRequest handled"	| latestFile pkgSpec |	^(file notNil and: [ self name = self file ])		ifTrue: [			latestFile := self loader latestPackage: self name fromRepository: self repositorySpecs.			pkgSpec := self copy.			pkgSpec file: latestFile.			pkgSpec savePackage ]		ifFalse: [ self loader savePackageUsing: self repositorySpecs ]! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 35100424!updatePackageRepositories: repositorySpecs	| resolvedPackageRef |	Transcript cr; show: '  Looking up version -> ', self file.	resolvedPackageRef := self loader resolveSpec: self from: repositorySpecs.	Transcript cr; show: 'Update repositoryGroup -> ', resolvedPackageRef name, ' ' , resolvedPackageRef repository description.	resolvedPackageRef version workingCopy repositoryGroup addRepository: resolvedPackageRef repository! !!MetacelloPackageSpec methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 35100964!updatePackageRepositoriesFor: aVersionSpec	"Don't update the repository unless the package is loaded in the image"		self workingCopy == nil ifTrue: [ ^self ].	self updatePackageRepositories: self repositorySpecs, aVersionSpec repositorySpecs.! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 35107606!mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: self! !!MetacelloMemberSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 35108004!removeFromMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: self! !!MetacelloMCVersionValidator class methodsFor: 'instance creation' stamp: 'dkh 6/8/2012 14:04:22' prior: 35016272!validateConfigurationLoad: configurationClass version: versionString	^self validateConfigurationLoad: configurationClass version: versionString loads: #()! !!MetacelloGoferPackage class methodsFor: 'package name matching' stamp: 'dkh 04/07/2015 20:41' prior: 35113285!packageFileName: pkgFileName matchesPackageName: wcPkgName  ^ (pkgFileName beginsWith: wcPkgName)    ifTrue: [       pkgFileName size = wcPkgName size        or: [           (pkgFileName at: wcPkgName size + 1) = $-            or: [               (pkgFileName at: wcPkgName size + 1) = $.                or: [ (pkgFileName at: wcPkgName size + 1) isDigit ] ] ] ]    ifFalse: [       pkgFileName size >= wcPkgName size        ifTrue: [ ^ false ].      (wcPkgName beginsWith: pkgFileName)        ifFalse: [ ^ false ].      ^ (wcPkgName at: pkgFileName size + 1) = $. ]! !!MetacelloGoferPackage methodsFor: 'private' stamp: 'dkh 04/07/2015 20:07' prior: 35114951!matches: aLoadableReference  | pFilename |  ((pFilename := self packageFilename) == nil    or: [ self name = self packageFilename ])    ifTrue: [ ^ super matches: aLoadableReference ].  aLoadableReference name = pFilename    ifTrue: [ ^ true ].  (aLoadableReference name beginsWith: pFilename)    ifFalse: [ ^ false ].  ^ aLoadableReference matchesMetacelloGoferPackage: self! !!MetacelloGoferPackage methodsFor: 'private' stamp: 'dkh 04/07/2015 20:41'!matchesMetacelloGoferPackage: aMetacelloGoferPackage  self    error:      'Should not be matching a MetacelloGoferPackage with another MetacelloGoferPackage'! !!MetacelloGoferPackage methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 35116151!matchesWorkingCopy: aWorkingCopy	"check that the working copy package name matches the package file name and that the first ancestor's package file name	 matches the packageName"		| pFilename |	(pFilename := self packageFilename) == nil ifTrue: [ ^self error: 'cannot match working copy' ].	(self class 		packageFileName: pFilename 		matchesPackageName: aWorkingCopy package name)			ifTrue: [				aWorkingCopy ancestry ancestors isEmpty ifTrue: [ ^true ].				^self class 					packageFileName: aWorkingCopy ancestry ancestors first name 					matchesPackageName: self packageName ].	^false! !!MetacelloLoaderPolicy class methodsFor: 'instance creation' stamp: 'dkh 6/8/2012 14:04:22' prior: 35108222!overrideRepositories: aCollection	^self new overrideRepositories: aCollection! !!MetacelloLoaderPolicy methodsFor: 'initialize-release' stamp: 'dkh 6/8/2012 14:04:22' prior: 35110022!initialize	self 		repositoryMap; 		cacheRepository;		ensuredMap.	ignoreImage := false! !!MetacelloLoaderPolicy methodsFor: 'accessing' stamp: 'dkh 6/8/2012 14:04:22' prior: 35110460!loadData 	loadData == nil ifTrue: [ loadData := MetacelloLoadData new ].	^loadData! !!MetacelloLoaderPolicy methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 35111164!pushAtomicLoadDirectivesDuring: aBlock for: aLoader	self pushLoadDirective: (MetacelloAtomicLoadDirective loader: aLoader) during: aBlock.! !!MetacelloLoaderPolicy methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 35111693!pushLinearLoadDirectivesDuring: aBlock for: aLoader	self pushLoadDirective: (MetacelloLinearLoadDirective loader: aLoader) during: aBlock.! !!MetacelloLoaderPolicy methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 35111931!pushLoadDirective: aLoaderDirective during: aBlock	|  oldRoot |	self loadDirective add: aLoaderDirective.	oldRoot := loadDirective.	loadDirective := aLoaderDirective.	aBlock ensure: [ loadDirective := oldRoot ].! !!MetacelloPreLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 35125706!loadUsing: aLoaderDirective gofer: aGofer	aLoaderDirective loadPreloadDirective: self.! !!MetacelloPostLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 35120030!loadUsing: aLoaderDirective gofer: aGofer	aLoaderDirective loadPostloadDirective: self.! !!MetacelloRepositorySpec methodsFor: 'printing' stamp: 'dkh 6/8/2012 14:04:22' prior: 35121606!configMethodCascadeOn: aStream lastCascade: lastCascade	aStream nextPutAll: 'repository: ', self description printString.	(self username isEmpty not or: [ self password isEmpty not ])		ifTrue: [ aStream nextPutAll: ' username: ', self username printString, ' password: ', self password printString ].	lastCascade ifFalse: [ aStream nextPut: $;; cr ].! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'printing' stamp: 'dkh 10/31/2015 11:09'!configHasVersionString  ^ false! !!MetacelloMCBaselineOfProjectSpec methodsFor: 'querying' stamp: 'dkh 10/28/2015 16:08' prior: 35498432!repositoryVersionString  "extract a version string from the repository ... if possible"  "must parallel implementation of MetacelloMCBaselineProject>>setBaselineRepositoryDescription: we want the same repoSpec"  | spec repo |  self repositorySpecs do: [ :repoSpec | spec := repoSpec ].  [ repo := spec createRepository ]    on: Error    do: [ :ex | ^ '' ].  ^ repo repositoryVersionString! !!GoferReference methodsFor: '*metacello-mc' stamp: 'dkh 04/07/2015 19:41'!matchesMetacelloGoferPackage: aMetacelloGoferPackage  | pFilename refFilename char |  ((pFilename := aMetacelloGoferPackage packageFilename) == nil    or: [ aMetacelloGoferPackage name = aMetacelloGoferPackage packageFilename ])    ifTrue: [ ^ super matches: self ].  self name = pFilename    ifTrue: [ ^ true ].  (self name beginsWith: pFilename)    ifFalse: [ ^ false ].  refFilename := self metacelloPackageNameWithBranch at: 2.  refFilename = pFilename    ifTrue: [ ^ true ].  pFilename size < refFilename size    ifTrue: [       (refFilename beginsWith: pFilename)        ifFalse: [ ^ false ].      (char := pFilename at: pFilename size) ~= $-        ifTrue: [ char := refFilename at: pFilename size + 1 ] ]    ifFalse: [       (pFilename beginsWith: refFilename)        ifFalse: [ ^ false ].      (char := refFilename at: refFilename size) ~= $-        ifTrue: [ char := pFilename at: refFilename size + 1 ] ].  ^ char = $. or: [ char = $- ]! !!MCFileBasedRepository methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 35127421!versionInfoFromVersionNamed: aString	| versions |	versions := self allVersionNames		select: [ :each | each beginsWith: aString ].	versions isEmpty ifTrue: [ ^ nil ].	versions := versions asSortedCollection: [ :a :b |		([ (a copyAfterLast: $.) asNumber ] on: Error do: [:ex | ex return: 0 ]) <= 			([ (b copyAfterLast: $.) asNumber ] on: Error do: [:ex | ex return: 0 ]) ].	^ self versionInfoFromFileNamed: versions last , '.mcz'! !!MetacelloLinearLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 35130196!loadUsing: aLoaderDirective gofer: aGofer	self loadDirectives isEmpty ifTrue: [ ^self ].	aLoaderDirective loadLinearLoadDirective: self gofer: aGofer.! !!MetacelloExplicitLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 35150460!explicitLoadUsing: aLoaderDirective gofer: aGofer	aLoaderDirective loadLinearLoadDirective: self gofer: aGofer.! !!MetacelloExplicitLoadDirective methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 35151106!loadUsing: aLoaderDirective gofer: aGofer	aLoaderDirective loadExplicitLoadDirective: self gofer: aGofer.! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 35152320!packagesNeedSavingVisited: visitedProjects using: repos into: aCollection	"noop by default"! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 35153637!resolveToAllPackagesIn: aVersionSpec visited: visited	| packages |	packages := Dictionary new.	self resolveToAllPackagesIn: aVersionSpec into: packages visited: visited.	^packages values asOrderedCollection! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 35154606!updatePackageRepositoriesFor: aVersionSpec	"noop by default"		^true! !!MetacelloAbstractPackageSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 35154787!updatePackageSpec: updatedSpecs using: anMCLoader	"Add pkg copy to updatedSpecs if the file in current image is different from the receiver's file"! !!Collection methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 35155349!addToMetacelloRepositories: aMetacelloRepositoriesSpec	self do: [:each | each addToMetacelloRepositories: aMetacelloRepositoriesSpec ]! !!Collection methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 35155980!mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec	self do: [:each | each mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec ]! !!Collection methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 35156421!removeFromMetacelloRepositories: aMetacelloRepositoriesSpec	self do: [:each | each removeFromMetacelloRepositories: aMetacelloRepositoriesSpec ]! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 35162353!versionDirectivesDepthFirstDo: aBlock	self loadDirectives do: [:directive | directive versionDirectivesDepthFirstDo: aBlock ].	aBlock value: self.! !!MetacelloVersionLoadDirective methodsFor: 'enumerating' stamp: 'dkh 6/8/2012 14:04:22' prior: 35162850!versionDo: aBlock	aBlock value: self.! !!MetacelloMCProject methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 35173143!fetchProject: aLoaderPolicy	"fetch the latest version of the configuration package"		| mcLoader |	(mcLoader := self loader) == nil		ifTrue: [ mcLoader := self project loaderClass on: nil ].	mcLoader loaderPolicy: aLoaderPolicy.	mcLoader doingLoads: [ 		MCWorkingCopy			managersForClass: self configuration class			do: [:mgr | | pkg |				pkg := self packageSpec.				mgr repositoryGroup repositories do: [:repo | pkg repositories repository: (repo asRepositorySpecFor: self) ].				pkg name: mgr packageName.				pkg fetchUsing: mcLoader.				^true ]].	^true! !!MetacelloMCProject methodsFor: 'as yet unclassified' stamp: 'dkh 7/2/2012 16:41' prior: 35177212!setBaselineRepositoryDescription: aListOrRepositoryDescriptions    "noop "! !!GoferVersionReference methodsFor: '*metacello-mc' stamp: 'dkh 04/07/2015 20:39'!matchesMetacelloGoferPackage: aMetacelloGoferPackage  | ref |  (super matchesMetacelloGoferPackage: aMetacelloGoferPackage)    ifFalse: [ ^ false ].  ref := self class name: aMetacelloGoferPackage packageFilename.  ref versionNumber = 0    ifTrue: [ ^ true ].  ^ self versionNumber = ref versionNumber! !!MetacelloGoferLoad methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 35167660!updateRepositories	"Noop for Metacello...done by loader itself"! !!MetacelloProjectReferenceSpec methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 35181002!updateForSpawnMethod: sourceSpec	"This means that this spec was used in a baseline and will be used in a version .... drop all information that isn't useful"	| nm |	nm := name.	self projectReference updateForSpawnMethod: sourceSpec.	super updateForSpawnMethod: sourceSpec.	name := nm.! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 35183284!mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec	| spec |	spec := 		(aMetacelloRepositoriesSpec project repositorySpec)			description: self;			yourself.	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec mergeMember 			name: spec name;			spec: spec;			yourself)! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22' prior: 35183672!packageFileSpecFor: aMetacelloPackagesSpec	^(aMetacelloPackagesSpec project packageSpec)			file: self;			yourself! !!MetacelloConfigTemplate class methodsFor: 'development support' stamp: 'dkh 6/8/2012 14:04:22' prior: 35187277!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!MetacelloConfigTemplate class methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 35187645!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #'ConfigurationOf'		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #'ConfigurationOf' ifAbsent: aBlock ].! !!MetacelloCommonMCSpecLoader methodsFor: 'versionInfo' stamp: 'dkh 6/8/2012 14:04:22' prior: 35056872!ancestorsFor: packageSpec	| cacheKey vi |	cacheKey := packageSpec file.	^MetacelloPlatform current		stackCacheFor: #ancestors		at: cacheKey		doing: [ :cache | 			vi := packageSpec ancestors.			cache at: cacheKey put: vi ].! !!MetacelloCommonMCSpecLoader methodsFor: 'versionInfo' stamp: 'dkh 6/8/2012 14:04:22' prior: 35057211!currentVersionInfoFor: packageSpec	| cacheKey vi |	cacheKey := packageSpec file.	^MetacelloPlatform current		stackCacheFor: #currentVersionInfo		at: cacheKey		doing: [ :cache | 			vi := packageSpec currentVersionInfo.			cache at: cacheKey put: vi ].! !!MetacelloCommonMCSpecLoader methodsFor: 'private' stamp: 'dkh 6/8/2012 14:04:22' prior: 35058949!linearLoadPackageSpecs: packageSpecs repositories: repositories		| gofer |	gofer := MetacelloGofer new.	repositories do: [:repo | gofer repository: repo ].	packageSpecs do: [:pkg | pkg loadUsing: self gofer: gofer ].! !!MetacelloCommonMCSpecLoader methodsFor: 'actions' stamp: 'dkh 6/8/2012 14:04:22' prior: 35059274!load	| repos |	repos := self repositoriesFrom: self spec repositorySpecs.	^ self loadType == #atomic		ifTrue: [self atomicLoadPackageSpecs: self spec packageSpecsInLoadOrder repositories: repos]		ifFalse: ["assume #linear"			self linearLoadPackageSpecs: self spec packageSpecsInLoadOrder repositories: repos ]! !!MetacelloCommonMCSpecLoader methodsFor: 'repositories' stamp: 'dkh 6/8/2012 14:04:22' prior: 35064687!repositoriesFrom: aMetacelloMVRepositorySpecs ignoreOverrides: ignoreOverrides	| repositories repos |	(ignoreOverrides not and: [self hasRepositoryOverrides]) ifTrue: [ ^self loaderPolicy overrideRepositories ].	repositories := MCRepositoryGroup default repositories.	repos := OrderedCollection new.	aMetacelloMVRepositorySpecs do: [:aSpec | | description repo |		description := aSpec description.		(repo := repositories detect: [:rep | rep description = description ] ifNone: [ aSpec createRepository ]) ~~ nil			ifTrue: [ repos add: repo ]].	^repos! !"Metacello-MC"!!MetacelloToolBox class methodsFor: 'scripts' stamp: 'dkh 10/23/2015 16:51'!createBaselineOf: baselineBasename requiredProjects: projectList packages: packageList repositories: repositories dependencies: dependencies groups: groups  "Create a new baseline in a BaselinOf based on the specified project structure.		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		repositories - collection of associations where key is name of package and value is collection of repository descriptions		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		groups - collection of associations where key is the name of the group and value is the collection of group members	"  <apiDocumentation>  | toolbox |  (toolbox := self baselineNamed: baselineBasename)    createBaselineOfMethod: 'baseline:' inCategory: 'baseline';    addBaselineOfSection: #'common'      requiredProjects: projectList      packages: packageList      repositories: repositories      dependencies: dependencies      groups: groups      versionSpecsDo: [ :versionSpec |  ];    commitBaselineOfMethod.  ^ toolbox! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 10/23/2015 16:50'!addBaselineOfSection: sectionAttributeOrPath requiredProjects: projectList packages: packageList dependencies: dependecies groups: groups versionSpecsDo: aBlock  "		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		groups - collection of associations where key is the name of the group and value is the collection of group members	"  self    addBaselineOfSection: sectionAttributeOrPath    requiredProjects: projectList    packages: packageList    dependencies: dependecies    includes: #()    files: #()    repositories: #()    preLoadDoIts: #()    postLoadDoIts: #()    supplyingAnswers: #()    groups: groups    versionSpecsDo: aBlock! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 10/23/2015 16:50'!addBaselineOfSection: sectionAttributeOrPath requiredProjects: projectList packages: packageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: groups versionSpecsDo: aBlock  "		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		groups - collection of associations where key is the name of the group and value is the collection of group members	"  | versionSpec dependencyMap includesMap filesMap repositoriesMap preLoadDoItsMap postLoadDoItsMap supplyingAnswersMap |  versionSpec := self createVersionSpec: self methodSpec versionString.  dependencyMap := self buildMapFrom: dependecies for: packageList.  includesMap := self buildMapFrom: includes for: packageList.  filesMap := self buildMapFrom: files for: packageList.  repositoriesMap := self    buildMapFrom: repositories    for: packageList , projectList.  preLoadDoItsMap := self buildMapFrom: preLoadDoIts for: packageList.  postLoadDoItsMap := self buildMapFrom: postLoadDoIts for: packageList.  supplyingAnswersMap := self buildMapFrom: supplyingAnswers for: packageList.  projectList    do: [ :projectName |       | spec |      spec := self createProjectReferenceSpec: projectName.      repositoriesMap        at: projectName        ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].      versionSpec packages merge: spec ].  packageList    do: [ :packageName |       | spec |      spec := self createPackageSpec: packageName.      dependencyMap        at: packageName        ifPresent: [ :dependencyList | spec requires: dependencyList ].      includesMap        at: packageName        ifPresent: [ :includesList | spec includes: includesList ].      filesMap at: packageName ifPresent: [ :file | spec file: file ].      repositoriesMap        at: packageName        ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].      preLoadDoItsMap        at: packageName        ifPresent: [ :preLoad | spec preLoadDoIt: preLoad ].      postLoadDoItsMap        at: packageName        ifPresent: [ :postLoad | spec postLoadDoIt: postLoad ].      supplyingAnswersMap        at: packageName        ifPresent: [ :answer | spec answers: answer ].      versionSpec packages merge: spec ].  groups    do: [ :assoc |       | spec |      spec := self createGroupSpec: assoc key.      spec includes: assoc value.      versionSpec packages merge: spec ].  aBlock value: versionSpec.  self methodSpec    addMethodSection: sectionAttributeOrPath asMetacelloAttributePath    versionSpec: versionSpec! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 10/23/2015 16:50'!addBaselineOfSection: sectionAttributeOrPath requiredProjects: projectList packages: packageList repositories: repositories dependencies: dependecies groups: groups versionSpecsDo: aBlock  "		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		repositories - collection of associations where key is name of package and value is collection of repository descriptions		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		groups - collection of associations where key is the name of the group and value is the collection of group members	"  self    addBaselineOfSection: sectionAttributeOrPath    requiredProjects: projectList    packages: packageList    dependencies: dependecies    includes: #()    files: #()    repositories: repositories    preLoadDoIts: #()    postLoadDoIts: #()    supplyingAnswers: #()    groups: groups    versionSpecsDo: aBlock! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 10/24/2015 08:32' prior: 35515606!baselineNamed: baseName  | baselineName |  "Check if the class does not exist"  baselineName := self baselineNameFrom: baseName.  (Smalltalk includesKey: baselineName asSymbol)    ifFalse: [       "Create the configuration class"      self ensureMetacello.      BaselineOf        subclass: baselineName asSymbol        instanceVariableNames: ''        classVariableNames: ''        poolDictionaries: ''        category: baselineName.      MetacelloPlatform current registerPackageNamed: baselineName.      (MetacelloPlatform current globalNamed: baselineName asSymbol)        compile: 'baseline: spec <baseline>'        classified: 'baseline'	"a bit of a hack here to create an initial null basline method" ].  project := (MetacelloPlatform current globalNamed: baselineName asSymbol)    project! !!MetacelloToolBox methodsFor: 'spec creation' stamp: 'dkh 10/31/2015 12:43'!classicCreateProjectReferenceSpec: projectBaseName  | configurationName projectReferenceProject versionString |  configurationName := self configurationNameFrom: projectBaseName.  projectReferenceProject := (MetacelloPlatform current    globalNamed: configurationName asSymbol    ifAbsent: [       self        error:          'The project with configuration ' , configurationName printString            , ' for the project ' , projectBaseName printString            , ' is not currently loaded into the image.' ])    project.  versionString := (projectReferenceProject hasVersion: #'stable')    ifTrue: [ #'stable' ]    ifFalse: [ #'bleedingEdge' ].  ^ project projectReferenceSpec    name: projectBaseName;    projectReference:        (project projectSpec            name: projectBaseName;            className: configurationName;            versionString: versionString;            yourself);    yourself! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 10/23/2015 16:25'!commitBaselineOfMethod  | skipValidation isues |  skipValidation := false.  self methodSpec ifNil: [ ^ self ].  self methodSpec compileMethod.  project := project configuration class project.	"recalculate project"  [ project version: self methodSpec versionString ]    on: MetacelloSymbolicVersionDoesNotExistError    do: [ :ex |       "symbolic versions can be removed"      skipValidation := true ].  skipValidation    ifFalse: [ self validateVersion: self methodSpec versionString ].  methodSpec := nil! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'dkh 10/23/2015 16:27'!createBaselineOfMethod: selector inCategory: category  methodSpec := MetacelloBaselineOfMethodSpec new    project: project;    selector: selector;    category: category;    yourself! !!MetacelloToolBox methodsFor: 'spec creation' stamp: 'dkh 10/31/2015 12:41' prior: 35271049!createProjectReferenceSpec: projectBaseName  | projectSpec |  projectSpec := (Metacello image    project: projectBaseName;    list)    detect: [ :each | true ]    ifNone: [ ^ self classicCreateProjectReferenceSpec: projectBaseName ].  ^ project projectReferenceSpec    name: projectBaseName;    projectReference: projectSpec;    yourself! !"Metacello-ToolBox"!!MCGitBasedNetworkRepository class methodsFor: 'accessing' stamp: 'topa 5/5/2015 11:22' prior: 35520751!cacheDirectoryPath  ^ MCFileTreeFileUtils current directoryPathString: self cacheDirectory! !!MCGitBasedNetworkRepository methodsFor: 'initialize-release' stamp: 'dkh 10/27/2015 14:39' prior: 35532343!flushCache  "the directory acts like a cache since we download the directory from a git-based repository (github, bitbucket, etc.)"  [ super flushCache ]    on: Error    do: [ :ex |       Transcript        cr;        show:            'Error for: ' , self description printString , ' during flushCache: '                , ex description printString ].  self class flushDownloadCache.  directory := nil! !!MCGitBasedNetworkRepository methodsFor: 'private' stamp: 'ChristopheDemarey 8/7/2015 15:41' prior: 35537748!resolveProjectVersionPattern: aString  "aString must conform to the syntax for MetacelloVersionNumber with the exception that aString may have a leading $v which is stripped before conversion to a MetacelloVersionNumber patterm"  | patternString tagDictionary matchingTags tagAssocs sortedMatchingTags theTag |  self projectPath    ifNil: [ self error: 'projectPath must be set to resolve project version pattern.' ].  patternString := (self class projectVersionFromString: aString) asString.  tagDictionary := self downloadJSONTags.  tagAssocs := tagDictionary keys    collect: [ :tagName |       | tagVersion |      tagVersion := self class projectVersionFromString: tagName.      tagVersion -> tagName ].  matchingTags := tagAssocs select: [ :assoc | assoc key match: patternString ].  matchingTags isEmpty    ifTrue: [       projectVersion := aString.      ^ self        error:          'No tags matching the pattern ' , aString printString            , ' found for repository description '            , self description printString ].  sortedMatchingTags := matchingTags asArray sort: [ :a :b | a key <= b key ].  theTag := sortedMatchingTags last.  projectVersionPattern := aString.  projectVersion := theTag value! !"Metacello-GitBasedRepository"!!MCBitbucketRepository class methodsFor: 'accessing' stamp: 'topa 5/5/2015 11:23'!cacheDirectoryPath  <preference: 'BitBucket Cache' category: 'Metacello' description: '' type:    #'String'>  ^ super cacheDirectoryPath! !"Metacello-Bitbucket"!MCGitBasedNetworkRepository subclass: #MCGitHubRepository	instanceVariableNames: ''	classVariableNames: 'CacheDirectory DownloadCache ETagsCache'	poolDictionaries: ''	category: 'Metacello-GitHub'!!MCGitHubRepository class methodsFor: 'accessing' stamp: 'topa 5/5/2015 11:24'!cacheDirectoryPath  <preference: 'GitHub Cache' category: 'Metacello' description: '' type:    #'String'>  ^ super cacheDirectoryPath! !!MCGitHubRepository class methodsFor: 'accessing' stamp: 'dkh 03/18/2015 06:35'!eTagsCache  "To avoid GitHub rate limiting problems, we are caching the ETags for the tag request: https://developer.github.com/v3/#conditional-requests"  ETagsCache ifNil: [ ETagsCache := Dictionary new ].  ^ ETagsCache! !!MCGitHubRepository class methodsFor: 'initialization' stamp: 'dkh 03/18/2015 07:35'!flushETagsCache  "mainly needed for tests .... but if you want to pare down object consumption..."  "self flushETagsCache"  ETagsCache := nil! !!MCGitHubRepository methodsFor: 'private' stamp: 'dkh 03/18/2015 07:39'!downloadJSONTags  | tagsUrl jsonObject |  tagsUrl := self projectTagsUrlFor: self projectPath.  jsonObject := MetacelloPlatform current    downloadJSON: tagsUrl    eTagsCache: self class eTagsCache    eTagsKey: self projectPath    username: self class siteUsername    pass: self class sitePassword.  ^ self normalizeTagsData: jsonObject! !"Metacello-GitHub"!(Smalltalk at: #Metacello) new  baseline: 'Metacello';  repository: 'github://dalehenrich/metacello-work:master/repository';  load.!Metacello new  baseline: 'FileTree';  repository: 'github://dalehenrich/filetree:squeak4.3/repository';  load.!----SNAPSHOT----{13 January 2016 . 6:48:13 am} Squeak5.0-15113.image priorSource: 9231!!SqueakSSL class methodsFor: 'examples' stamp: 'ul 10/23/2013 12:13' prior: 34567089!ensureSampleCertFile	"On Unix, we can simply create a valid cert file"	| certName file |	SqueakSSL platformName = 'unix' ifFalse:[^self].	certName := self name, 'Cert.pem'.	(FileDirectory default fileExists: certName) ifFalse:[		file := FileDirectory default newFileNamed: certName.		[file nextPutAll: self exampleCertFile withUnixLineEndings] ensure:[file close].	].	^FileDirectory default fullNameFor: certName.! !!SqueakSSL methodsFor: 'accessing' stamp: 'ul 10/16/2014 10:35'!serverName: aString	"Sets the name to use with the Server Name Indication TLS extension. Which should be a valid FQDN. No WinSSL support yet."	^[ self primitiveSSL: handle setStringProperty: 2 toValue: aString ]		on: Error		do: [ "nothing" ]! !!SecureSocketStream methodsFor: 'initialize' stamp: 'ul 10/15/2014 19:20' prior: 34567588!sslConnect	"Perform the SSL client handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete."	self sslConnectTo: nil! !!SecureSocketStream methodsFor: 'initialize' stamp: 'ul 10/15/2014 19:26'!sslConnectTo: serverName	"Perform the SSL client handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete. If serverName is not nil, then try to use it for SNI."	| inbuf squeakSSL result |	inbuf := ''.	squeakSSL := SqueakSSL new.	serverName ifNotNil: [ squeakSSL serverName: serverName ].	"Perform the SSL handshake"	[[result := squeakSSL connect: inbuf from: 1 to: inbuf size into: sendBuf.	result = 0] whileFalse:[		"Check for errors first"		result < -1 ifTrue:[^self error: 'SSL connect failed with code: ', result].		"If a token has been produced in the handshake, send it to the remote"		result > 0 ifTrue:[			self nextPutAll: (sendBuf copyFrom: 1 to: result).			self flush.		].		"Read more input and repeat"		self receiveData.		inbuf := self nextAvailable.	].	"There should be no pending data at this point, ensure it is so.	XXXX: If you ever see this problem, please inform me."	self isInBufferEmpty ifFalse:[self error: 'Unexpected input data'].	"We are connected. From here on, encryption will take place."	ssl := squeakSSL.	] ifCurtailed:[		"Make sure we destroy the platform handle if the handshake gets interrupted"		squeakSSL destroy.	].! !!SecureSocket class methodsFor: 'examples' stamp: 'ul 10/15/2014 18:36' prior: 34568878!google: query	"An example HTTPS query to encrypted.google.com.	Example:		SecureSocket google: 'squeak'.		SecureSocket google: 'SqueakSSL'.	"	| hostName address socket |	"Change the host name to try an https request to some other host"	hostName := 'encrypted.google.com'..	address := NetNameResolver addressForName: hostName.	socket := SecureSocket newTCP.	"Connect the TCP socket"	socket connectTo: address port: 443.	socket waitForConnectionFor: 10.	["Handle the client handshake"	socket sslConnectTo: hostName.	"Verify that the cert is valid"	socket certState = 0 ifFalse:[		self error: 'The certificate is invalid (code: ', socket certState,')'.	].	"If the certificate is valid, make sure we're were we wanted to go"	(socket peerName match: hostName) ifFalse:[		self error: 'Host name mismatch: ', socket peerName.	].	"Send encrypted data"	socket sendData:		'GET /search?q=', query,' HTTP/1.0', String crlf,		'Host: ', hostName, String crlf,		'Connection: close', String crlf,		String crlf.	"Wait for the response"	^String streamContents:[:s|		[[true] whileTrue:[s nextPutAll: socket receiveData]]			on: ConnectionClosed, ConnectionTimedOut do:[:ex| ex return].	]] ensure:[socket destroy].! !!SecureSocket methodsFor: 'connect' stamp: 'ul 10/23/2013 12:10'!accept	"Accept a connection from the receiver socket.	Return a new socket that is connected to the client"	^self class acceptFrom: self.! !!SecureSocket methodsFor: 'connect' stamp: 'ul 10/15/2014 19:27' prior: 34570187!sslConnect	"Perform the SSL client handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete."	self sslConnectTo: nil! !!SecureSocket methodsFor: 'connect' stamp: 'ul 10/15/2014 19:27'!sslConnectTo: serverName	"Perform the SSL client handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete. If serverName is not nil, then try to use it for SNI."	| inbuf squeakSSL result |	inbuf := ''.	squeakSSL := SqueakSSL new.	serverName ifNotNil: [ squeakSSL serverName: serverName ].	"Perform the SSL handshake"	[[result := squeakSSL connect: inbuf from: 1 to: inbuf size into: sendBuf.	result = 0] whileFalse:[		"Check for errors first"		result < -1 ifTrue:[^self error: 'SSL connect failed with code: ', result].		"If a token has been produced in the handshake, send it to the remote"		result > 0 ifTrue:[self sendData: (sendBuf copyFrom: 1 to: result)].		"Read more input and repeat"		inbuf := self receiveData.	].	"We are connected. From here on, encryption will take place."	ssl := squeakSSL.	] ifCurtailed:[		"Make sure we destroy the platform handle if the handshake gets interrupted"		squeakSSL destroy.	].! !"SqueakSSL-Core"!Exception subclass: #UnhandledError	instanceVariableNames: 'exception'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Exceptions'!!UnhandledError commentStamp: 'mt 8/25/2015 14:42' prior: 0!This is a wrapper for an unhandled error. Having this, process stepping is able to correctly fire other unhandled errors. See Process >> #stepToHome: for further explanations.!UnhandledError subclass: #UnhandledWarning	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Exceptions'!!Process methodsFor: 'changing suspended state' stamp: 'mt 8/25/2015 14:36' prior: 20168855!stepToHome: aContext 	"Resume self until the home of top context is aContext.  Top context may be a block context.	 Catch any UnhandledErrors that are created while stepping, answering the relevant signalerContext	 if so. Note that this will cause weird effects if using through to step through UnhandledError	 code, but as the doctor ordered, don't do that; use over or into instead."	^Processor activeProcess		evaluate:			[| home anError |			home := aContext home.			[suspendedContext := suspendedContext step.			 home == suspendedContext home or: [home isDead]] whileFalse:				[(suspendedContext selector == #signalForException:				 and: [(suspendedContext receiver isBehavior and: [						suspendedContext receiver includesBehavior: UnhandledError])				 and: [anError := suspendedContext tempAt: 1.					   ((suspendedContext objectClass: anError) includesBehavior: Exception)				 and: [anError canSearchForSignalerContext]]]) ifTrue:					[anError signalerContext ifNotNil:						[:unhandledErrorSignalerContext|						[unhandledErrorSignalerContext == suspendedContext] whileFalse:							[self completeStep: suspendedContext].						"Give a debugger a chance to update its title to reflect the new exception"						 Notification new							tag: {unhandledErrorSignalerContext. anError};							signal.						^unhandledErrorSignalerContext]]].			suspendedContext]		onBehalfOf: self! !!UnhandledError class methodsFor: 'as yet unclassified' stamp: 'mt 8/25/2015 14:42' prior: 55999530!signalForException: anError	"Very important entry point for analysis stack when stepping in a debugging session. See Process >> #stepToHome: for further explanations."		^ self new		exception: anError;		signal! !!UnhandledError methodsFor: 'accessing' stamp: 'ajh 9/4/2002 19:15' prior: 55996975!exception	^ exception! !!UnhandledError methodsFor: 'accessing' stamp: 'ajh 9/4/2002 19:15' prior: 55997363!exception: anError	exception := anError! !"Kernel"!!UnhandledError methodsFor: '*System-priv handling' stamp: 'mt 8/25/2015 14:43' prior: 55998869!defaultAction	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."	^ToolSet debugError: self exception! !!UnhandledWarning methodsFor: '*System-priv handling' stamp: 'mt 8/25/2015 14:40'!defaultAction	^ ToolSet		debugContext: self exception signalerContext		label: 'Warning'		contents: self exception messageText , '\\Select Proceed to continue, or close this window to cancel the operation.' withCRs! !!Warning methodsFor: '*System-exceptionDescription' stamp: 'mt 8/25/2015 14:31' prior: 59265607!defaultAction	"Inform the user of a Warning, giving them the choice of ignoring the warning (proceeding), debugging, or terminating the computation."	UnhandledWarning signalForException: self! !"System"!!Debugger methodsFor: 'initialize' stamp: 'mt 8/25/2015 13:35' prior: 54869224!openNotifierContents: msgString label: label	"Create, schedule and answer a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active process has not been suspended.  The sender will do this."	| msg builder spec |	Sensor flushKeyboard.	savedCursor := Cursor currentCursor.	Cursor currentCursor: Cursor normal.	msg := (label beginsWith: 'Space is low')		ifTrue: [self lowSpaceChoices, (msgString ifNil: [String empty])]		ifFalse: [msgString].	builder := ToolBuilder default.	spec := self buildNotifierWith: builder label: label message: msg.	self expandStack.	^[builder openDebugger: spec] ensure:		[errorWasInUIProcess := Project current spawnNewProcessIfThisIsUI: interruptedProcess]! !"Tools"!SystemOrganization addCategory: #'CS326-Sandbox'!Object subclass: #Boojum	instanceVariableNames: 'snark beaver railwayShare'	classVariableNames: ''	poolDictionaries: ''	category: 'CS326-Sandbox'!!Boojum methodsFor: 'accessing' stamp: 'jws 1/13/2016 06:53'!snark	^ snark! !!Boojum methodsFor: 'accessing' stamp: 'jws 1/13/2016 06:53'!snark: anObject	snark := anObject! !!Boojum methodsFor: 'accessing' stamp: 'jws 1/13/2016 06:53'!beaver	^ beaver! !!Boojum methodsFor: 'accessing' stamp: 'jws 1/13/2016 06:53'!beaver: anObject	beaver := anObject! !!Boojum methodsFor: 'accessing' stamp: 'jws 1/13/2016 06:53'!railwayShare	^ railwayShare! !!Boojum methodsFor: 'accessing' stamp: 'jws 1/13/2016 06:53'!railwayShare: anObject	railwayShare := anObject! !Smalltalk removeClassNamed: #Boojum!SystemOrganization removeSystemCategory: #'CS326-Sandbox'!----SNAPSHOT----{13 January 2016 . 6:56:09 am} Squeak5.0-15113.image priorSource: 2068237!----QUIT----{13 January 2016 . 6:57:51 am} Squeak5.0-15113.image priorSource: 2079539!----STARTUP----{13 January 2016 . 11:59:32 am} as C:\Users\dtrepani\git\cs326\Squeak-5.0-All-in-One\Squeak-5.0-All-in-One.app\Contents\Resources\Squeak5.0-15113.image!----QUIT/NOSAVE----{13 January 2016 . 12:00:03 pm} Squeak5.0-15113.image priorSource: 2079631!----STARTUP----{13 January 2016 . 1:03:34 pm} as C:\Users\dtrepani\git\cs326\Squeak-5.0-All-in-One\Squeak-5.0-All-in-One.app\Contents\Resources\Squeak5.0-15113.image!3+4!3+4!3+4.!5+2!3+4.!self class!3+4.!3+4.!3+4!3+4.!3+4.!3+4.! 7! 7!3+4.! 7! 7! 7! 7! 7! 7!Transcript show: 'Hellow, class.'!Transcript show: 'Hellow, class.'!Transcript show: 'Hellow, class.'!Transcript show: 'Hellow, class.'!Transcript show: 'Hellow, class.'!Transcript show: 'Hellow, class.'!Transcript show: 'Hellow, class.\n'!Transcript show: 'Hellow, class.\n'!Transcript show: 'Hellow, class.'; cr.!Transcript show: 'Hellow, class.'; cr.!Transcript show: 'Hellow, class.'; cr.!Transcript show: 'Hellow, class.'; cr.!Transcript show: 'Hellow, class.'; cr.!Transcript show: 'Hellow, class.'; cr.!Transcript show: 'Hellow, class.'; cr.!Transcript show: 'Hellow, class.'; cr.!Transcript show: 'Hellow, class.'; cr.!Transcript show: 'Hellow, class.'; cr.!Transcript show: 'Hellow, class.'; cr.!Transcript show: 'Hellow, class.'; cr.!Transcript show: 'Hellow, class.'; cr.!Transcript show: 'Hellow, class.'; cr.!Transcript show: 'Hellow, class.'; cr.!Transcript show: 'Hellow, class.'; cr.!Transcript show: 'Hellow, class.'; cr.!Transcript show: 'Hellow, class.'; cr.!Transcript show: 'Hellow, class.'; cr.!Transcript show: 'Hellow, class.'; cr.!Transcript	show: 'Boy howdy!!';	cr.!Transcript	show: 'Boy howdy!!';	cr.!Transcript	show: 'Boy howdy!!';	cr.!Transcript	show: 'Boy howdy!!';	cr.!Transcript	show: 'Boy howdy!!';	cr.!Transcript	show: 'Boy howdy!!';	cr.!Transcript	show: 'Boy howdy!!';	cr.!myBlock value.!myBlock value.!myBlock value.!myBlock value.!myBlock value.!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!myBlock value!1 to: 9 do: [ :index | Transcript show: index printString ].!myBlock value.!myBlock value.!----QUIT----{13 January 2016 . 1:50:41 pm} Squeak5.0-15113.image priorSource: 2079631!